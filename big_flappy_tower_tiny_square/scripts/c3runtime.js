// Generated by Construct 3, the game and app creator :: https://www.construct.net
'use strict'
'use strict'
;(function (e, b) {
  'object' === typeof exports && 'undefined' !== typeof module ? b(exports) : 'function' === typeof define && define.amd ? define(['exports'], b) : ((e = e || self), b((e.glMatrix = {})))
})(this, function (e) {
  function b(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2]
    n = n[3]
    var H = y[0],
      K = y[1],
      M = y[2]
    y = y[3]
    l[0] = B * H + G * K
    l[1] = D * H + n * K
    l[2] = B * M + G * y
    l[3] = D * M + n * y
    return l
  }

  function a(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    l[3] = n[3] - y[3]
    return l
  }

  function c(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2],
      H = n[3],
      K = n[4]
    n = n[5]
    var M = y[0],
      P = y[1],
      R = y[2],
      T = y[3],
      Z = y[4]
    y = y[5]
    l[0] = B * M + G * P
    l[1] = D * M + H * P
    l[2] = B * R + G * T
    l[3] = D * R + H * T
    l[4] = B * Z + G * y + K
    l[5] = D * Z + H * y + n
    return l
  }

  function d(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    l[3] = n[3] - y[3]
    l[4] = n[4] - y[4]
    l[5] = n[5] - y[5]
    return l
  }

  function f() {
    var l = new na(9)
    na != Float32Array && ((l[1] = 0), (l[2] = 0), (l[3] = 0), (l[5] = 0), (l[6] = 0), (l[7] = 0))
    l[0] = 1
    l[4] = 1
    l[8] = 1
    return l
  }

  function g(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2],
      H = n[3],
      K = n[4],
      M = n[5],
      P = n[6],
      R = n[7]
    n = n[8]
    var T = y[0],
      Z = y[1],
      W = y[2],
      da = y[3],
      ca = y[4],
      aa = y[5],
      ra = y[6],
      ma = y[7]
    y = y[8]
    l[0] = T * B + Z * H + W * P
    l[1] = T * D + Z * K + W * R
    l[2] = T * G + Z * M + W * n
    l[3] = da * B + ca * H + aa * P
    l[4] = da * D + ca * K + aa * R
    l[5] = da * G + ca * M + aa * n
    l[6] = ra * B + ma * H + y * P
    l[7] = ra * D + ma * K + y * R
    l[8] = ra * G + ma * M + y * n
    return l
  }

  function h(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    l[3] = n[3] - y[3]
    l[4] = n[4] - y[4]
    l[5] = n[5] - y[5]
    l[6] = n[6] - y[6]
    l[7] = n[7] - y[7]
    l[8] = n[8] - y[8]
    return l
  }

  function k(l) {
    l[0] = 1
    l[1] = 0
    l[2] = 0
    l[3] = 0
    l[4] = 0
    l[5] = 1
    l[6] = 0
    l[7] = 0
    l[8] = 0
    l[9] = 0
    l[10] = 1
    l[11] = 0
    l[12] = 0
    l[13] = 0
    l[14] = 0
    l[15] = 1
    return l
  }

  function m(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2],
      H = n[3],
      K = n[4],
      M = n[5],
      P = n[6],
      R = n[7],
      T = n[8],
      Z = n[9],
      W = n[10],
      da = n[11],
      ca = n[12],
      aa = n[13],
      ra = n[14]
    n = n[15]
    var ma = y[0],
      pa = y[1],
      qa = y[2],
      oa = y[3]
    l[0] = ma * B + pa * K + qa * T + oa * ca
    l[1] = ma * D + pa * M + qa * Z + oa * aa
    l[2] = ma * G + pa * P + qa * W + oa * ra
    l[3] = ma * H + pa * R + qa * da + oa * n
    ma = y[4]
    pa = y[5]
    qa = y[6]
    oa = y[7]
    l[4] = ma * B + pa * K + qa * T + oa * ca
    l[5] = ma * D + pa * M + qa * Z + oa * aa
    l[6] = ma * G + pa * P + qa * W + oa * ra
    l[7] = ma * H + pa * R + qa * da + oa * n
    ma = y[8]
    pa = y[9]
    qa = y[10]
    oa = y[11]
    l[8] = ma * B + pa * K + qa * T + oa * ca
    l[9] = ma * D + pa * M + qa * Z + oa * aa
    l[10] = ma * G + pa * P + qa * W + oa * ra
    l[11] = ma * H + pa * R + qa * da + oa * n
    ma = y[12]
    pa = y[13]
    qa = y[14]
    oa = y[15]
    l[12] = ma * B + pa * K + qa * T + oa * ca
    l[13] = ma * D + pa * M + qa * Z + oa * aa
    l[14] = ma * G + pa * P + qa * W + oa * ra
    l[15] = ma * H + pa * R + qa * da + oa * n
    return l
  }

  function r(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2],
      H = n[3],
      K = B + B,
      M = D + D,
      P = G + G
    n = B * K
    var R = B * M
    B *= P
    var T = D * M
    D *= P
    G *= P
    K *= H
    M *= H
    H *= P
    l[0] = 1 - (T + G)
    l[1] = R + H
    l[2] = B - M
    l[3] = 0
    l[4] = R - H
    l[5] = 1 - (n + G)
    l[6] = D + K
    l[7] = 0
    l[8] = B + M
    l[9] = D - K
    l[10] = 1 - (n + T)
    l[11] = 0
    l[12] = y[0]
    l[13] = y[1]
    l[14] = y[2]
    l[15] = 1
    return l
  }

  function w(l, n) {
    l[0] = n[12]
    l[1] = n[13]
    l[2] = n[14]
    return l
  }

  function p(l, n) {
    var y = n[4],
      B = n[5],
      D = n[6],
      G = n[8],
      H = n[9],
      K = n[10]
    l[0] = Math.hypot(n[0], n[1], n[2])
    l[1] = Math.hypot(y, B, D)
    l[2] = Math.hypot(G, H, K)
    return l
  }

  function q(l, n) {
    var y = new na(3)
    p(y, n)
    var B = 1 / y[0],
      D = 1 / y[1],
      G = 1 / y[2],
      H = n[0] * B
    y = n[1] * D
    var K = n[2] * G,
      M = n[4] * B,
      P = n[5] * D,
      R = n[6] * G
    B *= n[8]
    D *= n[9]
    n = n[10] * G
    G = H + P + n
    0 < G
      ? ((H = 2 * Math.sqrt(G + 1)), (l[3] = 0.25 * H), (l[0] = (R - D) / H), (l[1] = (B - K) / H), (l[2] = (y - M) / H))
      : H > P && H > n
      ? ((H = 2 * Math.sqrt(1 + H - P - n)), (l[3] = (R - D) / H), (l[0] = 0.25 * H), (l[1] = (y + M) / H), (l[2] = (B + K) / H))
      : P > n
      ? ((H = 2 * Math.sqrt(1 + P - H - n)), (l[3] = (B - K) / H), (l[0] = (y + M) / H), (l[1] = 0.25 * H), (l[2] = (R + D) / H))
      : ((H = 2 * Math.sqrt(1 + n - H - P)), (l[3] = (y - M) / H), (l[0] = (B + K) / H), (l[1] = (R + D) / H), (l[2] = 0.25 * H))
    return l
  }

  function t(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    l[3] = n[3] - y[3]
    l[4] = n[4] - y[4]
    l[5] = n[5] - y[5]
    l[6] = n[6] - y[6]
    l[7] = n[7] - y[7]
    l[8] = n[8] - y[8]
    l[9] = n[9] - y[9]
    l[10] = n[10] - y[10]
    l[11] = n[11] - y[11]
    l[12] = n[12] - y[12]
    l[13] = n[13] - y[13]
    l[14] = n[14] - y[14]
    l[15] = n[15] - y[15]
    return l
  }

  function x() {
    var l = new na(3)
    na != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0))
    return l
  }

  function v(l) {
    return Math.hypot(l[0], l[1], l[2])
  }

  function u(l, n, y) {
    var B = new na(3)
    B[0] = l
    B[1] = n
    B[2] = y
    return B
  }

  function A(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    return l
  }

  function z(l, n, y) {
    l[0] = n[0] * y[0]
    l[1] = n[1] * y[1]
    l[2] = n[2] * y[2]
    return l
  }

  function C(l, n, y) {
    l[0] = n[0] / y[0]
    l[1] = n[1] / y[1]
    l[2] = n[2] / y[2]
    return l
  }

  function E(l, n) {
    return Math.hypot(n[0] - l[0], n[1] - l[1], n[2] - l[2])
  }

  function J(l, n) {
    var y = n[0] - l[0],
      B = n[1] - l[1]
    l = n[2] - l[2]
    return y * y + B * B + l * l
  }

  function F(l) {
    var n = l[0],
      y = l[1]
    l = l[2]
    return n * n + y * y + l * l
  }

  function I(l, n) {
    var y = n[0],
      B = n[1],
      D = n[2]
    y = y * y + B * B + D * D
    0 < y && (y = 1 / Math.sqrt(y))
    l[0] = n[0] * y
    l[1] = n[1] * y
    l[2] = n[2] * y
    return l
  }

  function L(l, n) {
    return l[0] * n[0] + l[1] * n[1] + l[2] * n[2]
  }

  function N(l, n, y) {
    var B = n[0],
      D = n[1]
    n = n[2]
    var G = y[0],
      H = y[1]
    y = y[2]
    l[0] = D * y - n * H
    l[1] = n * G - B * y
    l[2] = B * H - D * G
    return l
  }

  function S() {
    var l = new na(4)
    na != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0), (l[3] = 0))
    return l
  }

  function V(l) {
    var n = new na(4)
    n[0] = l[0]
    n[1] = l[1]
    n[2] = l[2]
    n[3] = l[3]
    return n
  }

  function U(l, n, y, B) {
    var D = new na(4)
    D[0] = l
    D[1] = n
    D[2] = y
    D[3] = B
    return D
  }

  function X(l, n) {
    l[0] = n[0]
    l[1] = n[1]
    l[2] = n[2]
    l[3] = n[3]
    return l
  }

  function ia(l, n, y, B, D) {
    l[0] = n
    l[1] = y
    l[2] = B
    l[3] = D
    return l
  }

  function ka(l, n, y) {
    l[0] = n[0] + y[0]
    l[1] = n[1] + y[1]
    l[2] = n[2] + y[2]
    l[3] = n[3] + y[3]
    return l
  }

  function ya(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    l[2] = n[2] - y[2]
    l[3] = n[3] - y[3]
    return l
  }

  function ta(l, n, y) {
    l[0] = n[0] * y[0]
    l[1] = n[1] * y[1]
    l[2] = n[2] * y[2]
    l[3] = n[3] * y[3]
    return l
  }

  function Ba(l, n, y) {
    l[0] = n[0] / y[0]
    l[1] = n[1] / y[1]
    l[2] = n[2] / y[2]
    l[3] = n[3] / y[3]
    return l
  }

  function Ea(l, n, y) {
    l[0] = n[0] * y
    l[1] = n[1] * y
    l[2] = n[2] * y
    l[3] = n[3] * y
    return l
  }

  function Ca(l, n) {
    return Math.hypot(n[0] - l[0], n[1] - l[1], n[2] - l[2], n[3] - l[3])
  }

  function Aa(l, n) {
    var y = n[0] - l[0],
      B = n[1] - l[1],
      D = n[2] - l[2]
    l = n[3] - l[3]
    return y * y + B * B + D * D + l * l
  }

  function ja(l) {
    return Math.hypot(l[0], l[1], l[2], l[3])
  }

  function Fa(l) {
    var n = l[0],
      y = l[1],
      B = l[2]
    l = l[3]
    return n * n + y * y + B * B + l * l
  }

  function wa(l, n) {
    var y = n[0],
      B = n[1],
      D = n[2]
    n = n[3]
    var G = y * y + B * B + D * D + n * n
    0 < G && (G = 1 / Math.sqrt(G))
    l[0] = y * G
    l[1] = B * G
    l[2] = D * G
    l[3] = n * G
    return l
  }

  function Da(l, n) {
    return l[0] * n[0] + l[1] * n[1] + l[2] * n[2] + l[3] * n[3]
  }

  function Pa(l, n, y, B) {
    var D = n[0],
      G = n[1],
      H = n[2]
    n = n[3]
    l[0] = D + B * (y[0] - D)
    l[1] = G + B * (y[1] - G)
    l[2] = H + B * (y[2] - H)
    l[3] = n + B * (y[3] - n)
    return l
  }

  function Qa(l, n) {
    return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3]
  }

  function Ra(l, n) {
    var y = l[0],
      B = l[1],
      D = l[2]
    l = l[3]
    var G = n[0],
      H = n[1],
      K = n[2]
    n = n[3]
    return Math.abs(y - G) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(G)) && Math.abs(B - H) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(H)) && Math.abs(D - K) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(K)) && Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
  }

  function Ja() {
    var l = new na(4)
    na != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0))
    l[3] = 1
    return l
  }

  function Sa(l, n, y) {
    y *= 0.5
    var B = Math.sin(y)
    l[0] = B * n[0]
    l[1] = B * n[1]
    l[2] = B * n[2]
    l[3] = Math.cos(y)
    return l
  }

  function Ta(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2]
    n = n[3]
    var H = y[0],
      K = y[1],
      M = y[2]
    y = y[3]
    l[0] = B * y + n * H + D * M - G * K
    l[1] = D * y + n * K + G * H - B * M
    l[2] = G * y + n * M + B * K - D * H
    l[3] = n * y - B * H - D * K - G * M
    return l
  }

  function Ua(l, n, y) {
    y *= 0.5
    var B = n[0],
      D = n[1],
      G = n[2]
    n = n[3]
    var H = Math.sin(y)
    y = Math.cos(y)
    l[0] = B * y + n * H
    l[1] = D * y + G * H
    l[2] = G * y - D * H
    l[3] = n * y - B * H
    return l
  }

  function Va(l, n, y) {
    y *= 0.5
    var B = n[0],
      D = n[1],
      G = n[2]
    n = n[3]
    var H = Math.sin(y)
    y = Math.cos(y)
    l[0] = B * y - G * H
    l[1] = D * y + n * H
    l[2] = G * y + B * H
    l[3] = n * y - D * H
    return l
  }

  function Wa(l, n, y) {
    y *= 0.5
    var B = n[0],
      D = n[1],
      G = n[2]
    n = n[3]
    var H = Math.sin(y)
    y = Math.cos(y)
    l[0] = B * y + D * H
    l[1] = D * y - B * H
    l[2] = G * y + n * H
    l[3] = n * y - G * H
    return l
  }

  function Xa(l, n) {
    var y = n[0],
      B = n[1],
      D = n[2],
      G = Math.sqrt(y * y + B * B + D * D)
    n = Math.exp(n[3])
    var H = 0 < G ? (n * Math.sin(G)) / G : 0
    l[0] = y * H
    l[1] = B * H
    l[2] = D * H
    l[3] = n * Math.cos(G)
    return l
  }

  function Ya(l, n) {
    var y = n[0],
      B = n[1],
      D = n[2]
    n = n[3]
    var G = Math.sqrt(y * y + B * B + D * D)
    G = 0 < G ? Math.atan2(G, n) / G : 0
    l[0] = y * G
    l[1] = B * G
    l[2] = D * G
    l[3] = 0.5 * Math.log(y * y + B * B + D * D + n * n)
    return l
  }

  function Ka(l, n, y, B) {
    var D = n[0],
      G = n[1],
      H = n[2]
    n = n[3]
    var K = y[0],
      M = y[1],
      P = y[2]
    y = y[3]
    var R = D * K + G * M + H * P + n * y
    0 > R && ((R = -R), (K = -K), (M = -M), (P = -P), (y = -y))
    if (1e-6 < 1 - R) {
      var T = Math.acos(R)
      var Z = Math.sin(T)
      R = Math.sin((1 - B) * T) / Z
      B = Math.sin(B * T) / Z
    } else R = 1 - B
    l[0] = R * D + B * K
    l[1] = R * G + B * M
    l[2] = R * H + B * P
    l[3] = R * n + B * y
    return l
  }

  function Za(l, n) {
    var y = n[0] + n[4] + n[8]
    if (0 < y) (y = Math.sqrt(y + 1)), (l[3] = 0.5 * y), (y = 0.5 / y), (l[0] = (n[5] - n[7]) * y), (l[1] = (n[6] - n[2]) * y), (l[2] = (n[1] - n[3]) * y)
    else {
      var B = 0
      n[4] > n[0] && (B = 1)
      n[8] > n[3 * B + B] && (B = 2)
      var D = (B + 1) % 3,
        G = (B + 2) % 3
      y = Math.sqrt(n[3 * B + B] - n[3 * D + D] - n[3 * G + G] + 1)
      l[B] = 0.5 * y
      y = 0.5 / y
      l[3] = (n[3 * D + G] - n[3 * G + D]) * y
      l[D] = (n[3 * D + B] + n[3 * B + D]) * y
      l[G] = (n[3 * G + B] + n[3 * B + G]) * y
    }
    return l
  }

  function $a(l, n, y) {
    var B = 0.5 * y[0],
      D = 0.5 * y[1]
    y = 0.5 * y[2]
    var G = n[0],
      H = n[1],
      K = n[2]
    n = n[3]
    l[0] = G
    l[1] = H
    l[2] = K
    l[3] = n
    l[4] = B * n + D * K - y * H
    l[5] = D * n + y * G - B * K
    l[6] = y * n + B * H - D * G
    l[7] = -B * G - D * H - y * K
    return l
  }

  function ab(l, n) {
    l[0] = n[0]
    l[1] = n[1]
    l[2] = n[2]
    l[3] = n[3]
    l[4] = n[4]
    l[5] = n[5]
    l[6] = n[6]
    l[7] = n[7]
    return l
  }

  function bb(l, n, y) {
    var B = n[0],
      D = n[1],
      G = n[2],
      H = n[3],
      K = y[4],
      M = y[5],
      P = y[6],
      R = y[7],
      T = n[4],
      Z = n[5],
      W = n[6]
    n = n[7]
    var da = y[0],
      ca = y[1],
      aa = y[2]
    y = y[3]
    l[0] = B * y + H * da + D * aa - G * ca
    l[1] = D * y + H * ca + G * da - B * aa
    l[2] = G * y + H * aa + B * ca - D * da
    l[3] = H * y - B * da - D * ca - G * aa
    l[4] = B * R + H * K + D * P - G * M + T * y + n * da + Z * aa - W * ca
    l[5] = D * R + H * M + G * K - B * P + Z * y + n * ca + W * da - T * aa
    l[6] = G * R + H * P + B * M - D * K + W * y + n * aa + T * ca - Z * da
    l[7] = H * R - B * K - D * M - G * P + n * y - T * da - Z * ca - W * aa
    return l
  }

  function cb() {
    var l = new na(2)
    na != Float32Array && ((l[0] = 0), (l[1] = 0))
    return l
  }

  function db(l, n, y) {
    l[0] = n[0] - y[0]
    l[1] = n[1] - y[1]
    return l
  }

  function eb(l, n, y) {
    l[0] = n[0] * y[0]
    l[1] = n[1] * y[1]
    return l
  }

  function fb(l, n, y) {
    l[0] = n[0] / y[0]
    l[1] = n[1] / y[1]
    return l
  }

  function gb(l, n) {
    return Math.hypot(n[0] - l[0], n[1] - l[1])
  }

  function hb(l, n) {
    var y = n[0] - l[0]
    l = n[1] - l[1]
    return y * y + l * l
  }

  function ib(l) {
    return Math.hypot(l[0], l[1])
  }

  function jb(l) {
    var n = l[0]
    l = l[1]
    return n * n + l * l
  }
  var na = 'undefined' !== typeof Float32Array ? Float32Array : Array,
    Ga = Math.random,
    kb = Math.PI / 180
  Math.hypot ||
    (Math.hypot = function () {
      for (var l = 0, n = arguments.length; n--; ) l += arguments[n] * arguments[n]
      return Math.sqrt(l)
    })
  var lb = Object.freeze({
      __proto__: null,
      EPSILON: 1e-6,
      get ARRAY_TYPE() {
        return na
      },
      RANDOM: Ga,
      setMatrixArrayType: function (l) {
        na = l
      },
      toRadian: function (l) {
        return l * kb
      },
      equals: function (l, n) {
        return Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
      }
    }),
    mb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new na(4)
        na != Float32Array && ((l[1] = 0), (l[2] = 0))
        l[0] = 1
        l[3] = 1
        return l
      },
      clone: function (l) {
        var n = new na(4)
        n[0] = l[0]
        n[1] = l[1]
        n[2] = l[2]
        n[3] = l[3]
        return n
      },
      copy: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = n[2]
        l[3] = n[3]
        return l
      },
      identity: function (l) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 1
        return l
      },
      fromValues: function (l, n, y, B) {
        var D = new na(4)
        D[0] = l
        D[1] = n
        D[2] = y
        D[3] = B
        return D
      },
      set: function (l, n, y, B, D) {
        l[0] = n
        l[1] = y
        l[2] = B
        l[3] = D
        return l
      },
      transpose: function (l, n) {
        if (l === n) {
          var y = n[1]
          l[1] = n[2]
          l[2] = y
        } else (l[0] = n[0]), (l[1] = n[2]), (l[2] = n[1]), (l[3] = n[3])
        return l
      },
      invert: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2]
        n = n[3]
        var G = y * n - D * B
        if (!G) return null
        G = 1 / G
        l[0] = n * G
        l[1] = -B * G
        l[2] = -D * G
        l[3] = y * G
        return l
      },
      adjoint: function (l, n) {
        var y = n[0]
        l[0] = n[3]
        l[1] = -n[1]
        l[2] = -n[2]
        l[3] = y
        return l
      },
      determinant: function (l) {
        return l[0] * l[3] - l[2] * l[1]
      },
      multiply: b,
      rotate: function (l, n, y) {
        var B = n[0],
          D = n[1],
          G = n[2]
        n = n[3]
        var H = Math.sin(y)
        y = Math.cos(y)
        l[0] = B * y + G * H
        l[1] = D * y + n * H
        l[2] = B * -H + G * y
        l[3] = D * -H + n * y
        return l
      },
      scale: function (l, n, y) {
        var B = n[1],
          D = n[2],
          G = n[3],
          H = y[0]
        y = y[1]
        l[0] = n[0] * H
        l[1] = B * H
        l[2] = D * y
        l[3] = G * y
        return l
      },
      fromRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = n
        l[1] = y
        l[2] = -y
        l[3] = n
        return l
      },
      fromScaling: function (l, n) {
        l[0] = n[0]
        l[1] = 0
        l[2] = 0
        l[3] = n[1]
        return l
      },
      str: function (l) {
        return 'mat2(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ')'
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3])
      },
      LDU: function (l, n, y, B) {
        l[2] = B[2] / B[0]
        y[0] = B[0]
        y[1] = B[1]
        y[3] = B[3] - l[2] * y[1]
        return [l, n, y]
      },
      add: function (l, n, y) {
        l[0] = n[0] + y[0]
        l[1] = n[1] + y[1]
        l[2] = n[2] + y[2]
        l[3] = n[3] + y[3]
        return l
      },
      subtract: a,
      exactEquals: function (l, n) {
        return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3]
      },
      equals: function (l, n) {
        var y = l[0],
          B = l[1],
          D = l[2]
        l = l[3]
        var G = n[0],
          H = n[1],
          K = n[2]
        n = n[3]
        return Math.abs(y - G) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(G)) && Math.abs(B - H) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(H)) && Math.abs(D - K) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(K)) && Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
      },
      multiplyScalar: function (l, n, y) {
        l[0] = n[0] * y
        l[1] = n[1] * y
        l[2] = n[2] * y
        l[3] = n[3] * y
        return l
      },
      multiplyScalarAndAdd: function (l, n, y, B) {
        l[0] = n[0] + y[0] * B
        l[1] = n[1] + y[1] * B
        l[2] = n[2] + y[2] * B
        l[3] = n[3] + y[3] * B
        return l
      },
      mul: b,
      sub: a
    }),
    nb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new na(6)
        na != Float32Array && ((l[1] = 0), (l[2] = 0), (l[4] = 0), (l[5] = 0))
        l[0] = 1
        l[3] = 1
        return l
      },
      clone: function (l) {
        var n = new na(6)
        n[0] = l[0]
        n[1] = l[1]
        n[2] = l[2]
        n[3] = l[3]
        n[4] = l[4]
        n[5] = l[5]
        return n
      },
      copy: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = n[2]
        l[3] = n[3]
        l[4] = n[4]
        l[5] = n[5]
        return l
      },
      identity: function (l) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 1
        l[4] = 0
        l[5] = 0
        return l
      },
      fromValues: function (l, n, y, B, D, G) {
        var H = new na(6)
        H[0] = l
        H[1] = n
        H[2] = y
        H[3] = B
        H[4] = D
        H[5] = G
        return H
      },
      set: function (l, n, y, B, D, G, H) {
        l[0] = n
        l[1] = y
        l[2] = B
        l[3] = D
        l[4] = G
        l[5] = H
        return l
      },
      invert: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4]
        n = n[5]
        var K = y * G - B * D
        if (!K) return null
        K = 1 / K
        l[0] = G * K
        l[1] = -B * K
        l[2] = -D * K
        l[3] = y * K
        l[4] = (D * n - G * H) * K
        l[5] = (B * H - y * n) * K
        return l
      },
      determinant: function (l) {
        return l[0] * l[3] - l[1] * l[2]
      },
      multiply: c,
      rotate: function (l, n, y) {
        var B = n[0],
          D = n[1],
          G = n[2],
          H = n[3],
          K = n[4]
        n = n[5]
        var M = Math.sin(y)
        y = Math.cos(y)
        l[0] = B * y + G * M
        l[1] = D * y + H * M
        l[2] = B * -M + G * y
        l[3] = D * -M + H * y
        l[4] = K
        l[5] = n
        return l
      },
      scale: function (l, n, y) {
        var B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = y[0]
        y = y[1]
        l[0] = n[0] * M
        l[1] = B * M
        l[2] = D * y
        l[3] = G * y
        l[4] = H
        l[5] = K
        return l
      },
      translate: function (l, n, y) {
        var B = n[0],
          D = n[1],
          G = n[2],
          H = n[3],
          K = n[4]
        n = n[5]
        var M = y[0]
        y = y[1]
        l[0] = B
        l[1] = D
        l[2] = G
        l[3] = H
        l[4] = B * M + G * y + K
        l[5] = D * M + H * y + n
        return l
      },
      fromRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = n
        l[1] = y
        l[2] = -y
        l[3] = n
        l[4] = 0
        l[5] = 0
        return l
      },
      fromScaling: function (l, n) {
        l[0] = n[0]
        l[1] = 0
        l[2] = 0
        l[3] = n[1]
        l[4] = 0
        l[5] = 0
        return l
      },
      fromTranslation: function (l, n) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 1
        l[4] = n[0]
        l[5] = n[1]
        return l
      },
      str: function (l) {
        return 'mat2d(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ', ' + l[4] + ', ' + l[5] + ')'
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], 1)
      },
      add: function (l, n, y) {
        l[0] = n[0] + y[0]
        l[1] = n[1] + y[1]
        l[2] = n[2] + y[2]
        l[3] = n[3] + y[3]
        l[4] = n[4] + y[4]
        l[5] = n[5] + y[5]
        return l
      },
      subtract: d,
      multiplyScalar: function (l, n, y) {
        l[0] = n[0] * y
        l[1] = n[1] * y
        l[2] = n[2] * y
        l[3] = n[3] * y
        l[4] = n[4] * y
        l[5] = n[5] * y
        return l
      },
      multiplyScalarAndAdd: function (l, n, y, B) {
        l[0] = n[0] + y[0] * B
        l[1] = n[1] + y[1] * B
        l[2] = n[2] + y[2] * B
        l[3] = n[3] + y[3] * B
        l[4] = n[4] + y[4] * B
        l[5] = n[5] + y[5] * B
        return l
      },
      exactEquals: function (l, n) {
        return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5]
      },
      equals: function (l, n) {
        var y = l[0],
          B = l[1],
          D = l[2],
          G = l[3],
          H = l[4]
        l = l[5]
        var K = n[0],
          M = n[1],
          P = n[2],
          R = n[3],
          T = n[4]
        n = n[5]
        return (
          Math.abs(y - K) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(K)) &&
          Math.abs(B - M) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(M)) &&
          Math.abs(D - P) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(P)) &&
          Math.abs(G - R) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(R)) &&
          Math.abs(H - T) <= 1e-6 * Math.max(1, Math.abs(H), Math.abs(T)) &&
          Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
        )
      },
      mul: c,
      sub: d
    }),
    ob = Object.freeze({
      __proto__: null,
      create: f,
      fromMat4: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = n[2]
        l[3] = n[4]
        l[4] = n[5]
        l[5] = n[6]
        l[6] = n[8]
        l[7] = n[9]
        l[8] = n[10]
        return l
      },
      clone: function (l) {
        var n = new na(9)
        n[0] = l[0]
        n[1] = l[1]
        n[2] = l[2]
        n[3] = l[3]
        n[4] = l[4]
        n[5] = l[5]
        n[6] = l[6]
        n[7] = l[7]
        n[8] = l[8]
        return n
      },
      copy: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = n[2]
        l[3] = n[3]
        l[4] = n[4]
        l[5] = n[5]
        l[6] = n[6]
        l[7] = n[7]
        l[8] = n[8]
        return l
      },
      fromValues: function (l, n, y, B, D, G, H, K, M) {
        var P = new na(9)
        P[0] = l
        P[1] = n
        P[2] = y
        P[3] = B
        P[4] = D
        P[5] = G
        P[6] = H
        P[7] = K
        P[8] = M
        return P
      },
      set: function (l, n, y, B, D, G, H, K, M, P) {
        l[0] = n
        l[1] = y
        l[2] = B
        l[3] = D
        l[4] = G
        l[5] = H
        l[6] = K
        l[7] = M
        l[8] = P
        return l
      },
      identity: function (l) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 1
        l[5] = 0
        l[6] = 0
        l[7] = 0
        l[8] = 1
        return l
      },
      transpose: function (l, n) {
        if (l === n) {
          var y = n[1],
            B = n[2],
            D = n[5]
          l[1] = n[3]
          l[2] = n[6]
          l[3] = y
          l[5] = n[7]
          l[6] = B
          l[7] = D
        } else (l[0] = n[0]), (l[1] = n[3]), (l[2] = n[6]), (l[3] = n[1]), (l[4] = n[4]), (l[5] = n[7]), (l[6] = n[2]), (l[7] = n[5]), (l[8] = n[8])
        return l
      },
      invert: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = n[6],
          P = n[7]
        n = n[8]
        var R = n * H - K * P,
          T = -n * G + K * M,
          Z = P * G - H * M,
          W = y * R + B * T + D * Z
        if (!W) return null
        W = 1 / W
        l[0] = R * W
        l[1] = (-n * B + D * P) * W
        l[2] = (K * B - D * H) * W
        l[3] = T * W
        l[4] = (n * y - D * M) * W
        l[5] = (-K * y + D * G) * W
        l[6] = Z * W
        l[7] = (-P * y + B * M) * W
        l[8] = (H * y - B * G) * W
        return l
      },
      adjoint: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = n[6],
          P = n[7]
        n = n[8]
        l[0] = H * n - K * P
        l[1] = D * P - B * n
        l[2] = B * K - D * H
        l[3] = K * M - G * n
        l[4] = y * n - D * M
        l[5] = D * G - y * K
        l[6] = G * P - H * M
        l[7] = B * M - y * P
        l[8] = y * H - B * G
        return l
      },
      determinant: function (l) {
        var n = l[3],
          y = l[4],
          B = l[5],
          D = l[6],
          G = l[7],
          H = l[8]
        return l[0] * (H * y - B * G) + l[1] * (-H * n + B * D) + l[2] * (G * n - y * D)
      },
      multiply: g,
      translate: function (l, n, y) {
        var B = n[0],
          D = n[1],
          G = n[2],
          H = n[3],
          K = n[4],
          M = n[5],
          P = n[6],
          R = n[7]
        n = n[8]
        var T = y[0]
        y = y[1]
        l[0] = B
        l[1] = D
        l[2] = G
        l[3] = H
        l[4] = K
        l[5] = M
        l[6] = T * B + y * H + P
        l[7] = T * D + y * K + R
        l[8] = T * G + y * M + n
        return l
      },
      rotate: function (l, n, y) {
        var B = n[0],
          D = n[1],
          G = n[2],
          H = n[3],
          K = n[4],
          M = n[5],
          P = n[6],
          R = n[7]
        n = n[8]
        var T = Math.sin(y)
        y = Math.cos(y)
        l[0] = y * B + T * H
        l[1] = y * D + T * K
        l[2] = y * G + T * M
        l[3] = y * H - T * B
        l[4] = y * K - T * D
        l[5] = y * M - T * G
        l[6] = P
        l[7] = R
        l[8] = n
        return l
      },
      scale: function (l, n, y) {
        var B = y[0]
        y = y[1]
        l[0] = B * n[0]
        l[1] = B * n[1]
        l[2] = B * n[2]
        l[3] = y * n[3]
        l[4] = y * n[4]
        l[5] = y * n[5]
        l[6] = n[6]
        l[7] = n[7]
        l[8] = n[8]
        return l
      },
      fromTranslation: function (l, n) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 1
        l[5] = 0
        l[6] = n[0]
        l[7] = n[1]
        l[8] = 1
        return l
      },
      fromRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = n
        l[1] = y
        l[2] = 0
        l[3] = -y
        l[4] = n
        l[5] = 0
        l[6] = 0
        l[7] = 0
        l[8] = 1
        return l
      },
      fromScaling: function (l, n) {
        l[0] = n[0]
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = n[1]
        l[5] = 0
        l[6] = 0
        l[7] = 0
        l[8] = 1
        return l
      },
      fromMat2d: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = 0
        l[3] = n[2]
        l[4] = n[3]
        l[5] = 0
        l[6] = n[4]
        l[7] = n[5]
        l[8] = 1
        return l
      },
      fromQuat: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2]
        n = n[3]
        var G = y + y,
          H = B + B,
          K = D + D
        y *= G
        var M = B * G
        B *= H
        var P = D * G,
          R = D * H
        D *= K
        G *= n
        H *= n
        n *= K
        l[0] = 1 - B - D
        l[3] = M - n
        l[6] = P + H
        l[1] = M + n
        l[4] = 1 - y - D
        l[7] = R - G
        l[2] = P - H
        l[5] = R + G
        l[8] = 1 - y - B
        return l
      },
      normalFromMat4: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = n[6],
          P = n[7],
          R = n[8],
          T = n[9],
          Z = n[10],
          W = n[11],
          da = n[12],
          ca = n[13],
          aa = n[14]
        n = n[15]
        var ra = y * K - B * H,
          ma = y * M - D * H,
          pa = y * P - G * H,
          qa = B * M - D * K,
          oa = B * P - G * K,
          za = D * P - G * M,
          O = R * ca - T * da,
          Q = R * aa - Z * da
        R = R * n - W * da
        var Y = T * aa - Z * ca
        T = T * n - W * ca
        Z = Z * n - W * aa
        W = ra * Z - ma * T + pa * Y + qa * R - oa * Q + za * O
        if (!W) return null
        W = 1 / W
        l[0] = (K * Z - M * T + P * Y) * W
        l[1] = (M * R - H * Z - P * Q) * W
        l[2] = (H * T - K * R + P * O) * W
        l[3] = (D * T - B * Z - G * Y) * W
        l[4] = (y * Z - D * R + G * Q) * W
        l[5] = (B * R - y * T - G * O) * W
        l[6] = (ca * za - aa * oa + n * qa) * W
        l[7] = (aa * pa - da * za - n * ma) * W
        l[8] = (da * oa - ca * pa + n * ra) * W
        return l
      },
      projection: function (l, n, y) {
        l[0] = 2 / n
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = -2 / y
        l[5] = 0
        l[6] = -1
        l[7] = 1
        l[8] = 1
        return l
      },
      str: function (l) {
        return 'mat3(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ', ' + l[4] + ', ' + l[5] + ', ' + l[6] + ', ' + l[7] + ', ' + l[8] + ')'
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8])
      },
      add: function (l, n, y) {
        l[0] = n[0] + y[0]
        l[1] = n[1] + y[1]
        l[2] = n[2] + y[2]
        l[3] = n[3] + y[3]
        l[4] = n[4] + y[4]
        l[5] = n[5] + y[5]
        l[6] = n[6] + y[6]
        l[7] = n[7] + y[7]
        l[8] = n[8] + y[8]
        return l
      },
      subtract: h,
      multiplyScalar: function (l, n, y) {
        l[0] = n[0] * y
        l[1] = n[1] * y
        l[2] = n[2] * y
        l[3] = n[3] * y
        l[4] = n[4] * y
        l[5] = n[5] * y
        l[6] = n[6] * y
        l[7] = n[7] * y
        l[8] = n[8] * y
        return l
      },
      multiplyScalarAndAdd: function (l, n, y, B) {
        l[0] = n[0] + y[0] * B
        l[1] = n[1] + y[1] * B
        l[2] = n[2] + y[2] * B
        l[3] = n[3] + y[3] * B
        l[4] = n[4] + y[4] * B
        l[5] = n[5] + y[5] * B
        l[6] = n[6] + y[6] * B
        l[7] = n[7] + y[7] * B
        l[8] = n[8] + y[8] * B
        return l
      },
      exactEquals: function (l, n) {
        return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7] && l[8] === n[8]
      },
      equals: function (l, n) {
        var y = l[0],
          B = l[1],
          D = l[2],
          G = l[3],
          H = l[4],
          K = l[5],
          M = l[6],
          P = l[7]
        l = l[8]
        var R = n[0],
          T = n[1],
          Z = n[2],
          W = n[3],
          da = n[4],
          ca = n[5],
          aa = n[6],
          ra = n[7]
        n = n[8]
        return (
          Math.abs(y - R) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(R)) &&
          Math.abs(B - T) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(T)) &&
          Math.abs(D - Z) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(Z)) &&
          Math.abs(G - W) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(W)) &&
          Math.abs(H - da) <= 1e-6 * Math.max(1, Math.abs(H), Math.abs(da)) &&
          Math.abs(K - ca) <= 1e-6 * Math.max(1, Math.abs(K), Math.abs(ca)) &&
          Math.abs(M - aa) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(aa)) &&
          Math.abs(P - ra) <= 1e-6 * Math.max(1, Math.abs(P), Math.abs(ra)) &&
          Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
        )
      },
      mul: g,
      sub: h
    }),
    pb = Object.freeze({
      __proto__: null,
      create: function () {
        var l = new na(16)
        na != Float32Array && ((l[1] = 0), (l[2] = 0), (l[3] = 0), (l[4] = 0), (l[6] = 0), (l[7] = 0), (l[8] = 0), (l[9] = 0), (l[11] = 0), (l[12] = 0), (l[13] = 0), (l[14] = 0))
        l[0] = 1
        l[5] = 1
        l[10] = 1
        l[15] = 1
        return l
      },
      clone: function (l) {
        var n = new na(16)
        n[0] = l[0]
        n[1] = l[1]
        n[2] = l[2]
        n[3] = l[3]
        n[4] = l[4]
        n[5] = l[5]
        n[6] = l[6]
        n[7] = l[7]
        n[8] = l[8]
        n[9] = l[9]
        n[10] = l[10]
        n[11] = l[11]
        n[12] = l[12]
        n[13] = l[13]
        n[14] = l[14]
        n[15] = l[15]
        return n
      },
      copy: function (l, n) {
        l[0] = n[0]
        l[1] = n[1]
        l[2] = n[2]
        l[3] = n[3]
        l[4] = n[4]
        l[5] = n[5]
        l[6] = n[6]
        l[7] = n[7]
        l[8] = n[8]
        l[9] = n[9]
        l[10] = n[10]
        l[11] = n[11]
        l[12] = n[12]
        l[13] = n[13]
        l[14] = n[14]
        l[15] = n[15]
        return l
      },
      fromValues: function (l, n, y, B, D, G, H, K, M, P, R, T, Z, W, da, ca) {
        var aa = new na(16)
        aa[0] = l
        aa[1] = n
        aa[2] = y
        aa[3] = B
        aa[4] = D
        aa[5] = G
        aa[6] = H
        aa[7] = K
        aa[8] = M
        aa[9] = P
        aa[10] = R
        aa[11] = T
        aa[12] = Z
        aa[13] = W
        aa[14] = da
        aa[15] = ca
        return aa
      },
      set: function (l, n, y, B, D, G, H, K, M, P, R, T, Z, W, da, ca, aa) {
        l[0] = n
        l[1] = y
        l[2] = B
        l[3] = D
        l[4] = G
        l[5] = H
        l[6] = K
        l[7] = M
        l[8] = P
        l[9] = R
        l[10] = T
        l[11] = Z
        l[12] = W
        l[13] = da
        l[14] = ca
        l[15] = aa
        return l
      },
      identity: k,
      transpose: function (l, n) {
        if (l === n) {
          var y = n[1],
            B = n[2],
            D = n[3],
            G = n[6],
            H = n[7],
            K = n[11]
          l[1] = n[4]
          l[2] = n[8]
          l[3] = n[12]
          l[4] = y
          l[6] = n[9]
          l[7] = n[13]
          l[8] = B
          l[9] = G
          l[11] = n[14]
          l[12] = D
          l[13] = H
          l[14] = K
        } else (l[0] = n[0]), (l[1] = n[4]), (l[2] = n[8]), (l[3] = n[12]), (l[4] = n[1]), (l[5] = n[5]), (l[6] = n[9]), (l[7] = n[13]), (l[8] = n[2]), (l[9] = n[6]), (l[10] = n[10]), (l[11] = n[14]), (l[12] = n[3]), (l[13] = n[7]), (l[14] = n[11]), (l[15] = n[15])
        return l
      },
      invert: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = n[6],
          P = n[7],
          R = n[8],
          T = n[9],
          Z = n[10],
          W = n[11],
          da = n[12],
          ca = n[13],
          aa = n[14]
        n = n[15]
        var ra = y * K - B * H,
          ma = y * M - D * H,
          pa = y * P - G * H,
          qa = B * M - D * K,
          oa = B * P - G * K,
          za = D * P - G * M,
          O = R * ca - T * da,
          Q = R * aa - Z * da,
          Y = R * n - W * da,
          ba = T * aa - Z * ca,
          fa = T * n - W * ca,
          ha = Z * n - W * aa,
          ea = ra * ha - ma * fa + pa * ba + qa * Y - oa * Q + za * O
        if (!ea) return null
        ea = 1 / ea
        l[0] = (K * ha - M * fa + P * ba) * ea
        l[1] = (D * fa - B * ha - G * ba) * ea
        l[2] = (ca * za - aa * oa + n * qa) * ea
        l[3] = (Z * oa - T * za - W * qa) * ea
        l[4] = (M * Y - H * ha - P * Q) * ea
        l[5] = (y * ha - D * Y + G * Q) * ea
        l[6] = (aa * pa - da * za - n * ma) * ea
        l[7] = (R * za - Z * pa + W * ma) * ea
        l[8] = (H * fa - K * Y + P * O) * ea
        l[9] = (B * Y - y * fa - G * O) * ea
        l[10] = (da * oa - ca * pa + n * ra) * ea
        l[11] = (T * pa - R * oa - W * ra) * ea
        l[12] = (K * Q - H * ba - M * O) * ea
        l[13] = (y * ba - B * Q + D * O) * ea
        l[14] = (ca * ma - da * qa - aa * ra) * ea
        l[15] = (R * qa - T * ma + Z * ra) * ea
        return l
      },
      adjoint: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2],
          G = n[3],
          H = n[4],
          K = n[5],
          M = n[6],
          P = n[7],
          R = n[8],
          T = n[9],
          Z = n[10],
          W = n[11],
          da = n[12],
          ca = n[13],
          aa = n[14]
        n = n[15]
        l[0] = K * (Z * n - W * aa) - T * (M * n - P * aa) + ca * (M * W - P * Z)
        l[1] = -(B * (Z * n - W * aa) - T * (D * n - G * aa) + ca * (D * W - G * Z))
        l[2] = B * (M * n - P * aa) - K * (D * n - G * aa) + ca * (D * P - G * M)
        l[3] = -(B * (M * W - P * Z) - K * (D * W - G * Z) + T * (D * P - G * M))
        l[4] = -(H * (Z * n - W * aa) - R * (M * n - P * aa) + da * (M * W - P * Z))
        l[5] = y * (Z * n - W * aa) - R * (D * n - G * aa) + da * (D * W - G * Z)
        l[6] = -(y * (M * n - P * aa) - H * (D * n - G * aa) + da * (D * P - G * M))
        l[7] = y * (M * W - P * Z) - H * (D * W - G * Z) + R * (D * P - G * M)
        l[8] = H * (T * n - W * ca) - R * (K * n - P * ca) + da * (K * W - P * T)
        l[9] = -(y * (T * n - W * ca) - R * (B * n - G * ca) + da * (B * W - G * T))
        l[10] = y * (K * n - P * ca) - H * (B * n - G * ca) + da * (B * P - G * K)
        l[11] = -(y * (K * W - P * T) - H * (B * W - G * T) + R * (B * P - G * K))
        l[12] = -(H * (T * aa - Z * ca) - R * (K * aa - M * ca) + da * (K * Z - M * T))
        l[13] = y * (T * aa - Z * ca) - R * (B * aa - D * ca) + da * (B * Z - D * T)
        l[14] = -(y * (K * aa - M * ca) - H * (B * aa - D * ca) + da * (B * M - D * K))
        l[15] = y * (K * Z - M * T) - H * (B * Z - D * T) + R * (B * M - D * K)
        return l
      },
      determinant: function (l) {
        var n = l[0],
          y = l[1],
          B = l[2],
          D = l[3],
          G = l[4],
          H = l[5],
          K = l[6],
          M = l[7],
          P = l[8],
          R = l[9],
          T = l[10],
          Z = l[11],
          W = l[12],
          da = l[13],
          ca = l[14]
        l = l[15]
        return (n * H - y * G) * (T * l - Z * ca) - (n * K - B * G) * (R * l - Z * da) + (n * M - D * G) * (R * ca - T * da) + (y * K - B * H) * (P * l - Z * W) - (y * M - D * H) * (P * ca - T * W) + (B * M - D * K) * (P * da - R * W)
      },
      multiply: m,
      translate: function (l, n, y) {
        var B = y[0],
          D = y[1]
        y = y[2]
        if (n === l) (l[12] = n[0] * B + n[4] * D + n[8] * y + n[12]), (l[13] = n[1] * B + n[5] * D + n[9] * y + n[13]), (l[14] = n[2] * B + n[6] * D + n[10] * y + n[14]), (l[15] = n[3] * B + n[7] * D + n[11] * y + n[15])
        else {
          var G = n[0]
          var H = n[1]
          var K = n[2]
          var M = n[3]
          var P = n[4]
          var R = n[5]
          var T = n[6]
          var Z = n[7]
          var W = n[8]
          var da = n[9]
          var ca = n[10]
          var aa = n[11]
          l[0] = G
          l[1] = H
          l[2] = K
          l[3] = M
          l[4] = P
          l[5] = R
          l[6] = T
          l[7] = Z
          l[8] = W
          l[9] = da
          l[10] = ca
          l[11] = aa
          l[12] = G * B + P * D + W * y + n[12]
          l[13] = H * B + R * D + da * y + n[13]
          l[14] = K * B + T * D + ca * y + n[14]
          l[15] = M * B + Z * D + aa * y + n[15]
        }
        return l
      },
      scale: function (l, n, y) {
        var B = y[0],
          D = y[1]
        y = y[2]
        l[0] = n[0] * B
        l[1] = n[1] * B
        l[2] = n[2] * B
        l[3] = n[3] * B
        l[4] = n[4] * D
        l[5] = n[5] * D
        l[6] = n[6] * D
        l[7] = n[7] * D
        l[8] = n[8] * y
        l[9] = n[9] * y
        l[10] = n[10] * y
        l[11] = n[11] * y
        l[12] = n[12]
        l[13] = n[13]
        l[14] = n[14]
        l[15] = n[15]
        return l
      },
      rotate: function (l, n, y, B) {
        var D = B[0],
          G = B[1]
        B = B[2]
        var H = Math.hypot(D, G, B)
        if (1e-6 > H) return null
        H = 1 / H
        D *= H
        G *= H
        B *= H
        var K = Math.sin(y)
        var M = Math.cos(y)
        var P = 1 - M
        y = n[0]
        H = n[1]
        var R = n[2]
        var T = n[3]
        var Z = n[4]
        var W = n[5]
        var da = n[6]
        var ca = n[7]
        var aa = n[8]
        var ra = n[9]
        var ma = n[10]
        var pa = n[11]
        var qa = D * D * P + M
        var oa = G * D * P + B * K
        var za = B * D * P - G * K
        var O = D * G * P - B * K
        var Q = G * G * P + M
        var Y = B * G * P + D * K
        var ba = D * B * P + G * K
        D = G * B * P - D * K
        G = B * B * P + M
        l[0] = y * qa + Z * oa + aa * za
        l[1] = H * qa + W * oa + ra * za
        l[2] = R * qa + da * oa + ma * za
        l[3] = T * qa + ca * oa + pa * za
        l[4] = y * O + Z * Q + aa * Y
        l[5] = H * O + W * Q + ra * Y
        l[6] = R * O + da * Q + ma * Y
        l[7] = T * O + ca * Q + pa * Y
        l[8] = y * ba + Z * D + aa * G
        l[9] = H * ba + W * D + ra * G
        l[10] = R * ba + da * D + ma * G
        l[11] = T * ba + ca * D + pa * G
        n !== l && ((l[12] = n[12]), (l[13] = n[13]), (l[14] = n[14]), (l[15] = n[15]))
        return l
      },
      rotateX: function (l, n, y) {
        var B = Math.sin(y)
        y = Math.cos(y)
        var D = n[4],
          G = n[5],
          H = n[6],
          K = n[7],
          M = n[8],
          P = n[9],
          R = n[10],
          T = n[11]
        n !== l && ((l[0] = n[0]), (l[1] = n[1]), (l[2] = n[2]), (l[3] = n[3]), (l[12] = n[12]), (l[13] = n[13]), (l[14] = n[14]), (l[15] = n[15]))
        l[4] = D * y + M * B
        l[5] = G * y + P * B
        l[6] = H * y + R * B
        l[7] = K * y + T * B
        l[8] = M * y - D * B
        l[9] = P * y - G * B
        l[10] = R * y - H * B
        l[11] = T * y - K * B
        return l
      },
      rotateY: function (l, n, y) {
        var B = Math.sin(y)
        y = Math.cos(y)
        var D = n[0],
          G = n[1],
          H = n[2],
          K = n[3],
          M = n[8],
          P = n[9],
          R = n[10],
          T = n[11]
        n !== l && ((l[4] = n[4]), (l[5] = n[5]), (l[6] = n[6]), (l[7] = n[7]), (l[12] = n[12]), (l[13] = n[13]), (l[14] = n[14]), (l[15] = n[15]))
        l[0] = D * y - M * B
        l[1] = G * y - P * B
        l[2] = H * y - R * B
        l[3] = K * y - T * B
        l[8] = D * B + M * y
        l[9] = G * B + P * y
        l[10] = H * B + R * y
        l[11] = K * B + T * y
        return l
      },
      rotateZ: function (l, n, y) {
        var B = Math.sin(y)
        y = Math.cos(y)
        var D = n[0],
          G = n[1],
          H = n[2],
          K = n[3],
          M = n[4],
          P = n[5],
          R = n[6],
          T = n[7]
        n !== l && ((l[8] = n[8]), (l[9] = n[9]), (l[10] = n[10]), (l[11] = n[11]), (l[12] = n[12]), (l[13] = n[13]), (l[14] = n[14]), (l[15] = n[15]))
        l[0] = D * y + M * B
        l[1] = G * y + P * B
        l[2] = H * y + R * B
        l[3] = K * y + T * B
        l[4] = M * y - D * B
        l[5] = P * y - G * B
        l[6] = R * y - H * B
        l[7] = T * y - K * B
        return l
      },
      fromTranslation: function (l, n) {
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = 1
        l[6] = 0
        l[7] = 0
        l[8] = 0
        l[9] = 0
        l[10] = 1
        l[11] = 0
        l[12] = n[0]
        l[13] = n[1]
        l[14] = n[2]
        l[15] = 1
        return l
      },
      fromScaling: function (l, n) {
        l[0] = n[0]
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = n[1]
        l[6] = 0
        l[7] = 0
        l[8] = 0
        l[9] = 0
        l[10] = n[2]
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      fromRotation: function (l, n, y) {
        var B = y[0],
          D = y[1]
        y = y[2]
        var G = Math.hypot(B, D, y)
        if (1e-6 > G) return null
        G = 1 / G
        B *= G
        D *= G
        y *= G
        G = Math.sin(n)
        n = Math.cos(n)
        var H = 1 - n
        l[0] = B * B * H + n
        l[1] = D * B * H + y * G
        l[2] = y * B * H - D * G
        l[3] = 0
        l[4] = B * D * H - y * G
        l[5] = D * D * H + n
        l[6] = y * D * H + B * G
        l[7] = 0
        l[8] = B * y * H + D * G
        l[9] = D * y * H - B * G
        l[10] = y * y * H + n
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      fromXRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = 1
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = n
        l[6] = y
        l[7] = 0
        l[8] = 0
        l[9] = -y
        l[10] = n
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      fromYRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = n
        l[1] = 0
        l[2] = -y
        l[3] = 0
        l[4] = 0
        l[5] = 1
        l[6] = 0
        l[7] = 0
        l[8] = y
        l[9] = 0
        l[10] = n
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      fromZRotation: function (l, n) {
        var y = Math.sin(n)
        n = Math.cos(n)
        l[0] = n
        l[1] = y
        l[2] = 0
        l[3] = 0
        l[4] = -y
        l[5] = n
        l[6] = 0
        l[7] = 0
        l[8] = 0
        l[9] = 0
        l[10] = 1
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      fromRotationTranslation: r,
      fromQuat2: function (l, n) {
        var y = new na(3),
          B = -n[0],
          D = -n[1],
          G = -n[2],
          H = n[3],
          K = n[4],
          M = n[5],
          P = n[6],
          R = n[7],
          T = B * B + D * D + G * G + H * H
        0 < T
          ? ((y[0] = (2 * (K * H + R * B + M * G - P * D)) / T), (y[1] = (2 * (M * H + R * D + P * B - K * G)) / T), (y[2] = (2 * (P * H + R * G + K * D - M * B)) / T))
          : ((y[0] = 2 * (K * H + R * B + M * G - P * D)), (y[1] = 2 * (M * H + R * D + P * B - K * G)), (y[2] = 2 * (P * H + R * G + K * D - M * B)))
        r(l, n, y)
        return l
      },
      getTranslation: w,
      getScaling: p,
      getRotation: q,
      fromRotationTranslationScale: function (l, n, y, B) {
        var D = n[0],
          G = n[1],
          H = n[2],
          K = n[3],
          M = D + D,
          P = G + G,
          R = H + H
        n = D * M
        var T = D * P
        D *= R
        var Z = G * P
        G *= R
        H *= R
        M *= K
        P *= K
        K *= R
        R = B[0]
        var W = B[1]
        B = B[2]
        l[0] = (1 - (Z + H)) * R
        l[1] = (T + K) * R
        l[2] = (D - P) * R
        l[3] = 0
        l[4] = (T - K) * W
        l[5] = (1 - (n + H)) * W
        l[6] = (G + M) * W
        l[7] = 0
        l[8] = (D + P) * B
        l[9] = (G - M) * B
        l[10] = (1 - (n + Z)) * B
        l[11] = 0
        l[12] = y[0]
        l[13] = y[1]
        l[14] = y[2]
        l[15] = 1
        return l
      },
      fromRotationTranslationScaleOrigin: function (l, n, y, B, D) {
        var G = n[0],
          H = n[1],
          K = n[2],
          M = n[3],
          P = G + G,
          R = H + H,
          T = K + K
        n = G * P
        var Z = G * R,
          W = G * T
        G = H * R
        H *= T
        var da = K * T
        K = M * P
        R *= M
        var ca = M * T,
          aa = B[0],
          ra = B[1]
        T = B[2]
        B = D[0]
        M = D[1]
        D = D[2]
        P = (1 - (G + da)) * aa
        var ma = (Z + ca) * aa
        aa *= W - R
        Z = (Z - ca) * ra
        da = (1 - (n + da)) * ra
        ra *= H + K
        W = (W + R) * T
        H = (H - K) * T
        n = (1 - (n + G)) * T
        l[0] = P
        l[1] = ma
        l[2] = aa
        l[3] = 0
        l[4] = Z
        l[5] = da
        l[6] = ra
        l[7] = 0
        l[8] = W
        l[9] = H
        l[10] = n
        l[11] = 0
        l[12] = y[0] + B - (P * B + Z * M + W * D)
        l[13] = y[1] + M - (ma * B + da * M + H * D)
        l[14] = y[2] + D - (aa * B + ra * M + n * D)
        l[15] = 1
        return l
      },
      fromQuat: function (l, n) {
        var y = n[0],
          B = n[1],
          D = n[2]
        n = n[3]
        var G = y + y,
          H = B + B,
          K = D + D
        y *= G
        var M = B * G
        B *= H
        var P = D * G,
          R = D * H
        D *= K
        G *= n
        H *= n
        n *= K
        l[0] = 1 - B - D
        l[1] = M + n
        l[2] = P - H
        l[3] = 0
        l[4] = M - n
        l[5] = 1 - y - D
        l[6] = R + G
        l[7] = 0
        l[8] = P + H
        l[9] = R - G
        l[10] = 1 - y - B
        l[11] = 0
        l[12] = 0
        l[13] = 0
        l[14] = 0
        l[15] = 1
        return l
      },
      frustum: function (l, n, y, B, D, G, H) {
        var K = 1 / (y - n),
          M = 1 / (D - B),
          P = 1 / (G - H)
        l[0] = 2 * G * K
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = 2 * G * M
        l[6] = 0
        l[7] = 0
        l[8] = (y + n) * K
        l[9] = (D + B) * M
        l[10] = (H + G) * P
        l[11] = -1
        l[12] = 0
        l[13] = 0
        l[14] = H * G * 2 * P
        l[15] = 0
        return l
      },
      perspective: function (l, n, y, B, D) {
        n = 1 / Math.tan(n / 2)
        l[0] = n / y
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = n
        l[6] = 0
        l[7] = 0
        l[8] = 0
        l[9] = 0
        l[11] = -1
        l[12] = 0
        l[13] = 0
        l[15] = 0
        null != D && Infinity !== D ? ((y = 1 / (B - D)), (l[10] = (D + B) * y), (l[14] = 2 * D * B * y)) : ((l[10] = -1), (l[14] = -2 * B))
        return l
      },
      perspectiveFromFieldOfView: function (l, n, y, B) {
        var D = Math.tan((n.upDegrees * Math.PI) / 180),
          G = Math.tan((n.downDegrees * Math.PI) / 180),
          H = Math.tan((n.leftDegrees * Math.PI) / 180)
        n = Math.tan((n.rightDegrees * Math.PI) / 180)
        var K = 2 / (H + n),
          M = 2 / (D + G)
        l[0] = K
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = M
        l[6] = 0
        l[7] = 0
        l[8] = -((H - n) * K * 0.5)
        l[9] = (D - G) * M * 0.5
        l[10] = B / (y - B)
        l[11] = -1
        l[12] = 0
        l[13] = 0
        l[14] = (B * y) / (y - B)
        l[15] = 0
        return l
      },
      ortho: function (l, n, y, B, D, G, H) {
        var K = 1 / (n - y),
          M = 1 / (B - D),
          P = 1 / (G - H)
        l[0] = -2 * K
        l[1] = 0
        l[2] = 0
        l[3] = 0
        l[4] = 0
        l[5] = -2 * M
        l[6] = 0
        l[7] = 0
        l[8] = 0
        l[9] = 0
        l[10] = 2 * P
        l[11] = 0
        l[12] = (n + y) * K
        l[13] = (D + B) * M
        l[14] = (H + G) * P
        l[15] = 1
        return l
      },
      lookAt: function (l, n, y, B) {
        var D = n[0],
          G = n[1]
        n = n[2]
        var H = B[0]
        var K = B[1]
        var M = B[2]
        var P = y[0]
        B = y[1]
        var R = y[2]
        if (1e-6 > Math.abs(D - P) && 1e-6 > Math.abs(G - B) && 1e-6 > Math.abs(n - R)) return k(l)
        y = D - P
        B = G - B
        P = n - R
        var T = 1 / Math.hypot(y, B, P)
        y *= T
        B *= T
        P *= T
        R = K * P - M * B
        M = M * y - H * P
        H = H * B - K * y
        ;(T = Math.hypot(R, M, H)) ? ((T = 1 / T), (R *= T), (M *= T), (H *= T)) : (H = M = R = 0)
        K = B * H - P * M
        var Z = P * R - y * H
        var W = y * M - B * R
        ;(T = Math.hypot(K, Z, W)) ? ((T = 1 / T), (K *= T), (Z *= T), (W *= T)) : (W = Z = K = 0)
        l[0] = R
        l[1] = K
        l[2] = y
        l[3] = 0
        l[4] = M
        l[5] = Z
        l[6] = B
        l[7] = 0
        l[8] = H
        l[9] = W
        l[10] = P
        l[11] = 0
        l[12] = -(R * D + M * G + H * n)
        l[13] = -(K * D + Z * G + W * n)
        l[14] = -(y * D + B * G + P * n)
        l[15] = 1
        return l
      },
      targetTo: function (l, n, y, B) {
        var D = n[0],
          G = n[1]
        n = n[2]
        var H = B[0],
          K = B[1],
          M = B[2]
        B = D - y[0]
        var P = G - y[1]
        y = n - y[2]
        var R = B * B + P * P + y * y
        0 < R && ((R = 1 / Math.sqrt(R)), (B *= R), (P *= R), (y *= R))
        var T = K * y - M * P
        M = M * B - H * y
        H = H * P - K * B
        R = T * T + M * M + H * H
        0 < R && ((R = 1 / Math.sqrt(R)), (T *= R), (M *= R), (H *= R))
        l[0] = T
        l[1] = M
        l[2] = H
        l[3] = 0
        l[4] = P * H - y * M
        l[5] = y * T - B * H
        l[6] = B * M - P * T
        l[7] = 0
        l[8] = B
        l[9] = P
        l[10] = y
        l[11] = 0
        l[12] = D
        l[13] = G
        l[14] = n
        l[15] = 1
        return l
      },
      str: function (l) {
        return 'mat4(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ', ' + l[4] + ', ' + l[5] + ', ' + l[6] + ', ' + l[7] + ', ' + l[8] + ', ' + l[9] + ', ' + l[10] + ', ' + l[11] + ', ' + l[12] + ', ' + l[13] + ', ' + l[14] + ', ' + l[15] + ')'
      },
      frob: function (l) {
        return Math.hypot(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10], l[11], l[12], l[13], l[14], l[15])
      },
      add: function (l, n, y) {
        l[0] = n[0] + y[0]
        l[1] = n[1] + y[1]
        l[2] = n[2] + y[2]
        l[3] = n[3] + y[3]
        l[4] = n[4] + y[4]
        l[5] = n[5] + y[5]
        l[6] = n[6] + y[6]
        l[7] = n[7] + y[7]
        l[8] = n[8] + y[8]
        l[9] = n[9] + y[9]
        l[10] = n[10] + y[10]
        l[11] = n[11] + y[11]
        l[12] = n[12] + y[12]
        l[13] = n[13] + y[13]
        l[14] = n[14] + y[14]
        l[15] = n[15] + y[15]
        return l
      },
      subtract: t,
      multiplyScalar: function (l, n, y) {
        l[0] = n[0] * y
        l[1] = n[1] * y
        l[2] = n[2] * y
        l[3] = n[3] * y
        l[4] = n[4] * y
        l[5] = n[5] * y
        l[6] = n[6] * y
        l[7] = n[7] * y
        l[8] = n[8] * y
        l[9] = n[9] * y
        l[10] = n[10] * y
        l[11] = n[11] * y
        l[12] = n[12] * y
        l[13] = n[13] * y
        l[14] = n[14] * y
        l[15] = n[15] * y
        return l
      },
      multiplyScalarAndAdd: function (l, n, y, B) {
        l[0] = n[0] + y[0] * B
        l[1] = n[1] + y[1] * B
        l[2] = n[2] + y[2] * B
        l[3] = n[3] + y[3] * B
        l[4] = n[4] + y[4] * B
        l[5] = n[5] + y[5] * B
        l[6] = n[6] + y[6] * B
        l[7] = n[7] + y[7] * B
        l[8] = n[8] + y[8] * B
        l[9] = n[9] + y[9] * B
        l[10] = n[10] + y[10] * B
        l[11] = n[11] + y[11] * B
        l[12] = n[12] + y[12] * B
        l[13] = n[13] + y[13] * B
        l[14] = n[14] + y[14] * B
        l[15] = n[15] + y[15] * B
        return l
      },
      exactEquals: function (l, n) {
        return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7] && l[8] === n[8] && l[9] === n[9] && l[10] === n[10] && l[11] === n[11] && l[12] === n[12] && l[13] === n[13] && l[14] === n[14] && l[15] === n[15]
      },
      equals: function (l, n) {
        var y = l[0],
          B = l[1],
          D = l[2],
          G = l[3],
          H = l[4],
          K = l[5],
          M = l[6],
          P = l[7],
          R = l[8],
          T = l[9],
          Z = l[10],
          W = l[11],
          da = l[12],
          ca = l[13],
          aa = l[14]
        l = l[15]
        var ra = n[0],
          ma = n[1],
          pa = n[2],
          qa = n[3],
          oa = n[4],
          za = n[5],
          O = n[6],
          Q = n[7],
          Y = n[8],
          ba = n[9],
          fa = n[10],
          ha = n[11],
          ea = n[12],
          ua = n[13],
          sa = n[14]
        n = n[15]
        return (
          Math.abs(y - ra) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(ra)) &&
          Math.abs(B - ma) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(ma)) &&
          Math.abs(D - pa) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(pa)) &&
          Math.abs(G - qa) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(qa)) &&
          Math.abs(H - oa) <= 1e-6 * Math.max(1, Math.abs(H), Math.abs(oa)) &&
          Math.abs(K - za) <= 1e-6 * Math.max(1, Math.abs(K), Math.abs(za)) &&
          Math.abs(M - O) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(O)) &&
          Math.abs(P - Q) <= 1e-6 * Math.max(1, Math.abs(P), Math.abs(Q)) &&
          Math.abs(R - Y) <= 1e-6 * Math.max(1, Math.abs(R), Math.abs(Y)) &&
          Math.abs(T - ba) <= 1e-6 * Math.max(1, Math.abs(T), Math.abs(ba)) &&
          Math.abs(Z - fa) <= 1e-6 * Math.max(1, Math.abs(Z), Math.abs(fa)) &&
          Math.abs(W - ha) <= 1e-6 * Math.max(1, Math.abs(W), Math.abs(ha)) &&
          Math.abs(da - ea) <= 1e-6 * Math.max(1, Math.abs(da), Math.abs(ea)) &&
          Math.abs(ca - ua) <= 1e-6 * Math.max(1, Math.abs(ca), Math.abs(ua)) &&
          Math.abs(aa - sa) <= 1e-6 * Math.max(1, Math.abs(aa), Math.abs(sa)) &&
          Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
        )
      },
      mul: m,
      sub: t
    }),
    La = (function () {
      var l = x()
      return function (n, y, B, D, G, H) {
        y || (y = 3)
        B || (B = 0)
        for (D = D ? Math.min(D * y + B, n.length) : n.length; B < D; B += y) (l[0] = n[B]), (l[1] = n[B + 1]), (l[2] = n[B + 2]), G(l, l, H), (n[B] = l[0]), (n[B + 1] = l[1]), (n[B + 2] = l[2])
        return n
      }
    })()
  La = Object.freeze({
    __proto__: null,
    create: x,
    clone: function (l) {
      var n = new na(3)
      n[0] = l[0]
      n[1] = l[1]
      n[2] = l[2]
      return n
    },
    length: v,
    fromValues: u,
    copy: function (l, n) {
      l[0] = n[0]
      l[1] = n[1]
      l[2] = n[2]
      return l
    },
    set: function (l, n, y, B) {
      l[0] = n
      l[1] = y
      l[2] = B
      return l
    },
    add: function (l, n, y) {
      l[0] = n[0] + y[0]
      l[1] = n[1] + y[1]
      l[2] = n[2] + y[2]
      return l
    },
    subtract: A,
    multiply: z,
    divide: C,
    ceil: function (l, n) {
      l[0] = Math.ceil(n[0])
      l[1] = Math.ceil(n[1])
      l[2] = Math.ceil(n[2])
      return l
    },
    floor: function (l, n) {
      l[0] = Math.floor(n[0])
      l[1] = Math.floor(n[1])
      l[2] = Math.floor(n[2])
      return l
    },
    min: function (l, n, y) {
      l[0] = Math.min(n[0], y[0])
      l[1] = Math.min(n[1], y[1])
      l[2] = Math.min(n[2], y[2])
      return l
    },
    max: function (l, n, y) {
      l[0] = Math.max(n[0], y[0])
      l[1] = Math.max(n[1], y[1])
      l[2] = Math.max(n[2], y[2])
      return l
    },
    round: function (l, n) {
      l[0] = Math.round(n[0])
      l[1] = Math.round(n[1])
      l[2] = Math.round(n[2])
      return l
    },
    scale: function (l, n, y) {
      l[0] = n[0] * y
      l[1] = n[1] * y
      l[2] = n[2] * y
      return l
    },
    scaleAndAdd: function (l, n, y, B) {
      l[0] = n[0] + y[0] * B
      l[1] = n[1] + y[1] * B
      l[2] = n[2] + y[2] * B
      return l
    },
    distance: E,
    squaredDistance: J,
    squaredLength: F,
    negate: function (l, n) {
      l[0] = -n[0]
      l[1] = -n[1]
      l[2] = -n[2]
      return l
    },
    inverse: function (l, n) {
      l[0] = 1 / n[0]
      l[1] = 1 / n[1]
      l[2] = 1 / n[2]
      return l
    },
    normalize: I,
    dot: L,
    cross: N,
    lerp: function (l, n, y, B) {
      var D = n[0],
        G = n[1]
      n = n[2]
      l[0] = D + B * (y[0] - D)
      l[1] = G + B * (y[1] - G)
      l[2] = n + B * (y[2] - n)
      return l
    },
    hermite: function (l, n, y, B, D, G) {
      var H = G * G,
        K = H * (2 * G - 3) + 1,
        M = H * (G - 2) + G,
        P = H * (G - 1)
      G = H * (3 - 2 * G)
      l[0] = n[0] * K + y[0] * M + B[0] * P + D[0] * G
      l[1] = n[1] * K + y[1] * M + B[1] * P + D[1] * G
      l[2] = n[2] * K + y[2] * M + B[2] * P + D[2] * G
      return l
    },
    bezier: function (l, n, y, B, D, G) {
      var H = 1 - G,
        K = H * H,
        M = G * G,
        P = K * H
      K *= 3 * G
      H *= 3 * M
      G *= M
      l[0] = n[0] * P + y[0] * K + B[0] * H + D[0] * G
      l[1] = n[1] * P + y[1] * K + B[1] * H + D[1] * G
      l[2] = n[2] * P + y[2] * K + B[2] * H + D[2] * G
      return l
    },
    random: function (l, n) {
      n = n || 1
      var y = 2 * Ga() * Math.PI,
        B = 2 * Ga() - 1,
        D = Math.sqrt(1 - B * B) * n
      l[0] = Math.cos(y) * D
      l[1] = Math.sin(y) * D
      l[2] = B * n
      return l
    },
    transformMat4: function (l, n, y) {
      var B = n[0],
        D = n[1]
      n = n[2]
      var G = y[3] * B + y[7] * D + y[11] * n + y[15]
      G = G || 1
      l[0] = (y[0] * B + y[4] * D + y[8] * n + y[12]) / G
      l[1] = (y[1] * B + y[5] * D + y[9] * n + y[13]) / G
      l[2] = (y[2] * B + y[6] * D + y[10] * n + y[14]) / G
      return l
    },
    transformMat3: function (l, n, y) {
      var B = n[0],
        D = n[1]
      n = n[2]
      l[0] = B * y[0] + D * y[3] + n * y[6]
      l[1] = B * y[1] + D * y[4] + n * y[7]
      l[2] = B * y[2] + D * y[5] + n * y[8]
      return l
    },
    transformQuat: function (l, n, y) {
      var B = y[0],
        D = y[1],
        G = y[2],
        H = n[0],
        K = n[1]
      n = n[2]
      var M = D * n - G * K,
        P = G * H - B * n,
        R = B * K - D * H
      y = 2 * y[3]
      l[0] = H + M * y + 2 * (D * R - G * P)
      l[1] = K + P * y + 2 * (G * M - B * R)
      l[2] = n + R * y + 2 * (B * P - D * M)
      return l
    },
    rotateX: function (l, n, y, B) {
      var D = [],
        G = []
      D[0] = n[0] - y[0]
      D[1] = n[1] - y[1]
      D[2] = n[2] - y[2]
      G[0] = D[0]
      G[1] = D[1] * Math.cos(B) - D[2] * Math.sin(B)
      G[2] = D[1] * Math.sin(B) + D[2] * Math.cos(B)
      l[0] = G[0] + y[0]
      l[1] = G[1] + y[1]
      l[2] = G[2] + y[2]
      return l
    },
    rotateY: function (l, n, y, B) {
      var D = [],
        G = []
      D[0] = n[0] - y[0]
      D[1] = n[1] - y[1]
      D[2] = n[2] - y[2]
      G[0] = D[2] * Math.sin(B) + D[0] * Math.cos(B)
      G[1] = D[1]
      G[2] = D[2] * Math.cos(B) - D[0] * Math.sin(B)
      l[0] = G[0] + y[0]
      l[1] = G[1] + y[1]
      l[2] = G[2] + y[2]
      return l
    },
    rotateZ: function (l, n, y, B) {
      var D = [],
        G = []
      D[0] = n[0] - y[0]
      D[1] = n[1] - y[1]
      D[2] = n[2] - y[2]
      G[0] = D[0] * Math.cos(B) - D[1] * Math.sin(B)
      G[1] = D[0] * Math.sin(B) + D[1] * Math.cos(B)
      G[2] = D[2]
      l[0] = G[0] + y[0]
      l[1] = G[1] + y[1]
      l[2] = G[2] + y[2]
      return l
    },
    angle: function (l, n) {
      var y = l[0],
        B = l[1],
        D = l[2],
        G = n[0],
        H = n[1],
        K = n[2]
      l = (y = Math.sqrt(y * y + B * B + D * D) * Math.sqrt(G * G + H * H + K * K)) && L(l, n) / y
      return Math.acos(Math.min(Math.max(l, -1), 1))
    },
    zero: function (l) {
      l[0] = 0
      l[1] = 0
      l[2] = 0
      return l
    },
    str: function (l) {
      return 'vec3(' + l[0] + ', ' + l[1] + ', ' + l[2] + ')'
    },
    exactEquals: function (l, n) {
      return l[0] === n[0] && l[1] === n[1] && l[2] === n[2]
    },
    equals: function (l, n) {
      var y = l[0],
        B = l[1]
      l = l[2]
      var D = n[0],
        G = n[1]
      n = n[2]
      return Math.abs(y - D) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(D)) && Math.abs(B - G) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(G)) && Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
    },
    sub: A,
    mul: z,
    div: C,
    dist: E,
    sqrDist: J,
    len: v,
    sqrLen: F,
    forEach: La
  })
  var Ma = (function () {
    var l = S()
    return function (n, y, B, D, G, H) {
      y || (y = 4)
      B || (B = 0)
      for (D = D ? Math.min(D * y + B, n.length) : n.length; B < D; B += y) (l[0] = n[B]), (l[1] = n[B + 1]), (l[2] = n[B + 2]), (l[3] = n[B + 3]), G(l, l, H), (n[B] = l[0]), (n[B + 1] = l[1]), (n[B + 2] = l[2]), (n[B + 3] = l[3])
      return n
    }
  })()
  Ma = Object.freeze({
    __proto__: null,
    create: S,
    clone: V,
    fromValues: U,
    copy: X,
    set: ia,
    add: ka,
    subtract: ya,
    multiply: ta,
    divide: Ba,
    ceil: function (l, n) {
      l[0] = Math.ceil(n[0])
      l[1] = Math.ceil(n[1])
      l[2] = Math.ceil(n[2])
      l[3] = Math.ceil(n[3])
      return l
    },
    floor: function (l, n) {
      l[0] = Math.floor(n[0])
      l[1] = Math.floor(n[1])
      l[2] = Math.floor(n[2])
      l[3] = Math.floor(n[3])
      return l
    },
    min: function (l, n, y) {
      l[0] = Math.min(n[0], y[0])
      l[1] = Math.min(n[1], y[1])
      l[2] = Math.min(n[2], y[2])
      l[3] = Math.min(n[3], y[3])
      return l
    },
    max: function (l, n, y) {
      l[0] = Math.max(n[0], y[0])
      l[1] = Math.max(n[1], y[1])
      l[2] = Math.max(n[2], y[2])
      l[3] = Math.max(n[3], y[3])
      return l
    },
    round: function (l, n) {
      l[0] = Math.round(n[0])
      l[1] = Math.round(n[1])
      l[2] = Math.round(n[2])
      l[3] = Math.round(n[3])
      return l
    },
    scale: Ea,
    scaleAndAdd: function (l, n, y, B) {
      l[0] = n[0] + y[0] * B
      l[1] = n[1] + y[1] * B
      l[2] = n[2] + y[2] * B
      l[3] = n[3] + y[3] * B
      return l
    },
    distance: Ca,
    squaredDistance: Aa,
    length: ja,
    squaredLength: Fa,
    negate: function (l, n) {
      l[0] = -n[0]
      l[1] = -n[1]
      l[2] = -n[2]
      l[3] = -n[3]
      return l
    },
    inverse: function (l, n) {
      l[0] = 1 / n[0]
      l[1] = 1 / n[1]
      l[2] = 1 / n[2]
      l[3] = 1 / n[3]
      return l
    },
    normalize: wa,
    dot: Da,
    cross: function (l, n, y, B) {
      var D = y[0] * B[1] - y[1] * B[0],
        G = y[0] * B[2] - y[2] * B[0],
        H = y[0] * B[3] - y[3] * B[0],
        K = y[1] * B[2] - y[2] * B[1],
        M = y[1] * B[3] - y[3] * B[1]
      y = y[2] * B[3] - y[3] * B[2]
      B = n[0]
      var P = n[1],
        R = n[2]
      n = n[3]
      l[0] = P * y - R * M + n * K
      l[1] = -(B * y) + R * H - n * G
      l[2] = B * M - P * H + n * D
      l[3] = -(B * K) + P * G - R * D
      return l
    },
    lerp: Pa,
    random: function (l, n) {
      n = n || 1
      do {
        var y = 2 * Ga() - 1
        var B = 2 * Ga() - 1
        var D = y * y + B * B
      } while (1 <= D)
      do {
        var G = 2 * Ga() - 1
        var H = 2 * Ga() - 1
        var K = G * G + H * H
      } while (1 <= K)
      D = Math.sqrt((1 - D) / K)
      l[0] = n * y
      l[1] = n * B
      l[2] = n * G * D
      l[3] = n * H * D
      return l
    },
    transformMat4: function (l, n, y) {
      var B = n[0],
        D = n[1],
        G = n[2]
      n = n[3]
      l[0] = y[0] * B + y[4] * D + y[8] * G + y[12] * n
      l[1] = y[1] * B + y[5] * D + y[9] * G + y[13] * n
      l[2] = y[2] * B + y[6] * D + y[10] * G + y[14] * n
      l[3] = y[3] * B + y[7] * D + y[11] * G + y[15] * n
      return l
    },
    transformQuat: function (l, n, y) {
      var B = n[0],
        D = n[1],
        G = n[2],
        H = y[0],
        K = y[1],
        M = y[2]
      y = y[3]
      var P = y * B + K * G - M * D,
        R = y * D + M * B - H * G,
        T = y * G + H * D - K * B
      B = -H * B - K * D - M * G
      l[0] = P * y + B * -H + R * -M - T * -K
      l[1] = R * y + B * -K + T * -H - P * -M
      l[2] = T * y + B * -M + P * -K - R * -H
      l[3] = n[3]
      return l
    },
    zero: function (l) {
      l[0] = 0
      l[1] = 0
      l[2] = 0
      l[3] = 0
      return l
    },
    str: function (l) {
      return 'vec4(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ')'
    },
    exactEquals: Qa,
    equals: Ra,
    sub: ya,
    mul: ta,
    div: Ba,
    dist: Ca,
    sqrDist: Aa,
    len: ja,
    sqrLen: Fa,
    forEach: Ma
  })
  var Na = (function () {
      var l = x(),
        n = u(1, 0, 0),
        y = u(0, 1, 0)
      return function (B, D, G) {
        var H = L(D, G)
        if (-0.999999 > H) return N(l, n, D), 1e-6 > v(l) && N(l, y, D), I(l, l), Sa(B, l, Math.PI), B
        if (0.999999 < H) return (B[0] = 0), (B[1] = 0), (B[2] = 0), (B[3] = 1), B
        N(l, D, G)
        B[0] = l[0]
        B[1] = l[1]
        B[2] = l[2]
        B[3] = 1 + H
        return wa(B, B)
      }
    })(),
    Oa = (function () {
      var l = Ja(),
        n = Ja()
      return function (y, B, D, G, H, K) {
        Ka(l, B, H, K)
        Ka(n, D, G, K)
        Ka(y, l, n, 2 * K * (1 - K))
        return y
      }
    })(),
    Ia = (function () {
      var l = f()
      return function (n, y, B, D) {
        l[0] = B[0]
        l[3] = B[1]
        l[6] = B[2]
        l[1] = D[0]
        l[4] = D[1]
        l[7] = D[2]
        l[2] = -y[0]
        l[5] = -y[1]
        l[8] = -y[2]
        return wa(n, Za(n, l))
      }
    })()
  Na = Object.freeze({
    __proto__: null,
    create: Ja,
    identity: function (l) {
      l[0] = 0
      l[1] = 0
      l[2] = 0
      l[3] = 1
      return l
    },
    setAxisAngle: Sa,
    getAxisAngle: function (l, n) {
      var y = 2 * Math.acos(n[3]),
        B = Math.sin(y / 2)
      1e-6 < B ? ((l[0] = n[0] / B), (l[1] = n[1] / B), (l[2] = n[2] / B)) : ((l[0] = 1), (l[1] = 0), (l[2] = 0))
      return y
    },
    getAngle: function (l, n) {
      l = Da(l, n)
      return Math.acos(2 * l * l - 1)
    },
    multiply: Ta,
    rotateX: Ua,
    rotateY: Va,
    rotateZ: Wa,
    calculateW: function (l, n) {
      var y = n[0],
        B = n[1]
      n = n[2]
      l[0] = y
      l[1] = B
      l[2] = n
      l[3] = Math.sqrt(Math.abs(1 - y * y - B * B - n * n))
      return l
    },
    exp: Xa,
    ln: Ya,
    pow: function (l, n, y) {
      Ya(l, n)
      Ea(l, l, y)
      Xa(l, l)
      return l
    },
    slerp: Ka,
    random: function (l) {
      var n = Ga(),
        y = Ga(),
        B = Ga(),
        D = Math.sqrt(1 - n)
      n = Math.sqrt(n)
      l[0] = D * Math.sin(2 * Math.PI * y)
      l[1] = D * Math.cos(2 * Math.PI * y)
      l[2] = n * Math.sin(2 * Math.PI * B)
      l[3] = n * Math.cos(2 * Math.PI * B)
      return l
    },
    invert: function (l, n) {
      var y = n[0],
        B = n[1],
        D = n[2]
      n = n[3]
      var G = y * y + B * B + D * D + n * n
      G = G ? 1 / G : 0
      l[0] = -y * G
      l[1] = -B * G
      l[2] = -D * G
      l[3] = n * G
      return l
    },
    conjugate: function (l, n) {
      l[0] = -n[0]
      l[1] = -n[1]
      l[2] = -n[2]
      l[3] = n[3]
      return l
    },
    fromMat3: Za,
    fromEuler: function (l, n, y, B) {
      var D = (0.5 * Math.PI) / 180
      n *= D
      y *= D
      B *= D
      D = Math.sin(n)
      n = Math.cos(n)
      var G = Math.sin(y)
      y = Math.cos(y)
      var H = Math.sin(B)
      B = Math.cos(B)
      l[0] = D * y * B - n * G * H
      l[1] = n * G * B + D * y * H
      l[2] = n * y * H - D * G * B
      l[3] = n * y * B + D * G * H
      return l
    },
    str: function (l) {
      return 'quat(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ')'
    },
    clone: V,
    fromValues: U,
    copy: X,
    set: ia,
    add: ka,
    mul: Ta,
    scale: Ea,
    dot: Da,
    lerp: Pa,
    length: ja,
    len: ja,
    squaredLength: Fa,
    sqrLen: Fa,
    normalize: wa,
    exactEquals: Qa,
    equals: Ra,
    rotationTo: Na,
    sqlerp: Oa,
    setAxes: Ia
  })
  Oa = Object.freeze({
    __proto__: null,
    create: function () {
      var l = new na(8)
      na != Float32Array && ((l[0] = 0), (l[1] = 0), (l[2] = 0), (l[4] = 0), (l[5] = 0), (l[6] = 0), (l[7] = 0))
      l[3] = 1
      return l
    },
    clone: function (l) {
      var n = new na(8)
      n[0] = l[0]
      n[1] = l[1]
      n[2] = l[2]
      n[3] = l[3]
      n[4] = l[4]
      n[5] = l[5]
      n[6] = l[6]
      n[7] = l[7]
      return n
    },
    fromValues: function (l, n, y, B, D, G, H, K) {
      var M = new na(8)
      M[0] = l
      M[1] = n
      M[2] = y
      M[3] = B
      M[4] = D
      M[5] = G
      M[6] = H
      M[7] = K
      return M
    },
    fromRotationTranslationValues: function (l, n, y, B, D, G, H) {
      var K = new na(8)
      K[0] = l
      K[1] = n
      K[2] = y
      K[3] = B
      D *= 0.5
      G *= 0.5
      H *= 0.5
      K[4] = D * B + G * y - H * n
      K[5] = G * B + H * l - D * y
      K[6] = H * B + D * n - G * l
      K[7] = -D * l - G * n - H * y
      return K
    },
    fromRotationTranslation: $a,
    fromTranslation: function (l, n) {
      l[0] = 0
      l[1] = 0
      l[2] = 0
      l[3] = 1
      l[4] = 0.5 * n[0]
      l[5] = 0.5 * n[1]
      l[6] = 0.5 * n[2]
      l[7] = 0
      return l
    },
    fromRotation: function (l, n) {
      l[0] = n[0]
      l[1] = n[1]
      l[2] = n[2]
      l[3] = n[3]
      l[4] = 0
      l[5] = 0
      l[6] = 0
      l[7] = 0
      return l
    },
    fromMat4: function (l, n) {
      var y = Ja()
      q(y, n)
      var B = new na(3)
      w(B, n)
      $a(l, y, B)
      return l
    },
    copy: ab,
    identity: function (l) {
      l[0] = 0
      l[1] = 0
      l[2] = 0
      l[3] = 1
      l[4] = 0
      l[5] = 0
      l[6] = 0
      l[7] = 0
      return l
    },
    set: function (l, n, y, B, D, G, H, K, M) {
      l[0] = n
      l[1] = y
      l[2] = B
      l[3] = D
      l[4] = G
      l[5] = H
      l[6] = K
      l[7] = M
      return l
    },
    getReal: X,
    getDual: function (l, n) {
      l[0] = n[4]
      l[1] = n[5]
      l[2] = n[6]
      l[3] = n[7]
      return l
    },
    setReal: X,
    setDual: function (l, n) {
      l[4] = n[0]
      l[5] = n[1]
      l[6] = n[2]
      l[7] = n[3]
      return l
    },
    getTranslation: function (l, n) {
      var y = n[4],
        B = n[5],
        D = n[6],
        G = n[7],
        H = -n[0],
        K = -n[1],
        M = -n[2]
      n = n[3]
      l[0] = 2 * (y * n + G * H + B * M - D * K)
      l[1] = 2 * (B * n + G * K + D * H - y * M)
      l[2] = 2 * (D * n + G * M + y * K - B * H)
      return l
    },
    translate: function (l, n, y) {
      var B = n[0],
        D = n[1],
        G = n[2],
        H = n[3],
        K = 0.5 * y[0],
        M = 0.5 * y[1]
      y = 0.5 * y[2]
      var P = n[4],
        R = n[5],
        T = n[6]
      n = n[7]
      l[0] = B
      l[1] = D
      l[2] = G
      l[3] = H
      l[4] = H * K + D * y - G * M + P
      l[5] = H * M + G * K - B * y + R
      l[6] = H * y + B * M - D * K + T
      l[7] = -B * K - D * M - G * y + n
      return l
    },
    rotateX: function (l, n, y) {
      var B = -n[0],
        D = -n[1],
        G = -n[2],
        H = n[3],
        K = n[4],
        M = n[5],
        P = n[6],
        R = n[7],
        T = K * H + R * B + M * G - P * D,
        Z = M * H + R * D + P * B - K * G,
        W = P * H + R * G + K * D - M * B
      K = R * H - K * B - M * D - P * G
      Ua(l, n, y)
      B = l[0]
      D = l[1]
      G = l[2]
      H = l[3]
      l[4] = T * H + K * B + Z * G - W * D
      l[5] = Z * H + K * D + W * B - T * G
      l[6] = W * H + K * G + T * D - Z * B
      l[7] = K * H - T * B - Z * D - W * G
      return l
    },
    rotateY: function (l, n, y) {
      var B = -n[0],
        D = -n[1],
        G = -n[2],
        H = n[3],
        K = n[4],
        M = n[5],
        P = n[6],
        R = n[7],
        T = K * H + R * B + M * G - P * D,
        Z = M * H + R * D + P * B - K * G,
        W = P * H + R * G + K * D - M * B
      K = R * H - K * B - M * D - P * G
      Va(l, n, y)
      B = l[0]
      D = l[1]
      G = l[2]
      H = l[3]
      l[4] = T * H + K * B + Z * G - W * D
      l[5] = Z * H + K * D + W * B - T * G
      l[6] = W * H + K * G + T * D - Z * B
      l[7] = K * H - T * B - Z * D - W * G
      return l
    },
    rotateZ: function (l, n, y) {
      var B = -n[0],
        D = -n[1],
        G = -n[2],
        H = n[3],
        K = n[4],
        M = n[5],
        P = n[6],
        R = n[7],
        T = K * H + R * B + M * G - P * D,
        Z = M * H + R * D + P * B - K * G,
        W = P * H + R * G + K * D - M * B
      K = R * H - K * B - M * D - P * G
      Wa(l, n, y)
      B = l[0]
      D = l[1]
      G = l[2]
      H = l[3]
      l[4] = T * H + K * B + Z * G - W * D
      l[5] = Z * H + K * D + W * B - T * G
      l[6] = W * H + K * G + T * D - Z * B
      l[7] = K * H - T * B - Z * D - W * G
      return l
    },
    rotateByQuatAppend: function (l, n, y) {
      var B = y[0],
        D = y[1],
        G = y[2]
      y = y[3]
      var H = n[0],
        K = n[1],
        M = n[2],
        P = n[3]
      l[0] = H * y + P * B + K * G - M * D
      l[1] = K * y + P * D + M * B - H * G
      l[2] = M * y + P * G + H * D - K * B
      l[3] = P * y - H * B - K * D - M * G
      H = n[4]
      K = n[5]
      M = n[6]
      P = n[7]
      l[4] = H * y + P * B + K * G - M * D
      l[5] = K * y + P * D + M * B - H * G
      l[6] = M * y + P * G + H * D - K * B
      l[7] = P * y - H * B - K * D - M * G
      return l
    },
    rotateByQuatPrepend: function (l, n, y) {
      var B = n[0],
        D = n[1],
        G = n[2]
      n = n[3]
      var H = y[0],
        K = y[1],
        M = y[2],
        P = y[3]
      l[0] = B * P + n * H + D * M - G * K
      l[1] = D * P + n * K + G * H - B * M
      l[2] = G * P + n * M + B * K - D * H
      l[3] = n * P - B * H - D * K - G * M
      H = y[4]
      K = y[5]
      M = y[6]
      P = y[7]
      l[4] = B * P + n * H + D * M - G * K
      l[5] = D * P + n * K + G * H - B * M
      l[6] = G * P + n * M + B * K - D * H
      l[7] = n * P - B * H - D * K - G * M
      return l
    },
    rotateAroundAxis: function (l, n, y, B) {
      if (1e-6 > Math.abs(B)) return ab(l, n)
      var D = Math.hypot(y[0], y[1], y[2])
      B *= 0.5
      var G = Math.sin(B),
        H = (G * y[0]) / D,
        K = (G * y[1]) / D
      y = (G * y[2]) / D
      B = Math.cos(B)
      D = n[0]
      G = n[1]
      var M = n[2],
        P = n[3]
      l[0] = D * B + P * H + G * y - M * K
      l[1] = G * B + P * K + M * H - D * y
      l[2] = M * B + P * y + D * K - G * H
      l[3] = P * B - D * H - G * K - M * y
      D = n[4]
      G = n[5]
      M = n[6]
      n = n[7]
      l[4] = D * B + n * H + G * y - M * K
      l[5] = G * B + n * K + M * H - D * y
      l[6] = M * B + n * y + D * K - G * H
      l[7] = n * B - D * H - G * K - M * y
      return l
    },
    add: function (l, n, y) {
      l[0] = n[0] + y[0]
      l[1] = n[1] + y[1]
      l[2] = n[2] + y[2]
      l[3] = n[3] + y[3]
      l[4] = n[4] + y[4]
      l[5] = n[5] + y[5]
      l[6] = n[6] + y[6]
      l[7] = n[7] + y[7]
      return l
    },
    multiply: bb,
    mul: bb,
    scale: function (l, n, y) {
      l[0] = n[0] * y
      l[1] = n[1] * y
      l[2] = n[2] * y
      l[3] = n[3] * y
      l[4] = n[4] * y
      l[5] = n[5] * y
      l[6] = n[6] * y
      l[7] = n[7] * y
      return l
    },
    dot: Da,
    lerp: function (l, n, y, B) {
      var D = 1 - B
      0 > Da(n, y) && (B = -B)
      l[0] = n[0] * D + y[0] * B
      l[1] = n[1] * D + y[1] * B
      l[2] = n[2] * D + y[2] * B
      l[3] = n[3] * D + y[3] * B
      l[4] = n[4] * D + y[4] * B
      l[5] = n[5] * D + y[5] * B
      l[6] = n[6] * D + y[6] * B
      l[7] = n[7] * D + y[7] * B
      return l
    },
    invert: function (l, n) {
      var y = Fa(n)
      l[0] = -n[0] / y
      l[1] = -n[1] / y
      l[2] = -n[2] / y
      l[3] = n[3] / y
      l[4] = -n[4] / y
      l[5] = -n[5] / y
      l[6] = -n[6] / y
      l[7] = n[7] / y
      return l
    },
    conjugate: function (l, n) {
      l[0] = -n[0]
      l[1] = -n[1]
      l[2] = -n[2]
      l[3] = n[3]
      l[4] = -n[4]
      l[5] = -n[5]
      l[6] = -n[6]
      l[7] = n[7]
      return l
    },
    length: ja,
    len: ja,
    squaredLength: Fa,
    sqrLen: Fa,
    normalize: function (l, n) {
      var y = Fa(n)
      if (0 < y) {
        y = Math.sqrt(y)
        var B = n[0] / y,
          D = n[1] / y,
          G = n[2] / y,
          H = n[3] / y,
          K = n[4],
          M = n[5],
          P = n[6]
        n = n[7]
        var R = B * K + D * M + G * P + H * n
        l[0] = B
        l[1] = D
        l[2] = G
        l[3] = H
        l[4] = (K - B * R) / y
        l[5] = (M - D * R) / y
        l[6] = (P - G * R) / y
        l[7] = (n - H * R) / y
      }
      return l
    },
    str: function (l) {
      return 'quat2(' + l[0] + ', ' + l[1] + ', ' + l[2] + ', ' + l[3] + ', ' + l[4] + ', ' + l[5] + ', ' + l[6] + ', ' + l[7] + ')'
    },
    exactEquals: function (l, n) {
      return l[0] === n[0] && l[1] === n[1] && l[2] === n[2] && l[3] === n[3] && l[4] === n[4] && l[5] === n[5] && l[6] === n[6] && l[7] === n[7]
    },
    equals: function (l, n) {
      var y = l[0],
        B = l[1],
        D = l[2],
        G = l[3],
        H = l[4],
        K = l[5],
        M = l[6]
      l = l[7]
      var P = n[0],
        R = n[1],
        T = n[2],
        Z = n[3],
        W = n[4],
        da = n[5],
        ca = n[6]
      n = n[7]
      return (
        Math.abs(y - P) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(P)) &&
        Math.abs(B - R) <= 1e-6 * Math.max(1, Math.abs(B), Math.abs(R)) &&
        Math.abs(D - T) <= 1e-6 * Math.max(1, Math.abs(D), Math.abs(T)) &&
        Math.abs(G - Z) <= 1e-6 * Math.max(1, Math.abs(G), Math.abs(Z)) &&
        Math.abs(H - W) <= 1e-6 * Math.max(1, Math.abs(H), Math.abs(W)) &&
        Math.abs(K - da) <= 1e-6 * Math.max(1, Math.abs(K), Math.abs(da)) &&
        Math.abs(M - ca) <= 1e-6 * Math.max(1, Math.abs(M), Math.abs(ca)) &&
        Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
      )
    }
  })
  Ia = (function () {
    var l = cb()
    return function (n, y, B, D, G, H) {
      y || (y = 2)
      B || (B = 0)
      for (D = D ? Math.min(D * y + B, n.length) : n.length; B < D; B += y) (l[0] = n[B]), (l[1] = n[B + 1]), G(l, l, H), (n[B] = l[0]), (n[B + 1] = l[1])
      return n
    }
  })()
  Ia = Object.freeze({
    __proto__: null,
    create: cb,
    clone: function (l) {
      var n = new na(2)
      n[0] = l[0]
      n[1] = l[1]
      return n
    },
    fromValues: function (l, n) {
      var y = new na(2)
      y[0] = l
      y[1] = n
      return y
    },
    copy: function (l, n) {
      l[0] = n[0]
      l[1] = n[1]
      return l
    },
    set: function (l, n, y) {
      l[0] = n
      l[1] = y
      return l
    },
    add: function (l, n, y) {
      l[0] = n[0] + y[0]
      l[1] = n[1] + y[1]
      return l
    },
    subtract: db,
    multiply: eb,
    divide: fb,
    ceil: function (l, n) {
      l[0] = Math.ceil(n[0])
      l[1] = Math.ceil(n[1])
      return l
    },
    floor: function (l, n) {
      l[0] = Math.floor(n[0])
      l[1] = Math.floor(n[1])
      return l
    },
    min: function (l, n, y) {
      l[0] = Math.min(n[0], y[0])
      l[1] = Math.min(n[1], y[1])
      return l
    },
    max: function (l, n, y) {
      l[0] = Math.max(n[0], y[0])
      l[1] = Math.max(n[1], y[1])
      return l
    },
    round: function (l, n) {
      l[0] = Math.round(n[0])
      l[1] = Math.round(n[1])
      return l
    },
    scale: function (l, n, y) {
      l[0] = n[0] * y
      l[1] = n[1] * y
      return l
    },
    scaleAndAdd: function (l, n, y, B) {
      l[0] = n[0] + y[0] * B
      l[1] = n[1] + y[1] * B
      return l
    },
    distance: gb,
    squaredDistance: hb,
    length: ib,
    squaredLength: jb,
    negate: function (l, n) {
      l[0] = -n[0]
      l[1] = -n[1]
      return l
    },
    inverse: function (l, n) {
      l[0] = 1 / n[0]
      l[1] = 1 / n[1]
      return l
    },
    normalize: function (l, n) {
      var y = n[0],
        B = n[1]
      y = y * y + B * B
      0 < y && (y = 1 / Math.sqrt(y))
      l[0] = n[0] * y
      l[1] = n[1] * y
      return l
    },
    dot: function (l, n) {
      return l[0] * n[0] + l[1] * n[1]
    },
    cross: function (l, n, y) {
      n = n[0] * y[1] - n[1] * y[0]
      l[0] = l[1] = 0
      l[2] = n
      return l
    },
    lerp: function (l, n, y, B) {
      var D = n[0]
      n = n[1]
      l[0] = D + B * (y[0] - D)
      l[1] = n + B * (y[1] - n)
      return l
    },
    random: function (l, n) {
      n = n || 1
      var y = 2 * Ga() * Math.PI
      l[0] = Math.cos(y) * n
      l[1] = Math.sin(y) * n
      return l
    },
    transformMat2: function (l, n, y) {
      var B = n[0]
      n = n[1]
      l[0] = y[0] * B + y[2] * n
      l[1] = y[1] * B + y[3] * n
      return l
    },
    transformMat2d: function (l, n, y) {
      var B = n[0]
      n = n[1]
      l[0] = y[0] * B + y[2] * n + y[4]
      l[1] = y[1] * B + y[3] * n + y[5]
      return l
    },
    transformMat3: function (l, n, y) {
      var B = n[0]
      n = n[1]
      l[0] = y[0] * B + y[3] * n + y[6]
      l[1] = y[1] * B + y[4] * n + y[7]
      return l
    },
    transformMat4: function (l, n, y) {
      var B = n[0]
      n = n[1]
      l[0] = y[0] * B + y[4] * n + y[12]
      l[1] = y[1] * B + y[5] * n + y[13]
      return l
    },
    rotate: function (l, n, y, B) {
      var D = n[0] - y[0]
      n = n[1] - y[1]
      var G = Math.sin(B)
      B = Math.cos(B)
      l[0] = D * B - n * G + y[0]
      l[1] = D * G + n * B + y[1]
      return l
    },
    angle: function (l, n) {
      var y = l[0]
      l = l[1]
      var B = n[0]
      n = n[1]
      var D = Math.sqrt(y * y + l * l) * Math.sqrt(B * B + n * n)
      return Math.acos(Math.min(Math.max(D && (y * B + l * n) / D, -1), 1))
    },
    zero: function (l) {
      l[0] = 0
      l[1] = 0
      return l
    },
    str: function (l) {
      return 'vec2(' + l[0] + ', ' + l[1] + ')'
    },
    exactEquals: function (l, n) {
      return l[0] === n[0] && l[1] === n[1]
    },
    equals: function (l, n) {
      var y = l[0]
      l = l[1]
      var B = n[0]
      n = n[1]
      return Math.abs(y - B) <= 1e-6 * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(l - n) <= 1e-6 * Math.max(1, Math.abs(l), Math.abs(n))
    },
    len: ib,
    sub: db,
    mul: eb,
    div: fb,
    dist: gb,
    sqrDist: hb,
    sqrLen: jb,
    forEach: Ia
  })
  e.glMatrix = lb
  e.mat2 = mb
  e.mat2d = nb
  e.mat3 = ob
  e.mat4 = pb
  e.quat = Na
  e.quat2 = Oa
  e.vec2 = Ia
  e.vec3 = La
  e.vec4 = Ma
  Object.defineProperty(e, '__esModule', {
    value: !0
  })
})
{
  ;('use strict')

  function e(F, I, L) {
    var N = [0, 0]
    var S = F[1][1] - F[0][1]
    var V = F[0][0] - F[1][0]
    F = S * F[0][0] + V * F[0][1]
    var U = I[1][1] - I[0][1]
    var X = I[0][0] - I[1][0]
    I = U * I[0][0] + X * I[0][1]
    var ia = S * X - U * V
    E(ia, 0, L || 0) || ((N[0] = (X * F - V * I) / ia), (N[1] = (S * I - U * F) / ia))
    return N
  }

  function b(F, I, L, N) {
    var S = I[0] - F[0]
    I = I[1] - F[1]
    var V = N[0] - L[0],
      U = N[1] - L[1]
    if (0 === V * I - U * S) return !1
    N = (S * (L[1] - F[1]) + I * (F[0] - L[0])) / (V * I - U * S)
    F = (V * (F[1] - L[1]) + U * (L[0] - F[0])) / (U * S - V * I)
    return 0 <= N && 1 >= N && 0 <= F && 1 >= F
  }

  function a(F, I, L) {
    return (I[0] - F[0]) * (L[1] - F[1]) - (L[0] - F[0]) * (I[1] - F[1])
  }

  function c(F, I, L) {
    return 0 < a(F, I, L)
  }

  function d(F, I, L) {
    return 0 <= a(F, I, L)
  }

  function f(F, I, L) {
    return 0 > a(F, I, L)
  }

  function g(F, I, L) {
    return 0 >= a(F, I, L)
  }
  var tmpPoint1$$module$str$c3runtime = [],
    tmpPoint2$$module$str$c3runtime = []

  function h(F, I, L, N) {
    if (N) {
      var S = tmpPoint1$$module$str$c3runtime,
        V = tmpPoint2$$module$str$c3runtime
      S[0] = I[0] - F[0]
      S[1] = I[1] - F[1]
      V[0] = L[0] - I[0]
      V[1] = L[1] - I[1]
      return Math.acos((S[0] * V[0] + S[1] * V[1]) / (Math.sqrt(S[0] * S[0] + S[1] * S[1]) * Math.sqrt(V[0] * V[0] + V[1] * V[1]))) < N
    }
    return 0 === a(F, I, L)
  }

  function k(F, I) {
    var L = I[0] - F[0]
    F = I[1] - F[1]
    return L * L + F * F
  }

  function m(F, I) {
    var L = F.length
    return F[0 > I ? (I % L) + L : I % L]
  }

  function r(F) {
    F.length = 0
  }

  function w(F, I, L, N) {
    for (; L < N; L++) F.push(I[L])
  }

  function p(F) {
    for (var I = [], L = F.length, N = 0; N !== L; N++) I.push(F.pop())
    for (N = 0; N !== L; N++) F[N] = I[N]
  }

  function q(F, I) {
    return f(m(F, I - 1), m(F, I), m(F, I + 1))
  }
  var tmpLine1$$module$str$c3runtime = [],
    tmpLine2$$module$str$c3runtime = []

  function t(F, I, L) {
    var N = tmpLine1$$module$str$c3runtime,
      S = tmpLine2$$module$str$c3runtime
    if (d(m(F, I + 1), m(F, I), m(F, L)) && g(m(F, I - 1), m(F, I), m(F, L))) return !1
    var V = k(m(F, I), m(F, L))
    for (var U = 0; U !== F.length; ++U)
      if ((U + 1) % F.length !== I && U !== I && d(m(F, I), m(F, L), m(F, U + 1)) && g(m(F, I), m(F, L), m(F, U))) {
        N[0] = m(F, I)
        N[1] = m(F, L)
        S[0] = m(F, U)
        S[1] = m(F, U + 1)
        var X = e(N, S)
        if (k(m(F, I), X) < V) return !1
      }
    return !0
  }

  function x(F, I, L) {
    for (var N = 0; N !== F.length; ++N) if (N !== I && N !== L && (N + 1) % F.length !== I && (N + 1) % F.length !== L && b(m(F, I), m(F, L), m(F, N), m(F, N + 1))) return !1
    return !0
  }

  function v(F, I, L, N) {
    N = N || []
    r(N)
    if (I < L) for (var S = I; S <= L; S++) N.push(F[S])
    else {
      for (S = 0; S <= L; S++) N.push(F[S])
      for (S = I; S < F.length; S++) N.push(F[S])
    }
    return N
  }

  function u(F) {
    for (var I = [], L, N, S = [], V = Number.MAX_VALUE, U = 0; U < F.length; ++U)
      if (q(F, U))
        for (var X = 0; X < F.length; ++X)
          if (t(F, U, X)) {
            L = u(v(F, U, X, S))
            N = u(v(F, X, U, S))
            for (var ia = 0; ia < N.length; ia++) L.push(N[ia])
            L.length < V && ((I = L), (V = L.length), I.push([m(F, U), m(F, X)]))
          }
    return I
  }

  function A(F, I) {
    if (0 === I.length) return [F]
    if (I instanceof Array && I.length && I[0] instanceof Array && 2 === I[0].length && I[0][0] instanceof Array) {
      F = [F]
      for (var L = 0; L < I.length; L++)
        for (var N = I[L], S = 0; S < F.length; S++) {
          var V = A(F[S], N)
          if (V) {
            F.splice(S, 1)
            F.push(V[0], V[1])
            break
          }
        }
      return F
    }
    N = I
    L = F.indexOf(N[0])
    S = F.indexOf(N[1])
    return -1 !== L && -1 !== S ? [v(F, L, S), v(F, S, L)] : !1
  }

  function z(F, I, L, N, S) {
    var V = I[1] - F[1]
    I = F[0] - I[0]
    F = V * F[0] + I * F[1]
    var U = N[1] - L[1]
    N = L[0] - N[0]
    L = U * L[0] + N * L[1]
    var X = V * N - U * I
    return E(X, 0, S || 0) ? [0, 0] : [(N * F - I * L) / X, (V * L - U * F) / X]
  }

  function C(F, I, L, N, S, V, U) {
    V = V || 100
    U = U || 0
    S = S || 25
    I = 'undefined' !== typeof I ? I : []
    L = L || []
    N = N || []
    var X = [0, 0],
      ia = [0, 0],
      ka = [0, 0],
      ya,
      ta = 0,
      Ba = 0,
      Ea = 0,
      Ca = [],
      Aa = []
    if (3 > F.length) return I
    U++
    if (U > V) return console.warn('quickDecomp: max level (' + V + ') reached.'), I
    for (var ja = 0; ja < F.length; ++ja)
      if (q(F, ja)) {
        L.push(F[ja])
        var Fa = (ya = Number.MAX_VALUE)
        for (var wa = 0; wa < F.length; ++wa) {
          if (c(m(F, ja - 1), m(F, ja), m(F, wa)) && g(m(F, ja - 1), m(F, ja), m(F, wa - 1)) && ((ka = z(m(F, ja - 1), m(F, ja), m(F, wa), m(F, wa - 1))), f(m(F, ja + 1), m(F, ja), ka))) {
            var Da = k(F[ja], ka)
            Da < ya && ((ya = Da), (ia = ka), (Ba = wa))
          }
          c(m(F, ja + 1), m(F, ja), m(F, wa + 1)) && g(m(F, ja + 1), m(F, ja), m(F, wa)) && ((ka = z(m(F, ja + 1), m(F, ja), m(F, wa), m(F, wa + 1))), c(m(F, ja - 1), m(F, ja), ka) && ((Da = k(F[ja], ka)), Da < Fa && ((Fa = Da), (X = ka), (ta = wa))))
        }
        if (Ba === (ta + 1) % F.length)
          (ka[0] = (ia[0] + X[0]) / 2),
            (ka[1] = (ia[1] + X[1]) / 2),
            N.push(ka),
            ja < ta ? (w(Ca, F, ja, ta + 1), Ca.push(ka), Aa.push(ka), 0 !== Ba && w(Aa, F, Ba, F.length), w(Aa, F, 0, ja + 1)) : (0 !== ja && w(Ca, F, ja, F.length), w(Ca, F, 0, ta + 1), Ca.push(ka), Aa.push(ka), w(Aa, F, Ba, ja + 1))
        else {
          Ba > ta && (ta += F.length)
          X = Number.MAX_VALUE
          if (ta < Ba) return I
          for (wa = Ba; wa <= ta; ++wa) d(m(F, ja - 1), m(F, ja), m(F, wa)) && g(m(F, ja + 1), m(F, ja), m(F, wa)) && ((Da = k(m(F, ja), m(F, wa))), Da < X && x(F, ja, wa) && ((X = Da), (Ea = wa % F.length)))
          ja < Ea ? (w(Ca, F, ja, Ea + 1), 0 !== Ea && w(Aa, F, Ea, F.length), w(Aa, F, 0, ja + 1)) : (0 !== ja && w(Ca, F, ja, F.length), w(Ca, F, 0, Ea + 1), w(Aa, F, Ea, ja + 1))
        }
        Ca.length < Aa.length ? (C(Ca, I, L, N, S, V, U), C(Aa, I, L, N, S, V, U)) : (C(Aa, I, L, N, S, V, U), C(Ca, I, L, N, S, V, U))
        return I
      }
    I.push(F)
    return I
  }

  function E(F, I, L) {
    return Math.abs(F - I) <= (L || 0)
  }

  function J(F, I, L) {
    return E(F[0], I[0], L) && E(F[1], I[1], L)
  }
  self.polyDecomp = {
    decomp: function (F) {
      var I = u(F)
      return 0 < I.length ? A(F, I) : [F]
    },
    quickDecomp: C,
    isSimple: function (F) {
      var I
      for (I = 0; I < F.length - 1; I++) for (var L = 0; L < I - 1; L++) if (b(F[I], F[I + 1], F[L], F[L + 1])) return !1
      for (I = 1; I < F.length - 2; I++) if (b(F[0], F[F.length - 1], F[I], F[I + 1])) return !1
      return !0
    },
    removeCollinearPoints: function (F, I) {
      for (var L = 0, N = F.length - 1; 3 < F.length && 0 <= N; --N) h(m(F, N - 1), m(F, N), m(F, N + 1), I) && (F.splice(N % F.length, 1), L++)
      return L
    },
    removeDuplicatePoints: function (F, I) {
      for (var L = F.length - 1; 1 <= L; --L) for (var N = F[L], S = L - 1; 0 <= S; --S) J(N, F[S], I) && F.splice(L, 1)
    },
    makeCCW: function (F) {
      for (var I = 0, L = 1; L < F.length; ++L) if (F[L][1] < F[I][1] || (F[L][1] === F[I][1] && F[L][0] > F[I][0])) I = L
      if (c(m(F, I - 1), m(F, I), m(F, I + 1))) return !1
      p(F)
      return !0
    }
  }
}
{
  ;('use strict')
  let e = !1,
    b = !1,
    a = 'dev'
  const c = (self.C3 = class {
    constructor() {
      throw TypeError("static class can't be instantiated")
    }
    static SetReady() {
      e = !0
    }
    static IsReady() {
      return e
    }
    static SetAppStarted() {
      b = !0
    }
    static HasAppStarted() {
      return b
    }
    static SetBuildMode(d) {
      a = d
    }
    static GetBuildMode() {
      return a
    }
    static IsReleaseBuild() {
      return 'final' === a
    }
  })
  c.isDebug = !1
  c.isDebugDefend = !1
  c.hardwareConcurrency = navigator.hardwareConcurrency || 2
  self.C3X = {}
}
{
  ;('use strict')
  const e = self.C3
  e.QueryParser = class {
    constructor(b) {
      this._queryString = b
      this._parameters = new Map()
      this._Parse()
    }
    _Parse() {
      var b = this._queryString
      if (b.startsWith('?') || b.startsWith('#')) b = b.substr(1)
      b = b.split('&')
      for (const a of b) this._ParseParameter(a)
    }
    _ParseParameter(b) {
      if (b)
        if (b.includes('=')) {
          var a = b.indexOf('='),
            c = decodeURIComponent(b.substring(0, a))
          b = decodeURIComponent(b.substring(a + 1))
          this._parameters.set(c, b)
        } else this._parameters.set(b, null)
    }
    LogAll() {
      for (const b of this._parameters) console.log("[QueryParser] Parameter '" + b[0] + "' = " + (null === b[1] ? 'null' : "'" + b[1] + "'"))
    }
    Has(b) {
      return this._parameters.has(b)
    }
    Get(b) {
      b = this._parameters.get(b)
      return 'undefined' === typeof b ? null : b
    }
    ClearHash() {
      history.replaceState('', document.title, location.pathname + location.search)
    }
    Reparse(b) {
      this._queryString = b
      this._parameters.clear()
      this._Parse()
    }
  }
  e.QueryString = new e.QueryParser(location.search)
  e.LocationHashString = new e.QueryParser(location.hash)
  'dev' !== e.QueryString.Get('mode') && e.SetBuildMode('final')
}
{
  ;('use strict')
  const e = self.C3,
    b = navigator.userAgent
  let a = {
    linux: /linux|openbsd|freebsd|netbsd/i.test(b),
    chromeOS: /CrOS/.test(b),
    windowsTizen: /trident|iemobile|msie|tizen/i.test(b),
    genericMS: /trident|iemobile|msie|edge\//i.test(b),
    opera: /OPR\//.test(b),
    blackberry: /bb10/i.test(b),
    edge: /edge\//i.test(b),
    trident: /trident/i.test(b),
    webkit: /webkit/i.test(b),
    safari: /safari\//i.test(b),
    chrome: /chrome\//i.test(b),
    chromium: /chromium\//i.test(b),
    crosswalk: /crosswalk|xwalk/i.test(b),
    nwjs: /nwjs/i.test(b),
    amazonwebapp: /amazonwebappplatform/i.test(b),
    webview: /wv\)/.test(b),
    android: /android/i.test(b),
    nokia: /nokiabrowser\/[0-9.]+/i.test(b)
  }
  var JSCompiler_object_inline_windows_0 = /windows\s+nt\s+\d+\.\d+/i.exec(b),
    JSCompiler_object_inline_OSX_1 = /mac\s+os\s+x\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_android_2 = /android\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_opera_3 = /OPR\/[0-9.]+/.exec(b),
    JSCompiler_object_inline_tizen_4 = /tizen\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_iphone_5 = /iphone\s+os\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_ipad_6 = /ipad[^)]*os\s+[0-9_]+/i.exec(b),
    JSCompiler_object_inline_winPhone_7 = /windows\s+phone\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_winPhoneOS_8 = /windows\s+phone\s+os\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_chrome_9 = /chrome\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_chromium_10 = /chromium\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_nwjs_11 = /nwjs\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_firefox_12 = /firefox\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_ie_13 = /msie\s+[0-9.]+/i.exec(b),
    JSCompiler_object_inline_edge_14 = /edge\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_edgeChromium_15 = /edg\/[0-9.]+/i.exec(b),
    JSCompiler_object_inline_silk_16 = /silk\/[0-9.]+/i.exec(b)
  let c = '(unknown)',
    d = '(unknown)',
    f = '(unknown)',
    g = '(unknown)',
    h = '(unknown)',
    k = 'browser',
    m = !1,
    r = !1,
    w = new Map()

  function p(t, x, v) {
    !0 === x ? (v(), w.set(t, !0)) : x && x.length && (v(x[0]), w.set(t, !0))
  }
  p('isWindows', JSCompiler_object_inline_windows_0, t => {
    c = 'Windows'
    if ((t = t.split(' ')[2]))
      switch (t) {
        case '5.0':
          d = '2000'
          break
        case '5.1':
          d = 'XP'
          break
        case '5.2':
          d = 'XP'
          break
        case '6.0':
          d = 'Vista'
          break
        case '6.1':
          d = '7'
          break
        case '6.2':
          d = '8'
          break
        case '6.3':
          d = '8.1'
          break
        case '10.0':
          d = '10'
      }
  })
  p('isOSX', JSCompiler_object_inline_OSX_1, t => {
    c = 'Mac OS X'
    ;(t = t.split(' ')[3]) && (d = t.replace('_', '.'))
  })
  p('isLinux', a.linux, () => {
    c = 'Linux'
  })
  p('isChromeOS', a.chromeOS, () => {
    c = 'Chrome OS'
  })
  p('isAndroid', !a.windowsTizen && JSCompiler_object_inline_android_2, t => {
    c = 'Android'
    ;(t = t.split(' ')[1]) && (d = t)
  })
  p('isTizen', JSCompiler_object_inline_tizen_4, t => {
    c = 'Tizen'
    ;(t = t.split(' ')[1]) && (d = t)
  })
  p('isIPhone', !a.windowsTizen && JSCompiler_object_inline_iphone_5, t => {
    c = 'iOS'
    ;(t = t.split(' ')[2]) && (d = t.replace('_', '.'))
  })
  p('isIPad', !a.windowsTizen && JSCompiler_object_inline_ipad_6, t => {
    c = 'iOS'
    ;(t = t.split(' ')[3]) && (d = t.replace('_', '.'))
  })
  p('isWindowsPhone', JSCompiler_object_inline_winPhone_7, t => {
    c = 'Windows Phone'
    ;(t = t.split(' ')[2]) && (d = t)
  })
  p('isWindowsPhoneOS', JSCompiler_object_inline_winPhoneOS_8, t => {
    c = 'Windows Phone'
    ;(t = t.split(' ')[3]) && (d = t)
  })
  p('isBlackberry', a.blackberry, () => {
    c = 'Blackberry'
    d = '10'
    f = 'stock'
    h = 'webkit'
  })
  p('isChrome', !a.edge && !a.opera && JSCompiler_object_inline_chrome_9, t => {
    f = 'Chrome'
    h = 'Chromium'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isOpera', JSCompiler_object_inline_opera_3, t => {
    f = 'Opera'
    h = 'Chromium'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isChromium', JSCompiler_object_inline_chromium_10, t => {
    h = f = 'Chromium'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isFirefox', JSCompiler_object_inline_firefox_12, t => {
    f = 'Firefox'
    h = 'Gecko'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isInternetExplorer', JSCompiler_object_inline_ie_13, t => {
    f = 'Internet Explorer'
    h = 'Trident'
    ;(t = t.split(' ')[1]) && (g = t)
  })
  p('isTrident', 'Internet Explorer' !== f && a.trident, () => {
    h = 'Trident'
    var t = /rv:[0-9.]+/i.exec(b)
    t && t.length && ((f = 'Internet Explorer'), (t = t[0].split(':')[1]) && (g = t))
  })
  p('isEdge', JSCompiler_object_inline_edge_14, t => {
    h = f = 'Edge'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isEdgeChromium', JSCompiler_object_inline_edgeChromium_15, t => {
    f = 'Edge'
    h = 'Chromium'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isSafari', a.safari && !a.nokia && !a.chrome && !a.chromium && !a.genericIE && !a.blackberry, () => {
    f = 'Safari'
    h = 'WebKit'
    var t = /version\/[0-9.]+/i.exec(b),
      x = /crios\/[0-9.]+/i.exec(b),
      v = /fxios\/[0-9.]+/i.exec(b)
    t && t.length && (t = t[0].split('/')[1]) && (g = t)
    x && x.length && ((f = 'Chrome for iOS'), (x = x[0].split('/')[1]) && (g = x))
    v && v.length && ((f = 'Firefox for iOS'), (v = v[0].split('/')[1]) && (g = v))
  })
  p('isSilk', JSCompiler_object_inline_silk_16, t => {
    f = 'Silk'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isCrosswalk', a.crosswalk, () => (k = 'crosswalk'))
  p('isCordova', self.device && (self.device.cordova || self.device.phonegap), () => (k = 'cordova'))
  p('isNWJS', JSCompiler_object_inline_nwjs_11, t => {
    k = 'nwjs'
    f = 'NW.js'
    h = 'Chromium'
    ;(t = t.split('/')[1]) && (g = t)
  })
  p('isAmazonWebApp', a.amazonwebapp, () => (k = 'webapp'))
  p('isHomeScreenWebApp', 'nwjs' !== k && 'undefined' !== typeof window && ((window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) || navigator.standalone), () => (k = 'webapp'))
  p('isFalseSafari', 'Safari' === f && ('Android' === c || 'Tizen' === c || 'Blackberry' === c), () => (f = 'stock'))
  p('isAndroidWebview', 'Chrome' === f && 'browser' === k && a.webview, () => (k = 'webview'))
  p('isFirefoxOS', 'Firefox' === f && '(unknown)' === c, () => (c = 'Firefox OS'))
  p('isAndroidFallback', '(unknown)' === c && !a.windowsTizen && a.android, () => (c = 'Android'))
  p('isTridentFallback', '(unknown)' === c && a.trident, () => (h = 'Trident'))
  p('isWebkitFallback', '(unknown)' === c && a.webkit, () => (h = 'WebKit'))
  p('isDesktop', (() => 'Windows' === c || 'Mac OS X' === c || 'Linux' === c || 'Chrome OS' === c || 'nwjs' === k)(), () => (m = !0))
  r = 'nwjs' === k
  const q = 'Mac OS X' === c && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints
  q && ((c = 'iOS'), (d = g), (r = m = !1))
  e.Platform = {
    OS: c,
    OSVersion: d,
    Browser: f,
    BrowserVersion: g,
    BrowserVersionNumber: parseFloat(g),
    BrowserEngine: h,
    Context: k,
    IsDesktop: m,
    IsMobile: !m,
    IsDesktopApp: r,
    IsChromeWebStore: !!(self.chrome && self.chrome.runtime && self.chrome.runtime.id),
    IsAppleOS: 'Mac OS X' === c || 'iOS' === c,
    IsIpadOS: q,
    IsLinux: 'Linux' === c
  }
}
;('use strict')
{
  const e = new Map(),
    b = 'undefined' !== typeof IDBObjectStore && 'function' === typeof IDBObjectStore.prototype.getAll,
    a = 'undefined' !== typeof IDBObjectStore && 'function' === typeof IDBObjectStore.prototype.getAllKeys

  function c(q) {
    return new Promise((t, x) => {
      q.onsuccess = () => t(q.result)
      q.onerror = () => x(q.error)
    })
  }

  function d(q) {
    return new Promise((t, x) => {
      q.oncomplete = () => t()
      q.onerror = () => x(q.error)
      q.onabort = () => x(q.error)
    })
  }

  function f(q, t) {
    return h(q, t)
  }

  function g(q, t) {
    return h(q, t, !0)
  }
  async function h(q, t, x = !1, v = !0) {
    const u = await k(q)
    try {
      const A = u.transaction(['keyvaluepairs'], x ? 'readwrite' : 'readonly')
      return t(A)
    } catch (A) {
      if (v && 'InvalidStateError' === A.name) return e.delete(q), h(q, t, x, !1)
      throw A
    }
  }

  function k(q) {
    r(q)
    let t = e.get(q)
    t instanceof Promise || ((t = m(q)), e.set(q, t), t.catch(x => e.delete(q)))
    return t
  }
  async function m(q) {
    r(q)
    const t = indexedDB.open(q, 2)
    t.addEventListener('upgradeneeded', x => {
      try {
        x.target.result.createObjectStore('keyvaluepairs')
      } catch (v) {
        console.error(`Failed to create objectstore for database ${q}`, v)
      }
    })
    return c(t)
  }

  function r(q) {
    if ('string' !== typeof q) throw new TypeError('expected string')
  }

  function w(q, t) {
    const x = q.objectStore('keyvaluepairs').openCursor()
    return new Promise(v => {
      const u = []
      x.onsuccess = A => {
        if ((A = A.target.result)) {
          switch (t) {
            case 'entries':
              u.push([A.key, A.value])
              break
            case 'keys':
              u.push(A.key)
              break
            case 'values':
              u.push(A.value)
          }
          A.continue()
        } else v(u)
      }
    })
  }
  class p {
    constructor(q) {
      r(q)
      this.name = q
    }
    async ready() {
      await k(this.name)
    }
    set(q, t) {
      r(q)
      return g(this.name, async x => {
        var v = x.objectStore('keyvaluepairs').put(t, q)
        v = c(v)
        x = d(x)
        await Promise.all([x, v])
      })
    }
    get(q) {
      r(q)
      return f(this.name, async t => {
        var x = t.objectStore('keyvaluepairs').get(q)
        x = c(x)
        t = d(t)
        ;[, t] = await Promise.all([t, x])
        return t
      })
    }
    delete(q) {
      r(q)
      return g(this.name, async t => {
        var x = t.objectStore('keyvaluepairs').delete(q)
        x = c(x)
        t = d(t)
        await Promise.all([t, x])
      })
    }
    clear() {
      return g(this.name, async q => {
        var t = q.objectStore('keyvaluepairs').clear()
        t = c(t)
        q = d(q)
        await Promise.all([q, t])
      })
    }
    keys() {
      return f(this.name, async q => {
        if (a) {
          var t = q.objectStore('keyvaluepairs').getAllKeys()
          t = c(t)
        } else t = w(q, 'keys')
        q = d(q)
        ;[, q] = await Promise.all([q, t])
        return q
      })
    }
    values() {
      return f(this.name, async q => {
        if (b) {
          var t = q.objectStore('keyvaluepairs').getAll()
          t = c(t)
        } else t = w(q, 'values')
        q = d(q)
        ;[, q] = await Promise.all([q, t])
        return q
      })
    }
    entries() {
      return f(this.name, async q => {
        var t = w(q, 'entries')
        q = d(q)
        ;[, t] = await Promise.all([q, t])
        return t
      })
    }
  }
  self.KVStorageContainer = p
}
;('use strict')
{
  const e = self.KVStorageContainer,
    b = [
      /no available storage method found/i,
      /an attempt was made to break through the security policy of the user agent/i,
      /the user denied permission to access the database/i,
      /a mutation operation was attempted on a database that did not allow mutations/i,
      /idbfactory\.open\(\) called in an invalid security context/i
    ],
    a = new WeakMap()
  let c = !1
  'undefined' === typeof indexedDB && ((c = !0), console.warn('Unable to use local storage because indexedDB is not defined'))

  function d(k) {
    throw Error(`"${k}" is not implemented`)
  }

  function f(k) {
    if ('function' === typeof k) throw Error('localforage callback API is not implemented; please use the promise API instead')
  }

  function g(k) {
    return 'object' === typeof k
      ? new Promise(m => {
          const { port1: r, port2: w } = new MessageChannel()
          w.onmessage = p => m(p.data)
          r.postMessage(k)
        })
      : Promise.resolve(k)
  }
  class h {
    constructor(k) {
      this._inst = k
      a.set(this, new Map())
    }
    _MaybeSwitchToMemoryFallback(k) {
      if (!c)
        for (const m of b)
          if (k && m.test(k.message)) {
            console.error('Unable to use local storage, reverting to in-memory store: ', k, k.message)
            c = !0
            break
          }
    }
    async _getItemFallback(k) {
      k = a.get(this).get(k)
      k = await g(k)
      return 'undefined' === typeof k ? null : k
    }
    async _setItemFallback(k, m) {
      m = await g(m)
      a.get(this).set(k, m)
    }
    _removeItemFallback(k) {
      a.get(this).delete(k)
    }
    _clearFallback() {
      a.get(this).clear()
    }
    _keysFallback() {
      return Array.from(a.get(this).keys())
    }
    IsUsingFallback() {
      return c
    }
    async getItem(k, m) {
      f(m)
      if (c) return await this._getItemFallback(k)
      let r
      try {
        r = await this._inst.get(k)
      } catch (w) {
        this._MaybeSwitchToMemoryFallback(w)
        if (c) return await this._getItemFallback(k)
        console.error(`Error reading '${k}' from storage, returning null: `, w)
        return null
      }
      return 'undefined' === typeof r ? null : r
    }
    async setItem(k, m, r) {
      f(r)
      'undefined' === typeof m && (m = null)
      if (c) await this._setItemFallback(k, m)
      else
        try {
          await this._inst.set(k, m)
        } catch (w) {
          if ((this._MaybeSwitchToMemoryFallback(w), c)) await this._setItemFallback(k, m)
          else throw w
        }
    }
    async removeItem(k, m) {
      f(m)
      if (c) this._removeItemFallback(k)
      else
        try {
          await this._inst.delete(k)
        } catch (r) {
          this._MaybeSwitchToMemoryFallback(r), c ? this._removeItemFallback(k) : console.error(`Error removing '${k}' from storage: `, r)
        }
    }
    async clear(k) {
      f(k)
      if (c) this._clearFallback()
      else
        try {
          await this._inst.clear()
        } catch (m) {
          this._MaybeSwitchToMemoryFallback(m), c ? this._clearFallback() : console.error('Error clearing storage: ', m)
        }
    }
    async keys(k) {
      f(k)
      if (c) return this._keysFallback()
      k = []
      try {
        k = await this._inst.keys()
      } catch (m) {
        this._MaybeSwitchToMemoryFallback(m)
        if (c) return this._keysFallback()
        console.error('Error getting storage keys: ', m)
      }
      return k
    }
    ready(k) {
      f(k)
      return c ? Promise.resolve(!0) : this._inst.ready()
    }
    createInstance(k) {
      if ('object' !== typeof k) throw new TypeError('invalid options object')
      k = k.name
      if ('string' !== typeof k) throw new TypeError('invalid store name')
      k = new e(k)
      return new h(k)
    }
    length(k) {
      d('localforage.length()')
    }
    key(k, m) {
      d('localforage.key()')
    }
    iterate(k, m) {
      d('localforage.iterate()')
    }
    setDriver(k) {
      d('localforage.setDriver()')
    }
    config(k) {
      d('localforage.config()')
    }
    defineDriver(k) {
      d('localforage.defineDriver()')
    }
    driver() {
      d('localforage.driver()')
    }
    supports(k) {
      d('localforage.supports()')
    }
    dropInstance() {
      d('localforage.dropInstance()')
    }
    disableMemoryMode() {
      c = !1
    }
  }
  self.localforage = new h(new e('localforage'))
}
{
  ;('use strict')
  const e = self.C3
  e.Supports = {}
  e.Supports.WebAnimations = (() => {
    try {
      if ('Safari' === e.Platform.Browser || 'undefined' === typeof document) return !1
      const b = document.createElement('div')
      return 'undefined' === typeof b.animate
        ? !1
        : 'undefined' !==
            typeof b.animate(
              [
                {
                  opacity: '0'
                },
                {
                  opacity: '1'
                }
              ],
              1e3
            ).reverse
    } catch (b) {
      return !1
    }
  })()
  e.Supports.DialogElement = 'undefined' !== typeof HTMLDialogElement
  e.Supports.RequestIdleCallback = !!self.requestIdleCallback
  e.Supports.ImageBitmap = !!self.createImageBitmap
  e.Supports.ImageBitmapOptions = !1
  if (e.Supports.ImageBitmap)
    try {
      self
        .createImageBitmap(new ImageData(32, 32), {
          premultiplyAlpha: 'none'
        })
        .then(b => {
          e.Supports.ImageBitmapOptions = !0
        })
        .catch(b => {
          e.Supports.ImageBitmapOptions = !1
        })
    } catch (b) {
      e.Supports.ImageBitmapOptions = !1
    }
  e.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText || 'Firefox' === e.Platform.Browser)
  e.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query)
  e.Supports.Proxies = 'undefined' !== typeof Proxy
  e.Supports.DownloadAttribute = (() => ('undefined' === typeof document ? !1 : 'undefined' !== typeof document.createElement('a').download))()
  e.Supports.CanvasToBlob = (() => 'undefined' !== typeof HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob)()
  e.Supports.Fetch = 'function' === typeof fetch
  e.Supports.PersistentStorage = !!(self.isSecureContext && 'Opera' !== e.Platform.Browser && navigator.storage && navigator.storage.persist)
  e.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate)
  e.Supports.Fullscreen = (() => {
    if ('undefined' === typeof document || 'iOS' === e.Platform.OS) return !1
    const b = document.documentElement
    return !!(b.requestFullscreen || b.msRequestFullscreen || b.mozRequestFullScreen || b.webkitRequestFullscreen)
  })()
  e.Supports.ImageDecoder = 'undefined' !== typeof self.ImageDecoder
  e.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker
  e.Supports.NavigatorFontsQuery = !(!navigator.fonts || !navigator.fonts.query)
}
{
  ;('use strict')
  const e = self.C3
  if (!String.prototype.trimStart) {
    const b = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/
    String.prototype.trimStart = function () {
      return this.replace(b, '')
    }
  }
  if (!String.prototype.trimEnd) {
    const b = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/
    String.prototype.trimEnd = function () {
      return this.replace(b, '')
    }
  }
  String.prototype.replaceAll ||
    (String.prototype.replaceAll = function (b, a) {
      return this.replace(new RegExp(e.EscapeRegex(b), 'g'), a)
    })
  Array.prototype.values ||
    (Array.prototype.values = function* () {
      for (const b of this) yield b
    })
  if (!Array.prototype.flat) {
    function b(a, c) {
      return a.reduce((d, f) => {
        0 < c && Array.isArray(f) ? Array.prototype.push.apply(d, b(f, c - 1)) : d.push(f)
        return d
      }, [])
    }
    Array.prototype.flat = function (a = 1) {
      return b(this, a)
    }
  }
  RegExp.escape ||
    (RegExp.escape = function (b) {
      return String(b).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&')
    })
  navigator.storage &&
    !navigator.storage.estimate &&
    navigator.webkitTemporaryStorage &&
    navigator.webkitTemporaryStorage.queryUsageAndQuota &&
    (navigator.storage.estimate = function () {
      return new Promise((b, a) =>
        navigator.webkitTemporaryStorage.queryUsageAndQuota(
          (c, d) =>
            b({
              usage: c,
              quota: d
            }),
          a
        )
      )
    })
  'undefined' === typeof HTMLCollection ||
    HTMLCollection.prototype[Symbol.iterator] ||
    (HTMLCollection.prototype[Symbol.iterator] = function () {
      let b = 0
      return {
        next: () =>
          b >= this.length
            ? {
                done: !0
              }
            : {
                value: this.item(b++),
                done: !1
              }
      }
    })
  'undefined' === typeof NodeList ||
    NodeList.prototype[Symbol.iterator] ||
    (NodeList.prototype[Symbol.iterator] = function () {
      let b = 0
      return {
        next: () =>
          b >= this.length
            ? {
                done: !0
              }
            : {
                value: this.item(b++),
                done: !1
              }
      }
    })
  'undefined' === typeof DOMTokenList ||
    DOMTokenList.prototype[Symbol.iterator] ||
    (DOMTokenList.prototype[Symbol.iterator] = function () {
      let b = 0
      return {
        next: () =>
          b >= this.length
            ? {
                done: !0
              }
            : {
                value: this.item(b++),
                done: !1
              }
      }
    })
  'undefined' === typeof FileList ||
    FileList.prototype[Symbol.iterator] ||
    (FileList.prototype[Symbol.iterator] = function () {
      let b = 0
      return {
        next: () =>
          b >= this.length
            ? {
                done: !0
              }
            : {
                value: this.item(b++),
                done: !1
              }
      }
    })
  'undefined' === typeof TextEncoder &&
    ((self.TextEncoder = class {
      constructor() {
        Object.defineProperty(this, 'encoding', {
          value: 'utf-8',
          writable: !1
        })
      }
      encode(b) {
        for (var a = b.length, c = -1, d = new Uint8Array(3 * a), f, g, h = 0; h !== a; ) {
          f = b.charCodeAt(h)
          h += 1
          if (55296 <= f && 56319 >= f) {
            if (h === a) {
              d[(c += 1)] = 239
              d[(c += 1)] = 191
              d[(c += 1)] = 189
              break
            }
            g = b.charCodeAt(h)
            if (56320 <= g && 57343 >= g) {
              if (((f = 1024 * (f - 55296) + g - 56320 + 65536), (h += 1), 65535 < f)) {
                d[(c += 1)] = 240 | (f >>> 18)
                d[(c += 1)] = 128 | ((f >>> 12) & 63)
                d[(c += 1)] = 128 | ((f >>> 6) & 63)
                d[(c += 1)] = 128 | (f & 63)
                continue
              }
            } else {
              d[(c += 1)] = 239
              d[(c += 1)] = 191
              d[(c += 1)] = 189
              continue
            }
          }
          127 >= f ? (d[(c += 1)] = 0 | f) : (2047 >= f ? (d[(c += 1)] = 192 | (f >>> 6)) : ((d[(c += 1)] = 224 | (f >>> 12)), (d[(c += 1)] = 128 | ((f >>> 6) & 63))), (d[(c += 1)] = 128 | (f & 63)))
        }
        return new Uint8Array(d.buffer.slice(0, c + 1))
      }
      toString() {
        return '[object TextEncoder]'
      }
    }),
    (TextEncoder[Symbol.toStringTag] = 'TextEncoder'))
  if ('undefined' === typeof TextDecoder) {
    function b(d) {
      const f = d[Symbol.iterator]()
      return {
        next: g => f.next(),
        [Symbol.iterator]() {
          return this
        }
      }
    }

    function a(d) {
      d = d.next()
      if (d.done) throw Error('unexpected end of input')
      if (0 != ((d.value & 192) ^ 128)) throw Error('invalid byte')
      return d.value & 63
    }
    const c = new Map()
    c.set('utf-8', (d, f) => {
      if (d.buffer) var g = new Uint8Array(d.buffer, d.byteOffset, d.byteLength)
      else if (g instanceof ArrayBuffer) g = new Uint8Array(d)
      else throw Error('Invalid parameter')
      d = b(g)
      g = []
      try {
        for (const h of d) {
          let k
          if (127 > h) k = h & 127
          else if (223 > h) k = ((h & 31) << 6) | a(d)
          else if (239 > h) k = ((h & 15) << 12) | (a(d) << 6) | a(d)
          else if (247 > h) k = ((h & 7) << 18) | (a(d) << 12) | (a(d) << 6) | a(d)
          else throw Error('Invalid character')
          g.push(String.fromCodePoint(k))
        }
      } catch (h) {
        if (f) throw h
        g.push('\ufffd')
      }
      return g.join('')
    })
    c.set('utf8', c.get('utf-8'))
    c.set('utf-16le', (d, f) => {
      throw Error('utf-16le decoder not implemented')
    })
    self.TextDecoder = class {
      constructor(d = 'utf-8', f = {}) {
        const g = c.get(d)
        if (!g) throw Error(`TextDecoder polyfill does not support "${d}"`)
        Object.defineProperty(this, 'fatal', {
          value: !0 === f.fatal,
          writable: !1
        })
        Object.defineProperty(this, '_decoder', {
          value: g,
          writable: !1
        })
        Object.defineProperty(this, 'encoding', {
          value: d,
          writable: !1
        })
      }
      decode(d) {
        return this._decoder(d, this.fatal)
      }
      toString() {
        return '[object TextDecoder]'
      }
    }
    TextDecoder[Symbol.toStringTag] = 'TextDecoder'
  }
  'undefined' === typeof self.isSecureContext && (self.isSecureContext = 'https:' === location.protocol)
  'undefined' === typeof self.globalThis && (self.globalThis = self)
}
{
  ;('use strict')
  const e = self.C3

  function b(a) {
    let c = e.GetCallStack()
    console.error('Assertion failure: ' + a + '\n\nStack trace:\n' + c)
  }
  self.assert = function (a, c) {
    a || b(c)
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X
  e.IsNumber = function (c) {
    return 'number' === typeof c
  }
  e.IsFiniteNumber = function (c) {
    return e.IsNumber(c) && isFinite(c)
  }
  e.RequireNumber = function (c) {
    if (!e.IsNumber(c)) throw new TypeError('expected number')
  }
  e.RequireOptionalNumber = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireNumberInRange = function (c, d, f) {
    if (!e.IsNumber(c) || isNaN(c) || d > c || f < c) throw new RangeError('number outside of range')
  }
  e.RequireAllNumber = function (...c) {
    for (let d of c);
  }
  e.RequireFiniteNumber = function (c) {
    if (!e.IsFiniteNumber(c)) throw new TypeError('expected finite number')
  }
  e.RequireOptionalFiniteNumber = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllFiniteNumber = function (...c) {
    for (let d of c);
  }
  e.IsString = function (c) {
    return 'string' === typeof c
  }
  e.RequireString = function (c) {
    if (!e.IsString(c)) throw new TypeError('expected string')
  }
  e.RequireOptionalString = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllString = function (...c) {
    for (let d of c);
  }
  e.IsSimpleObject = function (c) {
    return 'object' !== typeof c || null === c ? !1 : (c = Object.getPrototypeOf(c)) ? c.constructor === Object : null === c
  }
  e.RequireSimpleObject = function (c) {
    if (!e.IsSimpleObject(c)) throw new TypeError('expected simple object')
  }
  e.RequireOptionalSimpleObject = function (c) {
    if (!e.IsNullOrUndefined(c) && !e.IsSimpleObject(c)) throw new TypeError('expected simple object')
  }
  e.IsObject = function (c) {
    return 'object' === typeof c && null !== c && !Array.isArray(c)
  }
  e.RequireObject = function (c) {
    if (!e.IsObject(c)) throw new TypeError('expected object')
  }
  e.RequireOptionalObject = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllObject = function (...c) {
    for (let d of c);
  }
  e.IsFileLike = function (c) {
    return e.IsInstanceOf(c, Blob) && 'string' === typeof c.name
  }
  e.RequireFileLike = function (c) {
    if (!e.IsFileLike(c)) throw new TypeError('expected file')
  }
  e.RequireOptionalFileLike = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.IsArray = function (c) {
    return Array.isArray(c)
  }
  e.RequireArray = function (c) {
    if (!e.IsArray(c)) throw new TypeError('expected array')
  }
  e.RequireOptionalArray = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllArray = function (...c) {
    for (let d of c);
  }
  e.Is2DArray = function (c) {
    return e.IsArray(c) ? (c.length ? (e.IsArray(c[0]) ? !0 : !1) : !0) : !1
  }
  e.Require2DArray = function (c) {
    if (!e.Is2DArray(c)) throw new TypeError('expected 2d array')
    for (let d of c) if (!e.IsArray(d)) throw new TypeError('expected 2d array')
  }
  e.RequireOptional2DArray = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.IsFunction = function (c) {
    return 'function' === typeof c
  }
  e.RequireFunction = function (c, d) {
    if (!e.IsFunction(c)) throw new TypeError('expected function')
    if (!e.IsNullOrUndefined(d) && c !== d) throw new TypeError('expected same function reference')
  }
  e.RequireOptionalFunction = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllFunction = function (...c) {
    for (let d of c);
  }
  e.RequireAnyFunction = function (c, ...d) {
    if (!e.IsFunction(c)) throw new TypeError('expected function')
    if (!d.length) throw Error('missing comparison functions')
    for (let f of d) if (!e.IsNullOrUndefined(f) && c === f) return
    throw new TypeError('expected same function reference')
  }
  e.RequireOptionalAllFunction = function (...c) {
    if (!e.IsNullOrUndefined(c)) for (let d of c);
  }
  e.IsInstanceOf = function (c, d) {
    return c instanceof d
  }
  e.IsInstanceOfAny = function (c, ...d) {
    for (let f of d) if (e.IsInstanceOf(c, f)) return !0
    return !1
  }
  e.RequireInstanceOf = function (c, d) {
    if (!e.IsInstanceOf(c, d)) throw new TypeError('unexpected type')
  }
  e.RequireOptionalInstanceOf = function (c, d) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllInstanceOf = function (c, ...d) {
    for (let f of d);
  }
  e.RequireAnyInstanceOf = function (c, ...d) {
    if (!e.IsInstanceOfAny(c, ...d)) throw new TypeError('unexpected type')
  }
  e.RequireAnyOptionalInstanceOf = function (c, ...d) {
    if (!e.IsNullOrUndefined(c) && !e.IsInstanceOfAny(c, ...d)) throw new TypeError('unexpected type')
  }
  e.IsArrayOf = function (c, d) {
    for (let f of c) if (!e.IsInstanceOf(f, d)) return !1
    return !0
  }
  e.IsArrayOfFiniteNumbers = function (c) {
    for (let d of c) if (!e.IsFiniteNumber(d)) return !1
    return !0
  }
  e.RequireArrayOf = function (c, d) {
    for (let f of c);
  }
  e.RequireOptionalArrayOf = function (c, d) {
    if (!e.IsNullOrUndefined(c)) for (let f of c);
  }
  e.RequireArrayOfAny = function (c, ...d) {
    for (let f of c);
  }
  e.RequireOptionalArrayOfAny = function (c, ...d) {
    if (!e.IsNullOrUndefined(c)) for (let f of c);
  }
  e.IsDOMNode = function (c, d) {
    return e.IsNullOrUndefined(c) || !e.IsString(c.nodeName) ? !1 : !d || e.equalsNoCase(c.nodeName, d)
  }
  e.RequireDOMNode = function (c, d) {
    if (e.IsNullOrUndefined(c) || !e.IsString(c.nodeName)) throw new TypeError('expected DOM node')
    if (d && !e.equalsNoCase(c.nodeName, d)) throw new TypeError(`expected DOM '${d}' node`)
  }
  e.RequireOptionalDOMNode = function (c, d) {
    e.IsNullOrUndefined(c)
  }
  e.IsHTMLElement = function (c, d) {
    return e.IsNullOrUndefined(c) || !e.IsString(c.tagName) ? !1 : !d || e.equalsNoCase(c.tagName, d)
  }
  e.RequireHTMLElement = function (c, d) {
    if (e.IsNullOrUndefined(c) || !e.IsString(c.tagName)) throw new TypeError('expected HTML element')
    if (d && !e.equalsNoCase(c.tagName, d)) throw new TypeError(`expected HTML '${d}' element`)
  }
  e.RequireOptionalHTMLElement = function (c, d) {
    e.IsNullOrUndefined(c)
  }
  e.IsDrawable = function (c) {
    return e.IsHTMLElement(c, 'img') || e.IsHTMLElement(c, 'canvas') || e.IsHTMLElement(c, 'video') || ('undefined' !== typeof OffscreenCanvas && c instanceof OffscreenCanvas) || ('undefined' !== typeof ImageBitmap && c instanceof ImageBitmap)
  }
  e.RequireDrawable = function (c) {
    if (!e.IsDrawable(c)) throw new TypeError('expected drawable')
  }
  e.RequireOptionalDrawable = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.IsDrawableOrImageData = function (c) {
    return c instanceof ImageData ? !0 : e.IsDrawable(c)
  }
  e.RequireDrawableOrImageData = function (c) {
    if (!e.IsDrawableOrImageData(c)) throw new TypeError('expected drawable or image data')
  }
  e.RequireOptionalDrawableOrImageData = function (c) {
    if (!e.IsNullOrUndefined(c) && !e.IsDrawableOrImageData(c)) throw new TypeError('expected drawable or image data')
  }
  e.IsStringLike = function (c) {
    return 'string' === typeof c || c instanceof e.HtmlString || c instanceof e.BBString
  }
  e.RequireStringLike = function (c) {
    if (!e.IsStringLike(c)) throw new TypeError('expected string-like')
  }
  e.RequireOptionalStringLike = function (c) {
    e.IsNullOrUndefined(c)
  }
  e.RequireAllStringLike = function (...c) {
    for (let d of c);
  }
  e.RequireOverride = function () {
    throw Error('must be overridden')
  }
  e.NotYetImplemented = function () {
    throw Error('not yet implemented')
  }
  e.IsDefined = function (c, ...d) {
    if ('undefined' === typeof c) return !1
    for (let f of d) {
      if ('undefined' === typeof c[f]) return !1
      c = c[f]
    }
    return !0
  }
  e.IsNullOrUndefined = function (c) {
    return 'undefined' === typeof c || null === c
  }
  e.AreArrayElementsOfSameType = function (c) {
    let d = c[0].constructor
    for (let f of c) if (f.constructor !== d) return !1
    return d
  }
  e.AreArrayElementsOfType = function (c, d) {
    for (let f of c) if (!(f instanceof d)) return !1
    return !0
  }
  const a = Object.getPrototypeOf(Uint8Array)
  e.IsTypedArray = function (c) {
    return e.IsInstanceOf(c, a)
  }
  e.RequireTypedArray = function (c) {}
  e.WeakRequireTypedArray = function (c) {
    e.WeakRequireInstanceOf(c, a)
  }
  e.WeakRequireAnyInstanceOf = function (c, ...d) {
    if (!e.WeakIsAnyInstanceOf(c, ...d)) throw new TypeError('unexpected type')
  }
  e.WeakIsAnyInstanceOf = function (c, ...d) {
    for (const f of d) if (e.WeakIsInstanceOf(c, f)) return !0
    return !1
  }
  e.WeakRequireInstanceOf = function (c, d) {
    if (!e.WeakIsInstanceOf(c, d)) throw new TypeError('unexpected type')
  }
  e.WeakIsInstanceOf = function (c, d) {
    for (; (c = Object.getPrototypeOf(c)); ) if (c.constructor.name === d.name) return !0
    return !1
  }
  b.RequireNumber = e.RequireNumber
  b.RequireOptionalNumber = e.RequireOptionalNumber
  b.RequireFiniteNumber = e.RequireFiniteNumber
  b.RequireOptionalFiniteNumber = e.RequireOptionalFiniteNumber
  b.RequireString = e.RequireString
  b.RequireOptionalString = e.RequireOptionalString
  b.RequireObject = e.RequireObject
  b.RequireOptionalObject = e.RequireOptionalObject
  b.RequireArray = e.RequireArray
  b.RequireOptionalArray = e.RequireOptionalArray
  b.RequireFunction = e.RequireFunction
  b.RequireOptionalFunction = e.RequireOptionalFunction
  b.RequireInstanceOf = e.RequireInstanceOf
  b.RequireOptionalInstanceOf = e.RequireOptionalInstanceOf
  b.IsNullOrUndefined = e.IsNullOrUndefined
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map()
  e.RafLog = function (t, ...x) {
    b.has(t) || b.set(t, -1)
    ;-1 === b.get(t) &&
      b.set(
        t,
        requestAnimationFrame(() => {
          console.log(`%c${t}`, 'font-weight: bold', ...x)
          b.set(t, -1)
        })
      )
  }
  e.GetCallStack = function () {
    return Error().stack
  }
  e.Debugger = function () {
    debugger
  }
  e.cast = function (t, x) {
    return t && t instanceof x ? t : null
  }
  e.getName = function (t) {
    return 'undefined' === typeof t
      ? 'undefined'
      : null === t
      ? 'null'
      : 'boolean' === typeof t
      ? '<boolean>'
      : e.IsNumber(t)
      ? '<number>'
      : e.IsString(t)
      ? '<string>'
      : e.IsArray(t)
      ? '<array>'
      : 'symbol' === typeof t
      ? '<' + t.toString() + '>'
      : e.IsFunction(t)
      ? t.name && 'Function' !== t.name
        ? t.name
        : '<anonymous function>'
      : 'object' === typeof t
      ? t.constructor && t.constructor.name && 'Object' !== t.constructor.name
        ? t.constructor.name
        : '<anonymous object>'
      : '<unknown>'
  }
  e.getType = function (t) {
    return null === t ? 'null' : Array.isArray(t) ? 'array' : typeof t
  }
  e.range = function* (t, x) {
    if (!isFinite(Math.abs(t - x))) throw Error('Invalid parameters')
    if (t > x) for (--t; t >= x; t--) yield t
    else for (; t < x; t++) yield t
  }

  function a(t, x) {
    t = e.getType(t)
    x = e.getType(x)
    return 'null' === t || 'null' === x ? !0 : 'undefined' === t || 'undefined' === x ? !1 : t === x
  }
  let c = new Map(),
    d = new Map(),
    f = new WeakMap(),
    g = new WeakMap()
  e.DefendHandler = {}
  const h = new Set(['then', 'splice'])

  function k(t) {
    console.warn('[Defence] ' + t + ' @', e.GetCallStack())
  }
  e.DefendHandler.get = function (t, x) {
    x in t || 'symbol' === typeof x || h.has(x) || k(`Accessed missing property '${x}' from defended object '${e.getName(t)}', returning undefined`)
    g.has(t) && 'symbol' !== typeof x && !h.has(x) && k(`Accessed property '${x}' on a released object '${e.getName(t)}'\nObject was originally released at: ${g.get(t)})\nCall stack at access: `)
    return t[x]
  }
  e.DefendHandler.set = function (t, x, v) {
    x in t || c.has(t) || k(`Set non-existent property '${x}' to '${v}' on defended object '${e.getName(t)}'`)
    a(t[x], v) || c.has(t) || k(`Set '${e.getType(t[x])}' property '${x}' to type '${e.getType(v)}' on defended object '${e.getName(t)}'`)
    g.has(t) && k(`Set property '${x}' on a released object '${e.getName(t)}'\nObject was originally released at: ${g.get(t)})\nCall stack at access: `)
    t[x] = v
    return !0
  }
  e.DefendHandler.deleteProperty = function (t, x) {
    throw new ReferenceError(`Cannot delete property '${x}' from defended object '${e.getName(t)}'`)
  }
  e.DefendHandler.defineProperty = function (t, x, v) {
    throw new ReferenceError(`Cannot define property '${x}' on defended object '${e.getName(t)}'`)
  }
  e.DefendHandler.enumerate = function (t) {
    throw new ReferenceError(`Cannot enumerate defended object '${e.getName(t)}'`)
  }
  let m = -1

  function r() {
    m = -1
    if (0 < c.size || 0 < d.size) {
      let t = [...new Set([...c.keys()].map(x => e.getName(x)))].join()
      console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${t}`)
      c.clear()
      d.clear()
    }
  }
  e.DefendedBase = class {
    constructor() {
      if (e.isDebugDefend && e.Supports.Proxies) {
        var t = new.target
        t = Object.create(t.prototype)
        var x = new Proxy(t, e.DefendHandler)
        c.set(t, x)
        d.set(x, t)
        f.set(x, t)
        ;-1 === m && (m = requestAnimationFrame(r))
        return x
      }
    }
  }
  e.debugDefend = function (t) {
    if (e.isDebugDefend && e.Supports.Proxies && t instanceof e.DefendedBase) {
      if (!d.has(t)) return t
      let x = d.get(t)
      d.delete(t)
      c.delete(x)
      return t
    }
    return e.isDebug ? Object.seal(t) : t
  }
  e.New = function (t, ...x) {
    let v
    try {
      v = new t(...x)
    } catch (u) {
      throw (d.clear(), c.clear(), u)
    }
    e.isDebugDefend && q(t, v)
    return e.debugDefend(v)
  }
  e.Release = function (t) {
    ;(t = f.get(t)) && g.set(t, e.GetCallStack())
  }
  e.WasReleased = function (t) {
    return (t = f.get(t)) ? !!g.get(t) : !1
  }
  let w = new Map()

  function p(t) {
    let x = new Set()
    for (let v in t) x.add(v)
    return x
  }

  function q(t, x) {
    x = p(x)
    let v = w.get(t)
    if (v) {
      let u = []
      for (let A of v.values()) x.has(A) ? x.delete(A) : u.push(A)
      e.appendArray(u, [...x])
      u.length && console.warn(`[Defence] '${e.getName(t)}' constructor creates inconsistent properties: ${u.join(', ')}`)
    } else w.set(t, x)
  }
  e.PerfMark = class {
    constructor(t) {
      this._name = ''
      t && this.start(t)
    }
    start(t) {
      this._name = t
      performance.mark(this._name + '-Start')
    }
    end() {
      performance.mark(this._name + '-End')
      performance.measure(this._name, this._name + '-Start', this._name + '-End')
    }
    next(t) {
      this.end()
      this._name = t
      performance.mark(this._name + '-Start')
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = 2 * Math.PI,
    a = Math.PI / 180,
    c = 180 / Math.PI
  e.wrap = function (g, h, k) {
    g = Math.floor(g)
    h = Math.floor(h)
    k = Math.floor(k)
    return g < h ? ((g = k - ((h - g) % (k - h))), g === k ? 0 : g) : h + ((g - h) % (k - h))
  }
  e.mapToRange = function (g, h, k, m, r) {
    return ((g - h) * (r - m)) / (k - h) + m
  }
  e.normalize = function (g, h, k) {
    return (g - h) / (k - h)
  }
  e.clamp = function (g, h, k) {
    return g < h ? h : g > k ? k : g
  }
  e.clampAngle = function (g) {
    g %= b
    0 > g && (g += b)
    return g
  }
  e.toRadians = function (g) {
    return g * a
  }
  e.toDegrees = function (g) {
    return g * c
  }
  e.distanceTo = function (g, h, k, m) {
    return Math.hypot(k - g, m - h)
  }
  e.distanceSquared = function (g, h, k, m) {
    g = k - g
    h = m - h
    return g * g + h * h
  }
  e.angleTo = function (g, h, k, m) {
    return Math.atan2(m - h, k - g)
  }
  e.angleDiff = function (g, h) {
    if (g === h) return 0
    g = Math.sin(g) * Math.sin(h) + Math.cos(g) * Math.cos(h)
    return 1 <= g ? 0 : -1 >= g ? Math.PI : Math.acos(g)
  }
  e.angleRotate = function (g, h, k) {
    let m = Math.sin(g),
      r = Math.cos(g),
      w = Math.sin(h),
      p = Math.cos(h)
    return Math.acos(m * w + r * p) > k ? (0 < r * w - m * p ? e.clampAngle(g + k) : e.clampAngle(g - k)) : e.clampAngle(h)
  }
  e.angleClockwise = function (g, h) {
    return 0 >= Math.cos(g) * Math.sin(h) - Math.sin(g) * Math.cos(h)
  }
  e.angleLerp = function (g, h, k, m = 0) {
    let r = e.angleDiff(g, h)
    m *= b
    return e.angleClockwise(h, g) ? e.clampAngle(g + (r + m) * k) : e.clampAngle(g - (r + m) * k)
  }
  e.angleLerpClockwise = function (g, h, k, m = 0) {
    const r = e.angleDiff(g, h)
    m *= b
    return e.angleClockwise(h, g) ? e.clampAngle(g + (r + m) * k) : e.clampAngle((b - r + m) * k)
  }
  e.angleLerpAntiClockwise = function (g, h, k, m = 0) {
    const r = e.angleDiff(g, h)
    m *= b
    return e.angleClockwise(h, g) ? e.clampAngle((-b + r - m) * k) : e.clampAngle(g - (r + m) * k)
  }
  e.lerp = function (g, h, k) {
    return g + k * (h - g)
  }
  e.unlerp = function (g, h, k) {
    return g === h ? 0 : (k - g) / (h - g)
  }
  e.relerp = function (g, h, k, m, r) {
    return e.lerp(m, r, e.unlerp(g, h, k))
  }
  e.qarp = function (g, h, k, m) {
    return e.lerp(e.lerp(g, h, m), e.lerp(h, k, m), m)
  }
  e.cubic = function (g, h, k, m, r) {
    return e.lerp(e.qarp(g, h, k, r), e.qarp(h, k, m, r), r)
  }
  e.cosp = function (g, h, k) {
    return (g + h + (g - h) * Math.cos(k * Math.PI)) / 2
  }
  e.isPOT = function (g) {
    return 0 < g && 0 === ((g - 1) & g)
  }
  e.nextHighestPowerOfTwo = function (g) {
    --g
    for (let h = 1; 32 > h; h <<= 1) g |= g >> h
    return g + 1
  }
  e.roundToNearestFraction = function (g, h) {
    return Math.round(g * h) / h
  }
  e.floorToNearestFraction = function (g, h) {
    return Math.floor(g * h) / h
  }
  e.round6dp = function (g) {
    return Math.round(1e6 * g) / 1e6
  }
  e.toFixed = function (g, h) {
    g = g.toFixed(h)
    for (h = g.length - 1; 0 <= h && '0' === g.charAt(h); --h);
    0 <= h && '.' === g.charAt(h) && --h
    return 0 > h ? g : g.substr(0, h + 1)
  }
  e.PackRGB = function (g, h, k) {
    return e.clamp(g, 0, 255) | (e.clamp(h, 0, 255) << 8) | (e.clamp(k, 0, 255) << 16)
  }
  e.PackRGBAEx = function (g, h, k, m) {
    g = e.clamp(Math.floor(1024 * g), -8192, 8191)
    h = e.clamp(Math.floor(1024 * h), -8192, 8191)
    k = e.clamp(Math.floor(1024 * k), -8192, 8191)
    m = e.clamp(Math.floor(1023 * m), 0, 1023)
    0 > g && (g += 16384)
    0 > h && (h += 16384)
    0 > k && (k += 16384)
    return -(274877906944 * g + 16777216 * h + 1024 * k + m)
  }
  e.PackRGBEx = function (g, h, k) {
    return e.PackRGBAEx(g, h, k, 1)
  }

  function d(g) {
    return 0 === g && 0 > 1 / g
  }
  e.GetRValue = function (g) {
    if (0 <= g) return (g & 255) / 255
    g = Math.floor(-g / 274877906944)
    8191 < g && (g -= 16384)
    return g / 1024
  }
  e.GetGValue = function (g) {
    if (0 <= g) return ((g & 65280) >> 8) / 255
    g = Math.floor((-g % 274877906944) / 16777216)
    8191 < g && (g -= 16384)
    return g / 1024
  }
  e.GetBValue = function (g) {
    if (0 <= g) return ((g & 16711680) >> 16) / 255
    g = Math.floor((-g % 16777216) / 1024)
    8191 < g && (g -= 16384)
    return g / 1024
  }
  e.GetAValue = function (g) {
    return d(g) ? 0 : 0 <= g ? 1 : Math.floor(-g % 1024) / 1023
  }
  e.greatestCommonDivisor = function (g, h) {
    g = Math.floor(g)
    for (h = Math.floor(h); 0 !== h; ) {
      let k = h
      h = g % h
      g = k
    }
    return g
  }
  const f = [
    [3, 2],
    [4, 3],
    [5, 4],
    [5, 3],
    [6, 5],
    [14, 9],
    [16, 9],
    [16, 10],
    [21, 9]
  ]
  e.getAspectRatio = function (g, h) {
    g = Math.floor(g)
    h = Math.floor(h)
    if (g === h) return [1, 1]
    for (var k of f) {
      let m = (g / k[0]) * k[1]
      if (1 > Math.abs(h - m)) return k.slice(0)
      m = (g / k[1]) * k[0]
      if (1 > Math.abs(h - m)) return [k[1], k[0]]
    }
    k = e.greatestCommonDivisor(g, h)
    return [g / k, h / k]
  }
  e.segmentsIntersect = function (g, h, k, m, r, w, p, q) {
    var t = Math.min(g, k),
      x = Math.max(r, p)
    if (Math.max(g, k) < Math.min(r, p) || t > x) return !1
    t = Math.min(h, m)
    x = Math.max(w, q)
    if (Math.max(h, m) < Math.min(w, q) || t > x) return !1
    t = r - g + p - k
    x = w - h + q - m
    g = k - g
    h = m - h
    r = p - r
    w = q - w
    q = Math.abs(h * r - w * g)
    return Math.abs(r * x - w * t) > q ? !1 : Math.abs(g * x - h * t) <= q
  }
  e.segmentsIntersectPreCalc = function (g, h, k, m, r, w, p, q, t, x, v, u) {
    const A = Math.max(t, v)
    if (w < Math.min(t, v) || r > A) return !1
    r = Math.max(x, u)
    if (q < Math.min(x, u) || p > r) return !1
    p = t - g + v - k
    q = x - h + u - m
    g = k - g
    h = m - h
    t = v - t
    x = u - x
    u = Math.abs(h * t - x * g)
    return Math.abs(t * q - x * p) > u ? !1 : Math.abs(g * q - h * p) <= u
  }
  e.segmentIntersectsQuad = function (g, h, k, m, r) {
    const w = Math.min(g, k),
      p = Math.max(g, k),
      q = Math.min(h, m),
      t = Math.max(h, m),
      x = r.getTlx(),
      v = r.getTly(),
      u = r.getTrx(),
      A = r.getTry(),
      z = r.getBrx(),
      C = r.getBry(),
      E = r.getBlx()
    r = r.getBly()
    return e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, x, v, u, A) || e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, u, A, z, C) || e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, z, C, E, r) || e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, E, r, x, v)
  }
  e.segmentIntersectsAnyN = function (g, h, k, m, r) {
    const w = Math.min(g, k),
      p = Math.max(g, k),
      q = Math.min(h, m),
      t = Math.max(h, m)
    let x = 0
    for (let v = r.length - 4; x <= v; x += 2) if (e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, r[x], r[x + 1], r[x + 2], r[x + 3])) return !0
    return e.segmentsIntersectPreCalc(g, h, k, m, w, p, q, t, r[x], r[x + 1], r[0], r[1])
  }
  e.rayIntersect = function (g, h, k, m, r, w, p, q) {
    k -= g
    w = q - w
    const t = k * w - (m - h) * (p - r)
    if (0 === t) return 2
    m = ((h - m) * (p - g) + k * (q - h)) / t
    return 0 < m && 1.000001 > m ? (w * (p - g) + (r - p) * (q - h)) / t : 2
  }
  e.rayIntersectExtended = function (g, h, k, m, r, w, p, q, t) {
    const x = (p - r) * t
    t *= q - w
    return e.rayIntersect(g, h, k, m, r - x, w - t, p + x, q + t)
  }
  e.isPointInTriangleInclusive = function (g, h, k, m, r, w, p, q) {
    r -= k
    w -= m
    p -= k
    q -= m
    g -= k
    k = h - m
    h = r * r + w * w
    m = r * p + w * q
    r = r * g + w * k
    w = p * p + q * q
    p = p * g + q * k
    q = 1 / (h * w - m * m)
    w = (w * r - m * p) * q
    r = (h * p - m * r) * q
    return 0 <= w && 0 <= r && 1 >= w + r
  }
  e.triangleCartesianToBarycentric = function (g, h, k, m, r, w, p, q) {
    r -= k
    w -= m
    p -= k
    q -= m
    g -= k
    const t = h - m
    h = r * r + w * w
    m = r * p + w * q
    k = p * p + q * q
    r = g * r + t * w
    w = g * p + t * q
    p = h * k - m * m
    q = (k * r - m * w) / p
    r = (h * w - m * r) / p
    return [1 - q - r, q, r]
  }
  e.triangleBarycentricToCartesian = function (g, h, k, m, r, w, p, q, t) {
    return [g * m + h * w + k * q, g * r + h * p + k * t]
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = null,
    a = ''
  if ('undefined' !== typeof document) {
    b = document
    const k = document.querySelector('base')
    if ((a = k && k.hasAttribute('href') ? k.getAttribute('href') : '')) a.startsWith('/') && (a = a.substr(1)), a.endsWith('/') || (a += '/')
  }
  e.GetBaseHref = function () {
    return a
  }
  e.GetBaseURL = function () {
    if (!b) return ''
    const k = b.location
    return e.GetPathFromURL(k.origin + k.pathname) + a
  }
  e.GetPathFromURL = function (k) {
    if (!k.length || k.endsWith('/') || k.endsWith('\\')) return k
    const m = Math.max(k.lastIndexOf('/'), k.lastIndexOf('\\'))
    return -1 === m ? '' : k.substr(0, m + 1)
  }
  e.GetFilenameFromURL = function (k) {
    if (!k.length) return k
    if (k.endsWith('/') || k.endsWith('\\')) return ''
    const m = Math.max(k.lastIndexOf('/'), k.lastIndexOf('\\'))
    return -1 === m ? k : k.substr(m + 1)
  }
  e.GetFileExtension = function (k) {
    let m = k.lastIndexOf('.')
    return 1 > m ? '' : k.substr(m)
  }
  e.GetFileNamePart = function (k) {
    let m = k.lastIndexOf('.')
    return 1 > m ? k : k.substr(0, m)
  }
  e.NormalizeFileSeparator = function (k) {
    return k.replace(/\\/g, '/')
  }
  e.IsFileExtension = function (k, m) {
    k = k ? e.GetFileExtension(k).slice(1) : ''
    return m === k
  }
  e.FileNameEquals = function (k, m) {
    let r, w
    e.IsFileLike(k) && (r = e.GetFileNamePart(k.name))
    e.IsString(k) && (r = e.GetFileNamePart(k))
    e.IsFileLike(m) && (w = e.GetFileNamePart(m.name))
    e.IsString(m) && (w = e.GetFileNamePart(m))
    return r === w
  }
  e.ParseFilePath = function (k) {
    k = e.NormalizeFileSeparator(k)
    let m = /^\w:\//.exec(k)
    m ? ((m = m[0]), (k = k.slice(3)), '/' !== k[0] && (k = '/' + k)) : (m = '')
    k = k.replace(/\/{2,}/g, '/')
    1 < k.length && '/' === k.slice(-1) && (k = k.slice(0, -1))
    var r = k.lastIndexOf('/') + 1
    let w = '',
      p = k,
      q = ''
    0 < r && ((w = k.slice(0, r)), (p = k.slice(r)))
    k = p
    r = p.lastIndexOf('.')
    0 < r && ((q = p.slice(r)), (k = p.slice(0, -q.length)))
    return {
      dir: w,
      base: p,
      name: k,
      root: m,
      ext: q,
      full: m + w + p
    }
  }
  e.Wait = function (k, m) {
    return new Promise((r, w) => {
      self.setTimeout(r, k, m)
    })
  }
  e.swallowException = function (k) {
    try {
      k()
    } catch (m) {
      e.isDebug && console.warn('Swallowed exception: ', m)
    }
  }
  e.noop = function () {}
  e.equalsNoCase = function (k, m) {
    return 'string' !== typeof k || 'string' !== typeof m ? !1 : k === m || k.normalize().toLowerCase() === m.normalize().toLowerCase()
  }
  e.equalsCase = function (k, m) {
    return 'string' !== typeof k || 'string' !== typeof m ? !1 : k === m ? !0 : k.normalize() === m.normalize()
  }
  e.typedArraySet16 = function (k, m, r) {
    k[r++] = m[0]
    k[r++] = m[1]
    k[r++] = m[2]
    k[r++] = m[3]
    k[r++] = m[4]
    k[r++] = m[5]
    k[r++] = m[6]
    k[r++] = m[7]
    k[r++] = m[8]
    k[r++] = m[9]
    k[r++] = m[10]
    k[r++] = m[11]
    k[r++] = m[12]
    k[r++] = m[13]
    k[r++] = m[14]
    k[r] = m[15]
  }
  e.truncateArray = function (k, m) {
    k.length = m
  }
  e.clearArray = function (k) {
    k && 0 !== k.length && e.truncateArray(k, 0)
  }
  e.clear2DArray = function (k) {
    if (k) {
      for (let m = 0; m < k.length; m++) e.truncateArray(k[m], 0)
      e.truncateArray(k, 0)
    }
  }
  e.extendArray = function (k, m, r) {
    m |= 0
    var w = k.length
    if (!(m <= w)) for (; w < m; ++w) k.push(r)
  }
  e.resizeArray = function (k, m, r) {
    m |= 0
    const w = k.length
    m < w ? e.truncateArray(k, m) : m > w && e.extendArray(k, m, r)
  }
  e.shallowAssignArray = function (k, m) {
    e.clearArray(k)
    e.appendArray(k, m)
  }
  e.appendArray = function (k, m) {
    if (1e4 > m.length) k.push(...m)
    else for (let r = 0, w = m.length; r < w; ++r) k.push(m[r])
  }
  e.arrayRemove = function (k, m) {
    m = Math.floor(m)
    if (!(0 > m || m >= k.length)) {
      for (var r = k.length - 1; m < r; ++m) k[m] = k[m + 1]
      e.truncateArray(k, r)
    }
  }
  e.arrayFindRemove = function (k, m) {
    m = k.indexOf(m)
    0 <= m && k.splice(m, 1)
  }
  e.arraysEqual = function (k, m) {
    let r = k.length
    if (m.length !== r) return !1
    for (let w = 0; w < r; ++w) if (k[w] !== m[w]) return !1
    return !0
  }
  e.arrayFilterOut = function (k, m) {
    let r = [],
      w = 0
    for (let p = 0, q = k.length; p < q; ++p) {
      let t = k[p]
      m(t) ? r.push(t) : ((k[w] = t), ++w)
    }
    e.truncateArray(k, w)
    return r
  }
  e.arrayRemoveAllInSet = function (k, m) {
    const r = k.length
    let w = 0
    for (let p = 0, q = k.length; p < q; ++p) {
      let t = k[p]
      m.has(t) || (k[w++] = t)
    }
    e.truncateArray(k, w)
    return r - w
  }
  e.isArrayIndexInBounds = function (k, m) {
    return k !== Math.floor(k) ? !1 : 0 <= k && k < m.length
  }
  e.validateArrayIndex = function (k, m) {
    if (!e.isArrayIndexInBounds(k, m)) throw new RangeError('array index out of bounds')
  }
  e.cloneArray = function (k) {
    return k.slice()
  }
  e.deepCloneArray = function (k, m) {
    let r = []
    for (let w of k)
      if (e.IsObject(w)) {
        k = m(w)
        if (!k) throw Error('missing clone')
        if (k.constructor !== w.constructor) throw Error('object is not a clone')
        r.push(k)
      } else e.IsArray(w) ? r.push(e.deepCloneArray(w, m)) : r.push(w)
    return r
  }
  e.clone2DArray = function (k) {
    let m = []
    for (let r of k) m.push(r.slice())
    return m
  }
  e.mergeSets = function (k, m) {
    return new Set([...k, ...m])
  }
  e.mergeSetsInPlace = function (k, m) {
    for (const r of m) k.add(r)
    return k
  }
  e.first = function (k) {
    for (let m of k) return m
    return null
  }
  e.xor = function (k, m) {
    return !k !== !m
  }
  e.compare = function (k, m, r) {
    switch (m) {
      case 0:
        return k === r
      case 1:
        return k !== r
      case 2:
        return k < r
      case 3:
        return k <= r
      case 4:
        return k > r
      case 5:
        return k >= r
      default:
        return !1
    }
  }
  e.hasAnyOwnProperty = function (k) {
    for (let m in k) if (k.hasOwnProperty(m)) return !0
    return !1
  }
  e.PromiseAllWithProgress = function (k, m) {
    return k.length
      ? new Promise((r, w) => {
          const p = []
          let q = 0,
            t = !1
          for (let x = 0, v = k.length; x < v; ++x)
            p.push(void 0),
              k[x]
                .then(u => {
                  t || ((p[x] = u), ++q, q === k.length ? r(p) : m(q, k.length))
                })
                .catch(u => {
                  t = !0
                  w(u)
                })
        })
      : Promise.resolve([])
  }
  let c = []
  e.AddLibraryMemoryCallback = function (k) {
    c.push(k)
  }
  e.GetEstimatedLibraryMemoryUsage = function () {
    let k = 0
    for (let m of c) {
      let r = m()
      k += r
    }
    return Math.floor(k)
  }
  let d = 1
  const f = new Map(),
    g = new MessageChannel()
  g.port2.onmessage = function (k) {
    k = k.data
    const m = f.get(k)
    f.delete(k)
    m && m(performance.now())
  }
  e.RequestUnlimitedAnimationFrame = function (k) {
    const m = d++
    f.set(m, k)
    g.port1.postMessage(m)
    return m
  }
  e.CancelUnlimitedAnimationFrame = function (k) {
    f.delete(k)
  }
  e.PostTask = e.RequestUnlimitedAnimationFrame
  e.WaitForNextTask = function () {
    return new Promise(k => e.PostTask(k))
  }
  const h = new Set()
  e.RequestPostAnimationFrame = function (k) {
    const m = self.requestAnimationFrame(async r => {
      await e.WaitForNextTask()
      h.has(m) && (h.delete(m), k(r))
    })
    h.add(m)
    return m
  }
  e.CancelPostAnimationFrame = function (k) {
    h.has(k) && (self.cancelAnimationFrame(k), h.delete(k))
  }
}
{
  ;('use strict')
  const e = self.C3
  e.IsAbsoluteURL = function (b) {
    return /^(?:[a-z\-]+:)?\/\//.test(b) || 'data:' === b.substr(0, 5) || 'blob:' === b.substr(0, 5)
  }
  e.IsRelativeURL = function (b) {
    return !e.IsAbsoluteURL(b)
  }
  e.ThrowIfNotOk = function (b) {
    if (!b.ok) throw Error(`fetch '${b.url}' response returned ${b.status} ${b.statusText}`)
  }
  e.FetchOk = function (b, a) {
    return fetch(b, a).then(c => {
      e.ThrowIfNotOk(c)
      return c
    })
  }
  e.FetchText = function (b) {
    return e.FetchOk(b).then(a => a.text())
  }
  e.FetchJson = function (b) {
    return e.FetchOk(b).then(a => a.json())
  }
  e.FetchBlob = function (b) {
    return e.FetchOk(b).then(a => a.blob())
  }
  e.FetchArrayBuffer = function (b) {
    return e.FetchOk(b).then(a => a.arrayBuffer())
  }
  e.FetchImage = function (b) {
    return new Promise((a, c) => {
      const d = new Image()
      d.onload = () => a(d)
      d.onerror = f => c(f)
      d.src = b
    })
  }
  e.BlobToArrayBuffer = function (b) {
    return 'function' === typeof b.arrayBuffer
      ? b.arrayBuffer()
      : new Promise((a, c) => {
          const d = new FileReader()
          d.onload = () => a(d.result)
          d.onerror = () => c(d.error)
          d.readAsArrayBuffer(b)
        })
  }
  e.BlobToString = function (b) {
    return 'function' === typeof b.text
      ? b.text()
      : new Promise((a, c) => {
          const d = new FileReader()
          d.onload = () => a(d.result)
          d.onerror = () => c(d.error)
          d.readAsText(b)
        })
  }
  e.BlobToJson = function (b) {
    return e.BlobToString(b).then(a => JSON.parse(a))
  }
  e.BlobToImage = async function (b, a) {
    b = URL.createObjectURL(b)
    try {
      const c = await e.FetchImage(b)
      URL.revokeObjectURL(b)
      b = ''
      a && 'function' === typeof c.decode && (await c.decode())
      return c
    } finally {
      b && URL.revokeObjectURL(b)
    }
  }
  e.CreateCanvas = function (b, a) {
    if ('undefined' !== typeof document && 'function' === typeof document.createElement) {
      const c = document.createElement('canvas')
      c.width = b
      c.height = a
      return c
    }
    return new OffscreenCanvas(b, a)
  }
  e.CanvasToBlob = function (b, a, c) {
    'number' !== typeof c && (c = 1)
    a = a || 'image/png'
    c = e.clamp(c, 0, 1)
    return b.toBlob
      ? new Promise(d => b.toBlob(d, a, c))
      : b.convertToBlob
      ? b.convertToBlob({
          type: a,
          quality: c
        })
      : e.Asyncify(() => e.CanvasToBlobSync(b, a, c))
  }
  e.CanvasToBlobSync = function (b, a, c) {
    'number' !== typeof c && (c = 1)
    a = a || 'image/png'
    c = e.clamp(c, 0, 1)
    return e.DataURIToBinaryBlobSync(b.toDataURL(a, c))
  }
  e.DataURIToBinaryBlobSync = function (b) {
    b = e.ParseDataURI(b)
    return e.BinaryStringToBlob(b.data, b.mime_type)
  }
  e.ParseDataURI = function (b) {
    if ('data:' !== b.substr(0, 5)) throw new URIError('expected data: uri')
    var a = b.indexOf(',')
    if (0 > a) throw new URIError('expected comma in data: uri')
    var c = b.substring(5, a)
    b = b.substring(a + 1)
    a = c.split(';')
    c = a[0] || ''
    let d = a[2]
    b = 'base64' === a[1] || 'base64' === d ? atob(b) : decodeURIComponent(b)
    return {
      mime_type: c,
      data: b
    }
  }
  e.BinaryStringToBlob = function (b, a) {
    var c = b.length
    let d = c >> 2,
      f = new Uint8Array(c),
      g = new Uint32Array(f.buffer, 0, d),
      h,
      k
    for (k = h = 0; h < d; ++h) g[h] = b.charCodeAt(k++) | (b.charCodeAt(k++) << 8) | (b.charCodeAt(k++) << 16) | (b.charCodeAt(k++) << 24)
    for (c &= 3; c--; ) (f[k] = b.charCodeAt(k)), ++k
    return a
      ? new Blob([f], {
          type: a
        })
      : new Blob([f])
  }
  e.DrawableToBlob = function (b, a, c) {
    const d = e.CreateCanvas(b.width, b.height)
    d.getContext('2d').drawImage(b, 0, 0)
    return e.CanvasToBlob(d, a, c)
  }
  e.ImageDataToBlobSync = function (b, a, c) {
    const d = e.CreateCanvas(b.width, b.height)
    d.getContext('2d').putImageData(b, 0, 0)
    return e.CanvasToBlobSync(d, a, c)
  }
  e.ImageDataToBlob = function (b, a, c) {
    if (e.Supports.ImageBitmapOptions)
      return createImageBitmap(b, {
        premultiplyAlpha: 'none'
      }).then(d => e.DrawableToBlob(d, a, c))
    if (e.Supports.ImageBitmap) return createImageBitmap(b).then(d => e.DrawableToBlob(d, a, c))
    {
      const d = e.CreateCanvas(b.width, b.height)
      d.getContext('2d').putImageData(b, 0, 0)
      return e.CanvasToBlob(d, a, c)
    }
  }
  e.CopySet = function (b, a) {
    b.clear()
    for (const c of a) b.add(c)
  }
  e.MapToObject = function (b) {
    const a = Object.create(null)
    for (const [c, d] of b.entries()) a[c] = d
    return a
  }
  e.ObjectToMap = function (b, a) {
    a.clear()
    for (const [c, d] of Object.entries(b)) a.set(c, d)
  }
  e.ToSuperJSON = function c(a) {
    if ('object' === typeof a && null !== a) {
      if (a instanceof Set)
        return {
          _c3type_: 'set',
          data: [...a].map(d => c(d))
        }
      if (a instanceof Map)
        return {
          _c3type_: 'map',
          data: [...a].map(d => [d[0], c(d[1])])
        }
      {
        const d = Object.create(null)
        for (const [f, g] of Object.entries(a)) d[f] = c(g)
        return d
      }
    }
    return a
  }
  e.FromSuperJSON = function d(c) {
    if (('object' === typeof c) & (null !== c)) {
      if ('set' === c._c3type_) return new Set(c.data.map(f => d(f)))
      if ('map' === c._c3type_) return new Map(c.data.map(f => [f[0], d(f[1])]))
      {
        const f = Object.create(null)
        for (const [g, h] of Object.entries(c)) f[g] = d(h)
        return f
      }
    }
    return c
  }
  e.CSSToCamelCase = function (c) {
    let d = '',
      f = !1
    for (const g of c) '-' === g ? (f = !0) : f ? ((d += g.toUpperCase()), (f = !1)) : (d += g)
    return d
  }
  e.IsIterator = function (c) {
    return 'object' === typeof c && 'function' === typeof c.next
  }
  e.MakeFilledArray = function (c, d) {
    const f = []
    if ('function' === typeof d) for (var g = 0; g < c; ++g) f.push(d())
    else for (g = 0; g < c; ++g) f.push(d)
    return f
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
    a = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i

  function c(f) {
    return 0 === f.length ? '00' : 1 === f.length ? '0' + f : f
  }

  function d(f, g, h) {
    0 > h && (h += 1)
    1 < h && --h
    return h < 1 / 6 ? f + 6 * (g - f) * h : 0.5 > h ? g : h < 2 / 3 ? f + (g - f) * (2 / 3 - h) * 6 : f
  }
  e.Color = class {
    constructor(f, g, h, k) {
      this._a = this._b = this._g = this._r = 0
      f instanceof e.Color ? this.set(f) : this.setRgba(f || 0, g || 0, h || 0, k || 0)
    }
    setRgb(f, g, h) {
      this._r = +f
      this._g = +g
      this._b = +h
      this.clamp()
      return this
    }
    setRgba(f, g, h, k) {
      this._r = +f
      this._g = +g
      this._b = +h
      this._a = +k
      this.clamp()
      return this
    }
    set(f) {
      this._r = f._r
      this._g = f._g
      this._b = f._b
      this._a = f._a
      return this
    }
    copy(f) {
      return this.set(f)
    }
    add(f) {
      this._r += f._r
      this._g += f._g
      this._b += f._b
      this._a += f._a
      this.clamp()
    }
    addRgb(f, g, h, k = 0) {
      this._r += +f
      this._g += +g
      this._b += +h
      this._a += +k
      this.clamp()
    }
    diff(f) {
      this.setR(Math.max(this._r, f._r) - Math.min(this._r, f._r))
      this.setG(Math.max(this._g, f._g) - Math.min(this._g, f._g))
      this.setB(Math.max(this._b, f._b) - Math.min(this._b, f._b))
      this.setA(Math.max(this._a, f._a) - Math.min(this._a, f._a))
      this.clamp()
    }
    copyRgb(f) {
      this._r = f._r
      this._g = f._g
      this._b = f._b
    }
    setR(f) {
      this._r = e.clamp(+f, 0, 1)
    }
    getR() {
      return this._r
    }
    setG(f) {
      this._g = e.clamp(+f, 0, 1)
    }
    getG() {
      return this._g
    }
    setB(f) {
      this._b = e.clamp(+f, 0, 1)
    }
    getB() {
      return this._b
    }
    setA(f) {
      this._a = e.clamp(+f, 0, 1)
    }
    getA() {
      return this._a
    }
    clone() {
      return e.New(e.Color, this._r, this._g, this._b, this._a)
    }
    toArray() {
      return [this._r, this._g, this._b, this._a]
    }
    toTypedArray() {
      return new Float64Array(this.toArray())
    }
    writeToTypedArray(f, g) {
      f[g++] = this._r
      f[g++] = this._g
      f[g++] = this._b
      f[g] = this._a
    }
    equals(f) {
      return this._r === f._r && this._g === f._g && this._b === f._b && this._a === f._a
    }
    equalsIgnoringAlpha(f) {
      return this._r === f._r && this._g === f._g && this._b === f._b
    }
    equalsRgb(f, g, h) {
      return this._r === f && this._g === g && this._b === h
    }
    equalsRgba(f, g, h, k) {
      return this._r === f && this._g === g && this._b === h && this._a === k
    }
    multiply(f) {
      this._r *= f._r
      this._g *= f._g
      this._b *= f._b
      this._a *= f._a
    }
    multiplyAlpha(f) {
      this._r *= f
      this._g *= f
      this._b *= f
      this._a *= f
    }
    premultiply() {
      this._r *= this._a
      this._g *= this._a
      this._b *= this._a
      return this
    }
    unpremultiply() {
      this._r /= this._a
      this._g /= this._a
      this._b /= this._a
      return this
    }
    clamp() {
      this._r = e.clamp(this._r, 0, 1)
      this._g = e.clamp(this._g, 0, 1)
      this._b = e.clamp(this._b, 0, 1)
      this._a = e.clamp(this._a, 0, 1)
      return this
    }
    setFromRgbValue(f) {
      this._r = e.GetRValue(f)
      this._g = e.GetGValue(f)
      this._b = e.GetBValue(f)
      this._a = e.GetAValue(f)
    }
    getCssRgb(f, g, h) {
      f = e.IsFiniteNumber(f) ? f : this.getR()
      g = e.IsFiniteNumber(g) ? g : this.getG()
      h = e.IsFiniteNumber(h) ? h : this.getB()
      return `rgb(${100 * f}%, ${100 * g}%, ${100 * h}%)`
    }
    getCssRgba(f, g, h, k) {
      f = e.IsFiniteNumber(f) ? f : this.getR()
      g = e.IsFiniteNumber(g) ? g : this.getG()
      h = e.IsFiniteNumber(h) ? h : this.getB()
      k = e.IsFiniteNumber(k) ? k : this.getA()
      return `rgba(${100 * f}%, ${100 * g}%, ${100 * h}%, ${k})`
    }
    toHexString() {
      const f = Math.round(255 * this.getR()),
        g = Math.round(255 * this.getG()),
        h = Math.round(255 * this.getB())
      return '#' + c(f.toString(16)) + c(g.toString(16)) + c(h.toString(16))
    }
    parseHexString(f) {
      if ('string' !== typeof f) return !1
      f = f.trim()
      '#' === f.charAt(0) && (f = f.substr(1))
      let g, h
      if (3 === f.length) (g = parseInt(f[0], 16) / 15), (h = parseInt(f[1], 16) / 15), (f = parseInt(f[2], 16) / 15)
      else if (6 === f.length) (g = parseInt(f.substr(0, 2), 16) / 255), (h = parseInt(f.substr(2, 2), 16) / 255), (f = parseInt(f.substr(4, 2), 16) / 255)
      else return !1
      isFinite(g) && this.setR(g)
      isFinite(h) && this.setG(h)
      isFinite(f) && this.setB(f)
      this.setA(1)
      return !0
    }
    toCommaSeparatedRgb() {
      const f = Math.round(255 * this.getR()),
        g = Math.round(255 * this.getG()),
        h = Math.round(255 * this.getB())
      return `${f}, ${g}, ${h}`
    }
    toRgbArray() {
      const f = Math.round(255 * this.getR()),
        g = Math.round(255 * this.getG()),
        h = Math.round(255 * this.getB())
      return [f, g, h]
    }
    parseCommaSeparatedRgb(f) {
      if ('string' !== typeof f) return !1
      f = f.replace(/^rgb\(|\)|%/, '')
      var g = f.split(',')
      if (3 > g.length) return !1
      f = parseInt(g[0].trim(), 10) / 255
      const h = parseInt(g[1].trim(), 10) / 255
      g = parseInt(g[2].trim(), 10) / 255
      isFinite(f) && this.setR(f)
      isFinite(h) && this.setG(h)
      isFinite(g) && this.setB(g)
      this.setA(1)
      return !0
    }
    parseCommaSeparatedPercentageRgb(f) {
      if ('string' !== typeof f) return !1
      f = f.replace(/^rgb\(|\)|%/, '')
      var g = f.split(',')
      if (3 > g.length) return !1
      f = parseInt(g[0].trim(), 10) / 100
      const h = parseInt(g[1].trim(), 10) / 100
      g = parseInt(g[2].trim(), 10) / 100
      isFinite(f) && this.setR(f)
      isFinite(h) && this.setG(h)
      isFinite(g) && this.setB(g)
      this.setA(1)
      return !0
    }
    parseCommaSeparatedRgba(f) {
      if ('string' !== typeof f) return !1
      f = f.replace(/^rgba\(|\)|%/, '')
      var g = f.split(',')
      if (4 > g.length) return !1
      f = parseInt(g[0].trim(), 10) / 255
      const h = parseInt(g[1].trim(), 10) / 255,
        k = parseInt(g[2].trim(), 10) / 255
      g = parseFloat(g[3].trim())
      isFinite(f) && this.setR(f)
      isFinite(h) && this.setG(h)
      isFinite(k) && this.setB(k)
      isFinite(g) && this.setA(g)
      return !0
    }
    parseCommaSeparatedPercentageRgba(f) {
      if ('string' !== typeof f) return !1
      f = f.replace(/^rgba\(|\)|%/, '')
      var g = f.split(',')
      if (4 > g.length) return !1
      f = parseInt(g[0].trim(), 10) / 100
      const h = parseInt(g[1].trim(), 10) / 100,
        k = parseInt(g[2].trim(), 10) / 100
      g = parseFloat(g[3].trim())
      isFinite(f) && this.setR(f)
      isFinite(h) && this.setG(h)
      isFinite(k) && this.setB(k)
      isFinite(g) && this.setA(g)
      return !0
    }
    parseString(f) {
      if ('string' !== typeof f) return !1
      f = f.replace(/\s+/, '')
      if (f.includes(',')) {
        if (f.startsWith('rgb(')) return f.includes('%') ? this.parseCommaSeparatedPercentageRgb(f) : this.parseCommaSeparatedRgb(f)
        if (f.startsWith('rgba(')) return f.includes('%') ? this.parseCommaSeparatedPercentageRgba(f) : this.parseCommaSeparatedRgba(f)
        if (f.startsWith('hsl(') || f.startsWith('hsla(')) return this.parseHSLString(f)
        {
          const g = f.split(',')
          if (f.includes('%')) {
            if (3 === g.length) return this.parseCommaSeparatedPercentageRgb(f)
            if (4 === g.length) return this.parseCommaSeparatedPercentageRgba(f)
          } else {
            if (3 === g.length) return this.parseCommaSeparatedRgb(f)
            if (4 === g.length) return this.parseCommaSeparatedRgba(f)
          }
          return !1
        }
      }
      return this.parseHexString(f)
    }
    toJSON() {
      return [this._r, this._g, this._b, this._a]
    }
    setFromHSLA(f, g, h, k) {
      f %= 360
      g = e.clamp(g, 0, 100)
      h = e.clamp(h, 0, 100)
      k = e.clamp(k, 0, 1)
      f /= 360
      g /= 100
      h /= 100
      if (0 === g) h = g = f = h
      else {
        const m = 0.5 > h ? h * (1 + g) : h + g - h * g,
          r = 2 * h - m
        h = d(r, m, f + 1 / 3)
        g = d(r, m, f)
        f = d(r, m, f - 1 / 3)
      }
      this.setR(h)
      this.setG(g)
      this.setB(f)
      this.setA(k)
      return this
    }
    parseHSLString(f) {
      var g = f.replace(/ |hsl|hsla|\(|\)|;/gi, '')
      f = b.exec(g)
      g = a.exec(g)
      return f && 4 === f.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], 1), !0) : g && 5 === g.length ? (this.setFromHSLA(+f[1], +f[2], +f[3], +f[4]), !0) : !1
    }
    toHSLAString() {
      var f = this._r
      const g = this._g,
        h = this._b,
        k = this._a,
        m = e.Color.GetHue(f, g, h),
        r = e.Color.GetSaturation(f, g, h)
      f = e.Color.GetLuminosity(f, g, h)
      return `hsla(${m}, ${r}%, ${f}%, ${k})`
    }
    toHSLAArray() {
      const f = this._r,
        g = this._g,
        h = this._b
      return [e.Color.GetHue(f, g, h), e.Color.GetSaturation(f, g, h), e.Color.GetLuminosity(f, g, h), this._a]
    }
    setFromJSON(f) {
      !Array.isArray(f) || 3 > f.length || ((this._r = f[0]), (this._g = f[1]), (this._b = f[2]), (this._a = 4 <= f.length ? f[3] : 1))
    }
    set r(f) {
      this.setR(f)
    }
    get r() {
      return this.getR()
    }
    set g(f) {
      this.setG(f)
    }
    get g() {
      return this.getG()
    }
    set b(f) {
      this.setB(f)
    }
    get b() {
      return this.getB()
    }
    set a(f) {
      this.setA(f)
    }
    get a() {
      return this.getA()
    }
    setAtIndex(f, g) {
      switch (f) {
        case 0:
          this.setR(g)
          break
        case 1:
          this.setG(g)
          break
        case 2:
          this.setB(g)
          break
        case 3:
          this.setA(g)
          break
        default:
          throw new RangeError('invalid color index')
      }
    }
    getAtIndex(f) {
      switch (f) {
        case 0:
          return this.getR()
        case 1:
          return this.getG()
        case 2:
          return this.getB()
        case 3:
          return this.getA()
        default:
          throw new RangeError('invalid color index')
      }
    }
    static Equals(f, g) {
      let h
      if (Array.isArray(f)) (h = new e.Color()), h.setFromJSON(f)
      else if (f instanceof e.Color) h = f
      else throw Error('unexpected type')
      if (Array.isArray(g)) (f = new e.Color()), f.setFromJSON(g)
      else if (g instanceof e.Color) f = g
      else throw Error('unexpected type')
      return h.equals(f)
    }
    static DiffChannel(f, g) {
      return e.clamp(Math.max(f, g) - Math.min(f, g), 0, 1)
    }
    static Diff(f, g) {
      const h = new e.Color()
      h.setR(Math.max(f._r, g._r) - Math.min(f._r, g._r))
      h.setG(Math.max(f._g, g._g) - Math.min(f._g, g._g))
      h.setB(Math.max(f._b, g._b) - Math.min(f._b, g._b))
      h.setA(Math.max(f._a, g._a) - Math.min(f._a, g._a))
      return h
    }
    static DiffNoAlpha(f, g) {
      const h = new e.Color(0, 0, 0, 1)
      h.setR(Math.max(f._r, g._r) - Math.min(f._r, g._r))
      h.setG(Math.max(f._g, g._g) - Math.min(f._g, g._g))
      h.setB(Math.max(f._b, g._b) - Math.min(f._b, g._b))
      return h
    }
    static GetHue(f, g, h) {
      const k = Math.max(f, g, h),
        m = Math.min(f, g, h)
      if (k === m) return 0
      let r = 0
      switch (k) {
        case f:
          r = (g - h) / (k - m) + (g < h ? 6 : 0)
          break
        case g:
          r = (h - f) / (k - m) + 2
          break
        case h:
          r = (f - g) / (k - m) + 4
      }
      return Math.round((r / 6) * 360)
    }
    static GetSaturation(f, g, h) {
      const k = Math.max(f, g, h)
      f = Math.min(f, g, h)
      if (k === f) return 0
      g = k - f
      return Math.round(100 * (0.5 < (k + f) / 2 ? g / (2 - k - f) : g / (k + f)))
    }
    static GetLuminosity(f, g, h) {
      const k = Math.max(f, g, h)
      return k ? Math.round(((k + Math.min(f, g, h)) / 2) * 100) : 0
    }
  }
  e.Color.White = Object.freeze(e.New(e.Color, 1, 1, 1, 1))
  e.Color.Black = Object.freeze(e.New(e.Color, 0, 0, 0, 1))
  e.Color.TransparentBlack = Object.freeze(e.New(e.Color, 0, 0, 0, 0))
}
{
  ;('use strict')
  const e = self.C3
  e.Vector2 = class {
    constructor(b, a) {
      this._y = this._x = 0
      b instanceof e.Vector2 ? this.copy(b) : this.set(b || 0, a || 0)
    }
    set(b, a) {
      this._x = +b
      this._y = +a
    }
    copy(b) {
      this._x = b._x
      this._y = b._y
    }
    equals(b) {
      return this._x === b._x && this._y === b._y
    }
    equalsValues(b, a) {
      return this._x === b && this._y === a
    }
    setX(b) {
      this._x = +b
    }
    getX() {
      return this._x
    }
    setY(b) {
      this._y = +b
    }
    getY() {
      return this._y
    }
    toArray() {
      return [this._x, this._y]
    }
    toTypedArray() {
      return new Float64Array(this.toArray())
    }
    writeToTypedArray(b, a) {
      b[a++] = this._x
      b[a] = this._y
    }
    offset(b, a) {
      this._x += +b
      this._y += +a
    }
    scale(b, a) {
      this._x *= b
      this._y *= a
    }
    divide(b, a) {
      this._x /= b
      this._y /= a
    }
    round() {
      this._x = Math.round(this._x)
      this._y = Math.round(this._y)
    }
    floor() {
      this._x = Math.floor(this._x)
      this._y = Math.floor(this._y)
    }
    ceil() {
      this._x = Math.ceil(this._x)
      this._y = Math.ceil(this._y)
    }
    angle() {
      return e.angleTo(0, 0, this._x, this._y)
    }
    lengthSquared() {
      return this._x * this._x + this._y * this._y
    }
    length() {
      return Math.sqrt(this.lengthSquared())
    }
    rotatePrecalc(b, a) {
      const c = this._x * a - this._y * b
      this._y = this._y * a + this._x * b
      this._x = c
    }
    rotate(b) {
      0 !== b && this.rotatePrecalc(Math.sin(b), Math.cos(b))
    }
    rotateAbout(b, a, c) {
      0 === b || (a === this._x && c === this._y) || ((this._x -= a), (this._y -= c), this.rotatePrecalc(Math.sin(b), Math.cos(b)), (this._x += +a), (this._y += +c))
    }
    move(b, a) {
      0 !== a && ((this._x += Math.cos(b) * a), (this._y += Math.sin(b) * a))
    }
    normalize() {
      const b = this.length()
      0 !== b && 1 !== b && ((this._x /= b), (this._y /= b))
    }
    clamp(b, a) {
      this._x = e.clamp(this._x, b, a)
      this._y = e.clamp(this._y, b, a)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Rect = class {
    constructor(b, a, c, d) {
      this._bottom = this._right = this._top = this._left = 0
      b instanceof e.Rect ? this.copy(b) : this.set(b || 0, a || 0, c || 0, d || 0)
    }
    set(b, a, c, d) {
      this._left = +b
      this._top = +a
      this._right = +c
      this._bottom = +d
    }
    setWH(b, a, c, d) {
      b = +b
      a = +a
      this._left = b
      this._top = a
      this._right = b + +c
      this._bottom = a + +d
    }
    copy(b) {
      this._left = +b._left
      this._top = +b._top
      this._right = +b._right
      this._bottom = +b._bottom
    }
    clone() {
      return new e.Rect(this._left, this._top, this._right, this._bottom)
    }
    static Merge(b, a) {
      const c = new e.Rect()
      c.setLeft(Math.min(b._left, a._left))
      c.setTop(Math.min(b._top, a._top))
      c.setRight(Math.max(b._right, a._right))
      c.setBottom(Math.max(b._bottom, a._bottom))
      return c
    }
    static FromObject(b) {
      return new e.Rect(b.left, b.top, b.right, b.bottom)
    }
    equals(b) {
      return this._left === b._left && this._top === b._top && this._right === b._right && this._bottom === b._bottom
    }
    equalsWH(b, a, c, d) {
      return this._left === b && this._top === a && this.width() === c && this.height() === d
    }
    setLeft(b) {
      this._left = +b
    }
    getLeft() {
      return this._left
    }
    setTop(b) {
      this._top = +b
    }
    getTop() {
      return this._top
    }
    setRight(b) {
      this._right = +b
    }
    getRight() {
      return this._right
    }
    setBottom(b) {
      this._bottom = +b
    }
    getBottom() {
      return this._bottom
    }
    toArray() {
      return [this._left, this._top, this._right, this._bottom]
    }
    toTypedArray() {
      return new Float64Array(this.toArray())
    }
    toDOMRect() {
      return new DOMRect(this._left, this._top, this.width(), this.height())
    }
    writeToTypedArray(b, a) {
      b[a++] = this._left
      b[a++] = this._top
      b[a++] = this._right
      b[a] = this._bottom
    }
    writeAsQuadToTypedArray(b, a) {
      b[a++] = this._left
      b[a++] = this._top
      b[a++] = this._right
      b[a++] = this._top
      b[a++] = this._right
      b[a++] = this._bottom
      b[a++] = this._left
      b[a] = this._bottom
    }
    writeAsQuadToTypedArray3D(b, a, c) {
      b[a++] = this._left
      b[a++] = this._top
      b[a++] = c
      b[a++] = this._right
      b[a++] = this._top
      b[a++] = c
      b[a++] = this._right
      b[a++] = this._bottom
      b[a++] = c
      b[a++] = this._left
      b[a++] = this._bottom
      b[a] = c
    }
    width() {
      return this._right - this._left
    }
    height() {
      return this._bottom - this._top
    }
    midX() {
      return (this._left + this._right) / 2
    }
    midY() {
      return (this._top + this._bottom) / 2
    }
    offset(b, a) {
      b = +b
      a = +a
      this._left += b
      this._top += a
      this._right += b
      this._bottom += a
    }
    offsetLeft(b) {
      this._left += +b
    }
    offsetTop(b) {
      this._top += +b
    }
    offsetRight(b) {
      this._right += +b
    }
    offsetBottom(b) {
      this._bottom += +b
    }
    toSquare(b) {
      if ('x' !== b) throw Error("invalid axis, only 'x' supported")
      this._bottom = this._top < this._bottom ? (this._left < this._right ? this._top + this.width() : this._top - this.width()) : this._left < this._right ? this._top - this.width() : this._top + this.width()
    }
    inflate(b, a) {
      b = +b
      a = +a
      this._left -= b
      this._top -= a
      this._right += b
      this._bottom += a
    }
    deflate(b, a) {
      b = +b
      a = +a
      this._left += b
      this._top += a
      this._right -= b
      this._bottom -= a
    }
    multiply(b, a) {
      this._left *= b
      this._top *= a
      this._right *= b
      this._bottom *= a
    }
    divide(b, a) {
      this._left /= b
      this._top /= a
      this._right /= b
      this._bottom /= a
    }
    mirrorAround(b) {
      this._left = +b - this._left
      this._right = +b - this._right
    }
    flipAround(b) {
      this._top = +b - this._top
      this._bottom = +b - this._bottom
    }
    swapLeftRight() {
      const b = this._left
      this._left = this._right
      this._right = b
    }
    swapTopBottom() {
      const b = this._top
      this._top = this._bottom
      this._bottom = b
    }
    shuntY(b) {
      const a = this._top
      this._top = +b - this._bottom
      this._bottom = +b - a
    }
    round() {
      this._left = Math.round(this._left)
      this._top = Math.round(this._top)
      this._right = Math.round(this._right)
      this._bottom = Math.round(this._bottom)
    }
    roundInner() {
      this._left = Math.ceil(this._left)
      this._top = Math.ceil(this._top)
      this._right = Math.floor(this._right)
      this._bottom = Math.floor(this._bottom)
    }
    roundOuter() {
      this._left = Math.floor(this._left)
      this._top = Math.floor(this._top)
      this._right = Math.ceil(this._right)
      this._bottom = Math.ceil(this._bottom)
    }
    floor() {
      this._left = Math.floor(this._left)
      this._top = Math.floor(this._top)
      this._right = Math.floor(this._right)
      this._bottom = Math.floor(this._bottom)
    }
    ceil() {
      this._left = Math.ceil(this._left)
      this._top = Math.ceil(this._top)
      this._right = Math.ceil(this._right)
      this._bottom = Math.ceil(this._bottom)
    }
    clamp(b, a, c, d) {
      this._left < b && (this._left = +b)
      this._top < a && (this._top = +a)
      this._right > c && (this._right = +c)
      this._bottom > d && (this._bottom = +d)
    }
    clampFlipped(b, a, c, d) {
      this._left < b && (this._left = +b)
      this._top > a && (this._top = +a)
      this._right > c && (this._right = +c)
      this._bottom < d && (this._bottom = +d)
    }
    normalize() {
      this._left > this._right && this.swapLeftRight()
      this._top > this._bottom && this.swapTopBottom()
    }
    intersectsRect(b) {
      return !(b._right < this._left || b._bottom < this._top || b._left > this._right || b._top > this._bottom)
    }
    intersectsRectOffset(b, a, c) {
      return !(b._right + a < this._left || b._bottom + c < this._top || b._left + a > this._right || b._top + c > this._bottom)
    }
    containsPoint(b, a) {
      return b >= this._left && b <= this._right && a >= this._top && a <= this._bottom
    }
    containsRect(b) {
      return b._left >= this._left && b._top >= this._top && b._right <= this._right && b._bottom <= this._bottom
    }
    expandToContain(b) {
      b._left < this._left && (this._left = +b._left)
      b._top < this._top && (this._top = +b._top)
      b._right > this._right && (this._right = +b._right)
      b._bottom > this._bottom && (this._bottom = +b._bottom)
    }
    lerpInto(b) {
      this._left = e.lerp(b._left, b._right, this._left)
      this._top = e.lerp(b._top, b._bottom, this._top)
      this._right = e.lerp(b._left, b._right, this._right)
      this._bottom = e.lerp(b._top, b._bottom, this._bottom)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Quad = class {
    constructor(b, a, c, d, f, g, h, k) {
      this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0
      b instanceof e.Quad ? this.copy(b) : this.set(b || 0, a || 0, c || 0, d || 0, f || 0, g || 0, h || 0, k || 0)
    }
    set(b, a, c, d, f, g, h, k) {
      this._tlx = +b
      this._tly = +a
      this._trx = +c
      this._try = +d
      this._brx = +f
      this._bry = +g
      this._blx = +h
      this._bly = +k
    }
    setRect(b, a, c, d) {
      this.set(b, a, c, a, c, d, b, d)
    }
    copy(b) {
      this._tlx = b._tlx
      this._tly = b._tly
      this._trx = b._trx
      this._try = b._try
      this._brx = b._brx
      this._bry = b._bry
      this._blx = b._blx
      this._bly = b._bly
    }
    equals(b) {
      return this._tlx === b._tlx && this._tly === b._tly && this._trx === b._trx && this._try === b._try && this._brx === b._brx && this._bry === b._bry && this._blx === b._blx && this._bly === b._bly
    }
    setTlx(b) {
      this._tlx = +b
    }
    getTlx() {
      return this._tlx
    }
    setTly(b) {
      this._tly = +b
    }
    getTly() {
      return this._tly
    }
    setTrx(b) {
      this._trx = +b
    }
    getTrx() {
      return this._trx
    }
    setTry(b) {
      this._try = +b
    }
    getTry() {
      return this._try
    }
    setBrx(b) {
      this._brx = +b
    }
    getBrx() {
      return this._brx
    }
    setBry(b) {
      this._bry = +b
    }
    getBry() {
      return this._bry
    }
    setBlx(b) {
      this._blx = +b
    }
    getBlx() {
      return this._blx
    }
    setBly(b) {
      this._bly = +b
    }
    getBly() {
      return this._bly
    }
    toDOMQuad() {
      return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
    }
    toArray() {
      return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
    }
    toTypedArray() {
      return new Float64Array(this.toArray())
    }
    writeToTypedArray(b, a) {
      b[a++] = this._tlx
      b[a++] = this._tly
      b[a++] = this._trx
      b[a++] = this._try
      b[a++] = this._brx
      b[a++] = this._bry
      b[a++] = this._blx
      b[a] = this._bly
    }
    writeToTypedArray3D(b, a, c) {
      b[a++] = this._tlx
      b[a++] = this._tly
      b[a++] = c
      b[a++] = this._trx
      b[a++] = this._try
      b[a++] = c
      b[a++] = this._brx
      b[a++] = this._bry
      b[a++] = c
      b[a++] = this._blx
      b[a++] = this._bly
      b[a] = c
    }
    offset(b, a) {
      b = +b
      a = +a
      this._tlx += b
      this._tly += a
      this._trx += b
      this._try += a
      this._brx += b
      this._bry += a
      this._blx += b
      this._bly += a
    }
    round() {
      this._tlx = Math.round(this._tlx)
      this._tly = Math.round(this._tly)
      this._trx = Math.round(this._trx)
      this._try = Math.round(this._try)
      this._brx = Math.round(this._brx)
      this._bry = Math.round(this._bry)
      this._blx = Math.round(this._blx)
      this._bly = Math.round(this._bly)
    }
    floor() {
      this._tlx = Math.floor(this._tlx)
      this._tly = Math.floor(this._tly)
      this._trx = Math.floor(this._trx)
      this._try = Math.floor(this._try)
      this._brx = Math.floor(this._brx)
      this._bry = Math.floor(this._bry)
      this._blx = Math.floor(this._blx)
      this._bly = Math.floor(this._bly)
    }
    ceil() {
      this._tlx = Math.ceil(this._tlx)
      this._tly = Math.ceil(this._tly)
      this._trx = Math.ceil(this._trx)
      this._try = Math.ceil(this._try)
      this._brx = Math.ceil(this._brx)
      this._bry = Math.ceil(this._bry)
      this._blx = Math.ceil(this._blx)
      this._bly = Math.ceil(this._bly)
    }
    setFromRect(b) {
      this._tlx = b._left
      this._tly = b._top
      this._trx = b._right
      this._try = b._top
      this._brx = b._right
      this._bry = b._bottom
      this._blx = b._left
      this._bly = b._bottom
    }
    setFromRotatedRect(b, a) {
      0 === a ? this.setFromRect(b) : this.setFromRotatedRectPrecalc(b, Math.sin(a), Math.cos(a))
    }
    setFromRotatedRectPrecalc(b, a, c) {
      const d = b._left * a,
        f = b._top * a,
        g = b._right * a
      a *= b._bottom
      const h = b._left * c,
        k = b._top * c,
        m = b._right * c
      b = b._bottom * c
      this._tlx = h - f
      this._tly = k + d
      this._trx = m - f
      this._try = k + g
      this._brx = m - a
      this._bry = b + g
      this._blx = h - a
      this._bly = b + d
    }
    getBoundingBox(b) {
      b.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
    }
    containsPoint(b, a) {
      var c = this._trx - this._tlx,
        d = this._try - this._tly
      const f = this._brx - this._tlx,
        g = this._bry - this._tly
      b -= this._tlx
      a -= this._tly
      var h = c * c + d * d
      let k = c * f + d * g
      d = c * b + d * a
      const m = f * f + g * g,
        r = f * b + g * a
      let w = 1 / (h * m - k * k)
      c = (m * d - k * r) * w
      h = (h * r - k * d) * w
      if (0 <= c && 0 < h && 1 > c + h) return !0
      c = this._blx - this._tlx
      d = this._bly - this._tly
      h = c * c + d * d
      k = c * f + d * g
      d = c * b + d * a
      w = 1 / (h * m - k * k)
      c = (m * d - k * r) * w
      h = (h * r - k * d) * w
      return 0 <= c && 0 < h && 1 > c + h
    }
    midX() {
      return (this._tlx + this._trx + this._brx + this._blx) / 4
    }
    midY() {
      return (this._tly + this._try + this._bry + this._bly) / 4
    }
    intersectsSegment(b, a, c, d) {
      return this.containsPoint(b, a) || this.containsPoint(c, d) ? !0 : e.segmentIntersectsQuad(b, a, c, d, this)
    }
    intersectsQuad(b) {
      var a = b.midX(),
        c = b.midY()
      if (this.containsPoint(a, c)) return !0
      a = this.midX()
      c = this.midY()
      if (b.containsPoint(a, c)) return !0
      a = this._tlx
      c = this._tly
      const d = this._trx,
        f = this._try,
        g = this._brx,
        h = this._bry,
        k = this._blx,
        m = this._bly
      return e.segmentIntersectsQuad(a, c, d, f, b) || e.segmentIntersectsQuad(d, f, g, h, b) || e.segmentIntersectsQuad(g, h, k, m, b) || e.segmentIntersectsQuad(k, m, a, c, b)
    }
    mirror() {
      this._swap(0, 2)
      this._swap(1, 3)
      this._swap(6, 4)
      this._swap(7, 5)
    }
    flip() {
      this._swap(0, 6)
      this._swap(1, 7)
      this._swap(2, 4)
      this._swap(3, 5)
    }
    diag() {
      this._swap(2, 6)
      this._swap(3, 7)
    }
    _swap(b, a) {
      const c = this._getAtIndex(b)
      this._setAtIndex(b, this._getAtIndex(a))
      this._setAtIndex(a, c)
    }
    _getAtIndex(b) {
      switch (b) {
        case 0:
          return this._tlx
        case 1:
          return this._tly
        case 2:
          return this._trx
        case 3:
          return this._try
        case 4:
          return this._brx
        case 5:
          return this._bry
        case 6:
          return this._blx
        case 7:
          return this._bly
        default:
          throw new RangeError('invalid quad point index')
      }
    }
    _setAtIndex(b, a) {
      a = +a
      switch (b) {
        case 0:
          this._tlx = a
          break
        case 1:
          this._tly = a
          break
        case 2:
          this._trx = a
          break
        case 3:
          this._try = a
          break
        case 4:
          this._brx = a
          break
        case 5:
          this._bry = a
          break
        case 6:
          this._blx = a
          break
        case 7:
          this._bly = a
          break
        default:
          throw new RangeError('invalid quad point index')
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = [0, 0, 1, 0, 1, 1, 0, 1],
    a = e.New(e.Quad)
  e.CollisionPoly = class extends e.DefendedBase {
    constructor(c, d = !0) {
      super()
      c || (c = b)
      this._ptsArr = Float64Array.from(c)
      this._bbox = new e.Rect()
      this._isBboxChanged = !0
      this._enabled = d
    }
    Release() {}
    pointsArr() {
      return this._ptsArr
    }
    pointCount() {
      return this._ptsArr.length / 2
    }
    setPoints(c) {
      this._ptsArr.length === c.length ? this._ptsArr.set(c) : (this._ptsArr = Float64Array.from(c))
      this._isBboxChanged = !0
    }
    setDefaultPoints() {
      this.setPoints(b)
    }
    copy(c) {
      this.setPoints(c._ptsArr)
    }
    setBboxChanged() {
      this._isBboxChanged = !0
    }
    _updateBbox() {
      if (this._isBboxChanged) {
        var c = this._ptsArr,
          d = c[0],
          f = c[1],
          g = d,
          h = f
        for (let k = 0, m = c.length; k < m; k += 2) {
          const r = c[k],
            w = c[k + 1]
          r < d && (d = r)
          r > g && (g = r)
          w < f && (f = w)
          w > h && (h = w)
        }
        this._bbox.set(d, f, g, h)
        this._isBboxChanged = !1
      }
    }
    setFromRect(c, d, f) {
      let g = this._ptsArr
      8 !== g.length && (this._ptsArr = g = new Float64Array(8))
      g[0] = c.getLeft() - d
      g[1] = c.getTop() - f
      g[2] = c.getRight() - d
      g[3] = c.getTop() - f
      g[4] = c.getRight() - d
      g[5] = c.getBottom() - f
      g[6] = c.getLeft() - d
      g[7] = c.getBottom() - f
      this._bbox.copy(c)
      ;(0 === d && 0 === f) || this._bbox.offset(-d, -f)
      this._isBboxChanged = !1
    }
    setFromQuad(c, d, f) {
      a.copy(c)
      a.offset(d, f)
      this.setPoints(a.toArray())
      this._isBboxChanged = !0
    }
    transform(c, d, f) {
      let g = 0,
        h = 1
      0 !== f && ((g = Math.sin(f)), (h = Math.cos(f)))
      this.transformPrecalc(c, d, g, h)
    }
    transformPrecalc(c, d, f, g) {
      const h = this._ptsArr
      for (let k = 0, m = h.length; k < m; k += 2) {
        const r = k + 1,
          w = h[k] * c,
          p = h[r] * d
        h[k] = w * g - p * f
        h[r] = p * g + w * f
      }
      this._isBboxChanged = !0
    }
    offset(c, d) {
      const f = this._ptsArr
      for (let g = 0, h = f.length; g < h; g += 2) (f[g] += c), (f[g + 1] += d)
    }
    containsPoint(c, d) {
      const f = this._ptsArr
      if (c === f[0] && d === f[1]) return !0
      this._updateBbox()
      var g = this._bbox
      const h = g.getLeft() - 110,
        k = g.getTop() - 101,
        m = g.getRight() + 131
      g = g.getBottom() + 120
      let r, w, p, q, t, x, v, u
      h < c ? ((r = h), (p = c)) : ((r = c), (p = h))
      k < d ? ((w = k), (q = d)) : ((w = d), (q = k))
      m < c ? ((t = m), (v = c)) : ((t = c), (v = m))
      g < d ? ((x = g), (u = d)) : ((x = d), (u = g))
      let A = 0,
        z = 0
      for (let E = 0, J = f.length; E < J; E += 2) {
        var C = (E + 2) % J
        const F = f[E],
          I = f[E + 1],
          L = f[C]
        C = f[C + 1]
        e.segmentsIntersectPreCalc(h, k, c, d, r, p, w, q, F, I, L, C) && ++A
        e.segmentsIntersectPreCalc(m, g, c, d, t, v, x, u, F, I, L, C) && ++z
      }
      return 1 === A % 2 || 1 === z % 2
    }
    intersectsPoly(c, d, f) {
      const g = c._ptsArr,
        h = this._ptsArr
      if (this.containsPoint(g[0] + d, g[1] + f) || c.containsPoint(h[0] - d, h[1] - f)) return !0
      for (let m = 0, r = h.length; m < r; m += 2) {
        var k = (m + 2) % r
        c = h[m]
        const w = h[m + 1],
          p = h[k]
        k = h[k + 1]
        let q, t, x, v
        c < p ? ((q = c), (x = p)) : ((q = p), (x = c))
        w < k ? ((t = w), (v = k)) : ((t = k), (v = w))
        for (let u = 0, A = g.length; u < A; u += 2) {
          const z = (u + 2) % A
          if (e.segmentsIntersectPreCalc(c, w, p, k, q, x, t, v, g[u] + d, g[u + 1] + f, g[z] + d, g[z + 1] + f)) return !0
        }
      }
      return !1
    }
    intersectsSegment(c, d, f, g, h, k) {
      if (this.containsPoint(f - c, g - d) || this.containsPoint(h - c, k - d)) return !0
      let m, r, w, p
      f < h ? ((m = f), (w = h)) : ((m = h), (w = f))
      g < k ? ((r = g), (p = k)) : ((r = k), (p = g))
      const q = this._ptsArr
      for (let t = 0, x = q.length; t < x; t += 2) {
        const v = (t + 2) % x
        if (e.segmentsIntersectPreCalc(f, g, h, k, m, w, r, p, q[t] + c, q[t + 1] + d, q[v] + c, q[v + 1] + d)) return !0
      }
      return !1
    }
    mirror(c) {
      const d = this._ptsArr
      for (let f = 0, g = d.length; f < g; f += 2) d[f] = 2 * c - d[f]
      this._isBboxChanged = !0
    }
    flip(c) {
      const d = this._ptsArr
      for (let f = 0, g = d.length; f < g; f += 2) {
        const h = f + 1
        d[h] = 2 * c - d[h]
      }
      this._isBboxChanged = !0
    }
    diag() {
      const c = this._ptsArr
      for (let d = 0, f = c.length; d < f; d += 2) {
        const g = d + 1,
          h = c[d]
        c[d] = c[g]
        c[g] = h
      }
      this._isBboxChanged = !0
    }
    GetMidX() {
      const c = this._ptsArr
      let d = 0
      for (let f = 0, g = c.length; f < g; f += 2) d += c[f]
      return d / this.pointCount()
    }
    GetMidY() {
      const c = this._ptsArr
      let d = 0
      for (let f = 0, g = c.length; f < g; f += 2) d += c[f + 1]
      return d / this.pointCount()
    }
    GetPointsArray() {
      return this._ptsArr
    }
    GetPointCount() {
      return this.pointCount()
    }
    IsEnabled() {
      return this._enabled
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.PairMap = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._firstMap = new Map()
      if (b) for (const [a, c, d] of b) this.Set(a, c, d)
    }
    Release() {
      this.Clear()
      this._firstMap = null
    }
    Clear() {
      const b = this._firstMap
      for (const a of b.values()) a.clear()
      b.clear()
    }
    Set(b, a, c) {
      const d = this._firstMap
      let f = d.get(b)
      f || ((f = new Map()), d.set(b, f))
      f.set(a, c)
    }
    Get(b, a) {
      return (b = this._firstMap.get(b)) ? b.get(a) : b
    }
    Has(b, a) {
      return (b = this._firstMap.get(b)) ? b.has(a) : !1
    }
    Delete(b, a) {
      const c = this._firstMap,
        d = c.get(b)
      if (!d) return !1
      ;(a = d.delete(a)) && 0 === d.size && c.delete(b)
      return a
    }
    DeleteEither(b) {
      const a = this._firstMap,
        c = a.get(b)
      c && (c.clear(), a.delete(b))
      for (const [d, f] of a.entries()) f.delete(b) && 0 === f.size && a.delete(d)
    }
    GetSize() {
      let b = 0
      for (const a of this._firstMap.values()) b += a.size
      return b
    }
    *values() {
      for (const b of this._firstMap.values()) yield* b.values()
    }
    *keyPairs() {
      for (const [b, a] of this._firstMap.entries()) for (const c of a.keys()) yield [b, c]
    }
    *entries() {
      for (const [b, a] of this._firstMap.entries()) for (const [c, d] of a.entries()) yield [b, c, d]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.ArraySet = class extends e.DefendedBase {
    constructor() {
      super()
      this._set = new Set()
      this._arr = []
      this._needToRebuildArray = !1
    }
    Release() {
      this.Clear()
    }
    Clear() {
      this._set.clear()
      e.clearArray(this._arr)
      this._needToRebuildArray = !1
    }
    Add(b) {
      this._set.has(b) || (this._set.add(b), this._needToRebuildArray || this._arr.push(b))
    }
    Has(b) {
      return this._set.has(b)
    }
    Delete(b) {
      this._set.delete(b) && (this._needToRebuildArray = !0)
    }
    GetSize() {
      return this._set.size
    }
    IsEmpty() {
      return 0 === this._set.size
    }
    GetArray() {
      this._needToRebuildArray && (this._RebuildArray(), (this._needToRebuildArray = !1))
      return this._arr
    }
    _RebuildArray() {
      const b = this._arr
      e.clearArray(b)
      for (const a of this._set) b.push(a)
    }
  }
}
{
  ;('use strict')
  const e = new Map(),
    b = new Map(),
    a = new Map(),
    c = new Map(),
    d = new Map(),
    f = new Map()
  f.set('linear', 'noease')
  f.set('default', 'noease')
  self.Ease = class p {
    constructor() {}
    static InheritEase() {
      return 'default'
    }
    static DefaultEase() {
      return 'noease'
    }
    static GetEditorEaseNames(q, ...t) {
      this._CreateEaseMap()
      a.has(q) || a.set(q, new Map())
      q = [...a.get(q).keys()]
      q.sort()
      return [...b.keys()].concat(q).filter(x => !t.includes(x))
    }
    static GetRuntimeEaseNames() {
      this._CreateEaseMap()
      const q = [...c.keys()]
      q.sort()
      return [...b.keys()].concat(q)
    }
    static IsNamePredefined(q) {
      this._CreateEaseMap()
      return [...b.keys()].includes(q)
    }
    static _GetEase(q) {
      const t = f.get(q)
      if (t) return e.get(t)
      if (p.IsNamePredefined(q)) return e.get(q)
      if (d.has(q)) return d.get(q)
    }
    static GetEditorEase(q, t) {
      this._CreateEaseMap()
      const x = p._GetEase(q)
      return x ? x : a.get(t).get(q)
    }
    static GetRuntimeEase(q) {
      this._CreateEaseMap()
      const t = p._GetEase(q)
      return t ? t : c.get(q)
    }
    static GetEaseFromIndex(q) {
      this._CreateEaseMap()
      return this.GetRuntimeEaseNames()[q]
    }
    static GetIndexForEase(q, t) {
      this._CreateEaseMap()
      return this.GetEditorEaseNames(t).indexOf(q)
    }
    static _CreateEaseMap() {
      0 === e.size &&
        (this._AddPredifinedEase('default', () => {}),
        this._AddPredifinedEase('noease', this.NoEase),
        this._AddPredifinedEase('easeinsine', this.EaseInSine),
        this._AddPredifinedEase('easeoutsine', this.EaseOutSine),
        this._AddPredifinedEase('easeinoutsine', this.EaseInOutSine),
        this._AddPredifinedEase('easeinelastic', this.EaseInElastic),
        this._AddPredifinedEase('easeoutelastic', this.EaseOutElastic),
        this._AddPredifinedEase('easeinoutelastic', this.EaseInOutElastic),
        this._AddPredifinedEase('easeinback', this.EaseInBack),
        this._AddPredifinedEase('easeoutback', this.EaseOutBack),
        this._AddPredifinedEase('easeinoutback', this.EaseInOutBack),
        this._AddPredifinedEase('easeinbounce', this.EaseInBounce),
        this._AddPredifinedEase('easeoutbounce', this.EaseOutBounce),
        this._AddPredifinedEase('easeinoutbounce', this.EaseInOutBounce),
        this._AddPredifinedEase('easeincubic', this.EaseInCubic),
        this._AddPredifinedEase('easeoutcubic', this.EaseOutCubic),
        this._AddPredifinedEase('easeinoutcubic', this.EaseInOutCubic),
        this._AddPredifinedEase('easeinquad', this.EaseInQuad),
        this._AddPredifinedEase('easeoutquad', this.EaseOutQuad),
        this._AddPredifinedEase('easeinoutquad', this.EaseInOutQuad),
        this._AddPredifinedEase('easeinquart', this.EaseInQuart),
        this._AddPredifinedEase('easeoutquart', this.EaseOutQuart),
        this._AddPredifinedEase('easeinoutquart', this.EaseInOutQuart),
        this._AddPredifinedEase('easeinquint', this.EaseInQuint),
        this._AddPredifinedEase('easeoutquint', this.EaseOutQuint),
        this._AddPredifinedEase('easeinoutquint', this.EaseInOutQuint),
        this._AddPredifinedEase('easeincirc', this.EaseInCirc),
        this._AddPredifinedEase('easeoutcirc', this.EaseOutCirc),
        this._AddPredifinedEase('easeinoutcirc', this.EaseInOutCirc),
        this._AddPredifinedEase('easeinexpo', this.EaseInExpo),
        this._AddPredifinedEase('easeoutexpo', this.EaseOutExpo),
        this._AddPredifinedEase('easeinoutexpo', this.EaseInOutExpo),
        this._AddPrivateCustomEase('cubicbezier', this.EaseCubicBezier),
        this._AddPrivateCustomEase('spline', this.EaseSpline))
    }
    static _AddPredifinedEase(q, t) {
      p._AddEase(q, t, 'predefined')
    }
    static _AddPrivateCustomEase(q, t) {
      p._AddEase(q, t, 'private')
    }
    static AddCustomEase(q, t, x) {
      this._CreateEaseMap()
      p._AddEase(q, t, 'custom', x)
    }
    static RemoveCustomEase(q, t) {
      this.IsNamePredefined(q) || [...d.keys()].includes(q) || ((t = a.get(t)) && t.delete(q))
    }
    static _AddEase(q, t, x, v) {
      switch (x) {
        case 'predefined':
          e.set(q, t)
          b.set(q, t)
          break
        case 'custom':
          v ? (a.has(v) || a.set(v, new Map()), a.get(v).set(q, t)) : c.set(q, t)
          break
        case 'private':
          e.set(q, t)
          d.set(q, t)
          break
        default:
          throw Error('unexpected ease mode')
      }
    }
    static NoEase(q, t, x, v) {
      return (x * q) / v + t
    }
    static EaseInQuad(q, t, x, v) {
      return x * (q /= v) * q + t
    }
    static EaseOutQuad(q, t, x, v) {
      return -x * (q /= v) * (q - 2) + t
    }
    static EaseInOutQuad(q, t, x, v) {
      return 1 > (q /= v / 2) ? (x / 2) * q * q + t : (-x / 2) * (--q * (q - 2) - 1) + t
    }
    static EaseInCubic(q, t, x, v) {
      return x * (q /= v) * q * q + t
    }
    static EaseOutCubic(q, t, x, v) {
      return x * ((q = q / v - 1) * q * q + 1) + t
    }
    static EaseInOutCubic(q, t, x, v) {
      return 1 > (q /= v / 2) ? (x / 2) * q * q * q + t : (x / 2) * ((q -= 2) * q * q + 2) + t
    }
    static EaseInQuart(q, t, x, v) {
      return x * (q /= v) * q * q * q + t
    }
    static EaseOutQuart(q, t, x, v) {
      return -x * ((q = q / v - 1) * q * q * q - 1) + t
    }
    static EaseInOutQuart(q, t, x, v) {
      return 1 > (q /= v / 2) ? (x / 2) * q * q * q * q + t : (-x / 2) * ((q -= 2) * q * q * q - 2) + t
    }
    static EaseInQuint(q, t, x, v) {
      return x * (q /= v) * q * q * q * q + t
    }
    static EaseOutQuint(q, t, x, v) {
      return x * ((q = q / v - 1) * q * q * q * q + 1) + t
    }
    static EaseInOutQuint(q, t, x, v) {
      return 1 > (q /= v / 2) ? (x / 2) * q * q * q * q * q + t : (x / 2) * ((q -= 2) * q * q * q * q + 2) + t
    }
    static EaseInSine(q, t, x, v) {
      return -x * Math.cos((q / v) * (Math.PI / 2)) + x + t
    }
    static EaseOutSine(q, t, x, v) {
      return x * Math.sin((q / v) * (Math.PI / 2)) + t
    }
    static EaseInOutSine(q, t, x, v) {
      return (-x / 2) * (Math.cos((Math.PI * q) / v) - 1) + t
    }
    static EaseInExpo(q, t, x, v) {
      return 0 === q ? t : x * Math.pow(2, 10 * (q / v - 1)) + t
    }
    static EaseOutExpo(q, t, x, v) {
      return q === v ? t + x : x * (-Math.pow(2, (-10 * q) / v) + 1) + t
    }
    static EaseInOutExpo(q, t, x, v) {
      return 0 === q ? t : q === v ? t + x : 1 > (q /= v / 2) ? (x / 2) * Math.pow(2, 10 * (q - 1)) + t : (x / 2) * (-Math.pow(2, -10 * --q) + 2) + t
    }
    static EaseInCirc(q, t, x, v) {
      return -x * (Math.sqrt(1 - (q /= v) * q) - 1) + t
    }
    static EaseOutCirc(q, t, x, v) {
      return x * Math.sqrt(1 - (q = q / v - 1) * q) + t
    }
    static EaseInOutCirc(q, t, x, v) {
      return 1 > (q /= v / 2) ? (-x / 2) * (Math.sqrt(1 - q * q) - 1) + t : (x / 2) * (Math.sqrt(1 - (q -= 2) * q) + 1) + t
    }
    static EaseInElastic(q, t, x, v) {
      let u = 0,
        A = x
      if (0 === q) return t
      if (1 === (q /= v)) return t + x
      u || (u = 0.3 * v)
      A < Math.abs(x) ? ((A = x), (x = u / 4)) : (x = (u / (2 * Math.PI)) * Math.asin(x / A))
      return -(A * Math.pow(2, 10 * --q) * Math.sin((2 * (q * v - x) * Math.PI) / u)) + t
    }
    static EaseOutElastic(q, t, x, v) {
      let u,
        A = 0,
        z = x
      if (0 === q) return t
      if (1 === (q /= v)) return t + x
      A || (A = 0.3 * v)
      z < Math.abs(x) ? ((z = x), (u = A / 4)) : (u = (A / (2 * Math.PI)) * Math.asin(x / z))
      return z * Math.pow(2, -10 * q) * Math.sin((2 * (q * v - u) * Math.PI) / A) + x + t
    }
    static EaseInOutElastic(q, t, x, v) {
      let u,
        A = 0,
        z = x
      if (0 === q) return t
      if (2 === (q /= v / 2)) return t + x
      A || (A = 0.3 * v * 1.5)
      z < Math.abs(x) ? ((z = x), (u = A / 4)) : (u = (A / (2 * Math.PI)) * Math.asin(x / z))
      return 1 > q ? -0.5 * z * Math.pow(2, 10 * --q) * Math.sin((2 * (q * v - u) * Math.PI) / A) + t : z * Math.pow(2, -10 * --q) * Math.sin((2 * (q * v - u) * Math.PI) / A) * 0.5 + x + t
    }
    static EaseInBack(q, t, x, v, u) {
      void 0 === u && (u = 1.70158)
      return x * (q /= v) * q * ((u + 1) * q - u) + t
    }
    static EaseOutBack(q, t, x, v, u) {
      void 0 === u && (u = 1.70158)
      return x * ((q = q / v - 1) * q * ((u + 1) * q + u) + 1) + t
    }
    static EaseInOutBack(q, t, x, v, u) {
      void 0 === u && (u = 1.70158)
      return 1 > (q /= v / 2) ? (x / 2) * q * q * (((u *= 1.525) + 1) * q - u) + t : (x / 2) * ((q -= 2) * q * (((u *= 1.525) + 1) * q + u) + 2) + t
    }
    static EaseInBounce(q, t, x, v) {
      return x - p.EaseOutBounce(v - q, 0, x, v) + t
    }
    static EaseOutBounce(q, t, x, v) {
      return (q /= v) < 1 / 2.75 ? 7.5625 * x * q * q + t : q < 2 / 2.75 ? x * (7.5625 * (q -= 1.5 / 2.75) * q + 0.75) + t : q < 2.5 / 2.75 ? x * (7.5625 * (q -= 2.25 / 2.75) * q + 0.9375) + t : x * (7.5625 * (q -= 2.625 / 2.75) * q + 0.984375) + t
    }
    static EaseInOutBounce(q, t, x, v) {
      return q < v / 2 ? 0.5 * p.EaseInBounce(2 * q, 0, x, v) + t : 0.5 * p.EaseOutBounce(2 * q - v, 0, x, v) + 0.5 * x + t
    }
    static EaseCubicBezier(q, t, x, v, u) {
      return t + 3 * q * (x - t) + 3 * q ** 2 * (t + v - 2 * x) + q ** 3 * (u - t + 3 * x - 3 * v)
    }
    static EaseSpline(q, t, x, v, u, A, z, C, E, J) {
      if (v === u && A === z) return q
      q = w(q, t, v, A, C, J)
      t = g(x, u, z, E)
      v = h(x, u, z, E)
      x = k(x, u, z, E)
      return m(q, t, v, x)
    }
    static GetBezierSamples(q, t, x, v) {
      const u = [],
        A = g(q, t, x, v),
        z = h(q, t, x, v)
      q = k(q, t, x, v)
      for (t = 0; 11 > t; ++t) (x = m(0.1 * t, A, z, q)), u.push(x)
      return u
    }
  }
  const g = (p, q, t, x) => x - 3 * t + 3 * q - p,
    h = (p, q, t, x) => 3 * t - 6 * q + 3 * p,
    k = (p, q, t, x) => 3 * (q - p),
    m = (p, q, t, x) => ((q * p + t) * p + x) * p,
    r = (p, q, t, x) => 3 * q * p * p + 2 * t * p + x,
    w = (p, q, t, x, v, u) => {
      if (1 == p) return 1
      for (var A = 0, z = 1, C = u[z]; 10 != z && C <= p; ) z++, (C = u[z]), (A += 0.1)
      z--
      C = u[z]
      u = A + ((p - C) / (u[z + 1] - C)) * 0.1
      z = g(q, t, x, v)
      C = h(q, t, x, v)
      q = k(q, t, x, v)
      t = r(u, z, C, q)
      if (0 !== t)
        if (0.02 <= t) for (A = 0; 4 > A; ++A) (t = m(u, z, C, q) - p), (x = r(u, z, C, q)), (u -= t / x)
        else {
          t = A
          A += 0.1
          x = 0
          let E
          do (u = t + (A - t) / 2), (v = m(u, z, C, q) - p), 0 < v ? (A = u) : (t = u), (v = 1e-7 < Math.abs(v)), (E = 10 > ++x)
          while (v && E)
        }
      return u
    }
}
{
  ;('use strict')
  const e = self.C3

  function b(a) {
    e.IsString(a)
  }
  e.ProbabilityTable = class {
    constructor() {
      this._items = []
      this._totalWeight = 0
    }
    Release() {
      this.Clear()
      this._items = null
    }
    Clear() {
      e.clear2DArray(this._items)
      this._totalWeight = 0
    }
    GetTotalWeight() {
      return this._totalWeight
    }
    Sample(a = Math.random() * this.GetTotalWeight()) {
      let c = 0
      for (const [d, f] of this._items) if (((c += d), a < c)) return f
      return 0
    }
    AddItem(a, c) {
      b(c)
      this._totalWeight += a
      this._items.push([a, c])
    }
    RemoveItem(a, c) {
      b(c)
      const d = 0 === a
      for (let f = 0; f < this._items.length; f++) {
        const g = this._items[f],
          h = g[1] === c
        if ((d || g[0] === a) && h) {
          this._items.splice(f, 1)
          this._totalWeight -= g[0]
          break
        }
      }
    }
    asJSON() {
      return JSON.stringify(this._items)
    }
    static fromJSON(a) {
      const c = new e.ProbabilityTable()
      a = JSON.parse(a)
      for (const d of a) c.AddItem(d[0], d[1])
      return c
    }
  }
}
;('use strict')
self.C3.Event = class {
  constructor(e, b) {
    this.type = e
    this.cancelable = !!b
    this.isAsync = this.propagationStopped = this.defaultPrevented = !1
  }
  preventDefault() {
    if (!this.cancelable) throw Error(`event '${this.type}' is not cancelable`)
    this.defaultPrevented = !0
  }
  stopPropagation() {
    if (!this.cancelable) throw Error(`event '${this.type}' cannot be stopped`)
    if (this.isAsync) throw Error(`cannot stop async event '${this.type}' propagation`)
    this.propagationStopped = !0
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Event.Handler = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._type = b
      this._captureListeners = []
      this._captureListenersSet = new Set()
      this._listeners = []
      this._listenersSet = new Set()
      this._fireDepth = 0
      this._queueAddListeners = []
      this._queueRemoveCaptureListeners = []
      this._queueRemoveListeners = []
    }
    Release() {
      0 < this._fireDepth ||
        (e.clearArray(this._captureListeners), this._captureListenersSet.clear(), e.clearArray(this._listeners), this._listenersSet.clear(), e.clearArray(this._queueAddListeners), e.clearArray(this._queueRemoveCaptureListeners), e.clearArray(this._queueRemoveListeners), e.Release(this))
    }
    _AddListener(b, a) {
      this._IsFiring() ? this._queueAddListeners.push([b, a]) : a ? this._captureListenersSet.has(b) || (this._captureListeners.push(b), this._captureListenersSet.add(b)) : this._listenersSet.has(b) || (this._listeners.push(b), this._listenersSet.add(b))
    }
    _RemoveListener(b, a) {
      this._IsFiring()
        ? a
          ? this._queueRemoveCaptureListeners.push(b)
          : this._queueRemoveListeners.push(b)
        : a
        ? this._captureListenersSet.has(b) && (this._captureListenersSet.delete(b), e.arrayFindRemove(this._captureListeners, b))
        : this._listenersSet.has(b) && (this._listenersSet.delete(b), e.arrayFindRemove(this._listeners, b))
    }
    _IsEmpty() {
      return !this._captureListeners.length && !this._listeners.length
    }
    _IsFiring() {
      return 0 < this._fireDepth
    }
    _ProcessQueuedListeners() {
      for (var b of this._queueAddListeners) this._AddListener(...b)
      e.clearArray(this._queueAddListeners)
      for (var a of this._queueRemoveListeners) this._listenersSet.delete(a)
      for (const c of this._queueRemoveCaptureListeners) this._captureListenersSet.delete(c)
      b = new Set(this._queueRemoveListeners)
      a = new Set(this._queueRemoveCaptureListeners)
      e.arrayRemoveAllInSet(this._listeners, b)
      e.arrayRemoveAllInSet(this._captureListeners, a)
      e.clearArray(this._queueRemoveCaptureListeners)
      e.clearArray(this._queueRemoveListeners)
    }
    _FireCancellable(b) {
      this._IncreaseFireDepth()
      let a = !1
      for (let c = 0, d = this._captureListeners.length; c < d; ++c)
        if ((this._captureListeners[c](b), b.propagationStopped)) {
          a = !0
          break
        }
      if (!a) for (let c = 0, d = this._listeners.length; c < d && (this._listeners[c](b), !b.propagationStopped); ++c);
      this._DecreaseFireDepth()
      return !b.defaultPrevented
    }
    _FireNonCancellable(b) {
      this._IncreaseFireDepth()
      for (let a = 0, c = this._captureListeners.length; a < c; ++a) this._captureListeners[a](b)
      for (let a = 0, c = this._listeners.length; a < c; ++a) this._listeners[a](b)
      this._DecreaseFireDepth()
      return !0
    }
    _IncreaseFireDepth() {
      this._fireDepth++
    }
    _DecreaseFireDepth() {
      this._fireDepth--
      0 === this._fireDepth && (this._queueAddListeners.length || this._queueRemoveCaptureListeners.length || this._queueRemoveListeners.length) && this._ProcessQueuedListeners()
    }
    SetDelayRemoveEventsEnabled(b) {
      b ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
    }
    _FireAsync(b) {
      let a = []
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        let f = this._captureListeners[c]
        a.push(e.Asyncify(() => f(b)))
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c) {
        let f = this._listeners[c]
        a.push(e.Asyncify(() => f(b)))
      }
      return Promise.all(a).then(() => !b.defaultPrevented)
    }
    _FireAndWait_AsyncOptional(b) {
      const a = []
      this._IncreaseFireDepth()
      for (let d = 0, f = this._captureListeners.length; d < f; ++d) {
        var c = this._captureListeners[d](b)
        c instanceof Promise && a.push(c)
      }
      for (let d = 0, f = this._listeners.length; d < f; ++d) (c = this._listeners[d](b)), c instanceof Promise && a.push(c)
      this._DecreaseFireDepth()
      return a.length ? Promise.all(a).then(() => !b.defaultPrevented) : !b.defaultPrevented
    }
    async _FireAndWaitAsync(b) {
      return await this._FireAndWait_AsyncOptional(b)
    }
    async _FireAndWaitAsyncSequential(b) {
      this._IncreaseFireDepth()
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        var a = this._captureListeners[c](b)
        a instanceof Promise && (await a)
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c) (a = this._listeners[c](b)), a instanceof Promise && (await a)
      this._DecreaseFireDepth()
      return !b.defaultPrevented
    }
    *_FireAsGenerator(b) {
      this._IncreaseFireDepth()
      for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
        var a = this._captureListeners[c](b)
        e.IsIterator(a) && (yield* a)
      }
      for (let c = 0, d = this._listeners.length; c < d; ++c) (a = this._listeners[c](b)), e.IsIterator(a) && (yield* a)
      this._DecreaseFireDepth()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Event.Dispatcher = class extends e.DefendedBase {
    constructor() {
      super()
      this._eventHandlers = new Map()
      this._dispatcherWasReleased = !1
    }
    Release() {
      if (this._dispatcherWasReleased) throw Error('already released')
      this.ClearEvents()
      this._dispatcherWasReleased = !0
      e.Release(this)
    }
    WasReleased() {
      return this._dispatcherWasReleased
    }
    ClearEvents() {
      for (let b of this._eventHandlers.values()) b.Release()
      this._eventHandlers.clear()
    }
    _GetHandlerByType(b, a) {
      let c = this._eventHandlers.get(b)
      return c ? c : a ? ((c = e.New(e.Event.Handler, b)), this._eventHandlers.set(b, c), c) : null
    }
    HasAnyHandlerFor(b) {
      return this._eventHandlers.has(b)
    }
    addEventListener(b, a, c) {
      this._GetHandlerByType(b, !0)._AddListener(a, !!c)
    }
    removeEventListener(b, a, c) {
      let d = this._GetHandlerByType(b, !1)
      d && (d._RemoveListener(a, !!c), d._IsEmpty() && this._eventHandlers.delete(b))
    }
    dispatchEvent(b) {
      const a = this._GetHandlerByType(b.type, !1)
      return a ? (b.cancelable ? a._FireCancellable(b) : a._FireNonCancellable(b)) : !0
    }
    dispatchEventAsync(b) {
      const a = this._GetHandlerByType(b.type, !1)
      if (!a) return Promise.resolve(!0)
      b.isAsync = !0
      return a._FireAsync(b)
    }
    async dispatchEventAndClearAsync(b) {
      const a = this._GetHandlerByType(b.type, !1)
      if (!a) return !0
      this._eventHandlers.delete(b.type)
      b.isAsync = !0
      b = await a._FireAsync(b)
      a.Release()
      return b
    }
    async dispatchEventAndWaitAsync(b) {
      const a = this._GetHandlerByType(b.type, !1)
      return a ? await a._FireAndWaitAsync(b) : !0
    }
    dispatchEventAndWait_AsyncOptional(b) {
      const a = this._GetHandlerByType(b.type, !1)
      return a ? a._FireAndWait_AsyncOptional(b) : !0
    }
    async dispatchEventAndWaitAsyncSequential(b) {
      const a = this._GetHandlerByType(b.type, !1)
      return a ? await a._FireAndWaitAsyncSequential(b) : !0
    }
    dispatchGeneratorEvent(b) {
      const a = this._GetHandlerByType(b.type, !1)
      if (!a) return null
      if (b.cancelable) throw Error('not supported')
      return a._FireAsGenerator(b)
    }
    SetDelayRemoveEventsEnabled(b) {
      for (const a of this._eventHandlers.values()) a.SetDelayRemoveEventsEnabled(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = 'undefined' !== typeof requestIdleCallback
  let a = [],
    c = -1,
    d = 0

  function f(m) {
    c =
      b && 0 === d
        ? requestIdleCallback(g, {
            timeout: 35
          })
        : setTimeout(g, 0 < d ? 1 : m)
  }

  function g(m) {
    c = -1
    if (a.length) {
      var r = performance.now(),
        w = 0
      do {
        h(a.shift())
        var p = performance.now()
        ++w
        var q = ((p - r) / w) * 1.1
      } while (a.length && (b && 0 === d && 'undefined' !== typeof m ? q < m.timeRemaining() : 12 > p - r + q))
      ;-1 === c && a.length && f(Math.max(16 - (p - r), 4))
    }
  }

  function h(m) {
    let r
    try {
      r = m.func()
    } catch (w) {
      m.reject(w)
      return
    }
    m.resolve(r)
  }
  let k = e.QueryString.Has('disable-asyncify')
  k && console.warn('[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.')
  e.Asyncify = function (m) {
    let r = null
    e.isDebug && (r = e.GetCallStack())
    return new Promise((w, p) => {
      a.push({
        func: m,
        resolve: w,
        reject: p,
        stack: r
      })
      k ? h(a.pop()) : -1 === c && f(16)
    })
  }
  e.Asyncify.SetHighThroughputMode = function (m) {
    if (m) ++d
    else if ((--d, 0 > d)) throw Error('already turned off high throughput mode')
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = -1

  function a() {
    b = -1
  }
  e.FastGetDateNow = function () {
    ;-1 === b && ((b = Date.now()), self.setTimeout(a, 16))
    return b
  }
  let c = -1,
    d = -1,
    f = new Set()

  function g() {
    d = c = -1
    let h = Date.now()
    for (let k of f)
      if (k._CheckTimeout(h)) {
        let m = k._GetDeadline()
        if (-1 === d || m < d) d = m
      } else f.delete(k)
    ;-1 !== d && (c = self.setTimeout(g, Math.max(d - h + 100, 1e3)))
  }
  e.IdleTimeout = class {
    constructor(h, k) {
      this._callback = h
      this._timeout = 1e3 * k
      this._deadline = 0
      this._isActive = !1
    }
    Reset() {
      let h = e.FastGetDateNow()
      this._deadline = h + this._timeout
      this._isActive || (f.add(this), (this._isActive = !0))
      ;-1 === c ? ((d = this._deadline), (c = self.setTimeout(g, this._timeout + 100))) : this._deadline < d && d > h + 1e3 && (self.clearTimeout(c), (d = this._deadline), (c = self.setTimeout(g, this._timeout + 100)))
    }
    _CheckTimeout(h) {
      return h >= this._deadline ? (this._callback() ? ((this._deadline = h + this._timeout), !0) : (this._isActive = !1)) : !0
    }
    _GetDeadline() {
      return this._deadline
    }
    Cancel() {
      this._isActive && (f.delete(this), (this._isActive = !1), 0 === f.size && -1 !== c && (self.clearTimeout(c), (d = c = -1)))
    }
    Release() {
      this.Cancel()
      this._callback = null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Disposable = class b {
    constructor(a) {
      this._disposed = !1
      this._disposeAction = a
    }
    Dispose() {
      this._disposed || ((this._disposed = !0), this._disposeAction && (this._disposeAction(), (this._disposeAction = null)))
    }
    IsDisposed() {
      return this._disposed
    }
    Release() {
      this.Dispose()
    }
    static Release(a) {
      return new b(() => a.Release())
    }
    static From(a, c, d, f, g) {
      if ('undefined' === typeof f || null === f) f = !1
      else if ('boolean' !== typeof f && 'object' !== typeof f) throw new TypeError('invalid event listener options')
      g && (d = d.bind(g))
      if (c.includes(' ')) {
        c = c.split(' ')
        g = new e.CompositeDisposable()
        for (let h of c) a.addEventListener(h, d, f), g.Add(e.New(e.Disposable, () => a.removeEventListener(h, d, f)))
        return g
      }
      a.addEventListener(c, d, f)
      return e.New(e.Disposable, () => a.removeEventListener(c, d, f))
    }
  }
  e.StubDisposable = class extends e.Disposable {
    SetAction(b) {
      this._disposeAction = b
    }
  }
  e.CompositeDisposable = class extends e.Disposable {
    constructor(...b) {
      super()
      this._disposables = new Set()
      for (let a of b) this.Add(a)
    }
    Add(...b) {
      if (this._disposed) throw Error('already disposed')
      for (let a of b) this._disposables.add(a)
    }
    Remove(b) {
      if (this._disposed) throw Error('already disposed')
      this._disposables.delete(b)
    }
    RemoveAll() {
      if (this._disposed) throw Error('already disposed')
      if (this._disposables) {
        for (let b of this._disposables) b.Dispose()
        this._disposables.clear()
      }
    }
    IsDisposed() {
      return this._disposed
    }
    Dispose() {
      if (this._disposed) throw Error('already disposed')
      this._disposed = !0
      for (let b of this._disposables) b.Dispose()
      this._disposables.clear()
      this._disposables = null
    }
    Release() {
      this.Dispose()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.KahanSum = class extends e.DefendedBase {
    constructor() {
      super()
      this._sum = this._t = this._y = this._c = 0
    }
    Add(b) {
      this._y = +b - this._c
      this._t = this._sum + this._y
      this._c = this._t - this._sum - this._y
      this._sum = this._t
    }
    Subtract(b) {
      this._sum -= +b
    }
    Get() {
      return this._sum
    }
    Reset() {
      this._sum = this._t = this._y = this._c = 0
    }
    Set(b) {
      this._t = this._y = this._c = 0
      this._sum = +b
    }
    Release() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = {
      RBnode: function (a) {
        this.tree = a
        this.left = this.right = this.tree.sentinel
        this.parent = null
        this.color = !1
        this.key = null
      },
      RedBlackSet: function (a) {
        this.size = 0
        this.sentinel = new b.RBnode(this)
        this.sentinel.color = !1
        this.root = this.sentinel
        this.root.parent = this.sentinel
        this.compare = a || this.default_compare
      }
    }
  b.RedBlackSet.prototype.default_compare = function (a, c) {
    return a < c ? -1 : c < a ? 1 : 0
  }
  b.RedBlackSet.prototype.clone = function () {
    var a = new b.RedBlackSet(this.compare)
    a.insertAll(this)
    return a
  }
  b.RedBlackSet.prototype.clear = function () {
    this.size = 0
    this.sentinel = new b.RBnode(this)
    this.sentinel.color = !1
    this.root = this.sentinel
    this.root.parent = this.sentinel
  }
  b.RedBlackSet.prototype.leftRotate = function (a) {
    var c = a.right
    a.right = c.left
    c.left != this.sentinel && (c.left.parent = a)
    c.parent = a.parent
    a.parent == this.sentinel ? (this.root = c) : a == a.parent.left ? (a.parent.left = c) : (a.parent.right = c)
    c.left = a
    a.parent = c
  }
  b.RedBlackSet.prototype.rightRotate = function (a) {
    var c = a.left
    a.left = c.right
    c.right != this.sentinel && (c.right.parent = a)
    c.parent = a.parent
    a.parent == this.sentinel ? (this.root = c) : a == a.parent.right ? (a.parent.right = c) : (a.parent.left = c)
    c.right = a
    a.parent = c
  }
  b.RedBlackSet.prototype.insert = function (a) {
    if (this.contains(a)) this.get_(a).key = a
    else {
      var c = new b.RBnode(this)
      c.key = a
      a = this.sentinel
      for (var d = this.root; d != this.sentinel; ) (a = d), (d = 0 > this.compare(c.key, d.key) ? d.left : d.right)
      c.parent = a
      a == this.sentinel ? (this.root = c) : 0 > this.compare(c.key, a.key) ? (a.left = c) : (a.right = c)
      c.left = this.sentinel
      c.right = this.sentinel
      c.color = !0
      this.insertFixup(c)
      this.size++
    }
  }
  b.RedBlackSet.prototype.insertFixup = function (a) {
    for (; a != this.sentinel && a != this.root && 1 == a.parent.color; )
      if (a.parent == a.parent.parent.left) {
        var c = a.parent.parent.right
        1 == c.color
          ? ((a.parent.color = !1), (c.color = !1), (a.parent.parent.color = !0), (a = a.parent.parent))
          : (a == a.parent.right && ((a = a.parent), this.leftRotate(a)), (a.parent.color = !1), (a.parent.parent.color = !0), a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
      } else
        (c = a.parent.parent.left),
          1 == c.color
            ? ((a.parent.color = !1), (c.color = !1), (a.parent.parent.color = !0), (a = a.parent.parent))
            : (a == a.parent.left && ((a = a.parent), this.rightRotate(a)), (a.parent.color = !1), (a.parent.parent.color = !0), a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent))
    this.root.color = !1
  }
  b.RedBlackSet.prototype.delete_ = function (a) {
    var c = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a)
    var d = c.left != this.sentinel ? c.left : c.right
    d.parent = c.parent
    c.parent == this.sentinel ? (this.root = d) : c == c.parent.left ? (c.parent.left = d) : (c.parent.right = d)
    c != a && (a.key = c.key)
    0 == c.color && this.deleteFixup(d)
    this.size--
  }
  b.RedBlackSet.prototype.deleteFixup = function (a) {
    for (; a != this.root && 0 == a.color; )
      if (a == a.parent.left) {
        var c = a.parent.right
        1 == c.color && ((c.color = !1), (a.parent.color = !0), this.leftRotate(a.parent), (c = a.parent.right))
        0 == c.left.color && 0 == c.right.color
          ? ((c.color = !0), (a = a.parent))
          : (0 == c.right.color && ((c.left.color = !1), (c.color = !0), this.rightRotate(c), (c = a.parent.right)), (c.color = a.parent.color), (a.parent.color = !1), (c.right.color = !1), this.leftRotate(a.parent), (a = this.root))
      } else
        (c = a.parent.left),
          1 == c.color && ((c.color = !1), (a.parent.color = !0), this.rightRotate(a.parent), (c = a.parent.left)),
          0 == c.right.color && 0 == c.left.color
            ? ((c.color = !0), (a = a.parent))
            : (0 == c.left.color && ((c.right.color = !1), (c.color = !0), this.leftRotate(c), (c = a.parent.left)), (c.color = a.parent.color), (a.parent.color = !1), (c.left.color = !1), this.rightRotate(a.parent), (a = this.root))
    a.color = !1
  }
  b.RedBlackSet.prototype.remove = function (a) {
    a = this.get_(a)
    if (a != this.sentinel) {
      var c = a.key
      this.delete_(a)
      return c
    }
    return null
  }
  b.RedBlackSet.prototype.removeSwapped = function (a, c) {
    this.remove(c)
  }
  b.RedBlackSet.prototype.min = function (a) {
    for (; a.left != this.sentinel; ) a = a.left
    return a
  }
  b.RedBlackSet.prototype.max = function (a) {
    for (; a.right != this.sentinel; ) a = a.right
    return a
  }
  b.RedBlackSet.prototype.successor_ = function (a) {
    if (a.right != this.sentinel) return this.min(a.right)
    for (var c = a.parent; c != this.sentinel && a == c.right; ) (a = c), (c = c.parent)
    return c
  }
  b.RedBlackSet.prototype.predeccessor_ = function (a) {
    if (a.left != this.sentinel) return this.max(a.left)
    for (var c = a.parent; c != this.sentinel && a == c.left; ) (a = c), (c = c.parent)
    return c
  }
  b.RedBlackSet.prototype.successor = function (a) {
    if (0 < this.size) {
      a = this.get_(a)
      if (a == this.sentinel) return null
      if (a.right != this.sentinel) return this.min(a.right).key
      for (var c = a.parent; c != this.sentinel && a == c.right; ) (a = c), (c = c.parent)
      return c != this.sentinel ? c.key : null
    }
    return null
  }
  b.RedBlackSet.prototype.predecessor = function (a) {
    if (0 < this.size) {
      a = this.get_(a)
      if (a == this.sentinel) return null
      if (a.left != this.sentinel) return this.max(a.left).key
      for (var c = a.parent; c != this.sentinel && a == c.left; ) (a = c), (c = c.parent)
      return c != this.sentinel ? c.key : null
    }
    return null
  }
  b.RedBlackSet.prototype.getMin = function () {
    return this.min(this.root).key
  }
  b.RedBlackSet.prototype.getMax = function () {
    return this.max(this.root).key
  }
  b.RedBlackSet.prototype.get_ = function (a) {
    for (var c = this.root; c != this.sentinel && 0 != this.compare(c.key, a); ) c = 0 > this.compare(a, c.key) ? c.left : c.right
    return c
  }
  b.RedBlackSet.prototype.contains = function (a) {
    return null != this.get_(a).key
  }
  b.RedBlackSet.prototype.getValues = function () {
    var a = []
    this.forEach(function (c) {
      a.push(c)
    })
    return a
  }
  b.RedBlackSet.prototype.insertAll = function (a) {
    if ('array' == b.typeOf(a)) for (var c = 0; c < a.length; c++) this.insert(a[c])
    else if ('function' == b.typeOf(a.forEach)) a.forEach(this.insert, this)
    else if ('function' == b.typeOf(a.getValues)) for (a = a.getValues(), c = 0; c < a.length; c++) this.insert(a[c])
    else if ('object' == b.typeOf(a)) for (c in a) this.insert(a[c])
  }
  b.RedBlackSet.prototype.removeAll = function (a) {
    if ('array' == b.typeOf(a)) for (var c = 0; c < a.length; c++) this.remove(a[c])
    else if ('function' == b.typeOf(a.forEach)) a.forEach(this.removeSwapped, this)
    else if ('function' == b.typeOf(a.getValues)) for (a = a.getValues(), c = 0; c < a.length; c++) this.remove(a[c])
    else if ('object' == b.typeOf(a)) for (c in a) this.remove(a[c])
  }
  b.RedBlackSet.prototype.containsAll = function (a) {
    if ('array' == b.typeOf(a)) {
      for (var c = 0; c < a.length; c++) if (!this.contains(a[c])) return !1
      return !0
    }
    if ('function' == b.typeOf(a.forEach)) return a.every(this.contains, this)
    if ('function' == b.typeOf(a.getValues)) {
      a = a.getValues()
      for (c = 0; c < a.length; c++) if (!this.contains(a[c])) return !1
      return !0
    }
    if ('object' == b.typeOf(a)) {
      for (c in a) if (!this.contains(a[c])) return !1
      return !0
    }
  }
  b.RedBlackSet.prototype.range = function (a, c) {
    var d = []
    this.traverseFromTo(
      function (f) {
        d.push(f)
      },
      a,
      c
    )
    return d
  }
  b.RedBlackSet.prototype.traverse = function (a, c) {
    if (!this.isEmpty()) for (var d = this.min(this.root); d != this.sentinel && !a.call(c, d.key, this); ) d = this.successor_(d)
  }
  b.RedBlackSet.prototype.traverseFrom = function (a, c, d) {
    if (!this.isEmpty()) for (c = this.get_(c); c != this.sentinel && !a.call(d, c.key, this); ) c = this.successor_(c)
  }
  b.RedBlackSet.prototype.traverseTo = function (a, c, d) {
    if (!this.isEmpty()) {
      var f = this.min(this.root)
      for (c = this.get_(c); f != c && !a.call(d, f.key, this); ) f = this.successor_(f)
    }
  }
  b.RedBlackSet.prototype.traverseFromTo = function (a, c, d, f) {
    if (!this.isEmpty()) for (c = this.get_(c), d = this.get_(d); c != d && !a.call(f, c.key, this); ) c = this.successor_(c)
  }
  b.RedBlackSet.prototype.traverseBackwards = function (a, c) {
    if (!this.isEmpty()) for (var d = this.max(this.root); d != this.sentinel && !a.call(c, d.key, this); ) d = this.predeccessor_(d)
  }
  b.RedBlackSet.prototype.forEach = function (a, c) {
    if (!this.isEmpty()) for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d)) a.call(c, d.key, d.key, this)
  }
  b.RedBlackSet.prototype.some = function (a, c) {
    if (this.isEmpty()) return !1
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d)) if (a.call(c, d.key, d.key, this)) return !0
    return !1
  }
  b.RedBlackSet.prototype.every = function (a, c) {
    if (this.isEmpty()) return !1
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d)) if (!a.call(c, d.key, d.key, this)) return !1
    return !0
  }
  b.RedBlackSet.prototype.map = function (a, c) {
    var d = []
    if (this.isEmpty()) return d
    for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) d.push(a.call(c, f.key, f.key, this))
    return d
  }
  b.RedBlackSet.prototype.filter = function (a, c) {
    var d = []
    if (this.isEmpty()) return d
    for (var f = this.min(this.root); f != this.sentinel; f = this.successor_(f)) a.call(c, f.key, f.key, this) && d.push(f.key)
    return d
  }
  b.RedBlackSet.prototype.getCount = function () {
    return this.size
  }
  b.RedBlackSet.prototype.isEmpty = function () {
    return 0 == this.size
  }
  b.RedBlackSet.prototype.isSubsetOf = function (a) {
    var c = b.getCount(a)
    if (this.getCount() > c) return !1
    c = 0
    if (this.isEmpty()) return !0
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d)) b.contains.call(a, a, d.key) && c++
    return c == this.getCount()
  }
  b.RedBlackSet.prototype.intersection = function (a) {
    var c = new b.RedBlackSet(this.compare)
    if (this.isEmpty()) return c
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d)) a.contains.call(a, d.key, d.key, this) && c.insert(d.key)
    return c
  }
  e.RedBlackSet = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._rbSet = new b.RedBlackSet(a)
      this._enableQueue = !1
      this._queueInsert = new Set()
      this._queueRemove = new Set()
    }
    Add(a) {
      this._enableQueue ? (this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a)) : this._rbSet.insert(a)
    }
    Remove(a) {
      this._enableQueue ? (this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a)) : this._rbSet.remove(a)
    }
    Has(a) {
      return this._enableQueue ? (this._queueInsert.has(a) ? !0 : !this._queueRemove.has(a) && this._rbSet.contains(a)) : this._rbSet.contains(a)
    }
    Clear() {
      this._rbSet.clear()
      this._queueInsert.clear()
      this._queueRemove.clear()
    }
    toArray() {
      if (this._enableQueue) throw Error('cannot be used in queueing mode')
      return this._rbSet.getValues()
    }
    GetSize() {
      return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
    }
    IsEmpty() {
      return 0 === this.GetSize()
    }
    Front() {
      if (this.IsEmpty()) throw Error('empty set')
      if (this._enableQueue) throw Error('cannot be used in queueing mode')
      const a = this._rbSet
      return a.min(a.root).key
    }
    Shift() {
      if (this.IsEmpty()) throw Error('empty set')
      if (this._enableQueue) throw Error('cannot be used in queueing mode')
      const a = this.Front()
      this.Remove(a)
      return a
    }
    SetQueueingEnabled(a) {
      a = !!a
      if (this._enableQueue !== a && ((this._enableQueue = a), !a)) {
        for (const c of this._queueRemove) this._rbSet.remove(c)
        this._queueRemove.clear()
        for (const c of this._queueInsert) this._rbSet.insert(c)
        this._queueInsert.clear()
      }
    }
    ForEach(a) {
      this._rbSet.forEach(a)
    }
    *values() {
      if (!this.IsEmpty()) {
        var a = this._rbSet
        for (let c = a.min(a.root); c != a.sentinel; c = a.successor_(c)) yield c.key
      }
    }
    [Symbol.iterator]() {
      return this.values()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.PromiseThrottle = class {
    constructor(b = e.hardwareConcurrency) {
      this._maxParallel = b
      this._queue = []
      this._activeCount = 0
    }
    Add(b) {
      return new Promise((a, c) => {
        this._queue.push({
          func: b,
          resolve: a,
          reject: c
        })
        this._MaybeStartNext()
      })
    }
    _FindInQueue(b) {
      for (let a = 0, c = this._queue.length; a < c; ++a) if (this._queue[a].func === b) return a
      return -1
    }
    RemoveAndResolve(b, a) {
      b = this._FindInQueue(b)
      if (-1 === b) throw Error('cannot find promise to resolve')
      this._queue[b].resolve(a)
      this._queue.splice(b, 1)
    }
    RemoveAndReject(b, a) {
      b = this._FindInQueue(b)
      if (-1 === b) throw Error('cannot find promise to reject')
      this._queue[b].reject(a)
      this._queue.splice(b, 1)
    }
    async _MaybeStartNext() {
      if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
        this._activeCount++
        var b = this._queue.shift()
        try {
          const a = await b.func()
          b.resolve(a)
        } catch (a) {
          b.reject(a)
        }
        this._activeCount--
        this._MaybeStartNext()
      }
    }
    static async Batch(b, a) {
      const c = []
      let d = !1
      const f = async h => {
          for (; (h = a.pop()) && !d; )
            try {
              c.push(await h())
            } catch (k) {
              throw ((d = !0), k)
            }
        },
        g = []
      for (; b--; ) g.push(f())
      await Promise.all(g)
      return c
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.RateLimiter = class {
    constructor(b, a, c) {
      this._callback = b
      this._interval = a
      this._intervalOnBattery = c || 2 * a
      this._timerId = -1
      this._lastCallTime = -Infinity
      this._timerCallFunc = () => this._OnTimer()
      this._canRunImmediate = this._ignoreReset = !1
      this._callbackArguments = null
    }
    SetCanRunImmediate(b) {
      this._canRunImmediate = !!b
    }
    _GetInterval() {
      return 'undefined' !== typeof e.Battery && e.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
    }
    Call(...b) {
      if (-1 === this._timerId) {
        this._callbackArguments = b
        b = e.FastGetDateNow()
        var a = b - this._lastCallTime,
          c = this._GetInterval()
        a >= c && this._canRunImmediate ? ((this._lastCallTime = b), this._RunCallback()) : (this._timerId = self.setTimeout(this._timerCallFunc, Math.max(c - a, 4)))
      }
    }
    _RunCallback() {
      this._ignoreReset = !0
      const b = this._callbackArguments
      this._callbackArguments = null
      b ? this._callback(...b) : this._callback()
      this._ignoreReset = !1
    }
    Reset() {
      this._ignoreReset || (this._CancelTimer(), (this._callbackArguments = null), (this._lastCallTime = e.FastGetDateNow()))
    }
    _OnTimer() {
      this._timerId = -1
      this._lastCallTime = e.FastGetDateNow()
      this._RunCallback()
    }
    _CancelTimer() {
      ;-1 !== this._timerId && (self.clearTimeout(this._timerId), (this._timerId = -1))
    }
    Release() {
      this._CancelTimer()
      this._timerCallFunc = this._callbackArguments = this._callback = null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SVGRasterManager = class {
    constructor() {
      this._images = new Map()
      this._allowNpotSurfaces = !1
      this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
    }
    SetNpotSurfaceAllowed(b) {
      this._allowNpotSurfaces = !!b
    }
    IsNpotSurfaceAllowed() {
      return this._allowNpotSurfaces
    }
    SetGetBaseSizeCallback(b) {
      this._getBaseSizeCallback = b
    }
    GetBaseSize(b) {
      if (!this._getBaseSizeCallback) throw Error('no get base size callback set')
      return this._getBaseSizeCallback(b)
    }
    SetRasterAtSizeCallback(b) {
      this._rasterAtSizeCallback = b
    }
    RasterAtSize(b, a, c, d, f, g) {
      if (!this._rasterAtSizeCallback) throw Error('no raster at size callback set')
      return this._rasterAtSizeCallback(b, a, c, d, f, g)
    }
    SetReleaseResultCallback(b) {
      this._releaseResultCallback = b
    }
    ReleaseResult(b) {
      if (!this._releaseResultCallback) throw Error('no release result callback set')
      this._releaseResultCallback(b)
    }
    SetRedrawCallback(b) {
      this._redrawCallback = b
    }
    Redraw() {
      if (!this._redrawCallback) throw Error('no redraw callback set')
      this._redrawCallback()
    }
    AddImage(b) {
      let a = this._images.get(b)
      a || ((a = e.New(e.SVGRasterImage, this, b)), this._images.set(b, a))
      a.IncReference()
      return a
    }
    _RemoveImage(b) {
      this._images.delete(b.GetDataSource())
    }
    OnTexturesChanged() {
      for (const b of this._images.values()) b.ReleaseRasterizedResult(), b.ForceRasterAgain()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SVGRasterImage = class {
    constructor(b, a) {
      this._manager = b
      this._dataSource = a
      this._baseHeight = this._baseWidth = this._refCount = 0
      this._getBaseSizePromise = this._manager
        .GetBaseSize(a)
        .then(c => {
          this._baseWidth = c[0]
          this._baseHeight = c[1]
          this._manager.Redraw()
        })
        .catch(c => {
          console.error('[SVG] Error loading SVG: ', c)
          this._hadError = !0
          this._manager.Redraw()
        })
      this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0
      this._isRasterizing = !1
      this._rasterizedResult = null
      this._hadError = this._forceRaster = !1
    }
    Release() {
      if (0 >= this._refCount) throw Error('already released')
      this._refCount--
      0 === this._refCount && this._Release()
    }
    ReleaseRasterizedResult() {
      this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), (this._rasterizedResult = null))
    }
    _Release() {
      this.ReleaseRasterizedResult()
      this._manager._RemoveImage(this)
      this._manager = null
    }
    GetDataSource() {
      return this._dataSource
    }
    IncReference() {
      this._refCount++
    }
    HasReferences() {
      return 0 < this._refCount
    }
    GetRasterizedResult() {
      return this._rasterizedResult
    }
    ForceRasterAgain() {
      this._forceRaster = !0
    }
    async StartRasterForSize(b, a, c) {
      if (0 !== a && 0 !== c && !this._hadError && !this._isRasterizing) {
        var d = e.nextHighestPowerOfTwo(Math.ceil(a)),
          f = e.nextHighestPowerOfTwo(Math.ceil(c)),
          g = Math.max(d, f)
        2048 < g && ((g = 2048 / g), (a *= g), (c *= g), (d = Math.min(Math.ceil(d * g), 2048)), (f = Math.min(Math.ceil(f * g), 2048)))
        a < d && c < f && ((c = a / c), d / f > c ? ((a = f * c), (c = f)) : ((a = d), (c = d / c)))
        this._manager.IsNpotSurfaceAllowed() && ((d = Math.ceil(a)), (f = Math.ceil(c)))
        ;(d <= this._rasterSurfaceWidth && f <= this._rasterSurfaceHeight && !this._forceRaster) ||
          ((this._isRasterizing = !0),
          (this._rasterSurfaceWidth = d),
          (this._rasterSurfaceHeight = f),
          (b = await this._manager.RasterAtSize(this._dataSource, b, this._rasterSurfaceWidth, this._rasterSurfaceHeight, a, c)),
          this._manager && (this.ReleaseRasterizedResult(), (this._rasterizedResult = b), (this._rasterImageWidth = a), (this._rasterImageHeight = c), (this._forceRaster = this._isRasterizing = !1), this._manager.Redraw()))
      }
    }
    WhenBaseSizeReady() {
      return this._getBaseSizePromise
    }
    GetBaseWidth() {
      return this._baseWidth
    }
    GetBaseHeight() {
      return this._baseHeight
    }
    GetRasterWidth() {
      return this._rasterImageWidth
    }
    GetRasterHeight() {
      return this._rasterImageHeight
    }
    HadError() {
      return this._hadError
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.UTF8_BOM = '\ufeff'
  const b = new Set([...'0123456789'])
  e.IsNumericChar = function (m) {
    return b.has(m)
  }
  const a = new Set([...' \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000'])
  e.IsWhitespaceChar = function (m) {
    return a.has(m)
  }
  e.FilterWhitespace = function (m) {
    return [...m].filter(r => !e.IsWhitespaceChar(r)).join('')
  }
  e.IsStringAllWhitespace = function (m) {
    for (const r of m) if (!e.IsWhitespaceChar(r)) return !1
    return !0
  }
  e.IsUnprintableChar = function (m) {
    return 1 === m.length && 32 > m.charCodeAt(0)
  }
  e.FilterUnprintableChars = function (m) {
    return [...m].filter(r => !e.IsUnprintableChar(r)).join('')
  }
  const c = new Set([...'0123456789.+-e'])
  e.IsStringNumber = function (m) {
    m = m.trim()
    if (!m.length) return !1
    let r = m.charAt(0)
    if ('-' !== r && !b.has(r)) return !1
    for (let w of m) if (!c.has(w)) return !1
    return !0
  }
  e.RemoveTrailingDigits = function (m) {
    let r = m.length
    for (; 0 < r; ) {
      let w = m.charAt(r - 1)
      if (!e.IsNumericChar(w)) break
      --r
    }
    return m.substr(0, r)
  }
  e.IncrementNumberAtEndOf = function (m) {
    let r = e.RemoveTrailingDigits(m)
    m = (m = m.substr(r.length)) ? (parseInt(m, 10) + 1).toString() : '2'
    return r + m
  }
  const d = new Map([
    ['&', '&amp;'],
    ['<', '&lt;'],
    ['>', '&gt;'],
    ['"', '&quot;'],
    ["'", '&#39;']
  ])

  function f(m) {
    return d.get(m)
  }
  const g = /[&<>"']/g
  e.EscapeHTML = function (m) {
    return m.replace(g, f)
  }
  e.EscapeJS = function (m) {
    m = e.ReplaceAll(m, '\\', '\\\\')
    m = e.ReplaceAll(m, '"', '\\"')
    m = e.ReplaceAll(m, '\t', '\\t')
    m = e.ReplaceAll(m, '\r', '')
    return e.ReplaceAll(m, '\n', '\\n')
  }
  e.EscapeXML = function (m) {
    m = e.ReplaceAll(m, '&', '&amp;')
    m = e.ReplaceAll(m, '<', '&lt;')
    m = e.ReplaceAll(m, '>', '&gt;')
    return e.ReplaceAll(m, '"', '&quot;')
  }
  const h = /[-[\]{}()*+?.,\\^$|#\s]/g
  e.EscapeRegex = function (m) {
    return m.replace(h, '\\$&')
  }
  e.FindAll = function (m, r, w = !1) {
    if (!r) return []
    w || ((m = m.toLowerCase()), (r = r.toLowerCase()))
    w = r.length
    var p = 0
    let q = []
    for (; -1 < (p = m.indexOf(r, p)); ) q.push(p), (p += w)
    return q
  }
  e.ReplaceAll = function (m, r, w) {
    return m.replaceAll(r, () => w)
  }
  e.ReplaceAllCaseInsensitive = function (m, r, w) {
    return m.replace(new RegExp(e.EscapeRegex(r), 'gi'), () => w)
  }
  e.SetElementContent = function (m, r) {
    'string' === typeof r ? (m.textContent = r) : r.isPlainText() ? (m.textContent = r.toString()) : ((m.innerHTML = r.toHTML()), r instanceof e.BBString && r.attachLinkHandlers(m))
  }
  e.StringLikeEquals = function (m, r) {
    return m instanceof e.HtmlString || m instanceof e.BBString ? m.equals(r) : r instanceof e.HtmlString || r instanceof e.BBString ? r.equals(m) : m === r
  }
  e.StringSubstitute = function (m, ...r) {
    let w = m
    for (let p = 0, q = r.length; p < q; ++p) {
      const t = `{${p}}`
      if (!m.includes(t)) throw Error(`missing placeholder '${t}' in string substitution`)
      w = w.replace(t, r[p].toString())
    }
    return w
  }
  e.StringSubstituteAllowMissing = function (m, ...r) {
    let w = m,
      p = -1,
      q = -1
    for (let t = 0, x = r.length; t < x; ++t) {
      const v = `{${t}}`
      m.includes(v) ? ((q = t), (w = w.replace(v, r[t].toString()))) : -1 === p && (p = t)
    }
    if (0 <= p && 0 <= q && p < q) throw Error(`missing placeholder '${p}' in string substitution`)
    return w
  }
  e.StringSubstituteMap = function (m, r) {
    for (let [w, p] of Object.entries(r)) m = m.replaceAll(w, p.toString())
    return m
  }
  e.SortAZCaseInsensitive = function (m, r) {
    m = m.toLowerCase()
    r = r.toLowerCase()
    return m > r ? 1 : m < r ? -1 : 0
  }
  e.FormatDataSize = function (m, r) {
    r = 'common.' + (r ? 'dataRates' : 'dataSizes') + '.'
    const w = self.langSub
    if (1024 > m) return w(r + 'bytes', m)
    if (1048576 > m) return (m /= 1024), (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)), w(r + 'kilobytes', m)
    if (1073741824 > m) return (m /= 1048576), (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)), w(r + 'megabytes', m)
    if (1099511627776 > m) return (m /= 1073741824), (m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)), w(r + 'gigabytes', m)
    m /= 1099511627776
    m = 10 > m ? Math.round(10 * m) / 10 : Math.round(m)
    return w(r + 'terabytes', m)
  }
  const k = {
    approximate: !1,
    days: !0,
    hours: !0,
    minutes: !0,
    seconds: !0
  }
  e.FormatTime = function (m, r) {
    r = Object.assign({}, k, r)
    e.Lang.PushContext('common.time')
    const w = [],
      p = self.lang,
      q = self.langPluralSub
    if (r.days) {
      var t = Math.floor(m / 86400)
      0 < t && ((m -= 86400 * t), w.push(q('.days', null, t)))
    }
    r.hours && ((t = Math.floor(m / 3600)), 0 < t || w.length) && ((m -= 3600 * t), w.push(q('.hours', null, t)))
    r.minutes && ((t = Math.floor(m / 60)), 0 < t || w.length || !r.seconds) && ((m -= 60 * t), w.push(q('.minutes', null, t)))
    r.seconds && w.push(q('.seconds', null, Math.floor(m % 60)))
    m = (r.approximate ? p('.approx-prefix') : '') + w.join(p('.separator'))
    e.Lang.PopContext()
    return m
  }
  e.ZeroPad = function (m, r) {
    let w = 0 > m ? '-' : ''
    m = Math.abs(m)
    m = m.toString()
    r -= m.length
    for (let p = 0; p < r; ++p) w += '0'
    return w + m
  }
  e.StringToTitleCase = function (m) {
    return m.toLowerCase().replace(/\b\w/g, r => r.toUpperCase())
  }
  e.CompareVersionStrings = function (m, r) {
    m = m.split('.').map(w => w.trim())
    r = r.split('.').map(w => w.trim())
    e.resizeArray(m, 4, '0')
    e.resizeArray(r, 4, '0')
    m = m.map(w => parseInt(w, 10))
    r = r.map(w => parseInt(w, 10))
    for (let w = 0; 4 > w; ++w) {
      const p = m[w] - r[w]
      if (0 !== p) return 0 > p ? -1 : 1
    }
    return 0
  }
  e.CreateGUID = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, m => {
      const r = Math.floor(16 * Math.random())
      return ('x' === m ? r : (r & 3) | 8).toString(16)
    })
  }
  e.StringHammingDistance = function (m, r) {
    if (m.length !== r.length) throw Error('strings must be same length')
    let w = 0
    for (let p = 0, q = m.length; p < q; ++p) m.charAt(p) !== r.charAt(p) && ++w
    return w
  }
  e.StringLevenshteinDistance = function (m, r) {
    if (0 === m.length) return r.length
    if (0 === r.length) return m.length
    let w, p, q, t
    if (m.length > r.length) {
      var x = m
      m = r
      r = x
    }
    t = Array(m.length + 1)
    for (x = 0; x <= m.length; x++) t[x] = x
    for (x = 1; x <= r.length; x++) {
      p = x
      for (w = 1; w <= m.length; w++) (q = r[x - 1] === m[w - 1] ? t[w - 1] : Math.min(t[w - 1] + 1, Math.min(p + 1, t[w] + 1))), (t[w - 1] = p), (p = q)
      t[m.length] = p
    }
    return t[m.length]
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map([
      ['b', 'strong'],
      ['i', 'em'],
      ['s', 's'],
      ['u', 'u'],
      ['sub', 'sub'],
      ['sup', 'sup'],
      ['small', 'small'],
      ['mark', 'mark'],
      ['a1', 'a'],
      ['a2', 'a'],
      ['a3', 'a'],
      ['a4', 'a'],
      ['a5', 'a'],
      ['a6', 'a'],
      ['a7', 'a'],
      ['a8', 'a'],
      ['a9', 'a'],
      ['bad', ['span', 'bbCodeBad']],
      ['good', ['span', 'bbCodeGood']],
      ['info', ['span', 'bbCodeInfo']],
      ['h1', ['span', 'bbCodeH1']],
      ['h2', ['span', 'bbCodeH2']],
      ['h3', ['span', 'bbCodeH3']],
      ['h4', ['span', 'bbCodeH4']],
      ['item', ['span', 'bbCodeItem']]
    ]),
    a = /\[(\/?)([a-zA-Z0-9]+)\]/g,
    c = /\[(\/?)([^\[]*?)\]/g
  let d = null,
    f = 0

  function g(k, m, r) {
    var w = b.get(r)
    if (w) {
      if ('string' === typeof w) {
        if ('a' !== w || m) return '<' + m + w + '>'
        m = parseInt(r.substring(1), 10) - 1
        if (0 > m || m >= d.length) throw Error('invalid bbcode link substitution')
        w = d[m]
        if ('string' === typeof w) return `<a href="${d[m]}">`
        if ('function' === typeof w) return `<a class="bblink${m}">`
        throw new TypeError('invalid bbcode link action')
      }
      if (Array.isArray(w)) return (k = w[0]), (w = w[1]), m ? '</' + k + '>' : `<${k} class="${w}">`
    } else return 'class' === r ? (m ? '</span>' : `<span class="bbclass${f++}">`) : k
  }
  const h = /\n/g
  e.BBString = class {
    constructor(k, m) {
      this._bbstr = m && m.noEscape ? k : e.EscapeHTML(k)
      this._htmlstr = ''
      this._convertLineBreaks = !1
      this._linkActions = []
      if (m && ((this._convertLineBreaks = !!m.convertLineBreaks), m.links)) {
        if (9 < m.links.length) throw Error('too many links')
        this._linkActions = m.links
      }
      this._hasAnyBBtags = this._bbstr.includes('[')
      this._needsLineBreakConversion = this._convertLineBreaks && this._bbstr.includes('\n')
      this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes('&')
      this._hasParsedFragments = !1
      this._fragments = []
    }
    toString() {
      return this._bbstr
    }
    valueOf() {
      return this._bbstr
    }
    isPlainText() {
      return this._isPlain
    }
    toPlainText() {
      return this._hasAnyBBtags ? this._bbstr.replace(a, '') : this._bbstr
    }
    toHTML() {
      if (this._isPlain) return this._bbstr
      if (!this._htmlstr && this._bbstr) {
        let k = this._bbstr
        this._hasAnyBBtags && ((f = 0), (d = this._linkActions), (k = k.replace(a, g)), (d = null))
        this._needsLineBreakConversion && (k = k.replace(h, '<br>'))
        this._htmlstr = k
      }
      return this._htmlstr
    }
    attachLinkHandlers(k) {
      if (this._linkActions.length)
        for (let m = 0, r = this._linkActions.length; m < r; ++m) {
          const w = this._linkActions[m]
          if ('function' !== typeof w) continue
          const p = k.querySelector('.bblink' + m)
          if (!p) throw Error('unable to attach BBString link handler')
          p.onclick = w
        }
    }
    equals(k) {
      return k instanceof e.HtmlString ? this.toHTML() === k.toHTML() : k instanceof e.BBString ? this._bbstr === k._bbstr : this._bbstr === k
    }
    toFragmentList() {
      if (this._hasParsedFragments) return this._fragments
      const k = this._bbstr,
        m = []
      let r = (c.lastIndex = 0)
      for (var w; null !== (w = c.exec(k)); ) {
        var p = w.index
        if (0 < p && '\\' === k.charAt(p - 1)) continue
        var q = w[0],
          t = w[1]
        w = w[2]
        const x = k.substring(r, p)
        r = p + q.length
        x &&
          this._fragments.push({
            text: x,
            styles: m.slice(0)
          })
        if (w)
          if (t)
            for (w = w.toLowerCase(), p = m.length - 1; 0 <= p; --p) {
              if (m[p].tag === w) {
                m.splice(p, 1)
                break
              }
            }
          else
            (p = w),
              (q = null),
              (t = w.indexOf('=')),
              -1 !== t ? ((p = w.substring(0, t).toLowerCase()), (q = w.substring(t + 1))) : (p = p.toLowerCase()),
              m.push({
                tag: p,
                param: q
              })
      }
      r < k.length &&
        this._fragments.push({
          text: k.substring(r),
          styles: m.slice(0)
        })
      for (const x of this._fragments) x.text = this._ProcessBBCodeEscapeSequences(x.text)
      this._hasParsedFragments = !0
      return this._fragments
    }
    _ProcessBBCodeEscapeSequences(k) {
      k = e.ReplaceAll(k, '\\[', '[')
      return e.ReplaceAll(k, '\\\\', '\\')
    }
    static StripTags(k) {
      return e
        .New(e.BBString, k, {
          noEscape: !0
        })
        .toPlainText()
    }
    static StripAnyTags(k) {
      return k.replace(c, '')
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.WordWrap = class {
    constructor() {
      this._lines = []
    }
    GetLines() {
      return this._lines
    }
    GetLineCount() {
      return this._lines.length
    }
    _MeasureLine(b, a) {
      let c = 0,
        d = 0,
        f = 0,
        g = 0,
        h = 0
      for (const k of b)
        -1 === k.width && ((b = a(k.text, k.styles)), (k.width = b.width), (k.height = b.height), (k.fontBoundingBoxAscent = b.fontBoundingBoxAscent || 0), (k.fontBoundingBoxDescent = b.fontBoundingBoxDescent || 0), (k.topToAlphabeticDistance = b.topToAlphabeticDistance || 0)),
          (c += k.width),
          (d = Math.max(d, k.height)),
          (f = Math.max(f, k.fontBoundingBoxAscent)),
          (g = Math.max(g, k.fontBoundingBoxDescent)),
          (h = Math.max(h, k.topToAlphabeticDistance))
      return {
        width: c,
        height: d,
        fontBoundingBoxAscent: f,
        fontBoundingBoxDescent: g,
        topToAlphabeticDistance: h
      }
    }
    _AddLine(b, a, c, d, f, g) {
      this._lines.push({
        fragments: b,
        width: a,
        height: c,
        fontBoundingBoxAscent: d,
        fontBoundingBoxDescent: f,
        topToAlphabeticDistance: g
      })
    }
    WordWrap(b, a, c, d, f) {
      'string' === typeof b &&
        (b = [
          {
            text: b,
            styles: []
          }
        ])
      e.clearArray(this._lines)
      if (!(!b.length || (1 === b.length && !b[0].text.length) || 2 > c)) {
        if (1 === b.length) {
          var g = b[0]
          const h = g.text
          g = g.styles
          if (100 >= h.length && !h.includes('\n')) {
            let { width: k, height: m, fontBoundingBoxAscent: r, fontBoundingBoxDescent: w, topToAlphabeticDistance: p } = a(h, g)
            k += f
            r = r || 0
            w = w || 0
            p = p || 0
            if (k <= c) {
              this._AddLine(
                [
                  {
                    text: h,
                    styles: g,
                    width: k,
                    height: m,
                    fontBoundingBoxAscent: r,
                    fontBoundingBoxDescent: w,
                    topToAlphabeticDistance: p
                  }
                ],
                k,
                m,
                r,
                w,
                p
              )
              return
            }
          }
        }
        if ('word' === d) d = this._TokeniseWords(b)
        else {
          d = []
          for (const h of b)
            e.appendArray(
              d,
              [...h.text].map(k => [
                {
                  text: k,
                  styles: h.styles
                }
              ])
            )
        }
        this._WrapText(d, a, c, f)
      }
    }
    _TokeniseWords(b) {
      const a = []
      let c = [],
        d = !1
      for (const g of b) {
        var f = g.text
        b = g.styles
        for (const h of f)
          '\n' === h
            ? (0 < c.length && a.push(c),
              a.push([
                {
                  text: '\n',
                  styles: b
                }
              ]),
              (c = []))
            : 0 === c.length
            ? (c.push({
                text: h,
                styles: b
              }),
              (d = e.IsWhitespaceChar(h)))
            : ((f = e.IsWhitespaceChar(h)),
              f === d
                ? ((f = c[c.length - 1]),
                  f.styles === b
                    ? (f.text += h)
                    : c.push({
                        text: h,
                        styles: b
                      }))
                : (a.push(c),
                  (c = []),
                  c.push({
                    text: h,
                    styles: b
                  }),
                  (d = f)))
      }
      0 < c.length && a.push(c)
      return a
    }
    _CopyLine(b) {
      return b.map(a => ({
        text: a.text,
        styles: a.styles,
        width: a.width,
        height: a.height,
        fontBoundingBoxAscent: a.fontBoundingBoxAscent,
        fontBoundingBoxDescent: a.fontBoundingBoxDescent,
        topToAlphabeticDistance: a.topToAlphabeticDistance
      }))
    }
    _AddWordToLine(b, a) {
      var c = b.length ? b[b.length - 1] : null
      let d = 0
      c && a[0].styles === c.styles && ((c.text += a[0].text), (c.width = -1), (c.height = -1), (c.fontBoundingBoxAscent = -1), (c.fontBoundingBoxDescent = -1), (c.topToAlphabeticDistance = -1), (d = 1))
      for (c = a.length; d < c; ++d) {
        const f = a[d]
        b.push({
          text: f.text,
          styles: f.styles,
          width: -1,
          height: -1,
          fontBoundingBoxAscent: -1,
          fontBoundingBoxDescent: -1,
          topToAlphabeticDistance: -1
        })
      }
    }
    _WrapText(b, a, c, d) {
      let f = [],
        g = 0,
        h = 0,
        k = 0,
        m = 0
      var r = 0
      for (const w of b) {
        if (1 === w.length && '\n' === w[0].text) {
          0 === h && ((r = a(' ', w[0].styles)), (h = r.height), (k = r.fontBoundingBoxAscent || 0), (m = r.fontBoundingBoxDescent || 0), (r = r.topToAlphabeticDistance || 0))
          this._AddLine(f, g, h, k, m, r)
          f = []
          r = m = k = h = g = 0
          continue
        }
        b = this._CopyLine(f)
        this._AddWordToLine(b, w)
        const p = this._MeasureLine(b, a),
          q = p.width
        q >= c
          ? (0 < f.length && this._AddLine(f, g, h, k, m, r),
            (f = []),
            e.IsStringAllWhitespace(w[0].text) ? (r = m = k = h = g = 0) : (this._AddWordToLine(f, w), (r = this._MeasureLine(f, a)), (g = r.width), (h = r.height), (k = r.fontBoundingBoxAscent), (m = r.fontBoundingBoxDescent), (r = r.topToAlphabeticDistance)))
          : ((f = b), (g = q), (h = p.height), (k = p.fontBoundingBoxAscent), (m = p.fontBoundingBoxDescent), (r = p.topToAlphabeticDistance))
      }
      0 < f.length && this._AddLine(f, g, h, k, m, r)
      this._TrimLinesTrailingWhitespace(a, d)
    }
    _TrimLinesTrailingWhitespace(b, a) {
      for (const d of this._lines) {
        const f = d.fragments
        if (!f.length) continue
        let g = f[f.length - 1]
        var c = g.text
        const h = c.trimEnd()
        if (!h) (d.width -= g.width), f.pop()
        else if (h.length < c.length) {
          c = b(h, g.styles).width
          const k = g.width - c
          g.width = c
          g.text = h
          d.width -= k
        }
        0 !== a && 0 < f.length && ((g = f[f.length - 1]), (g.width += a), (d.width += a))
      }
    }
    Clear() {
      e.clearArray(this._lines)
    }
    GetMaxLineWidth() {
      return this._lines.reduce((b, a) => Math.max(b, a.width), 0)
    }
    GetTotalLineHeight() {
      return this._lines.reduce((b, a) => b + a.height, 0)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec3,
    c = b.vec4,
    d = b.mat4,
    f = a.create(),
    g = a.create(),
    h = a.create(),
    k = c.create(),
    m = d.create(),
    r = a.create(),
    w = a.create(),
    p = a.create(),
    q = a.create(),
    t = a.create(),
    x = a.create(),
    v = a.create(),
    u = a.create(),
    A = c.fromValues(0, 0, 1, 1)
  e.Gfx = {
    Project(E, J, F, I, L, N, S) {
      const V = I[0] * E + I[4] * J + I[8] * F + I[12],
        U = I[1] * E + I[5] * J + I[9] * F + I[13]
      var X = I[2] * E + I[6] * J + I[10] * F + I[14]
      F = I[3] * E + I[7] * J + I[11] * F + I[15]
      E = L[0] * V + L[4] * U + L[8] * X + L[12] * F
      J = L[1] * V + L[5] * U + L[9] * X + L[13] * F
      L = L[2] * V + L[6] * U + L[10] * X + L[14] * F
      X = -X
      if (0 === X) return !1
      X = 1 / X
      S[0] = (E * X * 0.5 + 0.5) * N[2] + N[0]
      S[1] = (J * X * 0.5 + 0.5) * N[3] + N[1]
      S[2] = 0.5 * (1 + L * X)
      return !0
    },
    Unproject(E, J, F, I, L, N, S) {
      d.multiply(m, L, I)
      if (null === d.invert(m, m)) return !1
      k[0] = ((E - N[0]) / N[2]) * 2 - 1
      k[1] = ((J - N[1]) / N[3]) * 2 - 1
      k[2] = 2 * F - 1
      k[3] = 1
      c.transformMat4(k, k, m)
      if (0 === k[3]) return !1
      k[3] = 1 / k[3]
      S[0] = k[0] * k[3]
      S[1] = k[1] * k[3]
      S[2] = k[2] * k[3]
      return !0
    },
    UnprojectScreenToWorldZ(E, J, F, I, L, N, S) {
      if (!e.Gfx.Unproject(E, J, 0, I, L, N, f) || !e.Gfx.Unproject(E, J, 1, I, L, N, g)) return !1
      a.subtract(g, g, f)
      a.set(h, 0, 0, 1)
      E = -F
      J = a.dot(h, g)
      F = 0
      if (0 === J) {
        if (0 !== a.dot(h, f) + E) return !1
      } else if (((F = -(a.dot(f, h) + E) / J), 0 > F)) return !1
      a.scaleAndAdd(S, f, g, F)
      return !0
    }
  }

  function z(E, J, F, I) {
    a.subtract(f, F, J)
    a.subtract(g, E, J)
    a.cross(h, f, g)
    a.normalize(h, h)
    I[0] = h[0]
    I[1] = h[1]
    I[2] = h[2]
    I[3] = a.dot(E, h)
  }

  function C(E, J, F, I, L, N, S) {
    const V = S[0],
      U = S[1],
      X = S[2]
    S = S[3]
    let ia
    0 < V ? ((ia = V * E), (E = V * I)) : ((ia = V * I), (E *= V))
    0 < U ? ((ia += U * J), (E += U * L)) : ((ia += U * L), (E += U * J))
    0 < X ? ((ia += X * F), (E += X * N)) : ((ia += X * N), (E += X * F))
    return ia >= S || E > S
  }
  e.Gfx.ViewFrustum = class {
    constructor() {
      this._leftP = c.create()
      this._topP = c.create()
      this._rightP = c.create()
      this._bottomP = c.create()
      this._nearP = c.create()
      this._farP = c.create()
    }
    CalculatePlanes(E, J) {
      e.Gfx.Unproject(0, 1, 0, E, J, A, r)
      e.Gfx.Unproject(1, 1, 0, E, J, A, w)
      e.Gfx.Unproject(0, 0, 0, E, J, A, p)
      e.Gfx.Unproject(1, 0, 0, E, J, A, q)
      e.Gfx.Unproject(0, 1, 1, E, J, A, t)
      e.Gfx.Unproject(1, 1, 1, E, J, A, x)
      e.Gfx.Unproject(0, 0, 1, E, J, A, v)
      e.Gfx.Unproject(1, 0, 1, E, J, A, u)
      z(p, r, t, this._leftP)
      z(r, w, x, this._topP)
      z(w, q, u, this._rightP)
      z(q, p, v, this._bottomP)
      z(v, t, x, this._farP)
      z(q, w, r, this._nearP)
    }
    ContainsAABB(E, J, F, I, L, N) {
      return C(E, J, F, I, L, N, this._leftP) && C(E, J, F, I, L, N, this._topP) && C(E, J, F, I, L, N, this._rightP) && C(E, J, F, I, L, N, this._bottomP) && C(E, J, F, I, L, N, this._nearP) && C(E, J, F, I, L, N, this._farP)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec3,
    c = b.vec4,
    d = b.mat4,
    f = d.create(),
    g = a.fromValues(0, 0, 0),
    h = a.fromValues(0, 0, 0),
    k = a.fromValues(0, 0, 0),
    m = a.fromValues(0, 1, 0)
  c.fromValues(0, 0, 0, 0)
  const r = new e.Quad(),
    w = new e.Rect(),
    p = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1)
  e.Gfx.RendererBase = class {
    constructor() {
      this._height = this._width = 0
      this._fovY = e.toRadians(45)
      this._tan_fovY_2 = Math.tan(this._fovY / 2)
      this._matP = d.create()
      this._matMV = d.create()
      this._allShaderPrograms = []
      this._shaderProgramsByName = new Map()
      this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null
      this._stateGroups = new Map()
      this._currentStateGroup = null
      this._blendModeTable = []
      this._namedBlendModeMap = new Map()
      this._currentZ = this._baseZ = 0
      this._lineWidth = 1
      this._lineWidthStack = [this._lineWidth]
      this._lineCap = 1
      this._lineCapStack = [this._lineCap]
      this._lineOffset = 0.5
      this._lineOffsetStack = [this._lineOffset]
      this._frameNumber = 0
      this._enableMipmaps = !0
    }
    FillIndexBufferData(q) {
      let t = 0,
        x = q.length,
        v = 0
      for (; t < x; ) (q[t++] = v), (q[t++] = v + 1), (q[t++] = v + 2), (q[t++] = v), (q[t++] = v + 2), (q[t++] = v + 3), (v += 4)
    }
    _ClearState() {
      this._currentZ = this._baseZ = 0
      this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spLinearGradientFill = this._spColorFill = this._spTilemapFill = this._spPoints = this._spTextureFill = null
      this._ClearAllShaderPrograms()
    }
    InitState() {
      this._ClearState()
      this._currentStateGroup = null
    }
    OnDeviceOrContextLost() {
      for (const q of this._allShaderPrograms) q.Release()
      this._ClearState()
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    GetDefaultCameraZ() {
      return 100
    }
    GetNearZ() {
      return 1
    }
    GetFarZ() {
      return 1e4
    }
    GetFovY() {
      return this._fovY
    }
    _GetTanFovYDiv2() {
      return this._tan_fovY_2
    }
    CalculatePerspectiveMatrix(q, t, x = 0.5, v = 0.5) {
      const u = this.GetNearZ(),
        A = this.GetFarZ()
      x = 1 - x
      const z = 2 * x - 2
      x *= 2
      const C = 2 * v - 2
      v *= 2
      const E = this._GetTanFovYDiv2() * u
      t *= E
      d.frustum(q, z * t, x * t, C * E, v * E, u, A)
    }
    CalculateLookAtModelView(q, t, x, v, u = this.GetScissoredViewportHeight()) {
      u = (2 * this.GetDefaultCameraZ() * self.devicePixelRatio * this._GetTanFovYDiv2()) / u
      a.set(k, u, -u, 1)
      a.multiply(g, t, k)
      a.multiply(h, x, k)
      d.lookAt(q, g, h, v || m)
      d.scale(q, q, k)
    }
    CalculateLookAtModelView2(q, t, x, v, u, A, z) {
      a.set(g, q, t, x)
      a.set(h, v, u, A)
      this.CalculateLookAtModelView(f, g, h, m, z)
      return f
    }
    _AddShaderProgram(q) {
      this._allShaderPrograms.push(q)
      this._shaderProgramsByName.set(q.GetName(), q)
    }
    _RemoveShaderProgram(q) {
      const t = this._allShaderPrograms.indexOf(q)
      ;-1 !== t && this._allShaderPrograms.splice(t, 1)
      this._shaderProgramsByName.delete(q.GetName())
    }
    _ClearAllShaderPrograms() {
      e.clearArray(this._allShaderPrograms)
      this._shaderProgramsByName.clear()
    }
    GetShaderProgramByName(q) {
      return this._shaderProgramsByName.get(q) || null
    }
    GetTextureFillShaderProgram() {
      return this._spTextureFill
    }
    SetTextureFillMode() {
      this.SetProgram(this._spTextureFill)
    }
    GetPointsRenderingProgram() {
      return this._spPoints
    }
    SetPointsRenderingProgram() {
      this.SetProgram(this._spPoints)
    }
    SetTilemapFillMode() {
      this.SetProgram(this._spTilemapFill)
    }
    SetColorFillMode() {
      this.SetProgram(this._spColorFill)
    }
    SetLinearGradientFillMode() {
      this.SetProgram(this._spLinearGradientFill)
    }
    SetHardEllipseFillMode() {
      this.SetProgram(this._spHardEllipseFill)
    }
    SetHardEllipseOutlineMode() {
      this.SetProgram(this._spHardEllipseOutline)
    }
    SetSmoothEllipseFillMode() {
      this.SetProgram(this._spSmoothEllipseFill)
    }
    SetSmoothEllipseOutlineMode() {
      this.SetProgram(this._spSmoothEllipseOutline)
    }
    SetSmoothLineFillMode() {
      this.SetProgram(this._spSmoothLineFill)
    }
    _SetCurrentStateGroup(q) {
      this._currentStateGroup = q
    }
    GetCurrentStateGroup() {
      return this._currentStateGroup
    }
    AcquireStateGroup(q, t, x, v) {
      const u = e.Gfx.StateGroup.MakeKey(q, t, x, v)
      let A = this._stateGroups.get(u)
      A || ((A = e.New(e.Gfx.StateGroup, this, q, t, x, v)), this._stateGroups.set(u, A))
      A.AddRef()
      return A
    }
    ReleaseStateGroup(q) {
      q.DecRef()
      0 === q._GetRefCount() && (this._currentStateGroup === q && (this._currentStateGroup = null), this._stateGroups.delete(q.GetKey()), q.Release())
    }
    _InitBlendModeData(q) {
      e.clearArray(this._blendModeTable)
      this._namedBlendModeMap.clear()
      for (const t of q) {
        q = t[0]
        const x = t[1],
          v = t[2]
        this._blendModeTable.push([x, v])
        this._namedBlendModeMap.set(q, {
          srcBlend: x,
          destBlend: v
        })
      }
    }
    _GetBlendByIndex(q) {
      return this._blendModeTable[q]
    }
    GetSrcBlendByIndex(q) {
      return this._GetBlendByIndex(q)[0]
    }
    GetDestBlendByIndex(q) {
      return this._GetBlendByIndex(q)[1]
    }
    GetNamedBlend(q) {
      q = this._namedBlendModeMap.get(q)
      if ('undefined' === typeof q) throw Error('invalid blend name')
      return q
    }
    SetBaseZ(q) {
      this._baseZ = q
    }
    GetBaseZ() {
      return this._baseZ
    }
    SetCurrentZ(q) {
      this._currentZ = q
      this._currentStateGroup = null
    }
    GetCurrentZ() {
      return this._currentZ
    }
    Line(q, t, x, v) {
      var u = e.angleTo(q, t, x, v),
        A = 0.5 * this._lineWidth
      const z = Math.sin(u) * A
      u = Math.cos(u) * A
      A = this._lineCap
      2 === A ? this.LinePreCalc_LineCap2(q, t, 0, x, v, 0, z, u) : 1 === A ? this.LinePreCalc_LineCap1(q, t, 0, x, v, 0, z, u) : this.LinePreCalc_LineCap0(q, t, 0, x, v, 0, z, u)
    }
    Line3D(q, t, x, v, u, A) {
      var z = e.angleTo(q, t, v, u),
        C = 0.5 * this._lineWidth
      const E = Math.sin(z) * C
      z = Math.cos(z) * C
      C = this._lineCap
      2 === C ? this.LinePreCalc_LineCap2(q, t, x, v, u, A, E, z) : 1 === C ? this.LinePreCalc_LineCap1(q, t, x, v, u, A, E, z) : this.LinePreCalc_LineCap0(q, t, x, v, u, A, E, z)
    }
    LinePreCalc_LineCap2(q, t, x, v, u, A, z, C) {
      var E = this._lineOffset
      q = q + E - C
      t = t + E - z
      v = v + E + C
      u = u + E + z
      E = 2 * C
      const J = 2 * z
      this.Quad3D2(q + z, t - C, x, v + z, u - C, A, v - z - E, u + C - J, A, q - z + E, t + C + J, x, p)
    }
    LinePreCalc_LineCap1(q, t, x, v, u, A, z, C) {
      const E = this._lineOffset
      q = q + E - C
      t = t + E - z
      v = v + E + C
      u = u + E + z
      this.Quad3D2(q + z, t - C, x, v + z, u - C, A, v - z, u + C, A, q - z, t + C, x, p)
    }
    LinePreCalc_LineCap0(q, t, x, v, u, A, z, C) {
      const E = this._lineOffset
      q += E
      t += E
      v += E
      u += E
      this.Quad3D2(q + z, t - C, x, v + z, u - C, A, v - z, u + C, A, q - z, t + C, x, p)
    }
    TexturedLine(q, t, x, v, u, A) {
      var z = e.angleTo(q, t, x, v),
        C = 0.5 * this._lineWidth
      const E = Math.sin(z) * C
      z = Math.cos(z) * C
      C = this._lineCap
      2 === C ? this.TexturedLinePreCalc_LineCap2(q, t, x, v, E, z, u, A) : 1 === C ? this.TexturedLinePreCalc_LineCap1(q, t, x, v, E, z, u, A) : this.TexturedLinePreCalc_LineCap0(q, t, x, v, E, z, u, A)
    }
    TexturedLinePreCalc_LineCap2(q, t, x, v, u, A, z, C) {
      var E = this._lineOffset
      q = q + E - A
      t = t + E - u
      x = x + E + A
      v = v + E + u
      E = 2 * A
      const J = 2 * u
      r.set(q + u, t - A, x + u, v - A, x - u - E, v + A - J, q - u + E, t + A + J)
      w.set(z, 0, C, 0)
      this.Quad3(r, w)
    }
    TexturedLinePreCalc_LineCap1(q, t, x, v, u, A, z, C) {
      const E = this._lineOffset
      q = q + E - A
      t = t + E - u
      x = x + E + A
      v = v + E + u
      r.set(q + u, t - A, x + u, v - A, x - u, v + A, q - u, t + A)
      w.set(z, 0, C, 0)
      this.Quad3(r, w)
    }
    TexturedLinePreCalc_LineCap0(q, t, x, v, u, A, z, C) {
      const E = this._lineOffset
      q += E
      t += E
      x += E
      v += E
      r.set(q + u, t - A, x + u, v - A, x - u, v + A, q - u, t + A)
      w.set(z, 0, C, 0)
      this.Quad3(r, w)
    }
    LineRect(q, t, x, v) {
      const u = 0.5 * this._lineWidth,
        A = this._lineCap
      2 === A ? this._LineRectPreCalc_LineCap2(q, t, x, v, u) : 1 === A ? this._LineRectPreCalc_LineCap1(q, t, x, v, u) : this._LineRectPreCalc_LineCap0(q, t, x, v, u)
    }
    _LineRectPreCalc_LineCap2(q, t, x, v, u) {
      this.LinePreCalc_LineCap2(q, t, 0, x, t, 0, 0, u)
      this.LinePreCalc_LineCap2(x, t, 0, x, v, 0, u, 0)
      this.LinePreCalc_LineCap2(x, v, 0, q, v, 0, 0, -u)
      this.LinePreCalc_LineCap2(q, v, 0, q, t, 0, -u, 0)
    }
    _LineRectPreCalc_LineCap1(q, t, x, v, u) {
      this.LinePreCalc_LineCap1(q, t, 0, x, t, 0, 0, u)
      this.LinePreCalc_LineCap1(x, t, 0, x, v, 0, u, 0)
      this.LinePreCalc_LineCap1(x, v, 0, q, v, 0, 0, -u)
      this.LinePreCalc_LineCap1(q, v, 0, q, t, 0, -u, 0)
    }
    _LineRectPreCalc_LineCap0(q, t, x, v, u) {
      this.LinePreCalc_LineCap0(q, t, 0, x, t, 0, 0, u)
      this.LinePreCalc_LineCap0(x, t, 0, x, v, 0, u, 0)
      this.LinePreCalc_LineCap0(x, v, 0, q, v, 0, 0, -u)
      this.LinePreCalc_LineCap0(q, v, 0, q, t, 0, -u, 0)
    }
    LineRect2(q) {
      this.LineRect(q.getLeft(), q.getTop(), q.getRight(), q.getBottom())
    }
    LineQuad(q) {
      var t = e.angleTo(q.getTlx(), q.getTly(), q.getTrx(), q.getTry()),
        x = 0.5 * this._lineWidth
      const v = Math.sin(t) * x
      t = Math.cos(t) * x
      x = this._lineCap
      2 === x ? this._LineQuadPreCalc_LineCap2(q, v, t) : 1 === x ? this._LineQuadPreCalc_LineCap1(q, v, t) : this._LineQuadPreCalc_LineCap0(q, v, t)
    }
    _LineQuadPreCalc_LineCap2(q, t, x) {
      this.LinePreCalc_LineCap2(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, t, x)
      this.LinePreCalc_LineCap2(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, x, -t)
      this.LinePreCalc_LineCap2(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -t, -x)
      this.LinePreCalc_LineCap2(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -x, t)
    }
    _LineQuadPreCalc_LineCap1(q, t, x) {
      this.LinePreCalc_LineCap1(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, t, x)
      this.LinePreCalc_LineCap1(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, x, -t)
      this.LinePreCalc_LineCap1(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -t, -x)
      this.LinePreCalc_LineCap1(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -x, t)
    }
    _LineQuadPreCalc_LineCap0(q, t, x) {
      this.LinePreCalc_LineCap0(q.getTlx(), q.getTly(), 0, q.getTrx(), q.getTry(), 0, t, x)
      this.LinePreCalc_LineCap0(q.getTrx(), q.getTry(), 0, q.getBrx(), q.getBry(), 0, x, -t)
      this.LinePreCalc_LineCap0(q.getBrx(), q.getBry(), 0, q.getBlx(), q.getBly(), 0, -t, -x)
      this.LinePreCalc_LineCap0(q.getBlx(), q.getBly(), 0, q.getTlx(), q.getTly(), 0, -x, t)
    }
    SetLineWidth(q) {
      this._lineWidth = q
      this._lineWidthStack[this._lineWidthStack.length - 1] = q
    }
    GetLineWidth() {
      return this._lineWidth
    }
    PushLineWidth(q) {
      if (100 <= this._lineWidthStack.length) throw Error('pushed too many line widths - check push/pop pairs')
      this._lineWidthStack.push(q)
      this._lineWidth = q
    }
    PopLineWidth() {
      if (1 >= this._lineWidthStack.length) throw Error('cannot pop last line width - check push/pop pairs')
      this._lineWidthStack.pop()
      this._lineWidth = this._lineWidthStack[this._lineWidthStack.length - 1]
    }
    SetLineCapButt() {
      this._lineCap = 0
      this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapSquare() {
      this._lineCap = 1
      this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapZag() {
      this._lineCap = 2
      this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    PushLineCap(q) {
      if ('butt' === q) this.PushLineCapButt()
      else if ('square' === q) this.PushLineCapSquare()
      else if ('zag' === q) this.PushLineCapZag()
      else throw Error('invalid line cap')
    }
    PushLineCapButt() {
      if (100 <= this._lineCapStack.length) throw Error('pushed too many line caps - check push/pop pairs')
      this._lineCapStack.push(0)
      this._lineCap = 0
    }
    PushLineCapSquare() {
      if (100 <= this._lineCapStack.length) throw Error('pushed too many line caps - check push/pop pairs')
      this._lineCapStack.push(1)
      this._lineCap = 1
    }
    PushLineCapZag() {
      if (100 <= this._lineCapStack.length) throw Error('pushed too many line caps - check push/pop pairs')
      this._lineCapStack.push(2)
      this._lineCap = 2
    }
    PopLineCap() {
      if (1 >= this._lineCapStack.length) throw Error('cannot pop last line cap - check push/pop pairs')
      this._lineCapStack.pop()
      this._lineCap = this._lineCapStack[this._lineCapStack.length - 1]
    }
    SetLineOffset(q) {
      this._lineOffset = q
      this._lineOffsetStack[this._lineOffsetStack.length - 1] = q
    }
    GetLineOffset() {
      return this._lineOffset
    }
    PushLineOffset(q) {
      if (100 <= this._lineOffsetStack.length) throw Error('pushed too many line offsets - check push/pop pairs')
      this._lineOffsetStack.push(q)
      this._lineOffset = q
    }
    PopLineOffset() {
      if (1 >= this._lineOffsetStack.length) throw Error('cannot pop last line offset - check push/pop pairs')
      this._lineOffsetStack.pop()
      this._lineOffset = this._lineOffsetStack[this._lineOffsetStack.length - 1]
    }
    ConvexPoly(q) {
      var t = q.length / 2
      if (3 > t) throw Error('need at least 3 points')
      t -= 2
      const x = t - 1,
        v = q[0],
        u = q[1]
      for (let A = 0; A < t; A += 2) {
        const z = 2 * A,
          C = q[z + 2],
          E = q[z + 3],
          J = q[z + 4],
          F = q[z + 5]
        A === x ? this.Quad2(v, u, C, E, J, F, J, F) : this.Quad2(v, u, C, E, J, F, q[z + 6], q[z + 7])
      }
    }
    GetNumVertexComponents() {
      return 3
    }
    Finish() {
      this.EndBatch(!0)
      this._frameNumber++
    }
    GetFrameNumber() {
      return this._frameNumber
    }
    IncrementFrameNumber() {
      this._frameNumber++
    }
    SetMipmapsEnabled(q) {
      this._enableMipmaps = !!q
    }
    AreMipmapsEnabled() {
      return this._enableMipmaps
    }
    IsWebGL() {
      return !1
    }
    IsWebGPU() {
      return !1
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Gfx.StateGroup = class {
    constructor(b, a, c, d, f) {
      this._renderer = b
      this._refCount = 0
      this._shaderProgram = null
      this._shaderProgramName = ''
      this._blendMode = c
      this._color = e.New(e.Color)
      this._color.set(d)
      this._zElevation = f
      'string' === typeof a ? (this._shaderProgramName = a) : ((this._shaderProgram = a), (this._shaderProgramName = this._shaderProgram.GetName()))
    }
    Release() {
      if (0 < this._refCount) throw Error('releasing state group still in use')
      this._shaderProgram = this._renderer = null
      this._shaderProgramName = ''
    }
    Apply() {
      const b = this._renderer
      b.SetProgram(this._shaderProgram)
      b.SetBlendMode(this._blendMode)
      b.SetColor(this._color)
      b.SetCurrentZ(this._zElevation)
      b._SetCurrentStateGroup(this)
    }
    GetKey() {
      return e.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
    }
    AddRef() {
      ++this._refCount
    }
    DecRef() {
      --this._refCount
    }
    _GetRefCount() {
      return this._refCount
    }
    OnContextLost() {
      this._shaderProgram = null
    }
    OnContextRestored(b) {
      this._shaderProgram = b.GetShaderProgramByName(this._shaderProgramName)
      if (!this._shaderProgram) throw Error('failed to restore shader program')
    }
    static MakeKey(b, a, c, d) {
      return ('string' === typeof b ? b : b.GetName()) + ',' + a + ',' + c.getR() + ',' + c.getG() + ',' + c.getB() + ',' + c.getA() + ',' + d
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Quad)

  function a(c, d, f) {
    const g = f.getTlx(),
      h = f.getTly(),
      k = f.getTrx() - g,
      m = f.getTry() - h,
      r = f.getBlx() - g
    f = f.getBly() - h
    return [g + k * c + r * d, h + m * c + f * d]
  }
  e.Gfx.MeshPoint = class {
    constructor(c, d, f) {
      this._mesh = c
      this._col = d
      this._row = f
      this._v = this._u = this._zElevation = this._y = this._x = 0
    }
    _Init(c, d, f, g) {
      this._x = c
      this._y = d
      this._u = f
      this._v = g
    }
    GetX() {
      return this._x
    }
    SetX(c) {
      this._x !== c && ((this._x = c), this._mesh._SetPointsChanged())
    }
    GetY() {
      return this._y
    }
    SetY(c) {
      this._y !== c && ((this._y = c), this._mesh._SetPointsChanged())
    }
    GetZElevation() {
      return this._zElevation
    }
    SetZElevation(c) {
      this._zElevation !== c && ((this._zElevation = Math.max(c, 0)), this._mesh._SetPointsChanged())
    }
    GetU() {
      return this._u
    }
    SetU(c) {
      this._u = c
    }
    GetV() {
      return this._v
    }
    SetV(c) {
      this._v = c
    }
    _Interpolate_TexRect(c, d, f) {
      ;[this._x, this._y] = a(c._x, c._y, d)
      this._zElevation = c._zElevation
      this._u = e.lerp(f.getLeft(), f.getRight(), c._u)
      this._v = e.lerp(f.getTop(), f.getBottom(), c._v)
    }
    _Interpolate_TexQuad(c, d, f) {
      ;[this._x, this._y] = a(c._x, c._y, d)
      this._zElevation = c._zElevation
      ;[this._u, this._v] = a(c._u, c._v, f)
    }
    SaveToJson() {
      return {
        x: this.GetX(),
        y: this.GetY(),
        z: this.GetZElevation(),
        u: this.GetU(),
        v: this.GetV()
      }
    }
    LoadFromJson(c) {
      this.SetX(c.x)
      this.SetY(c.y)
      c.hasOwnProperty('z') && this.SetZElevation(c.z)
      this.SetU(c.u)
      this.SetV(c.v)
    }
    GetMesh() {
      return this._mesh
    }
    GetColumn() {
      return this._col
    }
    GetRow() {
      return this._row
    }
  }
  e.Gfx.Mesh = class {
    constructor(c, d, f) {
      if (2 > c || 2 > d) throw Error('invalid mesh size')
      this._hsize = c
      this._vsize = d
      this._owner = f || null
      this._pts = []
      this._minY = this._minX = 0
      this._maxY = this._maxX = 1
      this._pointsChanged = this._hasAnyZElevation = !1
      f = c - 1
      const g = d - 1
      for (let h = 0; h < d; ++h) {
        const k = []
        for (let m = 0; m < c; ++m) {
          const r = e.New(e.Gfx.MeshPoint, this, m, h),
            w = m / f,
            p = h / g
          r._Init(w, p, w, p)
          k.push(r)
        }
        this._pts.push(k)
      }
    }
    Release() {
      e.clearArray(this._pts)
    }
    GetHSize() {
      return this._hsize
    }
    GetVSize() {
      return this._vsize
    }
    GetOwner() {
      return this._owner
    }
    _GetPoints() {
      return this._pts
    }
    _SetPointsChanged() {
      this._pointsChanged = !0
    }
    _MaybeComputeBounds() {
      if (this._pointsChanged) {
        var c = Infinity,
          d = Infinity,
          f = -Infinity,
          g = -Infinity
        this._hasAnyZElevation = !1
        for (const h of this._pts)
          for (const k of h) {
            const m = k.GetX(),
              r = k.GetY()
            c = Math.min(c, m)
            d = Math.min(d, r)
            f = Math.max(f, m)
            g = Math.max(g, r)
            0 < k.GetZElevation() && (this._hasAnyZElevation = !0)
          }
        this._minX = c
        this._minY = d
        this._maxX = f
        this._maxY = g
        this._pointsChanged = !1
      }
    }
    GetMinX() {
      this._MaybeComputeBounds()
      return this._minX
    }
    GetMinY() {
      this._MaybeComputeBounds()
      return this._minY
    }
    GetMaxX() {
      this._MaybeComputeBounds()
      return this._maxX
    }
    GetMaxY() {
      this._MaybeComputeBounds()
      return this._maxY
    }
    HasAnyZElevation() {
      this._MaybeComputeBounds()
      return this._hasAnyZElevation
    }
    GetMeshPointAt(c, d) {
      c = Math.floor(c)
      d = Math.floor(d)
      return 0 > c || c >= this._hsize || 0 > d || d >= this._vsize ? null : this._pts[d][c]
    }
    CalculateTransformedMesh(c, d, f) {
      const g = f instanceof e.Rect
      if (c.GetHSize() !== this.GetHSize() || c.GetVSize() !== this.GetVSize()) throw Error('source mesh wrong size')
      c = c._pts
      const h = this._pts
      for (let k = 0, m = h.length; k < m; ++k) {
        const r = c[k],
          w = h[k]
        for (let p = 0, q = w.length; p < q; ++p) {
          const t = r[p],
            x = w[p]
          g ? x._Interpolate_TexRect(t, d, f) : x._Interpolate_TexQuad(t, d, f)
        }
      }
    }
    Draw(c) {
      const d = this._pts
      let f = d[0]
      for (let g = 1, h = d.length; g < h; ++g) {
        const k = d[g]
        let m = f[0],
          r = k[0]
        for (let w = 1, p = k.length; w < p; ++w) {
          const q = f[w],
            t = k[w]
          b.set(m.GetU(), m.GetV(), q.GetU(), q.GetV(), t.GetU(), t.GetV(), r.GetU(), r.GetV())
          c.Quad3D2(m.GetX(), m.GetY(), m.GetZElevation(), q.GetX(), q.GetY(), q.GetZElevation(), t.GetX(), t.GetY(), t.GetZElevation(), r.GetX(), r.GetY(), r.GetZElevation(), b)
          m = q
          r = t
        }
        f = k
      }
    }
    Outline(c, d) {
      d || (d = (h, k, m) => [h, k, m])
      const f = this._pts
      let g = f[0]
      for (let h = 1, k = f.length; h < k; ++h) {
        const m = f[h]
        let r = g[0],
          w = m[0]
        for (let p = 1, q = m.length; p < q; ++p) {
          const t = g[p],
            x = m[p],
            [v, u, A] = d(r.GetX(), r.GetY(), r.GetZElevation()),
            [z, C, E] = d(t.GetX(), t.GetY(), t.GetZElevation()),
            [J, F, I] = d(x.GetX(), x.GetY(), x.GetZElevation()),
            [L, N, S] = d(w.GetX(), w.GetY(), w.GetZElevation())
          c.Line3D(v, u, A, z, C, E)
          c.Line3D(v, u, A, J, F, I)
          c.Line3D(v, u, A, L, N, S)
          p === q - 1 && c.Line3D(z, C, E, J, F, I)
          h === k - 1 && c.Line3D(L, N, S, J, F, I)
          r = t
          w = x
        }
        g = m
      }
    }
    InsertPolyMeshVertices(c) {
      c = c.pointsArr()
      const d = [],
        f = this.GetHSize() - 1,
        g = this.GetVSize() - 1,
        h = 1 / f,
        k = 1 / g,
        m = f - 1,
        r = g - 1
      let w = c[0],
        p = c[1],
        q = e.clamp(Math.floor(w * f), 0, m),
        t = e.clamp(Math.floor(p * g), 0, r),
        x = 0,
        v = 0,
        u = 0
      var A = -1
      const z = () => {
        w = e.clamp(e.lerp(w, x, u), 0, 1)
        p = e.clamp(e.lerp(p, v, u), 0, 1)
        d.push(w, p)
      }
      for (let C = 0, E = c.length; C < E; C += 2)
        for (w = c[C], p = c[C + 1], d.push(w, p), q = e.clamp(Math.floor(w * f), 0, m), t = e.clamp(Math.floor(p * g), 0, r), A = (C + 2) % E, x = c[A], v = c[A + 1], A = -1; ; ) {
          if (1e6 < d.length) throw Error('Too many mesh poly points')
          const J = q * h,
            F = t * k,
            I = (q + 1) * h,
            L = (t + 1) * k
          e.isPointInTriangleInclusive(w, p, J, F, I, F, I, L)
          if (0 !== A && ((u = e.rayIntersectExtended(w, p, x, v, J, F, I, L, -0.001)), 0 <= u && 0.99999999 >= u)) {
            z()
            A = 0
            continue
          }
          if (0 < t && 2 !== A && ((u = e.rayIntersectExtended(w, p, x, v, J, F, I, F, 0.001)), 0 <= u && 0.99999999 >= u)) {
            z()
            t--
            A = 4
            continue
          }
          if (q < m && 3 !== A && ((u = e.rayIntersectExtended(w, p, x, v, I, F, I, L, 0.001)), 0 <= u && 0.99999999 >= u)) {
            z()
            q++
            A = 1
            continue
          }
          if (0 < q && 1 !== A && ((u = e.rayIntersectExtended(w, p, x, v, J, F, J, L, 0.001)), 0 <= u && 0.99999999 >= u)) {
            z()
            q--
            A = 3
            continue
          }
          if (t < r && 4 !== A && ((u = e.rayIntersectExtended(w, p, x, v, J, L, I, L, 0.001)), 0 <= u && 0.99999999 >= u)) {
            z()
            t++
            A = 2
            continue
          }
          break
        }
      return e.New(e.CollisionPoly, d)
    }
    TransformCollisionPoly(c, d) {
      c = this._TransformPolyPoints(c)
      this._SimplifyPoly(c)
      d.setPoints(c)
    }
    _TransformPolyPoints(c) {
      const d = []
      c = c.pointsArr()
      for (let f = 0, g = c.length; f < g; f += 2) {
        const [h, k] = this.TransformPoint(c[f], c[f + 1])
        d.push(h, k)
      }
      return d
    }
    TransformPoint(c, d) {
      var f = this.GetHSize() - 1,
        g = this.GetVSize() - 1,
        h = 1 / f,
        k = 1 / g
      f = e.clamp(Math.floor(c * f), 0, f - 1)
      const m = e.clamp(Math.floor(d * g), 0, g - 1)
      g = f * h
      const r = m * k,
        w = (f + 1) * h,
        p = (m + 1) * k,
        q = this.GetMeshPointAt(f, m),
        t = this.GetMeshPointAt(f + 1, m + 1),
        x = e.isPointInTriangleInclusive(c, d, g, r, w, r, w, p)
      h = x ? g + h : g
      k = x ? r : r + k
      f = this.GetMeshPointAt(f + (x ? 1 : 0), m + (x ? 0 : 1))
      const [v, u, A] = e.triangleCartesianToBarycentric(c, d, g, r, h, k, w, p)
      return e.triangleBarycentricToCartesian(v, u, A, q.GetX(), q.GetY(), f.GetX(), f.GetY(), t.GetX(), t.GetY())
    }
    _SimplifyPoly(c) {
      const d = []
      let f = c[0],
        g = c[1],
        h = f - c[c.length - 2],
        k = g - c[c.length - 1]
      for (let r = 0, w = c.length; r < w; r += 2) {
        var m = (r + 2) % w
        const p = c[m]
        m = c[m + 1]
        const q = p - f,
          t = m - g,
          x = 1e-7 > Math.abs(t) && 1e-7 > Math.abs(k) && Math.sign(q) === Math.sign(h)
        ;((!((1e-7 > Math.abs(q) && 1e-7 > Math.abs(h) && Math.sign(t) === Math.sign(k)) || x) && 1e-7 < Math.abs(q / h - t / k)) || (0 == q && 0 === t)) && d.push(f, g)
        f = p
        g = m
        h = q
        k = t
      }
      6 <= d.length && d.length < c.length && e.shallowAssignArray(c, d)
    }
    SaveToJson() {
      return {
        cols: this.GetHSize(),
        rows: this.GetVSize(),
        points: this._pts.map(c => c.map(d => d.SaveToJson()))
      }
    }
    LoadFromJson(c) {
      const d = this.GetHSize(),
        f = this.GetVSize()
      if (c.cols !== d || c.rows !== f) throw Error('mesh data wrong size')
      c = c.points
      for (let g = 0; g < f; ++g) {
        const h = c[g]
        for (let k = 0; k < d; ++k) this.GetMeshPointAt(k, g).LoadFromJson(h[k])
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set(['rgba8', 'rgb8', 'rgba4', 'rgb5_a1', 'rgb565']),
    a = new Set(['nearest', 'bilinear', 'trilinear']),
    c = new Set(['default', 'low', 'high']),
    d = new Set(['clamp-to-edge', 'repeat', 'mirror-repeat'])

  function f(m, r) {
    let w, p
    switch (m) {
      case 'rgba8':
        m = r.RGBA8
        p = w = r.RGBA
        r = r.UNSIGNED_BYTE
        break
      case 'rgb8':
        m = r.RGB8
        p = w = r.RGB
        r = r.UNSIGNED_BYTE
        break
      case 'rgba4':
        m = r.RGBA4
        p = w = r.RGBA
        r = r.UNSIGNED_SHORT_4_4_4_4
        break
      case 'rgb5_a1':
        m = r.RGB5_A1
        p = w = r.RGBA
        r = r.UNSIGNED_SHORT_5_5_5_1
        break
      case 'rgb565':
        m = r.RGB565
        p = w = r.RGB
        r = r.UNSIGNED_SHORT_5_6_5
        break
      default:
        throw Error('invalid pixel format')
    }
    return {
      sizedinternalformat: m,
      internalformat: w,
      format: p,
      type: r
    }
  }
  const g = {
      wrapX: 'clamp-to-edge',
      wrapY: 'clamp-to-edge',
      sampling: 'trilinear',
      anisotropy: 0,
      pixelFormat: 'rgba8',
      mipMap: !0,
      mipMapQuality: 'default',
      premultiplyAlpha: !0,
      isSvg: !1,
      width: -1,
      height: -1
    },
    h = {
      premultiplyAlpha: !0,
      flipY: !1
    },
    k = new Set()
  e.Gfx.WebGLRendererTexture = class {
    constructor(m) {
      this._renderer = m
      this._texture = null
      this._height = this._width = 0
      this._isStatic = !0
      this._wrapY = this._wrapX = 'clamp-to-edge'
      this._sampling = 'trilinear'
      this._anisotropy = 0
      this._pixelFormat = 'rgba8'
      this._isMipMapped = !1
      this._mipMapQuality = 'default'
      this._refCount = 0
    }
    _CreateStatic(m, r) {
      if (
        !(
          ('undefined' !== typeof HTMLImageElement && m instanceof HTMLImageElement) ||
          ('undefined' !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement) ||
          ('undefined' !== typeof ImageBitmap && m instanceof ImageBitmap) ||
          ('undefined' !== typeof OffscreenCanvas && m instanceof OffscreenCanvas) ||
          m instanceof ImageData ||
          m instanceof ArrayBuffer
        ) &&
        null !== m
      )
        throw Error('invalid texture source')
      r = Object.assign({}, g, r)
      if (this._texture) throw Error('already created texture')
      this._wrapX = r.wrapX
      this._wrapY = r.wrapY
      this._sampling = r.sampling
      this._anisotropy = r.anisotropy
      this._pixelFormat = r.pixelFormat
      this._isMipMapped = !!r.mipMap && this._renderer.AreMipmapsEnabled()
      this._mipMapQuality = r.mipMapQuality
      if (!d.has(this._wrapX) || !d.has(this._wrapY)) throw Error('invalid wrap mode')
      if (!a.has(this._sampling)) throw Error('invalid sampling')
      if (!b.has(this._pixelFormat)) throw Error('invalid pixel format')
      if (!c.has(this._mipMapQuality)) throw Error('invalid mipmap quality')
      this._isStatic = !0
      if (m instanceof ArrayBuffer || null === m || r.isSvg) {
        if (((this._width = r.width), (this._height = r.height), m instanceof ArrayBuffer && m.byteLength !== this._width * this._height * 4)) throw Error('ArrayBuffer wrong size')
      } else (this._width = m.width), (this._height = m.height)
      if (0 >= this._width || 0 >= this._height) throw Error('invalid texture data size')
      if (r.isSvg) {
        var w = e.CreateCanvas(this._width, this._height)
        w.getContext('2d').drawImage(m, 0, 0, this._width, this._height)
        m = w
      }
      var p = e.isPOT(this._width) && e.isPOT(this._height)
      w = this._renderer.GetMaxTextureSize()
      if (this._width > w || this._height > w) throw Error('texture data exceeds maximum texture size')
      w = this._renderer.GetContext()
      var q = this._renderer.GetWebGLVersionNumber()
      this._texture = w.createTexture()
      w.bindTexture(w.TEXTURE_2D, this._texture)
      w.pixelStorei(w.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha)
      w.pixelStorei(w.UNPACK_FLIP_Y_WEBGL, !1)
      r = f(this._pixelFormat, w)
      if (this._renderer.SupportsNPOTTextures() || p || !this._IsTiled())
        2 <= q
          ? (w.texStorage2D(w.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, r.sizedinternalformat, this._width, this._height),
            m instanceof ArrayBuffer ? w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, this._width, this._height, r.format, r.type, new Uint8Array(m)) : null !== m && w.texSubImage2D(w.TEXTURE_2D, 0, 0, 0, r.format, r.type, m))
          : m instanceof ArrayBuffer
          ? w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, this._width, this._height, 0, r.format, r.type, new Uint8Array(m))
          : null === m
          ? w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, this._width, this._height, 0, r.format, r.type, null)
          : w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, r.format, r.type, m)
      else {
        if (null === m) throw Error('cannot pass null data when creating a NPOT tiled texture without NPOT support')
        m instanceof ArrayBuffer && (m = new ImageData(new Uint8ClampedArray(m), this._width, this._height))
        m instanceof ImageData && ((p = e.CreateCanvas(this._width, this._height)), p.getContext('2d').putImageData(m, 0, 0), (m = p))
        p = e.CreateCanvas(e.nextHighestPowerOfTwo(this._width), e.nextHighestPowerOfTwo(this._height))
        q = p.getContext('2d')
        q.imageSmoothingEnabled = 'nearest' !== this._sampling
        q.drawImage(m, 0, 0, this._width, this._height, 0, 0, p.width, p.height)
        w.texImage2D(w.TEXTURE_2D, 0, r.internalformat, r.format, r.type, p)
      }
      null !== m && this._SetTextureParameters(w)
      w.bindTexture(w.TEXTURE_2D, null)
      this._renderer._ResetLastTexture()
      this._refCount = 1
      k.add(this)
    }
    _CreateDynamic(m, r, w) {
      w = Object.assign({}, g, w)
      if (this._texture) throw Error('already created texture')
      this._wrapX = w.wrapX
      this._wrapY = w.wrapY
      this._sampling = w.sampling
      this._pixelFormat = w.pixelFormat
      this._isMipMapped = !!w.mipMap && this._renderer.AreMipmapsEnabled()
      this._mipMapQuality = w.mipMapQuality
      if (!d.has(this._wrapX) || !d.has(this._wrapY)) throw Error('invalid wrap mode')
      if (!a.has(this._sampling)) throw Error('invalid sampling')
      if (!b.has(this._pixelFormat)) throw Error('invalid pixel format')
      if (!c.has(this._mipMapQuality)) throw Error('invalid mipmap quality')
      this._isStatic = !1
      this._width = Math.floor(m)
      this._height = Math.floor(r)
      m = e.isPOT(this._width) && e.isPOT(this._height)
      r = this._renderer.GetMaxTextureSize()
      if (0 >= this._width || 0 >= this._height) throw Error('invalid texture size')
      if (this._width > r || this._height > r) throw Error('texture exceeds maximum texture size')
      if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !m) throw Error('non-power-of-two tiled textures not supported')
      m = this._renderer.GetContext()
      r = this._renderer.GetWebGLVersionNumber()
      this._texture = m.createTexture()
      m.bindTexture(m.TEXTURE_2D, this._texture)
      m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha)
      m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, !1)
      w = f(this._pixelFormat, m)
      m.texImage2D(m.TEXTURE_2D, 0, 2 <= r ? w.sizedinternalformat : w.internalformat, this._width, this._height, 0, w.format, w.type, null)
      this._SetTextureParameters(m)
      m.bindTexture(m.TEXTURE_2D, null)
      this._renderer._ResetLastTexture()
      this._refCount = 1
      k.add(this)
    }
    _GetMipMapHint(m) {
      if ('default' === this._mipMapQuality) return this._isStatic ? m.NICEST : m.FASTEST
      if ('low' === this._mipMapQuality) return m.FASTEST
      if ('high' === this._mipMapQuality) return m.NICEST
      throw Error('invalid mipmap quality')
    }
    _IsTiled() {
      return 'clamp-to-edge' !== this._wrapX || 'clamp-to-edge' !== this._wrapY
    }
    _GetTextureWrapMode(m, r) {
      if ('clamp-to-edge' === r) return m.CLAMP_TO_EDGE
      if ('repeat' === r) return m.REPEAT
      if ('mirror-repeat' === r) return m.MIRRORED_REPEAT
      throw Error('invalid wrap mode')
    }
    _SetTextureParameters(m) {
      var r = e.isPOT(this._width) && e.isPOT(this._height)
      m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, this._GetTextureWrapMode(m, this._wrapX))
      m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, this._GetTextureWrapMode(m, this._wrapY))
      'nearest' === this._sampling
        ? (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST), (this._isMipMapped = !1))
        : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.LINEAR),
          (r || this._renderer.SupportsNPOTTextures()) && this._isMipMapped
            ? (m.hint(m.GENERATE_MIPMAP_HINT, this._GetMipMapHint(m)), m.generateMipmap(m.TEXTURE_2D), (r = 'trilinear' === this._sampling && !this._renderer.HasMajorPerformanceCaveat()), m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, r ? m.LINEAR_MIPMAP_LINEAR : m.LINEAR_MIPMAP_NEAREST))
            : (m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.LINEAR), (this._isMipMapped = !1)))
      ;(r = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && 'nearest' !== this._sampling && m.texParameterf(m.TEXTURE_2D, r.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
    }
    _Update(m, r) {
      if (
        !(
          ('undefined' !== typeof HTMLImageElement && m instanceof HTMLImageElement) ||
          ('undefined' !== typeof HTMLVideoElement && m instanceof HTMLVideoElement) ||
          ('undefined' !== typeof HTMLCanvasElement && m instanceof HTMLCanvasElement) ||
          ('undefined' !== typeof ImageBitmap && m instanceof ImageBitmap) ||
          ('undefined' !== typeof OffscreenCanvas && m instanceof OffscreenCanvas) ||
          m instanceof ImageData
        )
      )
        throw Error('invalid texture source')
      if (!this._texture || 0 >= this._refCount) throw Error('texture not created')
      if (this._isStatic) throw Error('cannot update static texture')
      r = Object.assign({}, h, r)
      const w = m.width || m.videoWidth,
        p = m.height || m.videoHeight
      var q = this._renderer.GetWebGLVersionNumber()
      const t = this._renderer.GetContext()
      t.bindTexture(t.TEXTURE_2D, this._texture)
      t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha)
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !!r.flipY)
      r = f(this._pixelFormat, t)
      q = 2 <= q ? r.sizedinternalformat : r.internalformat
      try {
        if (this._width === w && this._height === p) {
          const x = e.isPOT(this._width) && e.isPOT(this._height)
          t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, r.format, r.type, m)
          ;(x || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (t.hint(t.GENERATE_MIPMAP_HINT, this._GetMipMapHint(t)), t.generateMipmap(t.TEXTURE_2D))
        } else {
          this._width = w
          this._height = p
          const x = e.isPOT(this._width) && e.isPOT(this._height)
          if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !x) throw Error('non-power-of-two tiled textures not supported')
          t.texImage2D(t.TEXTURE_2D, 0, q, r.format, r.type, m)
          ;(x || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (t.hint(t.GENERATE_MIPMAP_HINT, this._GetMipMapHint(t)), t.generateMipmap(t.TEXTURE_2D))
        }
      } catch (x) {
        console.error('Error updating WebGL texture: ', x)
      }
      t.bindTexture(t.TEXTURE_2D, null)
      this._renderer._ResetLastTexture()
    }
    _Delete() {
      if (0 < this._refCount) throw Error('texture still has references')
      if (!this._texture) throw Error('already deleted texture')
      k.delete(this)
      this._renderer.GetContext().deleteTexture(this._texture)
      this._texture = null
    }
    IsValid() {
      return !!this._texture
    }
    _GetTexture() {
      return this._texture
    }
    GetRenderer() {
      return this._renderer
    }
    AddReference() {
      this._refCount++
    }
    SubtractReference() {
      if (0 >= this._refCount) throw Error('no more references')
      this._refCount--
    }
    GetReferenceCount() {
      return this._refCount
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    IsStatic() {
      return this._isStatic
    }
    GetEstimatedMemoryUsage() {
      let m = this._width * this._height
      switch (this._pixelFormat) {
        case 'rgba8':
          m *= 4
          break
        case 'rgb8':
          m *= 3
          break
        case 'rgba4':
        case 'rgb5_a1':
        case 'rgb565':
          m *= 2
      }
      this._isMipMapped && (m += Math.floor(m / 3))
      return m
    }
    static OnContextLost() {
      k.clear()
    }
    static allTextures() {
      return k.values()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix.mat4,
    a = new Set(['nearest', 'bilinear', 'trilinear']),
    c = {
      sampling: 'trilinear',
      alpha: !0,
      depth: !1,
      isSampled: !0,
      isDefaultSize: !0,
      multisampling: 0
    },
    d = new Set()
  e.Gfx.WebGLRenderTarget = class {
    constructor(f) {
      this._renderer = f
      this._renderBuffer = this._texture = this._frameBuffer = null
      this._height = this._width = 0
      this._isDefaultSize = !0
      this._sampling = 'trilinear'
      this._alpha = !0
      this._depth = !1
      this._isSampled = !0
      this._multisampling = 0
      this._projectionMatrix = b.create()
    }
    _Create(f, g, h) {
      h = Object.assign({}, c, h)
      const k = this._renderer.GetWebGLVersionNumber()
      if (this._texture || this._renderBuffer) throw Error('already created render target')
      this._sampling = h.sampling
      this._alpha = !!h.alpha
      this._depth = !!h.depth
      this._isSampled = !!h.isSampled
      this._isDefaultSize = !!h.isDefaultSize
      this._multisampling = h.multisampling
      if (!a.has(this._sampling)) throw Error('invalid sampling')
      if (0 < this._multisampling && (2 > k || this._isSampled)) throw Error('invalid use of multisampling')
      2 > k && (this._isSampled = !0)
      this._width = f
      this._height = g
      if (0 >= this._width || 0 >= this._height) throw Error('invalid render target size')
      this._CalculateProjection()
      f = this._renderer.GetContext()
      this._frameBuffer = f.createFramebuffer()
      f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer)
      this._isSampled
        ? ((this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
            sampling: this._sampling,
            pixelFormat: this._alpha ? 'rgba8' : 'rgb8',
            mipMap: !1
          })),
          (g = this._texture._GetTexture()),
          f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, g, 0))
        : ((this._renderBuffer = f.createRenderbuffer()),
          f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer),
          (g = this._alpha ? f.RGBA8 : f.RGB8),
          0 < this._multisampling && ((h = f.getInternalformatParameter(f.RENDERBUFFER, g, f.SAMPLES)) && h[0] ? ((h = h[0]), this._multisampling > h && (this._multisampling = h)) : (this._multisampling = 0)),
          0 === this._multisampling ? f.renderbufferStorage(f.RENDERBUFFER, g, this._width, this._height) : f.renderbufferStorageMultisample(f.RENDERBUFFER, this._multisampling, g, this._width, this._height),
          f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, this._renderBuffer),
          f.bindRenderbuffer(f.RENDERBUFFER, null))
      g = this._renderer._GetDepthBuffer()
      this._depth && g && f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, g)
      f.bindFramebuffer(f.FRAMEBUFFER, null)
      d.add(this)
    }
    _Resize(f, g) {
      if (this._width !== f || this._height !== g)
        (this._width = f),
          (this._height = g),
          this._CalculateProjection(),
          (f = this._renderer.GetContext()),
          f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer),
          this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (f.bindRenderbuffer(f.RENDERBUFFER, this._renderBuffer), f.renderbufferStorage(f.RENDERBUFFER, this._alpha ? f.RGBA8 : f.RGB8, this._width, this._height), f.bindRenderbuffer(f.RENDERBUFFER, null)),
          (g = this._renderer._GetDepthBuffer()),
          this._depth && g && f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, g),
          f.bindFramebuffer(f.FRAMEBUFFER, null)
    }
    _Delete() {
      if (!this._texture && !this._renderBuffer) throw Error('already deleted render target')
      d.delete(this)
      const f = this._renderer.GetContext()
      f.bindFramebuffer(f.FRAMEBUFFER, this._frameBuffer)
      this._texture
        ? (f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.TEXTURE_2D, null, 0), this._renderer.DeleteTexture(this._texture), (this._texture = null))
        : this._renderBuffer && (f.framebufferRenderbuffer(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, f.RENDERBUFFER, null), f.deleteRenderbuffer(this._renderBuffer), (this._renderBuffer = null))
      f.bindFramebuffer(f.FRAMEBUFFER, null)
      2 <= this._renderer.GetWebGLVersionNumber() && (f.bindFramebuffer(f.READ_FRAMEBUFFER, null), f.bindFramebuffer(f.DRAW_FRAMEBUFFER, null))
      f.deleteFramebuffer(this._frameBuffer)
      this._frameBuffer = this._renderer.GetBatchState().currentFramebuffer = null
    }
    _CalculateProjection() {
      this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height)
    }
    _GetFramebuffer() {
      return this._frameBuffer
    }
    GetRenderer() {
      return this._renderer
    }
    GetTexture() {
      return this._texture
    }
    GetProjectionMatrix() {
      return this._projectionMatrix
    }
    IsLinearSampling() {
      return 'nearest' !== this._sampling
    }
    HasAlpha() {
      return this._alpha
    }
    IsSampled() {
      return this._isSampled
    }
    HasDepthBuffer() {
      return this._depth
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    IsDefaultSize() {
      return this._isDefaultSize
    }
    GetMultisampling() {
      return this._multisampling
    }
    GetOptions() {
      const f = {
        sampling: this._sampling,
        alpha: this._alpha,
        isSampled: this._isSampled
      }
      this._isDefaultSize || ((f.width = this._width), (f.height = this._height))
      return f
    }
    IsCompatibleWithOptions(f) {
      f = Object.assign({}, c, f)
      return ('nearest' !== f.sampling) !== this.IsLinearSampling() || !!f.alpha !== this.HasAlpha() || !!f.depth !== this.HasDepthBuffer() || (2 <= this._renderer.GetWebGLVersionNumber() && !!f.isSampled !== this.IsSampled())
        ? !1
        : 'number' === typeof f.width || 'number' === typeof f.height
        ? !this.IsDefaultSize() && this.GetWidth() === f.width && this.GetHeight() === f.height
        : this.IsDefaultSize()
    }
    _GetWebGLTexture() {
      return this._texture ? this._texture._GetTexture() : null
    }
    GetEstimatedMemoryUsage() {
      return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
    }
    static async DebugReadPixelsToBlob(f, g) {
      f = await f.ReadBackRenderTargetToImageData(g, !0)
      return await e.ImageDataToBlob(f)
    }
    static OnContextLost() {
      d.clear()
    }
    static allRenderTargets() {
      return d.values()
    }
    static ResizeAll(f, g) {
      for (const h of d) h.IsDefaultSize() && h._Resize(f, g)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set('aPos aTex aPoints matP matMV samplerFront samplerBack destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness'.split(' '))
  e.Gfx.WebGLShaderProgram = class {
    static async Compile(a, c, d, f) {
      const g = a.GetContext(),
        h = g.createShader(g.FRAGMENT_SHADER)
      g.shaderSource(h, c)
      g.compileShader(h)
      c = g.createShader(g.VERTEX_SHADER)
      g.shaderSource(c, d)
      g.compileShader(c)
      const k = g.createProgram()
      g.attachShader(k, h)
      g.attachShader(k, c)
      g.bindAttribLocation(k, 0, 'aPos')
      g.bindAttribLocation(k, 1, 'aTex')
      g.bindAttribLocation(k, 2, 'aPoints')
      g.linkProgram(k)
      const m = a._GetParallelShaderCompileExtension()
      m ? await a._WaitForObjectReady(() => g.getProgramParameter(k, m.COMPLETION_STATUS_KHR)) : await e.Wait(5)
      if (!g.getShaderParameter(h, g.COMPILE_STATUS)) throw ((f = g.getShaderInfoLog(h)), g.deleteShader(h), g.deleteShader(c), g.deleteProgram(k), Error('Error compiling fragment shader: ' + f))
      if (!g.getShaderParameter(c, g.COMPILE_STATUS)) throw ((f = g.getShaderInfoLog(c)), g.deleteShader(h), g.deleteShader(c), g.deleteProgram(k), Error('Error compiling vertex shader: ' + f))
      if (!g.getProgramParameter(k, g.LINK_STATUS)) throw ((f = g.getProgramInfoLog(k)), g.deleteShader(h), g.deleteShader(c), g.deleteProgram(k), Error('Error linking shader program: ' + f))
      ;(a = e.FilterUnprintableChars(g.getProgramInfoLog(k) || '').trim()) && !e.IsStringAllWhitespace(a) && console.info(`[WebGL] Shader program '${f}' compilation log: `, a)
      g.deleteShader(h)
      g.deleteShader(c)
      return k
    }
    static async Create(a, c, d, f) {
      d = await e.Gfx.WebGLShaderProgram.Compile(a, c.src, d, f)
      return new e.Gfx.WebGLShaderProgram(a, d, c, f)
    }
    constructor(a, c, d, f) {
      const g = a.GetContext()
      var h = a.GetBatchState()
      a.EndBatch()
      g.useProgram(c)
      this._gl = g
      this._renderer = a
      this._name = f
      this._shaderProgram = c
      this._isDeviceTransform = '<default-device-transform>' === f
      f = g.getAttribLocation(c, 'aPos')
      const k = g.getAttribLocation(c, 'aTex')
      c = g.getAttribLocation(c, 'aPoints')
      ;-1 !== f && (g.bindBuffer(g.ARRAY_BUFFER, a._vertexBuffer), g.vertexAttribPointer(f, a.GetNumVertexComponents(), g.FLOAT, !1, 0, 0), g.enableVertexAttribArray(f))
      ;-1 !== k && (g.bindBuffer(g.ARRAY_BUFFER, a._texcoordBuffer), g.vertexAttribPointer(k, 2, g.FLOAT, !1, 0, 0), g.enableVertexAttribArray(k))
      ;-1 !== c && (g.bindBuffer(g.ARRAY_BUFFER, a._pointBuffer), g.vertexAttribPointer(c, 4, g.FLOAT, !1, 0, 0), g.enableVertexAttribArray(c))
      g.bindBuffer(g.ARRAY_BUFFER, null)
      this._uMatP = new e.Gfx.WebGLShaderUniform(this, 'matP', 'mat4')
      this._uMatMV = new e.Gfx.WebGLShaderUniform(this, 'matMV', 'mat4')
      this._uColor = new e.Gfx.WebGLShaderUniform(this, 'color', 'vec4')
      this._uSamplerFront = new e.Gfx.WebGLShaderUniform(this, 'samplerFront', 'sampler')
      this._uPointTexStart = new e.Gfx.WebGLShaderUniform(this, 'pointTexStart', 'vec2')
      this._uPointTexEnd = new e.Gfx.WebGLShaderUniform(this, 'pointTexEnd', 'vec2')
      this._uZElevation = new e.Gfx.WebGLShaderUniform(this, 'zElevation', 'float')
      this._uTileSize = new e.Gfx.WebGLShaderUniform(this, 'tileSize', 'vec2')
      this._uTileSpacing = new e.Gfx.WebGLShaderUniform(this, 'tileSpacing', 'vec2')
      this._uColor2 = new e.Gfx.WebGLShaderUniform(this, 'color2_', 'vec4')
      this._uOutlineThickness = new e.Gfx.WebGLShaderUniform(this, 'outlineThickness', 'float')
      this._uSamplerBack = new e.Gfx.WebGLShaderUniform(this, 'samplerBack', 'sampler')
      this._uDestStart = new e.Gfx.WebGLShaderUniform(this, 'destStart', 'vec2')
      this._uDestEnd = new e.Gfx.WebGLShaderUniform(this, 'destEnd', 'vec2')
      this._uSrcStart = new e.Gfx.WebGLShaderUniform(this, 'srcStart', 'vec2')
      this._uSrcEnd = new e.Gfx.WebGLShaderUniform(this, 'srcEnd', 'vec2')
      this._uSrcOriginStart = new e.Gfx.WebGLShaderUniform(this, 'srcOriginStart', 'vec2')
      this._uSrcOriginEnd = new e.Gfx.WebGLShaderUniform(this, 'srcOriginEnd', 'vec2')
      this._uPixelSize = new e.Gfx.WebGLShaderUniform(this, 'pixelSize', 'vec2')
      this._uSeconds = new e.Gfx.WebGLShaderUniform(this, 'seconds', 'float')
      this._uLayerScale = new e.Gfx.WebGLShaderUniform(this, 'layerScale', 'float')
      this._uLayerAngle = new e.Gfx.WebGLShaderUniform(this, 'layerAngle', 'float')
      this._uLayoutStart = new e.Gfx.WebGLShaderUniform(this, 'layoutStart', 'vec2')
      this._uLayoutEnd = new e.Gfx.WebGLShaderUniform(this, 'layoutEnd', 'vec2')
      this._hasAnyOptionalUniforms = !!(
        this._uPixelSize.IsUsed() ||
        this._uSeconds.IsUsed() ||
        this._uSamplerBack.IsUsed() ||
        this._uDestStart.IsUsed() ||
        this._uDestEnd.IsUsed() ||
        this._uSrcStart.IsUsed() ||
        this._uSrcEnd.IsUsed() ||
        this._uSrcOriginStart.IsUsed() ||
        this._uSrcOriginEnd.IsUsed() ||
        this._uLayerScale.IsUsed() ||
        this._uLayerAngle.IsUsed() ||
        this._uLayoutStart.IsUsed() ||
        this._uLayoutEnd.IsUsed()
      )
      this._extendBoxHorizontal = d.extendBoxHorizontal || 0
      this._extendBoxVertical = d.extendBoxVertical || 0
      this._crossSampling = !!d.crossSampling
      this._mustPreDraw = !!d.mustPreDraw
      this._preservesOpaqueness = !!d.preservesOpaqueness
      this._animated = !!d.animated
      a = d.parameters || []
      this._uCustomParameters = []
      this._usesDest = this._uDestStart.IsUsed() || this._uDestEnd.IsUsed()
      this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed()
      this._needsPostDrawOrExtendBox = this._crossSampling || this._usesDest || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
      this._hasCurrentMatMV = this._hasCurrentMatP = !1
      this._uColor.Init4f(1, 1, 1, 1)
      this._uColor2.Init4f(1, 1, 1, 1)
      this._uSamplerFront.Init1i(0)
      this._uSamplerBack.Init1i(1)
      this._uPointTexStart.Init2f(0, 0)
      this._uPointTexEnd.Init2f(1, 1)
      this._uZElevation.Init1f(0)
      this._uTileSize.Init2f(0, 0)
      this._uTileSpacing.Init2f(0, 0)
      this._uDestStart.Init2f(0, 0)
      this._uDestEnd.Init2f(1, 1)
      this._uSrcStart.Init2f(0, 0)
      this._uSrcEnd.Init2f(0, 0)
      this._uSrcOriginStart.Init2f(0, 0)
      this._uSrcOriginEnd.Init2f(0, 0)
      this._uPixelSize.Init2f(0, 0)
      this._uLayerScale.Init1f(1)
      this._uLayerAngle.Init1f(0)
      this._uSeconds.Init1f(0)
      this._uLayoutStart.Init2f(0, 0)
      this._uLayoutEnd.Init2f(0, 0)
      this._uOutlineThickness.Init1f(1)
      for (const m of a) (a = m[2]), (d = new e.Gfx.WebGLShaderUniform(this, m[0], a)), 'color' === a ? d.Init3f(0, 0, 0) : d.Init1f(0), this._uCustomParameters.push(d)
      this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(h.currentMatP) : (this.UpdateMatP(h.currentMatP, !0), this.UpdateMatMV(h.currentMV, !0))
      h = h.currentShader
      g.useProgram(h ? h._shaderProgram : null)
    }
    Release() {
      this._gl.deleteProgram(this._shaderProgram)
      this._shaderProgram = null
      this._renderer._RemoveShaderProgram(this)
      this._renderer = this._gl = null
    }
    GetName() {
      return this._name
    }
    GetWebGLContext() {
      return this._gl
    }
    GetShaderProgram() {
      return this._shaderProgram
    }
    UsesDest() {
      return this._usesDest
    }
    UsesCrossSampling() {
      return this._crossSampling
    }
    MustPreDraw() {
      return this._mustPreDraw
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness
    }
    ExtendsBox() {
      return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    GetBoxExtendHorizontal() {
      return this._extendBoxHorizontal
    }
    GetBoxExtendVertical() {
      return this._extendBoxVertical
    }
    UsesAnySrcRectOrPixelSize() {
      return this._usesAnySrcRectOrPixelSize
    }
    NeedsPostDrawOrExtendsBox() {
      return this._needsPostDrawOrExtendBox
    }
    GetParameterCount() {
      return this._uCustomParameters.length
    }
    GetParameterType(a) {
      return this._uCustomParameters[a].GetType()
    }
    AreCustomParametersAlreadySetInBatch(a) {
      for (let c = 0, d = a.length; c < d; ++c) if (!this._uCustomParameters[c].IsSetToCustomInBatch(a[c])) return !1
      return !0
    }
    SetCustomParametersInBatch(a) {
      for (let c = 0, d = a.length; c < d; ++c) this._uCustomParameters[c].SetBatchValueCustom(a[c])
    }
    AreOptionalUniformsAlreadySetInBatch(a, c, d, f, g, h, k, m, r) {
      return this._uSamplerBack.IsUsed() ||
        (this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(g, h)) ||
        (this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop())) ||
        (this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom())) ||
        (this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(k)) ||
        (this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(m)) ||
        (this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(c.getLeft(), c.getTop())) ||
        (this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(c.getRight(), c.getBottom())) ||
        (this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(d.getLeft(), d.getTop())) ||
        (this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(d.getRight(), d.getBottom())) ||
        (this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(f.getLeft(), f.getTop())) ||
        (this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(f.getTop(), f.getBottom())) ||
        (this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(r))
        ? !1
        : !0
    }
    SetOptionalUniformsInBatch(a, c, d, f, g, h, k, m, r) {
      this._uSamplerBack.IsUsed() ||
        (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(g, h),
        this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(a.getLeft(), a.getTop()),
        this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()),
        this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(k),
        this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(m),
        this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(c.getLeft(), c.getTop()),
        this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(c.getRight(), c.getBottom()),
        this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(d.getLeft(), d.getTop()),
        this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(d.getRight(), d.getBottom()),
        this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(f.getLeft(), f.getTop()),
        this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(f.getTop(), f.getBottom()),
        this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(r))
    }
    IsAnimated() {
      return this._animated
    }
    UpdateMatP(a, c) {
      ;(this._hasCurrentMatP && !c) || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a), (this._hasCurrentMatP = !0))
    }
    SetMatPStale() {
      this._hasCurrentMatP = !1
    }
    UpdateMatMV(a, c) {
      ;(this._hasCurrentMatMV && !c) || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a), (this._hasCurrentMatMV = !0))
    }
    SetMatMVStale() {
      this._hasCurrentMatMV = !1
    }
    _UpdateDeviceTransformUniforms(a) {
      if (!this._isDeviceTransform) throw Error('not device transform shader')
      this._uMatP.UpdateMatrix4fv(a)
      a = this._renderer
      const c = a.GetWidth() / 2,
        d = a.GetHeight() / 2
      a = a.CalculateLookAtModelView2(c, d, a.GetDefaultCameraZ() * self.devicePixelRatio, c, d, 0)
      this._uMatMV.UpdateMatrix4fv(a)
    }
    UpdateColor(a) {
      this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3])
    }
    static GetReservedUniformNames() {
      return b
    }
    static GetDefaultVertexShaderSource(a) {
      a = a ? 'highmedp' : 'mediump'
      return [
        '#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;',
        `attribute ${a} vec2 aTex;`,
        `varying ${a} vec2 vTex;`,
        'uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}'
      ].join('\n')
    }
    static GetTextureFillFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}'
    }
    static GetTilemapFragmentShaderSource() {
      return '#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}'
    }
    static GetPointVertexShaderSource() {
      return 'attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}'
    }
    static GetPointFragmentShaderSource() {
      return 'uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexStart, pointTexEnd, gl_PointCoord)) * color * pointOpacity;\n}'
    }
    static GetColorFillFragmentShaderSource() {
      return 'uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}'
    }
    static GetLinearGradientFillFragmentShaderSource() {
      return 'precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}'
    }
    static GetSmoothLineFillFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}'
    }
    static GetHardEllipseFillFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}'
    }
    static GetHardEllipseOutlineFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}'
    }
    static GetSmoothEllipseFillFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}'
    }
    static GetSmoothEllipseOutlineFragmentShaderSource() {
      return 'varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}'
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix.mat4,
    a = new Map([
      ['float', 1],
      ['percent', 1],
      ['sampler', 1],
      ['vec2', 2],
      ['vec3', 3],
      ['color', 3],
      ['vec4', 4],
      ['mat4', 16]
    ])
  e.Gfx.WebGLShaderUniform = class {
    constructor(c, d, f) {
      if (!a.has(f)) throw Error('invalid uniform type')
      this._owner = c
      this._gl = this._owner.GetWebGLContext()
      this._name = d
      this._type = f
      this._isColorType = 'color' === this._type
      this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), d)
      this._isUsed = !!this._location
      c = a.get(f)
      this._lastValue = new Float32Array(c)
      this._lastBatchValue = new Float32Array(c)
    }
    Release() {
      this._location = this._gl = this._owner = null
    }
    IsUsed() {
      return this._isUsed
    }
    GetType() {
      return this._type
    }
    IsColorType() {
      return this._isColorType
    }
    Init1f(c) {
      this.IsUsed() && ((this._lastValue[0] = c), this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, c))
    }
    Init1i(c) {
      this.IsUsed() && ((this._lastValue[0] = c), this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, c))
    }
    Init2f(c, d) {
      this.IsUsed() && ((this._lastValue[0] = c), (this._lastValue[1] = d), this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, c, d))
    }
    Init3f(c, d, f) {
      this.IsUsed() && ((this._lastValue[0] = c), (this._lastValue[1] = d), (this._lastValue[2] = f), this._lastBatchValue.set(this._lastValue), this._gl.uniform3f(this._location, c, d, f))
    }
    Init4f(c, d, f, g) {
      this.IsUsed() && ((this._lastValue[0] = c), (this._lastValue[1] = d), (this._lastValue[2] = f), (this._lastValue[3] = g), this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, c, d, f, g))
    }
    Update1f(c) {
      c = Math.fround(c)
      const d = this._lastValue
      d[0] !== c && ((d[0] = c), this._gl.uniform1f(this._location, c))
    }
    Update1i(c) {
      const d = this._lastValue
      d[0] !== c && ((d[0] = c), this._gl.uniform1i(this._location, c))
    }
    Update2f(c, d) {
      c = Math.fround(c)
      d = Math.fround(d)
      const f = this._lastValue
      if (f[0] !== c || f[1] !== d) (f[0] = c), (f[1] = d), this._gl.uniform2f(this._location, c, d)
    }
    Update3f(c, d, f) {
      c = Math.fround(c)
      d = Math.fround(d)
      f = Math.fround(f)
      const g = this._lastValue
      if (g[0] !== c || g[1] !== d || g[2] !== f) (g[0] = c), (g[1] = d), (g[2] = f), this._gl.uniform3f(this._location, c, d, f)
    }
    Update4f(c, d, f, g) {
      c = Math.fround(c)
      d = Math.fround(d)
      f = Math.fround(f)
      g = Math.fround(g)
      const h = this._lastValue
      if (h[0] !== c || h[1] !== d || h[2] !== f || h[3] !== g) (h[0] = c), (h[1] = d), (h[2] = f), (h[3] = g), this._gl.uniform4f(this._location, c, d, f, g)
    }
    UpdateMatrix4fv(c) {
      const d = this._lastValue
      b.exactEquals(d, c) || (e.typedArraySet16(d, c, 0), this._gl.uniformMatrix4fv(this._location, !1, c))
    }
    IsSetToCustomInBatch(c) {
      const d = this._lastBatchValue
      return this.IsColorType() ? d[0] === Math.fround(c.getR()) && d[1] === Math.fround(c.getG()) && d[2] === Math.fround(c.getB()) : d[0] === Math.fround(c)
    }
    SetBatchValueCustom(c) {
      const d = this._lastBatchValue
      this.IsColorType() ? ((d[0] = c.getR()), (d[1] = c.getG()), (d[2] = c.getB())) : (d[0] = c)
    }
    IsSetTo1InBatch(c) {
      return this._lastBatchValue[0] === Math.fround(c)
    }
    IsSetTo2InBatch(c, d) {
      const f = this._lastBatchValue
      return f[0] === Math.fround(c) && f[1] === Math.fround(d)
    }
    SetBatch1(c) {
      this._lastBatchValue[0] = c
    }
    SetBatch2(c, d) {
      const f = this._lastBatchValue
      f[0] = c
      f[1] = d
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec4,
    c = b.mat4
  e.Gfx.BatchState = class {
    constructor(d) {
      this.renderer = d
      this.currentMV = c.create()
      this.currentMatP = c.create()
      this.currentFramebuffer = null
      this.currentColor = a.fromValues(1, 1, 1, 1)
      this.currentShader = null
      this.pointTexCoords = new e.Rect()
      this.clearColor = e.New(e.Color, 0, 0, 0, 0)
    }
  }
  e.Gfx.WebGLBatchJob = class {
    constructor(d) {
      const f = new ArrayBuffer(96)
      this._type = 0
      this._batchState = d
      this._gl = d.renderer.GetContext()
      this._indexCount = this._startIndex = 0
      this._texParam = null
      this._mat4param = new Float32Array(f, 0, 16)
      this._colorParam = new Float32Array(f, 64, 4)
      this._srcOriginRect = new Float32Array(f, 80, 4)
      this._shaderParams = []
    }
    InitQuad(d, f) {
      this._type = 1
      this._startIndex = d
      this._indexCount = f
    }
    DoQuad() {
      const d = this._gl
      d.drawElements(d.TRIANGLES, this._indexCount, d.UNSIGNED_SHORT, this._startIndex)
    }
    InitSetTexture(d) {
      this._type = 2
      this._texParam = d
    }
    DoSetTexture() {
      const d = this._gl,
        f = this._texParam
      d.bindTexture(d.TEXTURE_2D, f ? f._GetTexture() : null)
    }
    InitSetColor(d) {
      this._type = 3
      d.writeToTypedArray(this._colorParam, 0)
    }
    DoSetColor() {
      const d = this._colorParam,
        f = this._batchState
      a.copy(f.currentColor, d)
      f.currentShader.UpdateColor(d)
    }
    InitSetGradientColor(d) {
      this._type = 21
      d.writeToTypedArray(this._colorParam, 0)
    }
    DoSetGradientColor() {
      const d = this._colorParam,
        f = this._batchState.currentShader
      f._uColor2.IsUsed() && f._uColor2.Update4f(d[0], d[1], d[2], d[3])
    }
    InitSetBlend(d, f) {
      this._type = 4
      this._startIndex = d
      this._indexCount = f
    }
    DoSetBlend() {
      this._gl.blendFunc(this._startIndex, this._indexCount)
    }
    InitSetViewport(d, f, g, h) {
      this._type = 5
      const k = this._colorParam
      k[0] = d
      k[1] = f
      k[2] = g
      k[3] = h
    }
    DoSetViewport() {
      const d = this._colorParam
      this._gl.viewport(d[0], d[1], d[2], d[3])
    }
    InitSetProjection(d) {
      this._type = 6
      c.copy(this._mat4param, d)
    }
    DoSetProjection() {
      const d = this._batchState,
        f = d.renderer._allShaderPrograms,
        g = d.currentShader,
        h = this._mat4param
      for (let k = 0, m = f.length; k < m; ++k) {
        const r = f[k]
        r === g ? r.UpdateMatP(h, !0) : r.SetMatPStale()
      }
      c.copy(d.currentMatP, h)
    }
    InitSetModelView(d) {
      this._type = 7
      c.copy(this._mat4param, d)
    }
    DoSetModelView() {
      const d = this._batchState,
        f = d.renderer._allShaderPrograms,
        g = d.currentShader,
        h = this._mat4param
      for (let k = 0, m = f.length; k < m; ++k) {
        const r = f[k]
        r === g ? r.UpdateMatMV(h, !0) : r.SetMatMVStale()
      }
      c.copy(d.currentMV, h)
    }
    InitSetRenderTarget(d) {
      this._type = 8
      this._texParam = d
    }
    DoSetRenderTarget() {
      const d = this._gl
      var f = this._texParam
      const g = this._batchState
      f ? ((f = f._GetFramebuffer()), (g.currentFramebuffer = f), d.bindFramebuffer(d.FRAMEBUFFER, f)) : ((g.currentFramebuffer = null), d.bindFramebuffer(d.FRAMEBUFFER, null))
    }
    InitClearSurface(d) {
      this._type = 9
      d.writeToTypedArray(this._mat4param, 0)
    }
    InitClearSurface2(d, f, g, h) {
      this._type = 9
      const k = this._mat4param
      k[0] = d
      k[1] = f
      k[2] = g
      k[3] = h
    }
    DoClearSurface() {
      const d = this._gl
      var f = this._mat4param,
        g = this._batchState
      const h = g.clearColor
      ;(g = g.renderer._isScissorViewport && e.isDebug) && d.disable(d.SCISSOR_TEST)
      const k = f[0],
        m = f[1],
        r = f[2]
      f = f[3]
      h.equalsRgba(k, m, r, f) || (d.clearColor(k, m, r, f), h.setRgba(k, m, r, f))
      d.clear(d.COLOR_BUFFER_BIT)
      g && d.enable(d.SCISSOR_TEST)
    }
    InitClearRect(d, f, g, h, k, m, r, w) {
      this._type = 10
      const p = this._mat4param
      p[0] = d
      p[1] = f
      p[2] = g
      p[3] = h
      p[4] = k
      p[5] = m
      p[6] = r
      p[7] = w
    }
    DoClearRectangle() {
      const d = this._gl
      var f = this._mat4param,
        g = this._batchState
      const h = g.renderer
      g = g.clearColor
      h._isScissorViewport || d.enable(d.SCISSOR_TEST)
      d.scissor(f[0], f[1], f[2], f[3])
      const k = f[4],
        m = f[5],
        r = f[6]
      f = f[7]
      g.equalsRgba(k, m, r, f) || (d.clearColor(k, m, r, f), g.setRgba(k, m, r, f))
      d.clear(d.COLOR_BUFFER_BIT)
      h._isScissorViewport ? d.scissor(0, 0, h._viewportScissorWidth, h._viewportScissorHeight) : d.disable(d.SCISSOR_TEST)
    }
    InitSetPointTexCoords(d) {
      this._type = 15
      d.writeToTypedArray(this._mat4param, 0)
    }
    DoSetPointTextureCoords() {
      const d = this._mat4param
      this._batchState.pointTexCoords.set(d[0], d[1], d[2], d[3])
    }
    InitPoints(d, f) {
      this._type = 11
      this._startIndex = d
      this._indexCount = 1
      this._mat4param[0] = f
    }
    DoPoints() {
      const d = this._gl,
        f = this._batchState,
        g = f.renderer._spPoints
      d.useProgram(g._shaderProgram)
      g.UpdateMatP(f.currentMatP, !1)
      g.UpdateMatMV(f.currentMV, !1)
      var h = f.pointTexCoords
      g._uPointTexStart.IsUsed() && g._uPointTexStart.Update2f(h.getLeft(), h.getTop())
      g._uPointTexEnd.IsUsed() && g._uPointTexEnd.Update2f(h.getRight(), h.getBottom())
      h = this._mat4param[0]
      g._uZElevation.IsUsed() && g._uZElevation.Update1f(h)
      g._uColor.IsUsed() && ((h = f.currentColor), g._uColor.Update4f(h[0], h[1], h[2], h[3]))
      d.drawArrays(d.POINTS, this._startIndex / 4, this._indexCount)
      d.useProgram(f.currentShader._shaderProgram)
    }
    InitSetProgram(d) {
      this._type = 12
      this._texParam = d
    }
    DoSetProgram() {
      var d = this._gl
      const f = this._batchState,
        g = this._texParam
      f.currentShader = g
      d.useProgram(g._shaderProgram)
      g.UpdateMatP(f.currentMatP, !1)
      g.UpdateMatMV(f.currentMV, !1)
      g._uColor.IsUsed() && ((d = f.currentColor), g._uColor.Update4f(d[0], d[1], d[2], d[3]))
    }
    InitSetProgramParameters() {
      this._type = 13
    }
    DoSetProgramParameters() {
      const d = this._batchState.currentShader
      d._hasAnyOptionalUniforms && this._DoSetOptionalUniformProgramParameters(d)
      d._uCustomParameters.length && this._DoUpdateCustomProgramParameters(d)
    }
    _DoSetOptionalUniformProgramParameters(d) {
      const f = this._gl,
        g = this._mat4param,
        h = this._colorParam,
        k = this._srcOriginRect
      if (d._uSamplerBack.IsUsed()) {
        const m = this._batchState.renderer,
          r = this._texParam
        m._lastTexture1 !== r && (f.activeTexture(f.TEXTURE1), f.bindTexture(f.TEXTURE_2D, r ? r._GetTexture() : null), (m._lastTexture1 = r), f.activeTexture(f.TEXTURE0))
      }
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(g[0], g[1])
      d._uDestStart.IsUsed() && d._uDestStart.Update2f(g[2], g[3])
      d._uDestEnd.IsUsed() && d._uDestEnd.Update2f(g[4], g[5])
      d._uLayerScale.IsUsed() && d._uLayerScale.Update1f(g[6])
      d._uLayerAngle.IsUsed() && d._uLayerAngle.Update1f(g[7])
      d._uSrcStart.IsUsed() && d._uSrcStart.Update2f(g[12], g[13])
      d._uSrcEnd.IsUsed() && d._uSrcEnd.Update2f(g[14], g[15])
      d._uSrcOriginStart.IsUsed() && d._uSrcOriginStart.Update2f(k[0], k[1])
      d._uSrcOriginEnd.IsUsed() && d._uSrcOriginEnd.Update2f(k[2], k[3])
      d._uLayoutStart.IsUsed() && d._uLayoutStart.Update2f(h[0], h[1])
      d._uLayoutEnd.IsUsed() && d._uLayoutEnd.Update2f(h[2], h[3])
      d._uSeconds.IsUsed() && d._uSeconds.Update1f(this._startIndex)
    }
    _DoUpdateCustomProgramParameters(d) {
      d = d._uCustomParameters
      const f = this._shaderParams
      for (let g = 0, h = d.length; g < h; ++g) {
        const k = d[g],
          m = f[g]
        k.IsColorType() ? k.Update3f(m.getR(), m.getG(), m.getB()) : k.Update1f(m)
      }
    }
    InitInvalidateFramebuffer(d) {
      this._type = 14
      this._texParam = d
    }
    DoInvalidateFramebuffer() {
      const d = this._gl,
        f = this._texParam,
        g = this._batchState.currentFramebuffer
      f !== g && d.bindFramebuffer(d.FRAMEBUFFER, f)
      d.invalidateFramebuffer(d.FRAMEBUFFER, [d.COLOR_ATTACHMENT0])
      f !== g && d.bindFramebuffer(d.FRAMEBUFFER, g)
    }
    InitBlitFramebuffer(d, f, g) {
      this._type = 17
      const h = this._mat4param,
        k = this._batchState.renderer
      h[0] = d.GetWidth()
      h[1] = d.GetHeight()
      h[2] = f ? f.GetWidth() : k.GetWidth()
      h[3] = f ? f.GetHeight() : k.GetHeight()
      h[4] = d.IsLinearSampling() ? 1 : 0
      h[5] = 'stretch' === g
      g = this._shaderParams
      e.clearArray(g)
      g.push(d._GetFramebuffer())
      g.push(f ? f._GetFramebuffer() : null)
    }
    DoBlitFramebuffer() {
      var d = this._mat4param,
        f = this._shaderParams
      const g = this._gl
      var h = d[0],
        k = d[1],
        m = d[2]
      const r = d[3],
        w = 0 !== d[4]
      d = 0 !== d[5]
      const p = f[1]
      g.bindFramebuffer(g.READ_FRAMEBUFFER, f[0])
      g.bindFramebuffer(g.DRAW_FRAMEBUFFER, p)
      d ? g.blitFramebuffer(0, 0, h, k, 0, 0, m, r, g.COLOR_BUFFER_BIT, w ? g.LINEAR : g.NEAREST) : ((f = Math.min(h, m)), (h = Math.min(k, r)), (m = Math.max(k - r, 0)), (k = Math.max(r - k, 0)), g.blitFramebuffer(0, m, f, h + m, 0, k, f, h + k, g.COLOR_BUFFER_BIT, g.NEAREST))
    }
    InitStartQuery(d) {
      this._type = 18
      this._texParam = d
    }
    DoStartQuery() {
      this._texParam.BeginTimeElapsed()
      this._texParam = null
    }
    InitEndQuery(d) {
      this._type = 19
      this._texParam = d
    }
    DoEndQuery() {
      this._texParam.EndTimeElapsed()
      this._texParam = null
    }
    InitSetEllipseParams(d, f, g) {
      this._type = 20
      const h = this._mat4param
      h[0] = d
      h[1] = f
      h[2] = g
    }
    DoSetEllipseParams() {
      const d = this._batchState.currentShader,
        f = this._mat4param
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(f[0], f[1])
      d._uOutlineThickness.IsUsed() && d._uOutlineThickness.Update1f(f[2])
    }
    InitSetTilemapInfo(d, f, g, h, k, m, r) {
      this._type = 16
      const w = this._mat4param
      d.writeToTypedArray(w, 0)
      w[4] = 1 / f
      w[5] = 1 / g
      w[6] = h / f
      w[7] = k / g
      w[8] = m / f
      w[9] = r / g
    }
    DoSetTilemapInfo() {
      const d = this._batchState.currentShader,
        f = this._mat4param
      d._uSrcStart.IsUsed() && d._uSrcStart.Update2f(f[0], f[1])
      d._uPixelSize.IsUsed() && d._uPixelSize.Update2f(f[4], f[5])
      d._uTileSize.IsUsed() && d._uTileSize.Update2f(f[6], f[7])
      d._uTileSpacing.IsUsed() && d._uTileSpacing.Update2f(f[8], f[9])
    }
    InitClearDepth() {
      this._type = 22
    }
    DoClearDepth() {
      const d = this._gl
      d.clear(d.DEPTH_BUFFER_BIT)
    }
    InitSetDepthEnabled(d) {
      this._type = 23
      this._startIndex = d ? 1 : 0
    }
    DoSetDepthEnabled() {
      const d = this._gl
      0 === this._startIndex ? (d.disable(d.DEPTH_TEST), d.depthMask(!1)) : (d.enable(d.DEPTH_TEST), d.depthMask(!0))
    }
    Run() {
      switch (this._type) {
        case 1:
          this.DoQuad()
          break
        case 2:
          this.DoSetTexture()
          break
        case 3:
          this.DoSetColor()
          break
        case 4:
          this.DoSetBlend()
          break
        case 5:
          this.DoSetViewport()
          break
        case 6:
          this.DoSetProjection()
          break
        case 7:
          this.DoSetModelView()
          break
        case 8:
          this.DoSetRenderTarget()
          break
        case 9:
          this.DoClearSurface()
          break
        case 10:
          this.DoClearRectangle()
          break
        case 11:
          this.DoPoints()
          break
        case 12:
          this.DoSetProgram()
          break
        case 13:
          this.DoSetProgramParameters()
          break
        case 14:
          this.DoInvalidateFramebuffer()
          break
        case 15:
          this.DoSetPointTextureCoords()
          break
        case 16:
          this.DoSetTilemapInfo()
          break
        case 17:
          this.DoBlitFramebuffer()
          break
        case 18:
          this.DoStartQuery()
          break
        case 19:
          this.DoEndQuery()
          break
        case 20:
          this.DoSetEllipseParams()
          break
        case 21:
          this.DoSetGradientColor()
          break
        case 22:
          this.DoClearDepth()
          break
        case 23:
          this.DoSetDepthEnabled()
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = {
      timeout: 60
    },
    a = new e.Color(0, 0, 0, 1),
    c = new Set(['left', 'center', 'right']),
    d = new Set(['top', 'center', 'bottom']),
    f = new Set(['word', 'character']),
    g = new Set()
  e.FontManager &&
    e.FontManager.addEventListener('fontload', p => {
      p = p.font.GetName()
      for (const q of g) (q.IsBBCodeEnabled() || e.equalsNoCase(q.GetFontName(), p)) && q._SetTextChanged()
    })

  function h(p, q, t, x, v, u) {
    q ? ('Gecko' === e.Platform.BrowserEngine ? p.strokeText(t, x, v, u) : p.strokeText(t, x, v)) : 'Gecko' === e.Platform.BrowserEngine ? p.fillText(t, x, v, u) : p.fillText(t, x, v)
  }

  function k(p, q, t, x, v, u) {
    q ? p.strokeRect(t, x, v, u) : p.fillRect(t, x, v, u)
  }

  function m(p) {
    return (4 / 3) * p
  }
  let r = !1,
    w = !1
  e.Gfx.RendererText = class {
    constructor(p, q) {
      q = Object.assign({}, b, q)
      this._renderer = p
      this._fontName = 'Arial'
      this._fontSize = 16
      this._fontSizeScale = 1
      this._lineHeight = 0
      this._isItalic = this._isBold = !1
      this._colorStr = 'black'
      this._isBBcodeEnabled = !1
      this.onloadfont = null
      this._alreadyLoadedFonts = new Set()
      this._horizontalAlign = 'left'
      this._verticalAlign = 'top'
      this._text = ''
      this._bbString = null
      this._wrappedText = e.New(e.WordWrap)
      this._wrapMode = 'word'
      this._isUpdating = this._textChanged = !1
      this._isAsync = !0
      this._drawMaxCharCount = -1
      this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0
      this._zoom = 1
      this._changed = !1
      this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null
      this._lastCanvasHeight = this._lastCanvasWidth = -1
      this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = ''
      this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity = 1
      this._measureTextCallback = (t, x) => this._MeasureText(t, x)
      this._texture = null
      this._textureHeight = this._textureWidth = 0
      this._rcTex = new e.Rect()
      this._scaleFactor = 1
      this._needToRecreateTexture = !1
      this._textureTimeout = new e.IdleTimeout(() => {
        this.ReleaseTexture()
        this._SetTextCanvasSize(8, 8)
      }, q.timeout)
      this.ontextureupdate = null
      this._wasReleased = !1
      g.add(this)
    }
    Release() {
      this.onloadfont = null
      this._alreadyLoadedFonts.clear()
      this._measureTextCallback = this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = this._bbString = null
      this._textureTimeout.Release()
      this.ontextureupdate = null
      this.ReleaseTexture()
      this._wrappedText.Clear()
      this._renderer = this._wrappedText = null
      this._wasReleased = !0
      g.delete(this)
    }
    _SetChanged() {
      this._changed = !0
    }
    _SetTextChanged() {
      this._SetChanged()
      this._wrappedText.Clear()
      this._textChanged = !0
    }
    SetIsAsync(p) {
      this._isAsync = !!p
    }
    IsAsync() {
      return this._isAsync
    }
    SetBBCodeEnabled(p) {
      p = !!p
      this._isBBcodeEnabled !== p && ((p = (this._isBBcodeEnabled = p) ? 'alphabetic' : 'top'), this._textContext && (this._textContext.textBaseline = p), this._measureContext && (this._measureContext.textBaseline = p), this._SetTextChanged())
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled
    }
    SetFontName(p) {
      p || (p = 'serif')
      this._fontName !== p && ((this._fontName = p), this._SetTextChanged())
    }
    GetFontName() {
      return this._fontName
    }
    SetFontSize(p) {
      0.1 > p && (p = 0.1)
      this._fontSize !== p && ((this._fontSize = p), this._SetTextChanged())
    }
    SetFontSizeScale(p) {
      this._fontSizeScale !== p && ((this._fontSizeScale = p), this._SetTextChanged())
    }
    SetLineHeight(p) {
      this._lineHeight !== p && ((this._lineHeight = p), this._SetChanged())
    }
    SetBold(p) {
      p = !!p
      this._isBold !== p && ((this._isBold = p), this._SetTextChanged())
    }
    SetItalic(p) {
      p = !!p
      this._isItalic !== p && ((this._isItalic = p), this._SetTextChanged())
    }
    SetDrawMaxCharacterCount(p) {
      p = Math.floor(p)
      this._drawMaxCharCount !== p && ((this._drawMaxCharCount = p), this._SetChanged())
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount
    }
    _GetStyleTag(p, q) {
      for (let t = p.length - 1; 0 <= t; --t) {
        const x = p[t]
        if (x.tag === q) return x
      }
      return null
    }
    _HasStyleTag(p, q) {
      return !!this._GetStyleTag(p, q)
    }
    _GetFontString(p, q) {
      let t = []
      ;(this._isBold || this._HasStyleTag(q, 'b')) && t.push('bold')
      ;(this._isItalic || this._HasStyleTag(q, 'i')) && t.push('italic')
      var x = this._GetStyleTag(q, 'size')
      x = (x ? parseFloat(x.param) : this._fontSize) * this._fontSizeScale
      p ? t.push(x + 'pt') : t.push(x * this._scaleFactor * this._zoom * self.devicePixelRatio + 'pt')
      p = this._fontName
      ;(q = this._GetStyleTag(q, 'font')) && q.param && ((p = q.param), this.onloadfont && !this._alreadyLoadedFonts.has(p) && (this.onloadfont(p), this._alreadyLoadedFonts.add(p)))
      p && t.push('"' + p + '"')
      return t.join(' ')
    }
    SetColor(p) {
      p instanceof e.Color && (p = p.getCssRgb())
      this._colorStr !== p && ((this._colorStr = p), this._SetChanged())
    }
    SetColorRgb(p, q, t) {
      a.setRgb(p, q, t)
      this.SetColor(a)
    }
    SetHorizontalAlignment(p) {
      if (!c.has(p)) throw Error('invalid horizontal alignment')
      this._horizontalAlign !== p && ((this._horizontalAlign = p), this._SetChanged())
    }
    SetVerticalAlignment(p) {
      if (!d.has(p)) throw Error('invalid vertical alignment')
      this._verticalAlign !== p && ((this._verticalAlign = p), this._SetChanged())
    }
    SetWordWrapMode(p) {
      if (!f.has(p)) throw Error('invalid word wrap mode')
      this._wrapMode !== p && ((this._wrapMode = p), this._SetTextChanged())
    }
    SetText(p) {
      this._text !== p && ((this._text = p), this._SetTextChanged())
    }
    SetSize(p, q, t) {
      'undefined' === typeof t && (t = 1)
      if (!(0 >= p || 0 >= p || (this._cssWidth === p && this._cssHeight === q && this._zoom === t))) {
        ;(1 === this._zoom) !== (1 === t) && (this._needToRecreateTexture = !0)
        var x = this._cssWidth,
          v = this._zoom
        this._cssWidth = p
        this._cssHeight = q
        this._zoom = t
        p = self.devicePixelRatio
        this._width = this._cssWidth * this._zoom * p
        this._height = this._cssHeight * this._zoom * p
        p = Math.max(this._width, this._height)
        q = Math.min(this._renderer.GetMaxTextureSize(), 2048)
        t = 1
        p > q && ((t = q / p), (this._width = Math.min(this._width * t, q)), (this._height = Math.min(this._height * t, q)))
        this._scaleFactor = t
        0 < this._textureWidth && 0 < this._textureHeight && this._zoom === v && this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight)
        this._cssWidth !== x ? this._SetTextChanged() : this._SetChanged()
      }
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    GetTextWidth() {
      this._MaybeWrapText()
      return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
      this._MaybeWrapText()
      return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() * (this._lineHeight + 4) - this._lineHeight
    }
    GetTexture() {
      this._textureTimeout.Reset()
      this._MaybeUpdate()
      return this._texture
    }
    _MaybeUpdate() {
      ;(this._texture && !this._changed && !this._textChanged) || this._isUpdating || 0 >= this._width || 0 >= this._height || ((this._changed = !1), (this._isUpdating = !0), this._isAsync ? e.Asyncify(() => this._DoUpdate()) : this._DoUpdate())
    }
    _DoUpdate() {
      this._wasReleased || (this._SetTextCanvasSize(Math.ceil(this._width), Math.ceil(this._height)), this._MaybeWrapText(), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset(), (this._isUpdating = !1))
    }
    _SetTextCanvasSize(p, q) {
      this._textCanvas || (this._textCanvas = e.CreateCanvas(16, 16))
      let t = !1
      if (this._lastCanvasWidth !== p || this._lastCanvasHeight !== q) (this._lastCanvasWidth = p), (this._lastCanvasHeight = q), (this._textCanvas.width = p), (this._textCanvas.height = q), (t = !0)
      this._textContext || ((this._textContext = this._textCanvas.getContext('2d')), (t = !0))
      t
        ? ((this._textContext.textBaseline = this._isBBcodeEnabled ? 'alphabetic' : 'top'),
          (this._textContext.font = this._lastTextCanvasFont),
          (this._textContext.fillStyle = this._lastTextCanvasFillStyle),
          (this._textContext.strokeStyle = this._lastTextCanvasFillStyle),
          (this._textContext.globalAlpha = this._lastTextCanvasOpacity),
          (this._textContext.lineWidth = this._lastTextCanvasLineWidth))
        : this._textContext.clearRect(0, 0, p, q)
    }
    _MaybeCreateMeasureContext() {
      this._measureContext || ((this._measureContext = e.CreateCanvas(16, 16).getContext('2d')), (this._measureContextTop = e.CreateCanvas(16, 16).getContext('2d')), (this._measureContext.textBaseline = this._isBBcodeEnabled ? 'alphabetic' : 'top'), (this._measureContextTop.textBaseline = 'top'))
    }
    _SetMeasureFontString(p) {
      this._lastMeasureCanvasFont !== p && ((this._lastMeasureCanvasFont = p), (this._measureContext.font = p), (this._measureContextTop.font = p))
    }
    _SupportsFontBoundingBoxMeasurements() {
      if (!r) {
        r = !0
        this._MaybeCreateMeasureContext()
        const p = this._measureContext.measureText('test')
        w = 'number' === typeof p.fontBoundingBoxAscent && 'number' === typeof p.fontBoundingBoxDescent
      }
      return w
    }
    _MaybeWrapText() {
      this._textChanged &&
        (this._MaybeCreateMeasureContext(),
        !this._isBBcodeEnabled ||
          (this._bbString && this._bbString.toString() === this._text) ||
          (this._bbString = new e.BBString(this._text, {
            noEscape: !0
          })),
        this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, 0),
        (this._textChanged = !1))
    }
    _MeasureText(p, q) {
      this._SetMeasureFontString(this._GetFontString(!0, q))
      q = this._GetStyleTag(q, 'size')
      q = (q ? parseFloat(q.param) : this._fontSize) * this._fontSizeScale
      const t = this._measureContext.measureText(p)
      let x = 0
      this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() && ((p = this._measureContextTop.measureText(p)), (x = t.fontBoundingBoxAscent - p.fontBoundingBoxAscent))
      return {
        width: t.width,
        height: m(q),
        fontBoundingBoxAscent: t.fontBoundingBoxAscent || 0,
        fontBoundingBoxDescent: t.fontBoundingBoxDescent || 0,
        topToAlphabeticDistance: x
      }
    }
    _SetDrawFontString(p) {
      this._lastTextCanvasFont !== p && ((this._lastTextCanvasFont = p), (this._textContext.font = p))
    }
    _SetDrawCanvasColor(p) {
      this._lastTextCanvasFillStyle !== p && ((this._lastTextCanvasFillStyle = p), (this._textContext.fillStyle = p), (this._textContext.strokeStyle = p))
    }
    _SetDrawCanvasOpacity(p) {
      this._lastTextCanvasOpacity !== p && ((this._lastTextCanvasOpacity = p), (this._textContext.globalAlpha = p))
    }
    _SetDrawCanvasLineWith(p) {
      this._lastTextCanvasLineWidth !== p && ((this._lastTextCanvasLineWidth = p), (this._textContext.lineWidth = p))
    }
    _DrawTextToCanvas() {
      this._drawCharCount = 0
      const p = this._scaleFactor * this._zoom * self.devicePixelRatio,
        q = (4 + this._lineHeight) * p
      var t = 0
      const x = this._wrappedText.GetLines()
      if (0 !== x.length) {
        var v = this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements(),
          u = x[0].height * p
        'center' === this._verticalAlign
          ? ((t = x.reduce((A, z) => A + z.height * p + q, 0) - q), (t = Math.max(this._height / 2 - t / 2, 0)), v && (u = x[0].topToAlphabeticDistance * p))
          : 'bottom' === this._verticalAlign && ((t = x.reduce((A, z) => A + z.height * p + q, 0) - this._lineHeight * p), (t = this._height - t - (v ? x[x.length - 1].fontBoundingBoxDescent * p : 0) - 2))
        for (let A = 0, z = x.length; A < z; ++A) {
          v = x[A]
          const C = v.height * p,
            E = t
          if (this._isBBcodeEnabled) {
            if (((t += 0 === A ? u : C), 0 < A && t > this._height - 4 * p)) break
          } else if (0 < A && t >= this._height - C) break
          0 <= E && this._DrawTextLine(v, t, p)
          this._isBBcodeEnabled || (t += C)
          t += q
        }
      }
    }
    _DrawTextLine(p, q, t) {
      let x = 0
      'center' === this._horizontalAlign ? (x = (this._width - p.width * t) / 2) : 'right' === this._horizontalAlign && (x = this._width - p.width * t)
      for (const v of p.fragments) this._DrawTextFragment(v, x, q, t, p.height), (x += v.width * t)
    }
    _DrawTextFragment(p, q, t, x, v) {
      const u = this._textContext,
        A = v / 16
      v = p.width * x
      const z = p.height * x,
        C = p.height / 16
      var E = (4 + this._lineHeight) * x
      const J = p.styles
      p = p.text
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return
        this._drawCharCount + p.length > this._drawMaxCharCount && ((p = p.substr(0, this._drawMaxCharCount - this._drawCharCount)), (v = this._MeasureText(p, J).width * x))
        this._drawCharCount += p.length
      }
      const F = this._GetStyleTag(J, 'background'),
        I = this._HasStyleTag(J, 'u'),
        L = this._HasStyleTag(J, 's')
      if ((!e.IsStringAllWhitespace(p) || F || I || L) && !this._HasStyleTag(J, 'hide')) {
        var N = this._GetStyleTag(J, 'offsetx')
        q += N ? parseFloat(N.param) * x : 0
        N = this._GetStyleTag(J, 'offsety')
        t += N ? parseFloat(N.param) * x : 0
        F && (this._SetDrawCanvasColor(F.param), u.fillRect(q, t - z, v, z + E))
        E = this._GetStyleTag(J, 'color')
        this._SetDrawCanvasColor(E ? E.param : this._colorStr)
        E = this._GetStyleTag(J, 'opacity')
        this._SetDrawCanvasOpacity(E ? parseFloat(E.param) / 100 : 1)
        ;(E = this._HasStyleTag(J, 'stroke')) && this._SetDrawCanvasLineWith(C * this._scaleFactor * this._zoom)
        I && k(u, E, q, t + x * A, v, x * A)
        L && k(u, E, q, t - z / 4, v, x * C)
        this._SetDrawFontString(this._GetFontString(!1, J))
        h(u, E, p, q, t, v)
        !E && (this._SetDrawCanvasLineWith(C * this._scaleFactor * this._zoom), (x = this._GetStyleTag(J, 'outline'))) && (this._SetDrawCanvasColor(x.param), h(u, !0, p, q, t, v))
      }
    }
    _UpdateTexture() {
      if (
        !this._renderer.IsContextLost() &&
        ((this._textureWidth = Math.ceil(this._width)),
        (this._textureHeight = Math.ceil(this._height)),
        this._rcTex.set(0, 0, this._width / this._textureWidth, this._height / this._textureHeight),
        this._needToRecreateTexture && (this.ReleaseTexture(), (this._needToRecreateTexture = !1)),
        this._texture ||
          (this._texture = this._renderer.CreateDynamicTexture(this._textureWidth, this._textureHeight, {
            mipMap: 1 === this._zoom,
            mipMapQuality: 'high'
          })),
        this._renderer.UpdateTexture(this._textCanvas, this._texture),
        this.ontextureupdate)
      )
        this.ontextureupdate()
    }
    GetTexRect() {
      return this._rcTex
    }
    ReleaseTexture() {
      this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), (this._texture = null))
    }
    static OnContextLost() {
      for (const p of g) p.ReleaseTexture()
    }
    static GetAll() {
      return g.values()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(a) {
      this._gl = a.GetContext()
      this._version = a.GetWebGLVersionNumber()
      this._timerExt = a._GetDisjointTimerQueryExtension()
      this._query = null
      this._hasResult = this._isActive = !1
      this._result = 0
      this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
    }
    Release() {
      this._DeleteQueryObject()
      this._timerExt = this._gl = null
      this._hasResult = !1
    }
    _DeleteQueryObject() {
      this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query), (this._query = null))
    }
    BeginTimeElapsed() {
      if (this._isActive) throw Error('query already active')
      1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query)
      this._isActive = !0
    }
    EndTimeElapsed() {
      if (!this._isActive) throw Error('query not active')
      1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT)
      this._isActive = !1
    }
    CheckForResult() {
      if (this._query && !this._hasResult && !this._isActive) {
        var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE)
        var c = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT)
        a && !c && ((this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT)), (this._result /= 1e9), (this._hasResult = !0))
        ;(a || c) && this._DeleteQueryObject()
      }
    }
    HasResult() {
      return this._hasResult
    }
    GetResult() {
      if (!this._hasResult) throw Error('no result available')
      return this._result
    }
  }
  e.Gfx.WebGLTimeElapsedQuery = class {
    constructor(a) {
      this._renderer = a
      this._frameNumber = a.GetFrameNumber()
      this._isActive = !1
      this._parentQuery = null
      this._isNested = !1
      this._realQuery = null
      this._queries = []
    }
    Release() {
      for (const a of this._queries) a instanceof b && a.Release()
      e.clearArray(this._queries)
      this._renderer = this._realQuery = this._parentQuery = null
    }
    BeginTimeElapsed() {
      if (this._isActive) throw Error('query already active')
      const a = this._renderer._GetTimeQueryStack()
      0 < a.length ? ((this._isNested = !0), (this._parentQuery = a[a.length - 1]), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : ((this._isNested = !1), (this._parentQuery = null))
      this._isActive = !0
      a.push(this)
      this._StartReal()
    }
    EndTimeElapsed() {
      if (!this._isActive) throw Error('query not active')
      if (this._renderer._GetTimeQueryStack().pop() !== this) throw Error('can only end most nested query')
      this._isActive = !1
      this._EndReal()
      this._parentQuery && (this._parentQuery._StartReal(), (this._parentQuery = null))
    }
    _StartReal() {
      this._realQuery = e.New(b, this._renderer)
      this._queries.push(this._realQuery)
      this._realQuery.BeginTimeElapsed()
    }
    _EndReal() {
      this._realQuery.EndTimeElapsed()
      this._realQuery = null
    }
    CheckForResult() {
      for (const a of this._queries) a.CheckForResult()
    }
    IsNested() {
      return this._isNested
    }
    HasResult() {
      return this._queries.every(a => a.HasResult())
    }
    GetResult() {
      return this._queries.reduce((a, c) => a + c.GetResult(), 0)
    }
    GetFrameNumber() {
      return this._frameNumber
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Gfx.WebGLQueryResultBuffer = class {
    constructor(b, a = 1e3) {
      this._renderer = b
      this._maxQueries = a
      this._buffer = []
      this._renderer._AddQueryResultBuffer(this)
    }
    Release() {
      this.Clear()
      this._renderer._RemoveQueryResultBuffer(this)
      this._renderer = null
    }
    Clear() {
      for (const b of this._buffer) b.Release()
      e.clearArray(this._buffer)
    }
    AddTimeElapsedQuery() {
      const b = new e.Gfx.WebGLTimeElapsedQuery(this._renderer)
      this._buffer.push(b)
      this._buffer.length > this._maxQueries && this._buffer.shift().Release()
      return b
    }
    CheckForResults(b) {
      for (const a of this._buffer) {
        if (a.GetFrameNumber() >= b) break
        if (a.IsNested()) break
        a.CheckForResult()
      }
    }
    GetFrameRangeResultSum(b, a) {
      if (a <= b) return NaN
      let c = 0
      for (const d of this._buffer) {
        if (d.GetFrameNumber() >= a) break
        if (!(d.GetFrameNumber() < b))
          if (d.HasResult()) c += d.GetResult()
          else return NaN
      }
      return c
    }
    DeleteAllBeforeFrameNumber(b) {
      for (let a = 0, c = this._buffer.length; a < c; ++a) {
        const d = this._buffer[a]
        if (d.GetFrameNumber() < b) d.Release()
        else {
          0 < a && this._buffer.splice(0, a)
          break
        }
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec4,
    c = b.mat4,
    d = {
      powerPreference: 'default',
      enableGpuProfiling: !0,
      alpha: !1,
      lowLatency: !1,
      depth: !1,
      maxWebGLVersion: 2
    },
    f = new Set(['default', 'low-power', 'high-performance']),
    g = new e.Quad(0, 0, 1, 0, 1, 1, 0, 1),
    h = c.create(),
    k = c.create(),
    m = new e.Quad(),
    r = new e.Rect()
  let w = null
  e.isDebug &&
    ((self.debug_lose_context = function () {
      w ? w.loseContext() : console.warn('WEBGL_lose_context not supported')
    }),
    (self.debug_restore_context = function () {
      w ? w.restoreContext() : console.warn('WEBGL_lose_context not supported')
    }))
  const p = new Set()
  let q = -1

  function t() {
    q = -1
    for (const v of p) v.checkFunc() && (v.resolve(), p.delete(v))
    0 < p.size && (q = self.requestAnimationFrame(t))
  }

  function x(v, u, A) {
    if (2 <= A && (A = v.getContext('webgl2', u)))
      return {
        gl: A,
        version: 2
      }
    A = v.getContext('webgl', u)
    return {
      gl: A,
      version: 1
    }
  }
  e.Gfx.WebGLRenderer = class extends e.Gfx.RendererBase {
    constructor(v, u) {
      super()
      u = Object.assign({}, d, u)
      if (!f.has(u.powerPreference)) throw Error('invalid power preference')
      let A = !1
      const z = {
        alpha: !!u.alpha,
        depth: !1,
        antialias: !1,
        powerPreference: u.powerPreference,
        failIfMajorPerformanceCaveat: !0
      }
      u.lowLatency && ((z.desynchronized = !0), (z.preserveDrawingBuffer = !0))
      let C = x(v, z, u.maxWebGLVersion)
      C.gl || ((A = !0), (z.failIfMajorPerformanceCaveat = !1), (C = x(v, z, u.maxWebGLVersion)))
      if (!C.gl) throw Error('failed to initialise WebGL context')
      this._gl = v = C.gl
      this._attribs = v.getContextAttributes()
      u.lowLatency && !this._attribs.desynchronized && console.info('[WebGLRenderer] Low-latency mode specified but is not supported here')
      this._versionString = v.getParameter(v.VERSION)
      this._version = C.version
      this._viewport = a.create()
      this._bbProjectionMatrix = c.create()
      this._isDepthEnabled = this._usesDepthBuffer = !!u.depth
      this._depthBuffer = null
      this._isAutoSizeDepthBuffer = !0
      this._depthBufferHeight = this._depthBufferWidth = 0
      this._pointBuffer = this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null
      this._vertexData = new Float32Array(8e3 * this.GetNumVertexComponents())
      this._indexData = new Uint16Array(12e3)
      this._texcoordData = new Float32Array(16e3)
      this._pointData = new Float32Array(32e3)
      this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0
      this._spDeviceTransformTextureFill = this._lastProgram = null
      this._batch = []
      this._topOfBatch = this._batchPtr = 0
      this._currentRenderTarget = null
      this._lastPointZ = 0
      this._batchState = e.New(e.Gfx.BatchState, this)
      this._lastColor = e.New(e.Color, 1, 1, 1, 1)
      this._lastTexture1 = this._lastTexture0 = null
      this._lastDestBlend = this._lastSrcBlend = 0
      this._isScissorViewport = !1
      this._viewportScissorHeight = this._viewportScissorWidth = -1
      this._lastPointTexCoords = new e.Rect()
      this._maxTextureSize = -1
      this._highpPrecision = this._maxPointSize = this._minPointSize = 0
      this._unmaskedRenderer = this._unmaskedVendor = '(unavailable)'
      this._extensions = []
      this._hasMajorPerformanceCaveat = A
      this._isInitialisingAfterContextRestored = !1
      this._anisotropicExt = this._parallelShaderCompileExt = null
      this._maxAnisotropy = 0
      this._isGpuProfilingEnabled = !!u.enableGpuProfiling
      this._timerExt = null
      this._allQueryResultBuffers = new Set()
      this._timeQueryStack = []
      this.FillIndexBufferData(this._indexData)
    }
    IsWebGL() {
      return !0
    }
    async InitState() {
      super.InitState()
      var v = this._gl,
        u = this.GetNumVertexComponents()
      this._lastColor.setRgba(1, 1, 1, 1)
      this._lastTexture1 = this._lastTexture0 = null
      this._pointPtr = this._vertexPtr = 0
      this._lastVertexPtr = 8e3 * u - 4 * u
      e.clearArray(this._batch)
      this._topOfBatch = this._batchPtr = 0
      this._currentRenderTarget = this._lastProgram = null
      this._lastPointTexCoords.set(0, 0, 1, 1)
      this._lastPointZ = 0
      u = this._batchState
      u.currentShader = null
      u.currentFramebuffer = null
      a.set(u.currentColor, 1, 1, 1, 1)
      u.clearColor.setRgba(0, 0, 0, 0)
      u.pointTexCoords.set(0, 0, 1, 1)
      v.clearColor(0, 0, 0, 0)
      v.clear(v.COLOR_BUFFER_BIT)
      v.enable(v.BLEND)
      v.blendFunc(v.ONE, v.ONE_MINUS_SRC_ALPHA)
      this._lastSrcBlend = v.ONE
      this._lastDestBlend = v.ONE_MINUS_SRC_ALPHA
      this._InitBlendModes(v)
      v.disable(v.CULL_FACE)
      v.disable(v.STENCIL_TEST)
      v.disable(v.DITHER)
      this._usesDepthBuffer ? (v.enable(v.DEPTH_TEST), v.depthMask(!0), v.depthFunc(v.LEQUAL)) : (v.disable(v.DEPTH_TEST), v.depthMask(!1))
      this._isDepthEnabled = this._usesDepthBuffer
      this._pointBuffer = v.createBuffer()
      v.bindBuffer(v.ARRAY_BUFFER, this._pointBuffer)
      v.bufferData(v.ARRAY_BUFFER, this._pointData.byteLength, v.DYNAMIC_DRAW)
      this._vertexBuffer = v.createBuffer()
      v.bindBuffer(v.ARRAY_BUFFER, this._vertexBuffer)
      v.bufferData(v.ARRAY_BUFFER, this._vertexData.byteLength, v.DYNAMIC_DRAW)
      this._texcoordBuffer = v.createBuffer()
      v.bindBuffer(v.ARRAY_BUFFER, this._texcoordBuffer)
      v.bufferData(v.ARRAY_BUFFER, this._texcoordData.byteLength, v.DYNAMIC_DRAW)
      this._indexBuffer = v.createBuffer()
      v.bindBuffer(v.ELEMENT_ARRAY_BUFFER, this._indexBuffer)
      v.bufferData(v.ELEMENT_ARRAY_BUFFER, this._indexData, v.STATIC_DRAW)
      v.activeTexture(v.TEXTURE0)
      v.bindTexture(v.TEXTURE_2D, null)
      this._maxTextureSize = v.getParameter(v.MAX_TEXTURE_SIZE)
      u = v.getParameter(v.ALIASED_POINT_SIZE_RANGE)
      this._minPointSize = u[0]
      this._maxPointSize = u[1]
      u = v.getShaderPrecisionFormat(v.VERTEX_SHADER, v.HIGH_FLOAT)
      const A = v.getShaderPrecisionFormat(v.FRAGMENT_SHADER, v.HIGH_FLOAT)
      this._highpPrecision = u && A ? Math.min(u.precision, A.precision) : 0
      2048 < this._maxPointSize && (this._maxPointSize = 2048)
      this._extensions = v.getSupportedExtensions()
      if ((u = v.getExtension('WEBGL_debug_renderer_info'))) (this._unmaskedVendor = v.getParameter(u.UNMASKED_VENDOR_WEBGL)), (this._unmaskedRenderer = v.getParameter(u.UNMASKED_RENDERER_WEBGL))
      this._parallelShaderCompileExt = v.getExtension('KHR_parallel_shader_compile')
      e.isDebug && (w = v.getExtension('WEBGL_lose_context'))
      if (this._isGpuProfilingEnabled)
        if (1 === this.GetWebGLVersionNumber()) {
          if ('Chromium' !== e.Platform.BrowserEngine || 81 <= e.Platform.BrowserVersionNumber || 'undefined' !== typeof document) this._timerExt = v.getExtension('EXT_disjoint_timer_query')
        } else this._timerExt = v.getExtension('EXT_disjoint_timer_query_webgl2') || v.getExtension('EXT_disjoint_timer_query')
      this._maxAnisotropy = (this._anisotropicExt = v.getExtension('EXT_texture_filter_anisotropic')) ? v.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
      v = e.Gfx.WebGLShaderProgram
      u = v.GetDefaultVertexShaderSource(!1)
      v = [
        [v.GetTextureFillFragmentShaderSource(), u, '<default>'],
        [v.GetTextureFillFragmentShaderSource(), u, '<default-device-transform>'],
        [v.GetPointFragmentShaderSource(), v.GetPointVertexShaderSource(), '<point>'],
        [v.GetColorFillFragmentShaderSource(), u, '<fill>'],
        [v.GetLinearGradientFillFragmentShaderSource(), u, '<lineargradient>'],
        [v.GetHardEllipseFillFragmentShaderSource(), u, '<hardellipse>'],
        [v.GetHardEllipseOutlineFragmentShaderSource(), u, '<hardellipseoutline>'],
        [v.GetSmoothEllipseFillFragmentShaderSource(), u, '<smoothellipse>'],
        [v.GetSmoothEllipseOutlineFragmentShaderSource(), u, '<smoothellipseoutline>'],
        [v.GetSmoothLineFillFragmentShaderSource(), u, '<smoothline>'],
        [v.GetTilemapFragmentShaderSource(), v.GetDefaultVertexShaderSource(!0), '<tilemap>']
      ]
      v = await Promise.all(
        v.map(z =>
          this.CreateShaderProgram(
            {
              src: z[0]
            },
            z[1],
            z[2]
          )
        )
      )
      this._spTextureFill = v[0]
      this._spDeviceTransformTextureFill = v[1]
      this._spPoints = v[2]
      this._spColorFill = v[3]
      this._spLinearGradientFill = v[4]
      this._spHardEllipseFill = v[5]
      this._spHardEllipseOutline = v[6]
      this._spSmoothEllipseFill = v[7]
      this._spSmoothEllipseOutline = v[8]
      this._spSmoothLineFill = v[9]
      this._spTilemapFill = v[10]
      this.SetTextureFillMode()
    }
    async CreateShaderProgram(v, u, A) {
      v = await e.Gfx.WebGLShaderProgram.Create(this, v, u, A)
      this._AddShaderProgram(v)
      return v
    }
    ResetLastProgram() {
      this._lastProgram = null
    }
    SetSize(v, u, A) {
      if (this._width !== v || this._height !== u || A) {
        this.EndBatch()
        A = this._gl
        var z = this._batchState
        this._width = v
        this._height = u
        v = this.GetScissoredViewportWidth()
        u = this.GetScissoredViewportHeight()
        this._SetViewport(0, 0, v, u)
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, v / u)
        this.SetProjectionMatrix(this._bbProjectionMatrix)
        this._spDeviceTransformTextureFill &&
          (A.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), (this._lastProgram = this._spDeviceTransformTextureFill), (this._batchState.currentShader = this._spDeviceTransformTextureFill))
        A.bindTexture(A.TEXTURE_2D, null)
        A.activeTexture(A.TEXTURE1)
        A.bindTexture(A.TEXTURE_2D, null)
        A.activeTexture(A.TEXTURE0)
        this._lastTexture1 = this._lastTexture0 = null
        this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height)
        this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height)
        A.bindFramebuffer(A.FRAMEBUFFER, null)
        this._currentRenderTarget = null
        z.currentFramebuffer = null
      }
    }
    _SetDepthBufferSize(v, u) {
      const A = this._gl
      if (this._depthBuffer) {
        if (this._depthBufferWidth === v && this._depthBufferHeight === u) return
        A.deleteRenderbuffer(this._depthBuffer)
      }
      this._depthBuffer = A.createRenderbuffer()
      A.bindRenderbuffer(A.RENDERBUFFER, this._depthBuffer)
      A.renderbufferStorage(A.RENDERBUFFER, 2 <= this._version ? A.DEPTH_COMPONENT24 : A.DEPTH_COMPONENT16, v, u)
      A.bindRenderbuffer(A.RENDERBUFFER, null)
      this._depthBufferWidth = v
      this._depthBufferHeight = u
    }
    SetFixedSizeDepthBuffer(v, u) {
      this._usesDepthBuffer && ((this._isAutoSizeDepthBuffer = !1), this._SetDepthBufferSize(v, u))
    }
    SetAutoSizeDepthBuffer() {
      this._usesDepthBuffer && ((this._isAutoSizeDepthBuffer = !0), this._SetDepthBufferSize(this._width, this._height))
    }
    SetViewportScissor(v, u) {
      const A = this._gl
      if (this._width === v && this._height === u) this._isScissorViewport && (this.EndBatch(), A.disable(A.SCISSOR_TEST), (this._isScissorViewport = !1), (this._viewportScissorHeight = this._viewportScissorWidth = -1), this.SetSize(this._width, this._height, !0))
      else if ((this._isScissorViewport || (this.EndBatch(), A.enable(A.SCISSOR_TEST), (this._isScissorViewport = !0)), this._viewportScissorWidth !== v || this._viewportScissorHeight !== u))
        this.EndBatch(), A.scissor(0, 0, v, u), (this._viewportScissorWidth = v), (this._viewportScissorHeight = u), this.SetSize(this._width, this._height, !0)
    }
    RemoveViewportScissor() {
      const v = this._gl
      this._isScissorViewport && (this.EndBatch(), v.disable(v.SCISSOR_TEST), (this._isScissorViewport = !1))
      this._viewportScissorHeight = this._viewportScissorWidth = -1
    }
    GetScissoredViewportWidth() {
      return this._isScissorViewport ? this._viewportScissorWidth : this.GetWidth()
    }
    GetScissoredViewportHeight() {
      return this._isScissorViewport ? this._viewportScissorHeight : this.GetHeight()
    }
    _SetViewport(v, u, A, z) {
      const C = this._viewport
      if (C[0] !== v || C[1] !== u || C[2] !== A || C[3] !== z) this.PushBatch().InitSetViewport(v, u, A, z), a.set(C, v, u, A, z), (this._topOfBatch = 0)
    }
    SetProjectionMatrix(v) {
      c.exactEquals(this._matP, v) || (this.PushBatch().InitSetProjection(v), c.copy(this._matP, v), (this._topOfBatch = 0))
    }
    SetDefaultRenderTargetProjectionState() {
      let v, u
      var A = this._currentRenderTarget
      null === A || (A.IsDefaultSize() && this._isScissorViewport) ? ((v = this._bbProjectionMatrix), (u = this.GetScissoredViewportWidth()), (A = this.GetScissoredViewportHeight())) : ((v = A.GetProjectionMatrix()), (u = A.GetWidth()), (A = A.GetHeight()))
      this.SetProjectionMatrix(v)
      this._SetViewport(0, 0, u, A)
    }
    SetModelViewMatrix(v) {
      c.exactEquals(this._matMV, v) || (this.PushBatch().InitSetModelView(v), c.copy(this._matMV, v), (this._topOfBatch = 0))
    }
    GetBatchState() {
      return this._batchState
    }
    PushBatch() {
      const v = this._batch
      this._batchPtr === v.length && v.push(new e.Gfx.WebGLBatchJob(this._batchState))
      return v[this._batchPtr++]
    }
    EndBatch() {
      0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), (this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0))
    }
    _WriteBuffers() {
      const v = this._gl
      0 < this._pointPtr && (v.bindBuffer(v.ARRAY_BUFFER, this._pointBuffer), v.bufferSubData(v.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)))
      0 < this._vertexPtr && (v.bindBuffer(v.ARRAY_BUFFER, this._vertexBuffer), v.bufferSubData(v.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), v.bindBuffer(v.ARRAY_BUFFER, this._texcoordBuffer), v.bufferSubData(v.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
    }
    _ExecuteBatch() {
      const v = this._batch
      for (let u = 0, A = this._batchPtr; u < A; ++u) v[u].Run()
    }
    GetOpacity() {
      return this._lastColor.getA()
    }
    SetColorRgba(v, u, A, z) {
      const C = this._lastColor
      C.equalsRgba(v, u, A, z) || (C.setRgba(v, u, A, z), this.PushBatch().InitSetColor(C), (this._topOfBatch = 0), (this._currentStateGroup = null))
    }
    SetOpacity(v) {
      const u = this._lastColor
      u.getA() !== v && (u.setA(v), this.PushBatch().InitSetColor(u), (this._topOfBatch = 0), (this._currentStateGroup = null))
    }
    SetColor(v) {
      const u = this._lastColor
      u.equals(v) || (u.set(v), this.PushBatch().InitSetColor(u), (this._topOfBatch = 0), (this._currentStateGroup = null))
    }
    ResetColor() {
      this.SetColorRgba(1, 1, 1, 1)
    }
    GetColor() {
      return this._lastColor
    }
    SetTexture(v) {
      v !== this._lastTexture0 && (this.PushBatch().InitSetTexture(v), (this._lastTexture0 = v), (this._topOfBatch = 0))
    }
    _ResetLastTexture() {
      this._lastTexture0 = null
    }
    SetBlendMode(v) {
      v = this._GetBlendByIndex(v)
      this._SetBlend(v[0], v[1])
    }
    SetNamedBlendMode(v) {
      v = this.GetNamedBlend(v)
      this._SetBlend(v.srcBlend, v.destBlend)
    }
    _SetBlend(v, u) {
      if (v !== this._lastSrcBlend || u !== this._lastDestBlend) this.PushBatch().InitSetBlend(v, u), (this._lastSrcBlend = v), (this._lastDestBlend = u), (this._topOfBatch = 0), (this._currentStateGroup = null)
    }
    IsPremultipliedAlphaBlend() {
      return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
    }
    SetAlphaBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetNoPremultiplyAlphaBlend() {
      this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetCopyBlend() {
      this._SetBlend(this._gl.ONE, this._gl.ZERO)
    }
    Rect(v) {
      this.Rect2(v.getLeft(), v.getTop(), v.getRight(), v.getBottom())
    }
    Rect2(v, u, A, z) {
      this.Quad2(v, u, A, u, A, z, v, z)
    }
    _ExtendQuadBatch() {
      let v = this._vertexPtr
      v >= this._lastVertexPtr && (this.EndBatch(), (v = 0))
      1 === this._topOfBatch ? (this._batch[this._batchPtr - 1]._indexCount += 6) : (this.PushBatch().InitQuad(v, 6), (this._topOfBatch = 1))
    }
    _WriteQuadToVertexBuffer(v) {
      v.writeToTypedArray3D(this._vertexData, this._vertexPtr, this._baseZ + this._currentZ)
      this._vertexPtr += 12
    }
    Quad(v) {
      this._ExtendQuadBatch()
      this._WriteQuadToVertexBuffer(v)
      g.writeToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    Quad2(v, u, A, z, C, E, J, F) {
      this._ExtendQuadBatch()
      const I = this._vertexData
      let L = this._vertexPtr
      const N = this._baseZ + this._currentZ
      I[L++] = v
      I[L++] = u
      I[L++] = N
      I[L++] = A
      I[L++] = z
      I[L++] = N
      I[L++] = C
      I[L++] = E
      I[L++] = N
      I[L++] = J
      I[L++] = F
      I[L++] = N
      this._vertexPtr = L
      g.writeToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    Quad3(v, u) {
      this._ExtendQuadBatch()
      this._WriteQuadToVertexBuffer(v)
      u.writeAsQuadToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    Quad4(v, u) {
      this._ExtendQuadBatch()
      this._WriteQuadToVertexBuffer(v)
      u.writeToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    Quad3D(v, u, A, z, C, E, J, F, I, L, N, S, V) {
      this._ExtendQuadBatch()
      const U = this._vertexData
      let X = this._vertexPtr
      const ia = this._baseZ + this._currentZ
      U[X++] = v
      U[X++] = u
      U[X++] = ia + A
      U[X++] = z
      U[X++] = C
      U[X++] = ia + E
      U[X++] = J
      U[X++] = F
      U[X++] = ia + I
      U[X++] = L
      U[X++] = N
      U[X++] = ia + S
      this._vertexPtr = X
      V.writeAsQuadToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    Quad3D2(v, u, A, z, C, E, J, F, I, L, N, S, V) {
      this._ExtendQuadBatch()
      const U = this._vertexData
      let X = this._vertexPtr
      const ia = this._baseZ + this._currentZ
      U[X++] = v
      U[X++] = u
      U[X++] = ia + A
      U[X++] = z
      U[X++] = C
      U[X++] = ia + E
      U[X++] = J
      U[X++] = F
      U[X++] = ia + I
      U[X++] = L
      U[X++] = N
      U[X++] = ia + S
      this._vertexPtr = X
      V.writeToTypedArray(this._texcoordData, this._texPtr)
      this._texPtr += 8
    }
    FullscreenQuad(v, u) {
      c.copy(h, this._matP)
      c.copy(k, this._matMV)
      this.SetDefaultRenderTargetProjectionState()
      if (this._isScissorViewport) {
        v = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ() * self.devicePixelRatio, 0, 0, 0)
        this.SetModelViewMatrix(v)
        v = this._viewportScissorWidth / 2
        var A = this._viewportScissorHeight / 2
        r.set(-v, A, -v + this._viewportScissorWidth, A - this._viewportScissorHeight)
        m.setFromRect(r)
        r.set(0, 0, this._viewportScissorWidth / this._width, this._viewportScissorHeight / this._height)
        this.Quad3(m, r)
      } else {
        const [E, J] = this.GetRenderTargetSize(this._currentRenderTarget)
        A = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ() * self.devicePixelRatio, 0, 0, 0, J)
        this.SetModelViewMatrix(A)
        if ('crop' === v && this._currentRenderTarget && u) {
          v = this._width / 2
          A = this._height / 2
          const F = u.GetWidth()
          u = u.GetHeight()
          var z = this._currentRenderTarget.GetWidth(),
            C = this._currentRenderTarget.GetHeight()
          z = Math.min(z, F)
          const I = Math.min(C, u),
            L = Math.max(u - C, 0)
          C = Math.max(C - u, 0)
          r.set(-v, A - C, -v + z, A - I - C)
          m.setFromRect(r)
          r.set(0, L, z, I + L)
          r.divide(F, u)
          this.Quad3(m, r)
        } else (v = E / 2), (A = J / 2), this.Rect2(-v, A, v, -A)
      }
      this.SetProjectionMatrix(h)
      this.SetModelViewMatrix(k)
    }
    StartRenderingPoints(v) {
      this._lastPointTexCoords.equals(v) || (this._lastPointTexCoords.copy(v), this.PushBatch().InitSetPointTexCoords(v), (this._topOfBatch = 0))
    }
    FinishRenderingPoints() {}
    Point(v, u, A, z) {
      7996 <= this._pointPtr && this.EndBatch()
      let C = this._pointPtr
      var E = this._baseZ + this._currentZ
      2 === this._topOfBatch && this._lastPointZ === E ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(C, E), (this._topOfBatch = 2), (this._lastPointZ = E))
      E = this._pointData
      E[C++] = v
      E[C++] = u
      E[C++] = A
      E[C++] = z
      this._pointPtr = C
    }
    SetProgram(v) {
      this._lastProgram !== v && (this.PushBatch().InitSetProgram(v), (this._lastProgram = v), (this._topOfBatch = 0), (this._currentStateGroup = null))
    }
    SetDeviceTransformTextureFillMode() {
      this.SetProgram(this._spDeviceTransformTextureFill)
    }
    SetGradientColor(v) {
      this.PushBatch().InitSetGradientColor(v)
      this._topOfBatch = 0
    }
    SetEllipseParams(v, u, A = 1) {
      this.PushBatch().InitSetEllipseParams(v, u, A)
      this._topOfBatch = 0
    }
    SetTilemapInfo(v, u, A, z, C, E, J) {
      if (this._lastProgram !== this._spTilemapFill) throw Error('must set tilemap fill mode first')
      this.PushBatch().InitSetTilemapInfo(v, u, A, z, C, E, J)
      this._topOfBatch = 0
    }
    SetProgramParameters(v, u, A, z, C, E, J, F, I, L, N) {
      const S = this._lastProgram
      var V = S._hasAnyOptionalUniforms
      const U = !!N.length
      if ((V && !S.AreOptionalUniformsAlreadySetInBatch(u, A, z, C, E, J, F, I, L)) || (U && !S.AreCustomParametersAlreadySetInBatch(N))) {
        var X = this.PushBatch()
        X.InitSetProgramParameters()
        V &&
          (S.SetOptionalUniformsInBatch(u, A, z, C, E, J, F, I, L),
          (V = X._mat4param),
          (V[0] = E),
          (V[1] = J),
          u.writeToTypedArray(V, 2),
          (V[6] = F),
          (V[7] = I),
          A.writeToTypedArray(V, 12),
          (u = X._colorParam),
          C.writeToTypedArray(u, 0),
          (C = u[1]),
          (u[1] = u[3]),
          (u[3] = C),
          z.writeToTypedArray(X._srcOriginRect, 0),
          (X._startIndex = L),
          S._uSamplerBack.IsUsed() ? (X._texParam = v ? v.GetTexture() : null) : (X._texParam = null))
        U && (S.SetCustomParametersInBatch(N), e.shallowAssignArray(X._shaderParams, N))
        this._topOfBatch = 0
      }
    }
    ClearRgba(v, u, A, z) {
      this.PushBatch().InitClearSurface2(v, u, A, z)
      this._topOfBatch = 0
    }
    Clear(v) {
      this.PushBatch().InitClearSurface(v)
      this._topOfBatch = 0
    }
    ClearRect(v, u, A, z) {
      this.ClearRect4(v, u, A, z, 0, 0, 0, 0)
    }
    ClearRect2(v) {
      this.ClearRect4(v.getLeft(), v.getTop(), v.width(), v.height(), 0, 0, 0, 0)
    }
    ClearRect3(v, u) {
      this.ClearRect4(v.getLeft(), v.getTop(), v.width(), v.height(), u.getR(), u.getG(), u.getB(), u.getA())
    }
    ClearRect4(v, u, A, z, C, E, J, F) {
      0 > A || 0 > z || (this.PushBatch().InitClearRect(v, u, A, z, C, E, J, F), (this._topOfBatch = 0))
    }
    Start() {}
    Finish() {
      super.Finish()
      this._gl.flush()
    }
    ClearDepth() {
      this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(), (this._topOfBatch = 0))
    }
    SetDepthEnabled(v) {
      v = !!v
      this._isDepthEnabled !== v && this._usesDepthBuffer && ((this._isDepthEnabled = v), this.PushBatch().InitSetDepthEnabled(v), (this._topOfBatch = 0))
    }
    _GetDepthBuffer() {
      return this._depthBuffer
    }
    CheckForQueryResults() {
      for (const v of this._allQueryResultBuffers) v.CheckForResults(this._frameNumber)
    }
    IsContextLost() {
      return !this._gl || this._gl.isContextLost() || this._isInitialisingAfterContextRestored
    }
    OnContextLost() {
      super.OnDeviceOrContextLost()
      e.Gfx.WebGLRendererTexture.OnContextLost()
      e.Gfx.WebGLRenderTarget.OnContextLost()
      e.Gfx.RendererText.OnContextLost()
      for (const v of this._allQueryResultBuffers) v.Clear()
      this._extensions = []
      this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null
      this._maxAnisotropy = 0
      this._unmaskedRenderer = this._unmaskedVendor = '(unavailable)'
      this._depthBuffer = this._spDeviceTransformTextureFill = this._lastProgram = null
      for (const v of this._stateGroups.values()) v.OnContextLost()
    }
    async OnContextRestored() {
      this._isInitialisingAfterContextRestored = !0
      await this.InitState()
      this._isInitialisingAfterContextRestored = !1
      for (const v of this._stateGroups.values()) v.OnContextRestored(this)
      this.SetSize(this._width, this._height, !0)
    }
    CreateStaticTexture(v, u) {
      if (this.IsContextLost()) throw Error('context lost')
      this.EndBatch()
      const A = e.New(e.Gfx.WebGLRendererTexture, this)
      A._CreateStatic(v, u)
      return A
    }
    CreateStaticTextureAsync(v, u) {
      if (this.IsContextLost()) return Promise.reject('context lost')
      u = Object.assign({}, u)
      const A = (u.wrapX && 'clamp-to-edge' !== u.wrapX) || (u.wrapY && 'clamp-to-edge' !== u.wrapY)
      if (!e.Supports.ImageBitmapOptions || (!this.SupportsNPOTTextures() && A))
        return e.Supports.ImageBitmap
          ? createImageBitmap(v).then(z => e.Asyncify(() => this.CreateStaticTexture(z, u)))
          : v instanceof Blob
          ? e.BlobToImage(v, !0).then(z => this.CreateStaticTextureAsync(z, u))
          : 'undefined' !== typeof HTMLImageElement && v instanceof HTMLImageElement && 'function' === typeof v.decode
          ? v.decode().then(() => e.Asyncify(() => this.CreateStaticTexture(v, u)))
          : e.Asyncify(() => this.CreateStaticTexture(v, u))
      u.premultiplyAlpha = !1
      return createImageBitmap(v, {
        premultiplyAlpha: 'premultiply'
      }).then(z => e.Asyncify(() => this.CreateStaticTexture(z, u)))
    }
    CreateDynamicTexture(v, u, A) {
      this.EndBatch()
      const z = e.New(e.Gfx.WebGLRendererTexture, this)
      z._CreateDynamic(v, u, A)
      return z
    }
    UpdateTexture(v, u, A) {
      this.EndBatch()
      u._Update(v, A)
    }
    DeleteTexture(v) {
      v &&
        (v.SubtractReference(),
        0 < v.GetReferenceCount() ||
          (this.EndBatch(),
          v === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), (this._lastTexture0 = null)),
          v === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), (this._lastTexture1 = null)),
          v._Delete()))
    }
    CreateRenderTarget(v) {
      let u = this._width,
        A = this._height,
        z = !0
      v && ('number' === typeof v.width && ((u = v.width), (z = !1)), 'number' === typeof v.height && ((A = v.height), (z = !1)))
      if (0 >= u || 0 >= A) throw Error('invalid size')
      this.EndBatch()
      const C = e.New(e.Gfx.WebGLRenderTarget, this)
      C._Create(
        u,
        A,
        Object.assign(
          {
            isDefaultSize: z
          },
          v
        )
      )
      this._currentRenderTarget = null
      this._batchState.currentFramebuffer = null
      return C
    }
    SetRenderTarget(v) {
      v !== this._currentRenderTarget && (v && v.IsDefaultSize() && v._Resize(this._width, this._height), this.PushBatch().InitSetRenderTarget(v), (this._currentRenderTarget = v), (this._topOfBatch = 0), this.SetDefaultRenderTargetProjectionState())
    }
    GetRenderTarget() {
      return this._currentRenderTarget
    }
    GetRenderTargetSize(v) {
      return v ? [v.GetWidth(), v.GetHeight()] : [this._width, this._height]
    }
    CopyRenderTarget(v, u = 'stretch') {
      2 > this._version || (this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling()) ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(v, u)) : (this.PushBatch().InitBlitFramebuffer(v, this._currentRenderTarget, u), (this._topOfBatch = 0))
    }
    DrawRenderTarget(v, u = 'stretch') {
      v = v.GetTexture()
      if (!v) throw Error('not a texture-backed render target')
      this.SetTexture(v)
      this.FullscreenQuad(u, v)
    }
    InvalidateRenderTarget(v) {
      2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(v._GetFramebuffer()), (this._topOfBatch = 0))
    }
    DeleteRenderTarget(v) {
      this.SetRenderTarget(null)
      this.EndBatch()
      const u = v.GetTexture()
      u === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), (this._lastTexture0 = null))
      u === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), (this._lastTexture1 = null))
      v._Delete()
    }
    async ReadBackRenderTargetToImageData(v, u, A) {
      this.EndBatch()
      const z = this._currentRenderTarget
      if (v) {
        var C = v.GetWidth()
        var E = v.GetHeight()
        var J = v._GetFramebuffer()
      } else (C = this.GetWidth()), (E = this.GetHeight()), (J = null)
      let F = (v = 0)
      var I = C,
        L = E
      A && ((v = e.clamp(Math.floor(A.getLeft()), 0, C - 1)), (F = e.clamp(Math.floor(A.getTop()), 0, E - 1)), (I = A.width()), (I = 0 === I ? C - v : e.clamp(Math.floor(I), 0, C - v)), (L = A.height()), (L = 0 === L ? E - F : e.clamp(Math.floor(L), 0, E - F)), (F = E - (F + L)))
      const N = this._gl
      N.bindFramebuffer(N.FRAMEBUFFER, J)
      E = () => {
        N.bindFramebuffer(N.FRAMEBUFFER, null)
        this._currentRenderTarget = null
        this._batchState.currentFramebuffer = null
        this.SetRenderTarget(z)
      }
      if (!u && 2 <= this.GetWebGLVersionNumber()) {
        N.bindFramebuffer(N.READ_FRAMEBUFFER, J)
        J = N.createBuffer()
        A = I * L * 4
        C = N.PIXEL_PACK_BUFFER
        N.bindBuffer(C, J)
        N.bufferData(C, A, N.STREAM_READ)
        N.readPixels(v, F, I, L, N.RGBA, N.UNSIGNED_BYTE, 0)
        N.bindFramebuffer(N.READ_FRAMEBUFFER, null)
        N.bindBuffer(C, null)
        E()
        const S = N.fenceSync(N.SYNC_GPU_COMMANDS_COMPLETE, 0)
        await this._WaitForObjectReady(() => N.getSyncParameter(S, N.SYNC_STATUS) === N.SIGNALED)
        N.deleteSync(S)
        u = new ImageData(I, L)
        N.bindBuffer(C, J)
        N.getBufferSubData(C, 0, new Uint8Array(u.data.buffer), 0, A)
        N.bindBuffer(C, null)
        N.deleteBuffer(J)
      } else (u = new ImageData(I, L)), N.readPixels(v, F, I, L, N.RGBA, N.UNSIGNED_BYTE, new Uint8Array(u.data.buffer)), E()
      return u
    }
    StartQuery(v) {
      this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(v), (this._topOfBatch = 0))
    }
    EndQuery(v) {
      this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(v), (this._topOfBatch = 0))
    }
    _WaitForObjectReady(v) {
      const u = new Promise(A =>
        p.add({
          resolve: A,
          checkFunc: v
        })
      )
      ;-1 === q && (q = self.requestAnimationFrame(t))
      return u
    }
    IsDesynchronized() {
      return !!this._attribs.desynchronized
    }
    GetEstimatedBackBufferMemoryUsage() {
      return this._width * this._height * (this._attribs.alpha ? 4 : 3)
    }
    GetEstimatedRenderBufferMemoryUsage() {
      let v = 0
      for (const u of e.Gfx.WebGLRenderTarget.allRenderTargets()) u.GetTexture() || (v += u.GetEstimatedMemoryUsage())
      return v
    }
    GetEstimatedTextureMemoryUsage() {
      let v = 0
      for (const u of e.Gfx.WebGLRendererTexture.allTextures()) v += u.GetEstimatedMemoryUsage()
      return v
    }
    GetEstimatedTotalMemoryUsage() {
      return this.GetEstimatedBackBufferMemoryUsage() + this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
    }
    GetWebGLVersionString() {
      return this._versionString
    }
    GetWebGLVersionNumber() {
      return this._version
    }
    GetDisplayName() {
      return 'webgl' + this.GetWebGLVersionNumber()
    }
    SupportsNPOTTextures() {
      return 2 <= this.GetWebGLVersionNumber()
    }
    GetMaxTextureSize() {
      return this._maxTextureSize
    }
    GetMinPointSize() {
      return this._minPointSize
    }
    GetMaxPointSize() {
      return this._maxPointSize
    }
    SupportsHighP() {
      return 0 !== this._highpPrecision
    }
    GetHighPPrecision() {
      return this._highpPrecision
    }
    GetUnmaskedVendor() {
      return this._unmaskedVendor
    }
    GetUnmaskedRenderer() {
      return this._unmaskedRenderer
    }
    GetExtensions() {
      return this._extensions
    }
    HasMajorPerformanceCaveat() {
      return this._hasMajorPerformanceCaveat
    }
    SupportsGPUProfiling() {
      return !!this._timerExt
    }
    _GetDisjointTimerQueryExtension() {
      return this._timerExt
    }
    _GetParallelShaderCompileExtension() {
      return this._parallelShaderCompileExt
    }
    _GetAnisotropicExtension() {
      return this._anisotropicExt
    }
    _GetMaxAnisotropy() {
      return this._maxAnisotropy
    }
    _AddQueryResultBuffer(v) {
      this._allQueryResultBuffers.add(v)
    }
    _RemoveQueryResultBuffer(v) {
      this._allQueryResultBuffers.delete(v)
    }
    _GetTimeQueryStack() {
      return this._timeQueryStack
    }
    GetContext() {
      return this._gl
    }
    _InitBlendModes(v) {
      this._InitBlendModeData([
        ['normal', v.ONE, v.ONE_MINUS_SRC_ALPHA],
        ['additive', v.ONE, v.ONE],
        ['xor', v.ONE, v.ONE_MINUS_SRC_ALPHA],
        ['copy', v.ONE, v.ZERO],
        ['destination-over', v.ONE_MINUS_DST_ALPHA, v.ONE],
        ['source-in', v.DST_ALPHA, v.ZERO],
        ['destination-in', v.ZERO, v.SRC_ALPHA],
        ['source-out', v.ONE_MINUS_DST_ALPHA, v.ZERO],
        ['destination-out', v.ZERO, v.ONE_MINUS_SRC_ALPHA],
        ['source-atop', v.DST_ALPHA, v.ONE_MINUS_SRC_ALPHA],
        ['destination-atop', v.ONE_MINUS_DST_ALPHA, v.SRC_ALPHA]
      ])
    }
    CreateRendererText() {
      return e.New(e.Gfx.RendererText, this)
    }
    CreateWebGLText() {
      return this.CreateRendererText()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X
  let a = null
  const c = new Set()

  function d(k, m) {
    const r = k[0] - m[0]
    return 0 !== r ? r : k[1] - m[1]
  }
  const f = [],
    g = []
  let h = !1
  self.IRuntime = class {
    constructor(k, m) {
      a = k
      Object.defineProperties(this, {
        assets: {
          value: a.GetAssetManager().GetIAssetManager(),
          writable: !1
        },
        objects: {
          value: m,
          writable: !1
        },
        globalVars: {
          value: {},
          writable: !1
        },
        projectName: {
          value: a.GetProjectName(),
          writable: !1
        },
        projectVersion: {
          value: a.GetProjectVersion(),
          writable: !1
        },
        storage: {
          value: new self.IStorage(a),
          writable: !1
        },
        isInWorker: {
          value: a.IsInWorker(),
          writable: !1
        }
      })
      a.UserScriptDispatcher().addEventListener('keydown', r => {
        c.has(r.key) ? r.stopPropagation() : c.add(r.key)
      })
      a.UserScriptDispatcher().addEventListener('keyup', r => c.delete(r.key))
      a.Dispatcher().addEventListener('window-blur', () => c.clear())
      a.IsInWorker() &&
        (self.alert = r => {
          h ||
            ((h = !0),
            console.warn(
              "[Construct 3] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."
            ))
          return this.alert(r)
        })
    }
    _InitGlobalVars(k) {
      Object.defineProperties(this.globalVars, k)
    }
    addEventListener(k, m) {
      a.UserScriptDispatcher().addEventListener(k, m)
    }
    removeEventListener(k, m) {
      a.UserScriptDispatcher().removeEventListener(k, m)
    }
    callFunction(k, ...m) {
      b.RequireString(k)
      const r = a.GetEventSheetManager(),
        w = r.GetFunctionBlockByName(k)
      if (!w) throw Error(`cannot find function name '${k}'`)
      if (!w.IsEnabled()) return w.GetDefaultReturnValue()
      if (m.length < w.GetFunctionParameterCount()) throw Error(`not enough function parameters passed for '${k}' (${m.length} passed, ${w.GetFunctionParameterCount()} expected)`)
      const p = w.GetEventBlock()
      k = null
      var q = r.GetCurrentEvent()
      q && ((q = q.GetSolModifiersIncludingParents()), 0 < q.length && ((k = q), r.PushCleanSol(q)))
      m = p.RunAsExpressionFunctionCall(p.GetSolModifiersIncludingParents(), w.GetReturnType(), w.GetDefaultReturnValue(), ...m)
      k && r.PopSol(k)
      return m
    }
    setReturnValue(k) {
      const m = a.GetEventStack().GetCurrentExpFuncStackFrame()
      if (!m) throw Error('not in a function which returns a value')
      switch (m.GetFunctionReturnType()) {
        case 1:
          'number' === typeof k && m.SetFunctionReturnValue(k)
          break
        case 2:
          'string' === typeof k && m.SetFunctionReturnValue(k)
          break
        case 3:
          ;('number' !== typeof k && 'string' !== typeof k) || m.SetFunctionReturnValue(k)
      }
    }
    get dt() {
      return a.GetDt()
    }
    get gameTime() {
      return a.GetGameTime()
    }
    get wallTime() {
      return a.GetWallTime()
    }
    random() {
      return a.Random()
    }
    get layout() {
      return a.GetMainRunningLayout().GetILayout()
    }
    getLayout(k) {
      const m = a.GetLayoutManager()
      if ('number' === typeof k || 'string' === typeof k) k = m.GetLayout(k)
      else throw new TypeError('expected string or number')
      if (!k) throw Error('invalid layout')
      return k.GetILayout()
    }
    getAllLayouts() {
      return a
        .GetLayoutManager()
        .GetAllLayouts()
        .map(k => k.GetILayout())
    }
    goToLayout(k) {
      const m = a.GetLayoutManager()
      if ('number' === typeof k || 'string' === typeof k) k = m.GetLayout(k)
      else throw new TypeError('expected string or number')
      if (!k) throw Error('invalid layout')
      m.IsPendingChangeMainLayout() || m.ChangeMainLayout(k)
    }
    get keyboard() {
      const k = a._GetCommonScriptInterfaces().keyboard
      if (!k) throw Error('runtime.keyboard used but Keyboard object missing - add it to your project first')
      return k
    }
    get mouse() {
      const k = a._GetCommonScriptInterfaces().mouse
      if (!k) throw Error('runtime.mouse used but Mouse object missing - add it to your project first')
      return k
    }
    get touch() {
      const k = a._GetCommonScriptInterfaces().touch
      if (!k) throw Error('runtime.touch used but Touch object missing - add it to your project first')
      return k
    }
    invokeDownload(k, m) {
      b.RequireString(k)
      b.RequireString(m)
      a.InvokeDownload(k, m)
    }
    getInstanceByUid(k) {
      b.RequireFiniteNumber(k)
      return (k = a.GetInstanceByUID(k)) ? k.GetInterfaceClass() : null
    }
    sortZOrder(k, m) {
      b.RequireFunction(m)
      const r = a.GetCurrentLayout()
      for (var w of k) {
        k = a._UnwrapIWorldInstance(w)
        var p = k.GetWorldInfo()
        f.push([p.GetLayer().GetIndex(), p.GetZIndex()])
        g.push(k)
      }
      if (0 !== f.length) {
        f.sort(d)
        g.sort((q, t) => m(q.GetInterfaceClass(), t.GetInterfaceClass()))
        w = !1
        for (let q = 0, t = f.length; q < t; ++q) {
          k = g[q]
          p = r.GetLayerByIndex(f[q][0])
          const x = f[q][1],
            v = p._GetInstances()
          v[x] !== k && ((v[x] = k), k.GetWorldInfo()._SetLayer(p), p.SetZIndicesChanged(), (w = !0))
        }
        w && a.UpdateRender()
        e.clearArray(f)
        e.clearArray(g)
      }
    }
    alert(k) {
      return a.PostComponentMessageToDOMAsync('runtime', 'alert', {
        message: k + (a.IsInWorker() ? ' [via Web Worker]' : '')
      })
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = null
  self.IAssetManager = class {
    constructor(a) {
      b = a
      Object.defineProperties(this, {
        isWebMOpusSupported: {
          value: b.IsAudioFormatSupported('audio/webm; codecs=opus'),
          writable: !1
        }
      })
    }
    fetchText(a) {
      return b.FetchText(a)
    }
    fetchJson(a) {
      return b.FetchJson(a)
    }
    fetchBlob(a) {
      return b.FetchBlob(a)
    }
    fetchArrayBuffer(a) {
      return b.FetchArrayBuffer(a)
    }
    getProjectFileUrl(a) {
      return b.GetProjectFileUrl(a)
    }
    getMediaFileUrl(a) {
      e.IsRelativeURL(a) && (a = a.toLowerCase())
      return b.GetMediaFileUrl(a, b.GetMediaSubfolder())
    }
    get mediaFolder() {
      return b.GetMediaSubfolder()
    }
    async decodeWebMOpus(a, c) {
      if (this.isWebMOpusSupported) throw Error('decodeWebMOpus(): not supported because WebM Opus is supported by the platform')
      c = await b.GetRuntime()._WasmDecodeWebMOpus(c)
      c = new Float32Array(c)
      a = a.createBuffer(1, c.length, 48e3)
      a.getChannelData(0).set(c)
      return a
    }
    loadScripts(...a) {
      return b.LoadScripts(...a)
    }
    compileWebAssembly(a) {
      return b.CompileWebAssembly(a)
    }
    loadStyleSheet(a) {
      return b.LoadStyleSheet(a)
    }
  }
}
{
  ;('use strict')
  const e = self.C3X
  self.IStorage = class {
    constructor(b) {
      this._storage = b._GetProjectStorage()
    }
    getItem(b) {
      e.RequireString(b)
      return this._storage.getItem(b)
    }
    setItem(b, a) {
      e.RequireString(b)
      return this._storage.setItem(b, a)
    }
    removeItem(b) {
      e.RequireString(b)
      return this._storage.removeItem(b)
    }
    clear() {
      return this._storage.clear()
    }
    keys() {
      return this._storage.keys()
    }
  }
}
{
  ;('use strict')
  const e = self.C3X,
    b = new WeakMap()
  self.IObjectClass = class {
    constructor(a) {
      b.set(this, a)
      Object.defineProperties(this, {
        name: {
          value: a.GetName(),
          writable: !1
        }
      })
      a.GetRuntime()._MapScriptInterface(this, a)
    }
    addEventListener(a, c) {
      e.RequireString(a)
      e.RequireFunction(c)
      b.get(this).UserScriptDispatcher().addEventListener(a, c)
    }
    removeEventListener(a, c) {
      e.RequireString(a)
      e.RequireFunction(c)
      b.get(this).UserScriptDispatcher().removeEventListener(a, c)
    }
    getAllInstances() {
      return b
        .get(this)
        .GetInstances()
        .map(a => a.GetInterfaceClass())
    }
    getFirstInstance() {
      const a = b.get(this).GetInstances()
      return 0 < a.length ? a[0].GetInterfaceClass() : null
    }
    getPickedInstances() {
      return b
        .get(this)
        .GetCurrentSol()
        .GetInstances()
        .map(a => a.GetInterfaceClass())
    }
    getFirstPickedInstance() {
      const a = b.get(this).GetCurrentSol().GetInstances()
      return 0 < a.length ? a[0].GetInterfaceClass() : null
    }
    *instances() {
      for (const a of b.get(this).GetInstances()) yield a.GetInterfaceClass()
    }
    *pickedInstances() {
      for (const a of b.get(this).GetCurrentSol().GetInstances()) yield a.GetInterfaceClass()
    }
    setInstanceClass(a) {
      e.RequireFunction(a)
      if (0 < b.get(this).GetInstanceCount()) throw Error('setInstanceClass() called too late, because instances have already been created - call in runOnStartup')
      b.get(this)._SetUserScriptInstanceClass(a)
    }
    createInstance(a, c, d, f) {
      e.RequireNumber(c)
      e.RequireNumber(d)
      if ('number' !== typeof a && 'string' !== typeof a) throw new TypeError('invalid layer parameter')
      const g = b.get(this),
        h = g.GetRuntime()
      a = h.GetMainRunningLayout().GetLayer(a)
      if (!a) throw Error('invalid layer')
      c = h.CreateInstance(g, a, c, d, f)
      f && a.SortAndAddSceneGraphInstancesByZIndex(c)
      f = h.GetEventSheetManager()
      f.BlockFlushingInstances(!0)
      c._TriggerOnCreatedOnSelfAndRelated()
      f.BlockFlushingInstances(!1)
      return c.GetInterfaceClass()
    }
  }
}
{
  ;('use strict')
  const e = self.C3X,
    b = new WeakMap()
  self.ILayout = class {
    constructor(a) {
      b.set(this, a)
      const c = [],
        d = a.GetEffectList(),
        f = d.GetAllEffectTypes().length
      for (let g = 0; g < f; ++g) c.push(new self.IEffectInstance(d, g))
      Object.defineProperties(this, {
        name: {
          value: a.GetName(),
          writable: !1
        },
        index: {
          value: a.GetIndex(),
          writable: !1
        },
        effects: {
          value: c,
          writable: !1
        }
      })
    }
    addEventListener(a, c) {
      e.RequireString(a)
      e.RequireFunction(c)
      b.get(this).UserScriptDispatcher().addEventListener(a, c)
    }
    removeEventListener(a, c) {
      e.RequireString(a)
      e.RequireFunction(c)
      b.get(this).UserScriptDispatcher().removeEventListener(a, c)
    }
    get width() {
      return b.get(this).GetWidth()
    }
    set width(a) {
      b.get(this).SetWidth(a)
    }
    get height() {
      return b.get(this).GetHeight()
    }
    set height(a) {
      b.get(this).SetHeight(a)
    }
    set scale(a) {
      e.RequireFiniteNumber(a)
      b.get(this).SetScale(a)
    }
    get scale() {
      return b.get(this).GetScale()
    }
    set angle(a) {
      e.RequireFiniteNumber(a)
      b.get(this).SetAngle(a)
    }
    get angle() {
      return b.get(this).GetAngle()
    }
    set scrollX(a) {
      e.RequireNumber(a)
      b.get(this).SetScrollX(a)
    }
    get scrollX() {
      return b.get(this).GetScrollX()
    }
    set scrollY(a) {
      e.RequireNumber(a)
      b.get(this).SetScrollY(a)
    }
    get scrollY() {
      return b.get(this).GetScrollY()
    }
    scrollTo(a, c) {
      e.RequireNumber(a)
      e.RequireNumber(c)
      const d = b.get(this)
      d.SetScrollX(a)
      d.SetScrollY(c)
    }
    getLayer(a) {
      const c = b.get(this)
      if ('number' === typeof a || 'string' === typeof a) a = c.GetLayer(a)
      else throw new TypeError('expected string or number')
      return a ? a.GetILayer() : null
    }
    getAllLayers() {
      return b
        .get(this)
        .GetLayers()
        .map(a => a.GetILayer())
    }
    setVanishingPoint(a, c) {
      e.RequireFiniteNumber(a)
      e.RequireFiniteNumber(c)
      b.get(this).SetVanishingPointXY(a, c)
    }
    getVanishingPoint() {
      const a = b.get(this)
      return [a.GetVanishingPointX(), a.GetVanishingPointY()]
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new Map([
      ['normal', 0],
      ['additive', 1],
      ['copy', 3],
      ['destination-over', 4],
      ['source-in', 5],
      ['destination-in', 6],
      ['source-out', 7],
      ['destination-out', 8],
      ['source-atop', 9],
      ['destination-atop', 10]
    ]),
    d = new Map([...c.entries()].map(g => [g[1], g[0]])),
    f = e.New(e.Color)
  self.ILayer = class {
    constructor(g) {
      a.set(this, g)
      const h = [],
        k = g.GetEffectList(),
        m = k.GetAllEffectTypes().length
      for (let r = 0; r < m; ++r) h.push(new self.IEffectInstance(k, r))
      Object.defineProperties(this, {
        name: {
          value: g.GetName(),
          writable: !1
        },
        index: {
          value: g.GetIndex(),
          writable: !1
        },
        layout: {
          value: g.GetLayout().GetILayout(),
          writable: !1
        },
        effects: {
          value: h,
          writable: !1
        }
      })
    }
    static _Unwrap(g) {
      return a.get(g)
    }
    get isVisible() {
      return a.get(this).IsVisible()
    }
    set isVisible(g) {
      a.get(this).SetVisible(g)
    }
    get opacity() {
      return a.get(this).GetOpacity()
    }
    set opacity(g) {
      g = e.clamp(+g, 0, 1)
      isNaN(g) || a.get(this).SetOpacity(g)
    }
    set scale(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetOwnScale(g)
    }
    get scale() {
      return a.get(this).GetOwnScale()
    }
    set scaleRate(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetScaleRate(g)
    }
    get scaleRate() {
      return a.get(this).GetScaleRate()
    }
    set angle(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetAngle(g)
    }
    get angle() {
      return a.get(this).GetOwnAngle()
    }
    set parallaxX(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetParallaxX(g)
    }
    get parallaxX() {
      return a.get(this).GetParallaxX()
    }
    set parallaxY(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetParallaxY(g)
    }
    get parallaxY() {
      return a.get(this).GetParallaxY()
    }
    set zElevation(g) {
      b.RequireFiniteNumber(g)
      a.get(this).SetZElevation(g)
    }
    get zElevation() {
      return a.get(this).GetZElevation()
    }
    set isTransparent(g) {
      a.get(this).SetTransparent(g)
    }
    get isTransparent() {
      return a.get(this).IsTransparent()
    }
    set isForceOwnTexture(g) {
      a.get(this).SetForceOwnTexture(g)
    }
    get isForceOwnTexture() {
      return a.get(this).IsForceOwnTexture()
    }
    set blendMode(g) {
      b.RequireString(g)
      g = c.get(g)
      if ('number' !== typeof g) throw Error('invalid blend mode')
      a.get(this).SetBlendMode(g)
    }
    get blendMode() {
      return d.get(a.get(this).GetBlendMode())
    }
    set backgroundColor(g) {
      b.RequireArray(g)
      if (3 > g.length) throw Error('expected 3 elements')
      f.setRgb(g[0], g[1], g[2])
      g = a.get(this)
      const h = g.GetBackgroundColor()
      h.equalsIgnoringAlpha(f) || (h.copyRgb(f), g.GetRuntime().UpdateRender())
    }
    get backgroundColor() {
      const g = a.get(this).GetBackgroundColor()
      return [g.getR(), g.getG(), g.getB()]
    }
    set scrollX(g) {
      b.RequireNumber(g)
      const h = a.get(this)
      h.SetOwnScrollPositionEnabled(!0)
      h.SetScrollX(g)
    }
    get scrollX() {
      return a.get(this).GetScrollX()
    }
    set scrollY(g) {
      b.RequireNumber(g)
      const h = a.get(this)
      h.SetOwnScrollPositionEnabled(!0)
      h.SetScrollY(g)
    }
    get scrollY() {
      return a.get(this).GetScrollY()
    }
    scrollTo(g, h) {
      b.RequireNumber(g)
      b.RequireNumber(h)
      const k = a.get(this)
      k.SetOwnScrollPositionEnabled(!0)
      k.SetScrollX(g)
      k.SetScrollY(h)
    }
    restoreScrollPosition() {
      a.get(this).SetOwnScrollPositionEnabled(!1)
    }
    getViewport() {
      return a.get(this).GetViewport().toDOMRect()
    }
    cssPxToLayer(g, h, k = 0) {
      b.RequireNumber(g)
      b.RequireNumber(h)
      b.RequireNumber(k)
      const m = a.get(this),
        r = m.GetRuntime()
      return m.CanvasCssToLayer(g - r.GetCanvasClientX(), h - r.GetCanvasClientY(), k)
    }
    layerToCssPx(g, h, k = 0) {
      b.RequireNumber(g)
      b.RequireNumber(h)
      b.RequireNumber(k)
      const m = a.get(this),
        r = m.GetRuntime(),
        [w, p] = m.LayerToCanvasCss(g, h, k)
      return [w + r.GetCanvasClientX(), p + r.GetCanvasClientY()]
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new WeakMap()

  function d(g) {
    let h = c.get(g)
    if (h) return h
    h = e.New(e.Event.Dispatcher)
    c.set(g, h)
    return h
  }
  let f = null
  self.IInstance = class {
    constructor() {
      a.set(this, f)
      const g = {
        runtime: {
          value: f.GetRuntime().GetIRuntime(),
          writable: !1
        },
        objectType: {
          value: f.GetObjectClass().GetIObjectClass(),
          writable: !1
        },
        uid: {
          value: f.GetUID(),
          writable: !1
        }
      }
      f._GetInstVarsScriptDescriptor(g)
      f._GetBehaviorsScriptDescriptor(g)
      Object.defineProperties(this, g)
      f.GetRuntime()._MapScriptInterface(this, f)
    }
    static _Init(g) {
      f = g
    }
    static _GetInitInst() {
      return f
    }
    _Release() {
      const g = c.get(this)
      g && (g.Release(), c.delete(this))
      a.delete(this)
    }
    addEventListener(g, h, k) {
      b.RequireString(g)
      b.RequireFunction(h)
      d(this).addEventListener(g, h, k)
    }
    removeEventListener(g, h, k) {
      b.RequireString(g)
      b.RequireFunction(h)
      d(this).removeEventListener(g, h, k)
    }
    dispatchEvent(g) {
      d(this).dispatchEvent(g)
    }
    destroy() {
      const g = a.get(this)
      g.GetRuntime().DestroyInstance(g)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IInstance,
    c = self.ILayer,
    d = new WeakMap(),
    f = new Map([
      ['normal', 0],
      ['additive', 1],
      ['copy', 3],
      ['destination-over', 4],
      ['source-in', 5],
      ['destination-in', 6],
      ['source-out', 7],
      ['destination-out', 8],
      ['source-atop', 9],
      ['destination-atop', 10]
    ]),
    g = new Map([...f.entries()].map(k => [k[1], k[0]])),
    h = e.New(e.Color)
  self.IWorldInstance = class k extends a {
    constructor() {
      super()
      var m = a._GetInitInst()
      d.set(this, m)
      const r = []
      var w = m.GetWorldInfo()
      if ((m = w.GetInstanceEffectList())) {
        w = w.GetObjectClass().GetEffectList().GetAllEffectTypes().length
        for (let p = 0; p < w; ++p) r.push(new self.IEffectInstance(m, p))
      }
      Object.defineProperties(this, {
        effects: {
          value: r,
          writable: !1
        }
      })
    }
    get layout() {
      return d.get(this).GetWorldInfo().GetLayout().GetILayout()
    }
    get layer() {
      return d.get(this).GetWorldInfo().GetLayer().GetILayer()
    }
    get x() {
      return d.get(this).GetWorldInfo().GetX()
    }
    set x(m) {
      m = +m
      const r = d.get(this).GetWorldInfo()
      isNaN(m) || r.GetX() === m || (r.SetX(m), r.SetBboxChanged())
    }
    get y() {
      return d.get(this).GetWorldInfo().GetY()
    }
    set y(m) {
      m = +m
      const r = d.get(this).GetWorldInfo()
      isNaN(m) || r.GetY() === m || (r.SetY(m), r.SetBboxChanged())
    }
    get zElevation() {
      return d.get(this).GetWorldInfo().GetZElevation()
    }
    set zElevation(m) {
      m = +m
      const r = d.get(this),
        w = r.GetWorldInfo()
      isNaN(m) || w.GetZElevation() === m || (w.SetZElevation(m), r.GetRuntime().UpdateRender())
    }
    get totalZElevation() {
      return d.get(this).GetWorldInfo().GetTotalZElevation()
    }
    get width() {
      return d.get(this).GetWorldInfo().GetWidth()
    }
    set width(m) {
      m = +m
      const r = d.get(this).GetWorldInfo()
      isNaN(m) || r.GetWidth() === m || (r.SetWidth(m), r.SetBboxChanged())
    }
    get height() {
      return d.get(this).GetWorldInfo().GetHeight()
    }
    set height(m) {
      m = +m
      const r = d.get(this).GetWorldInfo()
      isNaN(m) || r.GetHeight() === m || (r.SetHeight(m), r.SetBboxChanged())
    }
    get angle() {
      return d.get(this).GetWorldInfo().GetAngle()
    }
    set angle(m) {
      m = e.clampAngle(+m)
      const r = d.get(this).GetWorldInfo()
      isNaN(m) || r.GetAngle() === m || (r.SetAngle(m), r.SetBboxChanged())
    }
    get angleDegrees() {
      return e.toDegrees(this.angle)
    }
    set angleDegrees(m) {
      this.angle = e.toRadians(m)
    }
    getBoundingBox() {
      return d.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
    }
    getBoundingQuad() {
      return d.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
    }
    get isVisible() {
      return d.get(this).GetWorldInfo().IsVisible()
    }
    set isVisible(m) {
      m = !!m
      const r = d.get(this),
        w = r.GetWorldInfo()
      w.IsVisible() !== m && (w.SetVisible(m), r.GetRuntime().UpdateRender())
    }
    get opacity() {
      return d.get(this).GetWorldInfo().GetOpacity()
    }
    set opacity(m) {
      m = e.clamp(+m, 0, 1)
      const r = d.get(this),
        w = r.GetWorldInfo()
      isNaN(m) || w.GetOpacity() === m || (w.SetOpacity(m), r.GetRuntime().UpdateRender())
    }
    set colorRgb(m) {
      b.RequireArray(m)
      if (3 > m.length) throw Error('expected 3 elements')
      h.setRgb(m[0], m[1], m[2])
      m = d.get(this)
      const r = m.GetWorldInfo()
      r.GetUnpremultipliedColor().equalsIgnoringAlpha(h) || (r.SetUnpremultipliedColor(h), m.GetRuntime().UpdateRender())
    }
    get colorRgb() {
      const m = d.get(this).GetWorldInfo().GetUnpremultipliedColor()
      return [m.getR(), m.getG(), m.getB()]
    }
    set blendMode(m) {
      b.RequireString(m)
      m = f.get(m)
      if ('number' !== typeof m) throw Error('invalid blend mode')
      const r = d.get(this)
      r.GetWorldInfo().SetBlendMode(m)
      r.GetRuntime().UpdateRender()
    }
    get blendMode() {
      return g.get(d.get(this).GetWorldInfo().GetBlendMode())
    }
    moveToTop() {
      d.get(this).GetWorldInfo().ZOrderMoveToTop()
    }
    moveToBottom() {
      d.get(this).GetWorldInfo().ZOrderMoveToBottom()
    }
    moveToLayer(m) {
      b.RequireInstanceOf(m, c)
      m = c._Unwrap(m)
      if (!m) throw Error('invalid layer')
      d.get(this).GetWorldInfo().ZOrderMoveToLayer(m)
    }
    moveAdjacentToInstance(m, r) {
      b.RequireInstanceOf(m, k)
      d.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(d.get(m), r)
    }
    get zIndex() {
      return d.get(this).GetWorldInfo().GetZIndex()
    }
    containsPoint(m, r) {
      b.RequireNumber(m)
      b.RequireNumber(r)
      return d
        .get(this)
        .GetWorldInfo()
        .ContainsPoint(+m, +r)
    }
    testOverlap(m) {
      b.RequireInstanceOf(m, k)
      const r = d.get(this)
      m = d.get(m)
      return r.GetRuntime().GetCollisionEngine().TestOverlap(r, m)
    }
    testOverlapSolid() {
      var m = d.get(this)
      return (m = m.GetRuntime().GetCollisionEngine().TestOverlapSolid(m)) ? m.GetInterfaceClass() : null
    }
    getParent() {
      const m = d.get(this).GetParent()
      return m ? m.GetInterfaceClass() : null
    }
    getTopParent() {
      const m = d.get(this).GetTopParent()
      return m ? m.GetInterfaceClass() : null
    }
    *parents() {
      for (const m of d.get(this).parents()) yield m.GetInterfaceClass()
    }
    getChildCount() {
      return d.get(this).GetChildCount()
    }
    getChildAt(m) {
      return (m = d.get(this).GetChildAt(m)) ? m.GetInterfaceClass() : null
    }
    *children() {
      for (const m of d.get(this).children()) yield m.GetInterfaceClass()
    }
    *allChildren() {
      for (const m of d.get(this).allChildren()) yield m.GetInterfaceClass()
    }
    addChild(m, r) {
      b.RequireInstanceOf(m, k)
      b.RequireOptionalObject(r)
      r || (r = {})
      const w = d.get(this)
      m = d.get(m)
      w.AddChild(m, r)
    }
    removeChild(m) {
      b.RequireInstanceOf(m, k)
      const r = d.get(this)
      m = d.get(m)
      r.RemoveChild(m)
    }
    removeFromParent() {
      const m = d.get(this)
      m.HasParent() && m.GetParent().RemoveChild(m)
    }
    createMesh(m, r) {
      b.RequireFiniteNumber(m)
      b.RequireFiniteNumber(r)
      d.get(this).GetWorldInfo().CreateMesh(m, r)
    }
    releaseMesh() {
      const m = d.get(this).GetWorldInfo()
      m.ReleaseMesh()
      m.SetBboxChanged()
    }
    setMeshPoint(m, r, w) {
      b.RequireFiniteNumber(m)
      b.RequireFiniteNumber(r)
      b.RequireObject(w)
      const p = d.get(this).GetWorldInfo()
      p.SetMeshPoint(m, r, w) && p.SetBboxChanged()
    }
    getMeshSize() {
      var m = d.get(this).GetWorldInfo()
      if (!m.HasMesh()) return [0, 0]
      m = m.GetSourceMesh()
      return [m.GetHSize(), m.GetVSize()]
    }
  }
}
{
  ;('use strict')
  const e = self.C3X,
    b = new WeakMap()
  self.IDOMInstance = class extends self.IWorldInstance {
    constructor() {
      super()
      b.set(this, self.IInstance._GetInitInst())
    }
    getElement() {
      return b.get(this).GetSdkInstance()._GetElementInDOMMode()
    }
    focus() {
      b.get(this).GetSdkInstance().FocusElement()
    }
    blur() {
      b.get(this).GetSdkInstance().BlurElement()
    }
    setCssStyle(a, c) {
      e.RequireString(a)
      b.get(this).GetSdkInstance().SetElementCSSStyle(a, c)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap(),
    c = new WeakMap()

  function d(g) {
    let h = c.get(g)
    if (h) return h
    h = e.New(e.Event.Dispatcher)
    c.set(g, h)
    return h
  }
  let f = null
  self.IBehaviorInstance = class {
    constructor() {
      a.set(this, f)
      const g = {
        runtime: {
          value: f.GetRuntime().GetIRuntime(),
          writable: !1
        },
        behavior: {
          value: f.GetBehavior().GetIBehavior(),
          writable: !1
        }
      }
      Object.defineProperties(this, g)
    }
    static _Init(g) {
      f = g
    }
    static _GetInitInst() {
      return f
    }
    get instance() {
      return a.get(this).GetObjectInstance().GetInterfaceClass()
    }
    _Release() {
      const g = c.get(this)
      g && (g.Release(), c.delete(this))
      a.delete(this)
    }
    addEventListener(g, h, k) {
      b.RequireString(g)
      b.RequireFunction(h)
      d(this).addEventListener(g, h, k)
    }
    removeEventListener(g, h, k) {
      b.RequireString(g)
      b.RequireFunction(h)
      d(this).removeEventListener(g, h, k)
    }
    dispatchEvent(g) {
      d(this).dispatchEvent(g)
    }
  }
}
{
  ;('use strict')
  const e = new WeakMap()
  self.IBehavior = class {
    constructor(b) {
      e.set(this, b)
      b = {
        runtime: {
          value: b.GetRuntime().GetIRuntime(),
          writable: !1
        }
      }
      Object.defineProperties(this, b)
    }
    getAllInstances() {
      return e
        .get(this)
        .GetInstances()
        .map(b => b.GetInterfaceClass())
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = new WeakMap()
  self.IEffectInstance = class {
    constructor(c, d) {
      a.set(this, c)
      Object.defineProperties(this, {
        index: {
          value: d,
          writable: !1
        }
      })
    }
    get name() {
      return a.get(this).GetAllEffectTypes()[this.index].GetName()
    }
    get isActive() {
      return a.get(this).IsEffectIndexActive(this.index)
    }
    set isActive(c) {
      c = !!c
      const d = a.get(this)
      d.IsEffectIndexActive(this.index) !== c && (d.SetEffectIndexActive(this.index, c), d.UpdateActiveEffects(), d.GetRuntime().UpdateRender())
    }
    setParameter(c, d) {
      b.RequireFiniteNumber(c)
      c = Math.floor(+c)
      const f = a.get(this)
      var g = f.GetEffectParametersForIndex(this.index)
      if (0 > c || c >= g.length) throw new RangeError('invalid effect parameter index')
      const h = g[c]
      if (h instanceof e.Color) {
        if (!Array.isArray(d) || 3 > d.length) throw new TypeError('expected array with 3 elements')
        c = d[0]
        g = d[1]
        d = d[2]
        if (h.equalsRgb(c, g, d)) return
        h.setRgb(c, g, d)
      } else {
        if ('number' !== typeof d) throw new TypeError('expected number')
        if (h === d) return
        g[c] = d
      }
      f.IsEffectIndexActive(this.index) && f.GetRuntime().UpdateRender()
    }
    getParameter(c) {
      b.RequireFiniteNumber(c)
      c = Math.floor(+c)
      const d = a.get(this).GetEffectParametersForIndex(this.index)
      if (0 > c || c >= d.length) throw new RangeError('invalid effect parameter index')
      c = d[c]
      return c instanceof e.Color ? [c.getR(), c.getG(), c.getB()] : c
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set(['local', 'remote']),
    a = new Map([
      ['mp4', 'video/mp4'],
      ['webm', 'video/webm'],
      ['m4a', 'audio/mp4'],
      ['mp3', 'audio/mpeg'],
      ['js', 'application/javascript'],
      ['wasm', 'application/wasm'],
      ['svg', 'image/svg+xml'],
      ['html', 'text/html']
    ])

  function c(f) {
    if (!f) return ''
    f = f.split('.')
    if (2 > f.length) return ''
    f = f[f.length - 1].toLowerCase()
    return a.get(f) || ''
  }

  function d(f) {
    return new Promise((g, h) => {
      const k = document.createElement('script')
      k.onload = g
      k.onerror = h
      k.async = !1
      k.type = 'module'
      k.src = f
      document.head.appendChild(k)
    })
  }
  e.AssetManager = class extends e.DefendedBase {
    constructor(f, g) {
      super()
      var h = g.exportType
      this._runtime = f
      this._localUrlBlobs = new Map()
      this._localBlobUrlCache = new Map()
      this._localBlobSWUrls = new Map()
      this._isCordova = 'cordova' === h
      this._isiOSCordova = !!g.isiOSCordova
      this._isFileProtocol = !!g.isFileProtocol
      this._swClientId = g.swClientId
      this._supportedAudioFormats = g.supportedAudioFormats || {}
      this._audioFiles = new Map()
      this._preloadSounds = !1
      this._iconsSubfolder = this._fontsSubfolder = this._mediaSubfolder = ''
      this._defaultLoadPolicy = 'html5' === h || 'scirra-arcade' === h || 'instant-games' === h ? 'remote' : 'local'
      this._allAssets = []
      this._assetsByUrl = new Map()
      this._webFonts = []
      this._loadPromises = []
      this._hasFinishedInitialLoad = !1
      this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0
      this._hasHadErrorLoading = !1
      this._loadingRateLimiter = e.New(e.RateLimiter, () => this._FireLoadingProgressEvent(), 50)
      this._promiseThrottle = new e.PromiseThrottle(Math.max(e.hardwareConcurrency, 8))
      if ((f = g.previewImageBlobs)) {
        ;(h = g.previewProjectFileBlobs) && Object.assign(f, h)
        ;(h = g.projectData) && (f['data.json'] = h)
        for (const [k, m] of Object.entries(f)) this._localUrlBlobs.set(k.toLowerCase(), m)
      }
      if ((g = g.previewProjectFileSWUrls)) for (const [k, m] of Object.entries(g)) this._localBlobSWUrls.set(k, m)
      this._iAssetManager = new self.IAssetManager(this)
    }
    Release() {
      this._localUrlBlobs.clear()
      for (const f of this._localBlobUrlCache.values()) f.startsWith('blob:') && URL.revokeObjectURL(f)
      this._localBlobUrlCache.clear()
      for (const f of this._allAssets) f.Release()
      e.clearArray(this._allAssets)
      this._assetsByUrl.clear()
      e.clearArray(this._loadPromises)
      this._runtime = null
    }
    GetRuntime() {
      return this._runtime
    }
    _SetMediaSubfolder(f) {
      this._mediaSubfolder = f
    }
    GetMediaSubfolder() {
      return this._mediaSubfolder
    }
    _SetFontsSubfolder(f) {
      this._fontsSubfolder = f
    }
    GetFontsSubfolder() {
      return this._fontsSubfolder
    }
    _SetIconsSubfolder(f) {
      this._iconsSubfolder = f
    }
    GetIconsSubfolder() {
      return this._iconsSubfolder
    }
    IsFileProtocol() {
      return this._isFileProtocol
    }
    _HasLocalUrlBlob(f) {
      return this._localUrlBlobs.has(f.toLowerCase())
    }
    _GetLocalUrlBlob(f) {
      return this._localUrlBlobs.get(f.toLowerCase()) || null
    }
    GetLocalUrlAsBlobUrl(f) {
      if (!this._HasLocalUrlBlob(f)) return f
      f = f.toLowerCase()
      var g = this._localBlobUrlCache.get(f)
      g || ((g = this._GetLocalUrlBlob(f)), (g = URL.createObjectURL(g)), this._localBlobUrlCache.set(f, g))
      return g
    }
    FetchBlob(f, g) {
      g = g || this._defaultLoadPolicy
      const h = this._GetLocalUrlBlob(f)
      if (h) return Promise.resolve(h)
      if (e.IsRelativeURL(f)) {
        const k = f.toLowerCase()
        return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(k) : 'local' === g ? this._promiseThrottle.Add(() => e.FetchBlob(k)) : e.FetchBlob(k)
      }
      return e.FetchBlob(f)
    }
    FetchArrayBuffer(f) {
      const g = this._GetLocalUrlBlob(f)
      if (g) return e.BlobToArrayBuffer(g)
      if (e.IsRelativeURL(f)) {
        const h = f.toLowerCase()
        return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(h) : 'local' === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchArrayBuffer(h)) : e.FetchArrayBuffer(h)
      }
      return e.FetchArrayBuffer(f)
    }
    FetchText(f) {
      const g = this._GetLocalUrlBlob(f)
      if (g) return e.BlobToString(g)
      if (e.IsRelativeURL(f)) {
        const h = f.toLowerCase()
        return this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(h) : 'local' === this._defaultLoadPolicy ? this._promiseThrottle.Add(() => e.FetchText(h)) : e.FetchText(h)
      }
      return e.FetchText(f)
    }
    async FetchJson(f) {
      f = await this.FetchText(f)
      return JSON.parse(f)
    }
    _CordovaFetchLocalFileAs(f, g) {
      return this._runtime.PostComponentMessageToDOMAsync('runtime', 'cordova-fetch-local-file', {
        filename: f,
        as: g
      })
    }
    CordovaFetchLocalFileAsText(f) {
      return this._CordovaFetchLocalFileAs(f, 'text')
    }
    async CordovaFetchLocalFileAsBlob(f) {
      const g = await this._CordovaFetchLocalFileAs(f, 'buffer')
      f = c(f)
      return new Blob([g], {
        type: f
      })
    }
    async CordovaFetchLocalFileAsBlobURL(f) {
      f = f.toLowerCase()
      var g = this._localBlobUrlCache.get(f)
      if (g) return g
      g = await this.CordovaFetchLocalFileAsBlob(f)
      g = URL.createObjectURL(g)
      this._localBlobUrlCache.set(f, g)
      return g
    }
    CordovaFetchLocalFileAsArrayBuffer(f) {
      return this._CordovaFetchLocalFileAs(f, 'buffer')
    }
    GetMediaFileUrl(f) {
      return this._HasLocalUrlBlob(f) ? this.GetLocalUrlAsBlobUrl(f) : this._mediaSubfolder + f.toLowerCase()
    }
    GetProjectFileUrl(f, g = '') {
      if (e.IsAbsoluteURL(f)) {
        if (g) throw Error('cannot specify subfolder with remote URL')
        return Promise.resolve(f)
      }
      return this._HasLocalUrlBlob(f) ? Promise.resolve(this.GetLocalUrlAsBlobUrl(f)) : this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlobURL(g + f) : Promise.resolve(g + f.toLowerCase())
    }
    GetProjectFileIframeUrl(f) {
      if (e.IsAbsoluteURL(f)) return Promise.resolve(f)
      var g = f.indexOf('?'),
        h = -1 === g ? '' : f.substr(g)
      g = -1 === g ? f : f.substr(0, g)
      return this._HasLocalUrlBlob(g)
        ? ((f = this._localBlobSWUrls.get(g) || this.GetLocalUrlAsBlobUrl(g)), !f.startsWith('blob:') && this._swClientId && ((f = new URL(f)), (h = new URLSearchParams(h)), h.set('__c3_client_id', this._swClientId), (f.search = h.toString()), (f = f.toString())), Promise.resolve(f))
        : this._isCordova && this._isFileProtocol
        ? this.CordovaFetchLocalFileAsBlobURL(g)
        : Promise.resolve(f.toLowerCase())
    }
    LoadProjectFileUrl(f) {
      return this.GetProjectFileUrl(f)
    }
    LoadImage(f) {
      if (f.loadPolicy && !b.has(f.loadPolicy)) throw Error('invalid load policy')
      let g = this._assetsByUrl.get(f.url)
      if (g) return g
      g = e.New(e.ImageAsset, this, {
        url: f.url,
        size: f.size || 0,
        loadPolicy: f.loadPolicy || this._defaultLoadPolicy
      })
      this._allAssets.push(g)
      this._assetsByUrl.set(g.GetURL(), g)
      this._hasFinishedInitialLoad || ((this._totalAssetSizeToLoad += g.GetSize()), this._loadPromises.push(g.Load().then(() => this._AddLoadedSize(g.GetSize()))))
      return g
    }
    async WaitForAllToLoad() {
      try {
        await Promise.all(this._loadPromises), (this._lastLoadProgress = 1)
      } catch (f) {
        console.error('Error loading: ', f), (this._hasHadErrorLoading = !0), this._FireLoadingProgressEvent()
      }
    }
    SetInitialLoadFinished() {
      this._hasFinishedInitialLoad = !0
    }
    HasHadErrorLoading() {
      return this._hasHadErrorLoading
    }
    _AddLoadedSize(f) {
      this._assetSizeLoaded += f
      this._loadingRateLimiter.Call()
    }
    _FireLoadingProgressEvent() {
      const f = e.New(e.Event, 'loadingprogress')
      this._lastLoadProgress = e.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1)
      f.progress = this._lastLoadProgress
      this._runtime.Dispatcher().dispatchEvent(f)
    }
    GetLoadProgress() {
      return this._lastLoadProgress
    }
    _SetWebFonts(f) {
      e.shallowAssignArray(this._webFonts, f)
      this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
    }
    _LoadWebFonts() {
      if ('undefined' === typeof FontFace) return Promise.resolve()
      const f = []
      for (const [g, h, k] of this._webFonts) (this._totalAssetSizeToLoad += k), f.push(this._LoadWebFont(g, h).then(() => this._AddLoadedSize(k)))
      return Promise.all(f)
    }
    async _LoadWebFont(f, g) {
      try {
        const h = await this.GetProjectFileUrl(g, this._fontsSubfolder),
          k = new FontFace(f, `url('${h}')`)
        this._runtime.IsInWorker() ? self.fonts.add(k) : document.fonts.add(k)
        await k.load()
      } catch (h) {
        console.warn(`[C3 runtime] Failed to load web font '${f}': `, h)
      }
    }
    IsAudioFormatSupported(f) {
      return !!this._supportedAudioFormats[f]
    }
    _SetAudioFiles(f, g) {
      this._preloadSounds = !!g
      for (const [h, k, m] of f)
        this._audioFiles.set(h, {
          fileName: h,
          formats: k.map(r => ({
            type: r[0],
            fileExtension: r[1],
            fullName: h + r[1],
            fileSize: r[2]
          })),
          isMusic: m
        })
    }
    GetPreferredAudioFile(f) {
      f = this._audioFiles.get(f.toLowerCase())
      if (!f) return null
      let g = null
      for (const h of f.formats) if ((g || 'audio/webm; codecs=opus' !== h.type || (g = h), this.IsAudioFormatSupported(h.type))) return h
      return g
    }
    GetProjectAudioFileUrl(f) {
      return (f = this.GetPreferredAudioFile(f))
        ? {
            url: this.GetMediaFileUrl(f.fullName),
            type: f.type
          }
        : null
    }
    GetAudioToPreload() {
      if (this._preloadSounds) {
        const f = []
        for (const g of this._audioFiles.values()) {
          if (g.isMusic) continue
          const h = this.GetPreferredAudioFile(g.fileName)
          h &&
            f.push({
              originalUrl: g.fileName,
              url: this.GetMediaFileUrl(h.fullName),
              type: h.type,
              fileSize: h.fileSize
            })
        }
        return f
      }
      return []
    }
    GetIAssetManager() {
      return this._iAssetManager
    }
    async LoadScripts(...f) {
      const g = await Promise.all(f.map(h => this.GetProjectFileUrl(h)))
      this._runtime.IsInWorker()
        ? 1 === f.length
          ? ((f = f[0]), await self.c3_import((e.IsRelativeURL(f) ? './' : '') + f))
          : ((f = f.map(h => `import "${e.IsRelativeURL(h) ? './' : ''}${h}";`).join('\n')),
            (f = URL.createObjectURL(
              new Blob([f], {
                type: 'application/javascript'
              })
            )),
            await self.c3_import(f))
        : await Promise.all(g.map(h => d(h)))
    }
    async CompileWebAssembly(f) {
      if (WebAssembly.compileStreaming) return (f = await this.GetProjectFileUrl(f)), await WebAssembly.compileStreaming(fetch(f))
      f = await e.FetchArrayBuffer(f)
      return await WebAssembly.compile(f)
    }
    async LoadStyleSheet(f) {
      f = await this.GetProjectFileUrl(f)
      return await this._runtime.PostComponentMessageToDOMAsync('runtime', 'add-stylesheet', {
        url: f
      })
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Asset = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._assetManager = b
      this._runtime = b.GetRuntime()
      this._url = a.url
      this._size = a.size
      this._loadPolicy = a.loadPolicy
      this._blob = null
      this._isLoaded = !1
      this._loadPromise = null
    }
    Release() {
      this._blob = this._runtime = this._assetManager = this._loadPromise = null
    }
    GetURL() {
      return this._url
    }
    GetSize() {
      return this._size
    }
    Load() {
      return 'local' === this._loadPolicy || this._blob
        ? ((this._isLoaded = !0), Promise.resolve())
        : this._loadPromise
        ? this._loadPromise
        : (this._loadPromise = this._assetManager
            .FetchBlob(this._url, this._loadPolicy)
            .then(b => {
              this._isLoaded = !0
              this._loadPromise = null
              return (this._blob = b)
            })
            .catch(b => console.error('Error loading resource: ', b)))
    }
    IsLoaded() {
      return this._isLoaded
    }
    GetBlob() {
      return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new e.PromiseThrottle(),
    a = new Set()
  e.ImageAsset = class extends e.Asset {
    constructor(c, d) {
      super(c, d)
      this._webglTexture = this._texturePromise = null
      this._refCount = 0
      this._imageHeight = this._imageWidth = -1
      a.add(this)
    }
    Release() {
      this.ReleaseTexture()
      if (0 !== this._refCount) throw Error('released image asset which still has texture references')
      this._texturePromise = null
      a.delete(this)
      super.Release()
    }
    static OnWebGLContextLost() {
      for (const c of a) (c._texturePromise = null), (c._webglTexture = null), (c._refCount = 0)
    }
    LoadStaticTexture(c, d) {
      d = d || {}
      this._refCount++
      if (this._webglTexture) return Promise.resolve(this._webglTexture)
      if (this._texturePromise) return this._texturePromise
      d.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy()
      return (this._texturePromise = this.GetBlob()
        .then(f =>
          b.Add(() =>
            c.CreateStaticTextureAsync(f, d).then(g => {
              this._texturePromise = null
              if (0 === this._refCount) return c.DeleteTexture(g), null
              this._webglTexture = g
              this._imageWidth = g.GetWidth()
              this._imageHeight = g.GetHeight()
              return this._webglTexture
            })
          )
        )
        .catch(f => {
          console.error('Failed to load texture: ', f)
          throw f
        }))
    }
    ReleaseTexture() {
      if (0 >= this._refCount) throw Error('texture released too many times')
      this._refCount--
      0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), (this._webglTexture = null))
    }
    GetTexture() {
      return this._webglTexture
    }
    GetWidth() {
      return this._imageWidth
    }
    GetHeight() {
      return this._imageHeight
    }
    async LoadToDrawable() {
      const c = await this.GetBlob()
      return e.Supports.ImageBitmapOptions
        ? await createImageBitmap(c, {
            premultiplyAlpha: 'none'
          })
        : e.Supports.ImageBitmap
        ? await createImageBitmap(c)
        : await e.BlobToImage(c)
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a, c) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - c.GetWorldInfo()._GetLastCachedZIndex()
  }
  e.RenderCell = class extends e.DefendedBase {
    constructor(a, c, d) {
      super()
      this._grid = a
      this._x = c
      this._y = d
      this._instances = []
      this._isSorted = !0
      this._pendingRemoval = new Set()
      this._isAnyPendingRemoval = !1
    }
    Release() {
      e.clearArray(this._instances)
      this._pendingRemoval.clear()
      this._grid = null
    }
    Reset() {
      e.clearArray(this._instances)
      this._isSorted = !0
      this._pendingRemoval.clear()
      this._isAnyPendingRemoval = !1
    }
    SetChanged() {
      this._isSorted = !1
    }
    IsEmpty() {
      if (!this._instances.length) return !0
      if (this._instances.length > this._pendingRemoval.size) return !1
      this._FlushPending()
      return !0
    }
    Insert(a) {
      this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a), (this._isSorted = 1 === this._instances.length))
    }
    Remove(a) {
      this._pendingRemoval.add(a)
      this._isAnyPendingRemoval = !0
      50 <= this._pendingRemoval.size && this._FlushPending()
    }
    _FlushPending() {
      this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ? this.Reset() : (e.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), (this._isAnyPendingRemoval = !1)))
    }
    _EnsureSorted() {
      this._isSorted || (this._instances.sort(b), (this._isSorted = !0))
    }
    Dump(a) {
      this._FlushPending()
      this._EnsureSorted()
      this._instances.length && a.push(this._instances)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.RenderGrid = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._cellWidth = b
      this._cellHeight = a
      this._cells = e.New(e.PairMap)
    }
    Release() {
      this._cells.Release()
      this._cells = null
    }
    GetCell(b, a, c) {
      let d = this._cells.Get(b, a)
      return d ? d : c ? ((d = e.New(e.RenderCell, this, b, a)), this._cells.Set(b, a, d), d) : null
    }
    XToCell(b) {
      return Math.floor(b / this._cellWidth)
    }
    YToCell(b) {
      return Math.floor(b / this._cellHeight)
    }
    Update(b, a, c) {
      if (a)
        for (let d = a.getLeft(), f = a.getRight(); d <= f; ++d)
          for (let g = a.getTop(), h = a.getBottom(); g <= h; ++g) {
            if (c && c.containsPoint(d, g)) continue
            const k = this.GetCell(d, g, !1)
            k && (k.Remove(b), k.IsEmpty() && this._cells.Delete(d, g))
          }
      if (c) for (let d = c.getLeft(), f = c.getRight(); d <= f; ++d) for (let g = c.getTop(), h = c.getBottom(); g <= h; ++g) (a && a.containsPoint(d, g)) || this.GetCell(d, g, !0).Insert(b)
    }
    QueryRange(b, a) {
      let c = this.XToCell(b.getLeft())
      const d = this.YToCell(b.getTop()),
        f = this.XToCell(b.getRight())
      for (b = this.YToCell(b.getBottom()); c <= f; ++c)
        for (let g = d; g <= b; ++g) {
          const h = this.GetCell(c, g, !1)
          h && h.Dump(a)
        }
    }
    MarkRangeChanged(b) {
      let a = b.getLeft()
      const c = b.getTop(),
        d = b.getRight()
      for (b = b.getBottom(); a <= d; ++a)
        for (let f = c; f <= b; ++f) {
          const g = this.GetCell(a, f, !1)
          g && g.SetChanged()
        }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new e.Rect(),
    a = new e.Quad(),
    c = [],
    d = new e.Rect(),
    f = new e.Rect(),
    g = self.glMatrix,
    h = g.vec3,
    k = g.vec4,
    m = g.mat4,
    r = m.create(),
    w = h.create(),
    p = k.create(),
    q = h.create(),
    t = h.create(),
    x = h.create(),
    v = e.New(e.Vector2)

  function u(z, C) {
    return z.GetWorldInfo()._GetLastCachedZIndex() - C.GetWorldInfo()._GetLastCachedZIndex()
  }

  function A(z, C) {
    return z.GetWorldInfo().GetZElevation() - C.GetWorldInfo().GetZElevation()
  }
  e.Layer = class extends e.DefendedBase {
    constructor(z, C, E) {
      super()
      this._layout = z
      this._runtime = z.GetRuntime()
      this._name = E[0]
      this._index = C
      this._sid = E[2]
      this._isVisible = !!E[3]
      this._backgroundColor = e.New(e.Color)
      this._backgroundColor.setFromJSON(E[4].map(J => J / 255))
      this._isTransparent = !!E[5]
      this._parallaxX = E[6]
      this._parallaxY = E[7]
      this._color = e.New(e.Color, 1, 1, 1, E[8])
      this._premultipliedColor = e.New(e.Color)
      this._isForceOwnTexture = E[9]
      this._renderAs3d = E[17]
      this._useRenderCells = E[10]
      this._scaleRate = E[11]
      this._blendMode = E[12]
      this._curRenderTarget = null
      this._scale = 1
      this._zElevation = E[16]
      this._scrollY = this._scrollX = this._angle = 0
      this._hasOwnScrollPosition = !1
      this._viewport = e.New(e.Rect)
      this._viewportZ0 = e.New(e.Rect)
      this._projectionMatrix = m.create()
      this._isProjectionMatrixChanged = !0
      this._modelViewMatrix = m.create()
      this._isMVMatrixChanged = !0
      this._viewFrustum = e.New(e.Gfx.ViewFrustum)
      this._isViewFrustumChanged = !0
      this._startupInitialInstances = []
      this._initialInstances = []
      this._createdGlobalUids = []
      this._initialUIDsToInstanceData = new Map()
      this._instances = []
      this._anyInstanceZElevated = this._zIndicesUpToDate = !1
      this._effectList = e.New(e.EffectList, this, E[15])
      this._renderGrid = null
      this._lastRenderList = []
      this._isRenderListUpToDate = !1
      this._lastRenderCells = e.New(e.Rect, 0, 0, -1, -1)
      this._curRenderCells = e.New(e.Rect, 0, 0, -1, -1)
      this._iLayer = new self.ILayer(this)
      this._UpdatePremultipliedColor()
      this._useRenderCells && (this._renderGrid = e.New(e.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()))
      for (const J of E[14]) (z = this._runtime.GetObjectClassByIndex(J[1])), this._layout._AddInitialObjectClass(z), z.GetDefaultInstanceData() || (z.SetDefaultInstanceData(J), z._SetDefaultLayerIndex(this._index)), this._initialInstances.push(J), this._initialUIDsToInstanceData.set(J[2], J)
      e.shallowAssignArray(this._startupInitialInstances, this._initialInstances)
    }
    static Create(z, C, E) {
      return e.New(e.Layer, z, C, E)
    }
    Release() {
      this._runtime = this._layout = null
    }
    GetInitialInstanceData(z) {
      return this._initialUIDsToInstanceData.get(z)
    }
    CreateInitialInstances(z) {
      const C = this._layout.IsFirstVisit()
      let E = 0
      const J = this._initialInstances
      for (let I = 0, L = J.length; I < L; ++I) {
        var F = J[I]
        const N = this._runtime.GetObjectClassByIndex(F[1])
        let S = !0
        if (!N.HasPersistBehavior() || C) (F = this._runtime.CreateInstanceFromData(F, this, !0)), z.push(F), N.IsGlobal() && ((S = !1), this._createdGlobalUids.push(F.GetUID()))
        S && ((J[E] = J[I]), ++E)
      }
      e.truncateArray(J, E)
      this._runtime.FlushPendingInstances()
      this.SetZIndicesChanged()
    }
    _AddInstance(z, C) {
      const E = z.GetWorldInfo()
      if (E.GetLayer() !== this) throw Error('instance added to wrong layer')
      this._instances.push(z)
      0 !== E.GetZElevation() && (this._anyInstanceZElevated = !0)
      C && this._useRenderCells && z.GetWorldInfo().SetBboxChanged()
      this.SetZIndicesChanged()
    }
    _MaybeAddInstance(z) {
      this._instances.includes(z) || (this._instances.push(z), 0 !== z.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged())
    }
    _PrependInstance(z, C) {
      const E = z.GetWorldInfo()
      if (E.GetLayer() !== this) throw Error('instance added to wrong layer')
      this._instances.unshift(z)
      0 !== E.GetZElevation() && (this._anyInstanceZElevated = !0)
      this.SetZIndicesChanged()
      C && this._useRenderCells && z.GetWorldInfo().SetBboxChanged()
    }
    _RemoveInstance(z, C) {
      const E = this._instances.indexOf(z)
      0 > E || (C && this._useRenderCells && z.GetWorldInfo()._RemoveFromRenderCells(), this._instances.splice(E, 1), this.SetZIndicesChanged(), this._MaybeResetAnyInstanceZElevatedFlag())
    }
    _SetAnyInstanceZElevated() {
      this._anyInstanceZElevated = !0
    }
    _MaybeResetAnyInstanceZElevatedFlag() {
      0 === this._instances.length && (this._anyInstanceZElevated = !1)
    }
    _SortInstancesByLastCachedZIndex(z) {
      if (z) {
        z = new Set()
        for (var C of this._instances) {
          var E = C.GetWorldInfo()._GetLastCachedZIndex()
          0 <= E && z.add(E)
        }
        C = -1
        for (const J of this._instances)
          if (((E = J.GetWorldInfo()), !(0 <= E._GetLastCachedZIndex()))) {
            for (++C; z.has(C); ) ++C
            E._SetZIndex(C)
          }
      }
      this._instances.sort(u)
    }
    _Start() {}
    _End() {
      for (const z of this._instances) z.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(z)
      this._runtime.FlushPendingInstances()
      e.clearArray(this._instances)
      this._anyInstanceZElevated = !1
      this.SetZIndicesChanged()
    }
    RecreateInitialObjects(z, C, E, J, F) {
      const I = this._runtime.GetEventSheetManager(),
        L = this._runtime.GetAllObjectClasses(),
        N = z.IsFamily(),
        S = []
      for (const X of this._initialInstances) {
        var V = X[0]
        if (C.containsPoint(V[0], V[1])) {
          V = L[X[1]]
          if (V !== z)
            if (N) {
              if (!z.FamilyHasMember(V)) continue
            } else continue
          V = this
          var U = this._runtime.GetCurrentLayout()
          this.GetLayout() !== U && ((V = U.GetLayerByName(this.GetName())) || (V = U.GetLayerByIndex(this.GetIndex())))
          U = this._runtime.CreateInstanceFromData(X, V, !1, void 0, void 0, !1, F)
          V.SortAndAddSceneGraphInstancesByZIndex(U)
          V = U.GetWorldInfo()
          V.OffsetXY(E, J)
          V.SetBboxChanged()
          I.BlockFlushingInstances(!0)
          U._TriggerOnCreatedOnSelfAndRelated()
          I.BlockFlushingInstances(!1)
          S.push(U)
        }
      }
      return S
    }
    GetInstanceCount() {
      return this._instances.length
    }
    GetLayout() {
      return this._layout
    }
    GetName() {
      return this._name
    }
    GetIndex() {
      return this._index
    }
    GetSID() {
      return this._sid
    }
    GetRuntime() {
      return this._runtime
    }
    GetDevicePixelRatio() {
      return this._runtime.GetDevicePixelRatio()
    }
    GetEffectList() {
      return this._effectList
    }
    UsesRenderCells() {
      return this._useRenderCells
    }
    GetRenderGrid() {
      return this._renderGrid
    }
    SetRenderListStale() {
      this._isRenderListUpToDate = !1
    }
    IsVisible() {
      return this._isVisible
    }
    SetVisible(z) {
      z = !!z
      this._isVisible !== z && ((this._isVisible = z), this._runtime.UpdateRender())
    }
    SetOwnScrollPositionEnabled(z) {
      z = !!z
      if (this._hasOwnScrollPosition !== z) {
        if ((this._hasOwnScrollPosition = z)) (z = this.GetLayout()), (this._scrollX = z.GetScrollX()), (this._scrollY = z.GetScrollY())
        this._SetMVMatrixChanged()
        this._runtime.UpdateRender()
      }
    }
    IsOwnScrollPositionEnabled() {
      return this._hasOwnScrollPosition
    }
    SetScrollX(z) {
      var C = this.GetLayout()
      const E = C.GetScrollLeftBound()
      C = C.GetScrollRightBound()
      z > C && (z = C)
      z < E && (z = E)
      this._scrollX !== z && ((this._scrollX = z), this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
    }
    SetScrollY(z) {
      var C = this.GetLayout()
      const E = C.GetScrollTopBound()
      C = C.GetScrollBottomBound()
      z > C && (z = C)
      z < E && (z = E)
      this._scrollY !== z && ((this._scrollY = z), this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
    }
    GetScrollX() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX()
    }
    GetScrollY() {
      return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
    }
    GetViewport() {
      return this._viewport
    }
    _GetVanishingPoint() {
      if (this._renderAs3d) {
        const z = this.GetLayout()
        return [z.GetVanishingPointX(), z.GetVanishingPointY()]
      }
      return [0.5, 0.5]
    }
    GetViewportForZ(z, C) {
      var E = this._viewportZ0
      if (0 === z) C.copy(E)
      else {
        let L = E.midX(),
          N = E.midY()
        var J = this.Get2DScaleFactorToZ(z)
        const S = E.width() / J
        E = E.height() / J
        const [V, U] = this._GetVanishingPoint()
        if (0.5 !== V || 0.5 !== U) {
          const X = this.GetCameraZ()
          var F = this._runtime,
            I = 100 / X
          J = ((V - 0.5) * F.GetViewportWidth()) / I
          F = ((U - 0.5) * F.GetViewportHeight()) / I
          I = this.GetAngle()
          0 !== I && (v.set(J, F), v.rotate(I), (J = v.getX()), (F = v.getY()))
          z = e.unlerp(X, 0, z)
          L += e.lerp(J, 0, z)
          N += e.lerp(F, 0, z)
        }
        C.set(L - S / 2, N - E / 2, L + S / 2, N + E / 2)
      }
    }
    GetOpacity() {
      return this._color.getA()
    }
    SetOpacity(z) {
      z = e.clamp(z, 0, 1)
      this._color.getA() !== z && (this._color.setA(z), this._UpdatePremultipliedColor(), this._runtime.UpdateRender())
    }
    _UpdatePremultipliedColor() {
      this._premultipliedColor.copy(this._color)
      this._premultipliedColor.premultiply()
    }
    GetPremultipliedColor() {
      return this._premultipliedColor
    }
    HasDefaultColor() {
      return this._color.equalsRgba(1, 1, 1, 1)
    }
    GetScaleRate() {
      return this._scaleRate
    }
    SetScaleRate(z) {
      this._scaleRate !== z && ((this._scaleRate = z), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetParallaxX() {
      return this._parallaxX
    }
    GetParallaxY() {
      return this._parallaxY
    }
    SetParallax(z, C) {
      if (this._parallaxX !== z || this._parallaxY !== C) if (((this._parallaxX = z), (this._parallaxY = C), this._SetMVMatrixChanged(), this._runtime.UpdateRender(), 1 !== this._parallaxX || 1 !== this._parallaxY)) for (const E of this._instances) E.GetObjectClass()._SetAnyInstanceParallaxed(!0)
    }
    SetParallaxX(z) {
      this.SetParallax(z, this.GetParallaxY())
    }
    SetParallaxY(z) {
      this.SetParallax(this.GetParallaxX(), z)
    }
    SetZElevation(z) {
      this._zElevation !== z && ((this._zElevation = z), this._runtime.UpdateRender())
    }
    GetZElevation() {
      return this._zElevation
    }
    SetAngle(z) {
      z = e.clampAngle(z)
      this._angle !== z && ((this._angle = z), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetAngle() {
      return e.clampAngle(this._layout.GetAngle() + this._angle)
    }
    GetOwnAngle() {
      return this._angle
    }
    HasInstances() {
      return 0 < this._instances.length
    }
    _GetInstances() {
      return this._instances
    }
    GetBackgroundColor() {
      return this._backgroundColor
    }
    IsTransparent() {
      return this._isTransparent
    }
    SetTransparent(z) {
      z = !!z
      this._isTransparent !== z && ((this._isTransparent = z), this._runtime.UpdateRender())
    }
    IsForceOwnTexture() {
      return this._isForceOwnTexture
    }
    SetForceOwnTexture(z) {
      z = !!z
      this._isForceOwnTexture !== z && ((this._isForceOwnTexture = z), this._runtime.UpdateRender())
    }
    RendersIn2DMode() {
      return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d
    }
    SetBlendMode(z) {
      this._blendMode !== z && ((this._blendMode = z), this._runtime.UpdateRender())
    }
    GetBlendMode() {
      return this._blendMode
    }
    IsTransformCompatibleWith(z) {
      return this === z || (this._parallaxX === z._parallaxX && this._parallaxY === z._parallaxY && this._scale === z._scale && this._scaleRate === z._scaleRate && this._angle === z._angle && this.GetScrollX() === z.GetScrollX() && this.GetScrollY() === z.GetScrollY())
    }
    SaveTransform() {
      return {
        parallaxX: this.GetParallaxX(),
        parallaxY: this.GetParallaxY(),
        scale: this.GetOwnScale(),
        scaleRate: this.GetScaleRate(),
        angle: this.GetOwnAngle(),
        hasOwnScroll: this.IsOwnScrollPositionEnabled(),
        scrollX: this.GetScrollX(),
        scrollY: this.GetScrollY()
      }
    }
    RestoreTransform(z) {
      this.SetParallax(z.parallaxX, z.parallaxY)
      this.SetOwnScale(z.scale)
      this.SetScaleRate(z.scaleRate)
      this.SetAngle(z.angle)
      this.SetOwnScrollPositionEnabled(z.hasOwnScroll)
      this.SetScrollX(z.scrollX)
      this.SetScrollY(z.scrollY)
    }
    _RemoveAllInstancesInSet(z) {
      0 !== z.size && 0 < e.arrayRemoveAllInSet(this._instances, z) && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged())
    }
    SetZIndicesChanged() {
      this._isRenderListUpToDate = this._zIndicesUpToDate = !1
    }
    _UpdateZIndices() {
      if (!this._zIndicesUpToDate) {
        this._instances.sort(A)
        if (this._useRenderCells)
          for (let z = 0, C = this._instances.length; z < C; ++z) {
            const E = this._instances[z].GetWorldInfo()
            E._SetZIndex(z)
            this._renderGrid.MarkRangeChanged(E.GetRenderCellRange())
          }
        else for (let z = 0, C = this._instances.length; z < C; ++z) this._instances[z].GetWorldInfo()._SetZIndex(z)
        this._zIndicesUpToDate = !0
      }
    }
    MoveInstanceAdjacent(z, C, E) {
      var J = z.GetWorldInfo()
      C = C.GetWorldInfo()
      if (J.GetLayer() !== this || C.GetLayer() !== this) throw Error("can't arrange Z order unless both objects on this layer")
      J = J.GetZIndex()
      C = C.GetZIndex()
      if (J === C + (E ? 1 : -1)) return !1
      e.arrayRemove(this._instances, J)
      J < C && C--
      E && C++
      C === this._instances.length ? this._instances.push(z) : this._instances.splice(C, 0, z)
      this.SetZIndicesChanged()
      return !0
    }
    _MergeSortedZArrays(z, C) {
      const E = []
      let J = 0,
        F = 0,
        I = z.length,
        L = C.length
      for (; J < I && F < L; ) {
        const N = z[J],
          S = C[F]
        N.GetWorldInfo()._GetLastCachedZIndex() < S.GetWorldInfo()._GetLastCachedZIndex() ? (E.push(N), ++J) : (E.push(S), ++F)
      }
      for (; J < I; ++J) E.push(z[J])
      for (; F < L; ++F) E.push(C[F])
      return E
    }
    _MergeAllSortedZArrays_pass(z) {
      const C = [],
        E = z.length
      for (let J = 0; J < E - 1; J += 2) C.push(this._MergeSortedZArrays(z[J], z[J + 1]))
      1 === E % 2 && C.push(z[E - 1])
      return C
    }
    _MergeAllSortedZArrays(z) {
      for (; 1 < z.length; ) z = this._MergeAllSortedZArrays_pass(z)
      return z[0]
    }
    _GetRenderCellInstancesToDraw() {
      this._UpdateZIndices()
      e.clearArray(c)
      this._renderGrid.QueryRange(this._viewport, c)
      return c.length ? (1 === c.length ? c[0] : this._MergeAllSortedZArrays(c)) : []
    }
    _IsOpaque() {
      return !this.UsesOwnTexture() && !this.IsTransparent()
    }
    ShouldDraw() {
      return this.IsVisible() && 0 < this.GetOpacity() && (this.HasInstances() || !this.IsTransparent())
    }
    UsesOwnTexture() {
      return this.IsForceOwnTexture() || !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
    }
    GetRenderTarget() {
      return this._curRenderTarget
    }
    _CanFastPathDrawLayer(z) {
      if (0 === z.length) return !0
      if (2 <= z.length) return !1
      z = z[0].GetShaderProgram()
      return !z.MustPreDraw() && !z.UsesDest() && !z.UsesCrossSampling() && this.HasDefaultColor()
    }
    Get2DScaleFactorToZ(z) {
      const C = this.GetCameraZ()
      return C / (C - z)
    }
    GetCameraZ() {
      return 100 / this.GetNormalScale()
    }
    _SetMVMatrixChanged() {
      this._isViewFrustumChanged = this._isMVMatrixChanged = !0
    }
    _GetModelViewMatrix(z) {
      this._isMVMatrixChanged && (this._CalculateModelViewMatrix(z, this._modelViewMatrix, 0, 0, null), (this._isMVMatrixChanged = !1))
      return this._modelViewMatrix
    }
    _CalculateModelViewMatrix(z, C, E, J, F) {
      const I = this._runtime,
        L = I.GetRenderScale()
      var N = I.GetParallaxXOrigin(),
        S = I.GetParallaxYOrigin()
      N = (this.GetScrollX() - N) * this._parallaxX + N
      S = (this.GetScrollY() - S) * this._parallaxY + S
      this._runtime.IsPixelRoundingEnabled() && ((N = Math.round(N)), (S = Math.round(S)))
      E = (N + E) * L
      J = (S + J) * L
      S = this.GetCameraZ()
      N = this.GetAngle()
      const [V, U] = this._GetVanishingPoint()
      if (0.5 !== V || 0.5 !== U) {
        var X = 100 / S
        let ia = ((V - 0.5) * I.GetViewportWidth() * L) / X
        X = ((U - 0.5) * I.GetViewportHeight() * L) / X
        0 !== N && (v.set(ia, X), v.rotate(N), (ia = v.getX()), (X = v.getY()))
        E += ia
        J += X
      }
      h.set(q, E, J, S)
      h.set(t, E, J, S - 100)
      0 === N ? h.set(x, 0, 1, 0) : h.set(x, Math.sin(N), Math.cos(N), 0)
      z.CalculateLookAtModelView(C, q, t, x, F || I.GetCanvasManager().GetDrawHeight())
      1 !== L && (h.set(w, L, L, 1), m.scale(C, C, w))
    }
    _SetProjectionMatrixChanged() {
      this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
    }
    _GetProjectionMatrix(z) {
      this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(z), (this._isProjectionMatrixChanged = !1))
      return this._projectionMatrix
    }
    _CalculateProjectionMatrix(z) {
      var C = this._runtime.GetCanvasManager()
      const E = C.GetDrawWidth()
      C = C.GetDrawHeight()
      const [J, F] = this._GetVanishingPoint()
      z.CalculatePerspectiveMatrix(this._projectionMatrix, E / C, J, F)
    }
    _SetTransform(z, C = !0, E = 0, J = 0, F = 0) {
      C && z.SetProjectionMatrix(this._GetProjectionMatrix(z))
      0 === E && 0 === J && 0 === F ? (C = this._GetModelViewMatrix(z)) : (this._CalculateModelViewMatrix(z, r, E, J, F), (C = r))
      z.SetModelViewMatrix(C)
    }
    Draw(z, C, E) {
      const J = this._runtime.GetCanvasManager(),
        F = this.UsesOwnTexture()
      var I = null
      let L = null
      if (this._runtime.IsGPUProfiling())
        if (z.IsWebGL()) {
          const N = J.GetLayerTimingsBuffer(this)
          N && ((L = N.AddTimeElapsedQuery()), z.StartQuery(L))
        } else z.IsWebGPU() && z.WriteTimestamp(2 * (this.GetIndex() + 1))
      F
        ? ((I = {
            sampling: this._runtime.GetSampling()
          }),
          'low' === J.GetCurrentFullscreenScalingQuality() && ((I.width = J.GetDrawWidth()), (I.height = J.GetDrawHeight())),
          (I = this._runtime.GetAdditionalRenderTarget(I)),
          z.SetRenderTarget(I),
          this.IsTransparent() ? z.ClearRgba(0, 0, 0, 0) : z.Clear(this._backgroundColor))
        : (z.SetRenderTarget(C), this.IsTransparent() || E || z.Clear(this._backgroundColor))
      this._curRenderTarget = I || C
      this._SetTransform(z)
      z.SetBaseZ(this.GetZElevation())
      z.SetDepthEnabled(this.GetRuntime().Uses3DFeatures() && this._renderAs3d)
      this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(), this._useRenderCells && 0 === this.GetZElevation() && !this._anyInstanceZElevated ? this._DrawInstances_RenderCells(z) : this._DrawInstances(z, this._instances))
      z.SetBaseZ(0)
      z.SetCurrentZ(0)
      F && (z.SetDepthEnabled(!1), this._DrawLayerOwnTextureToRenderTarget(z, I, C, E))
      L && z.EndQuery(L)
      this._runtime.IsGPUProfiling() && z.IsWebGPU() && z.WriteTimestamp(2 * (this.GetIndex() + 1) + 1)
      this._curRenderTarget = null
    }
    _DrawInstances(z, C) {
      const E = this._viewport,
        J = this._curRenderTarget,
        F = this.GetLayout().HasVanishingPointOutsideViewport()
      let I = null
      for (let L = 0, N = C.length; L < N; ++L) {
        const S = C[L]
        if (S === I) continue
        I = S
        const V = S.GetWorldInfo()
        V.IsVisible() && V.IsInViewport(E, F) && (V.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(S, V, z, J) : this._DrawInstance(S, V, z))
      }
    }
    _DrawInstances_RenderCells(z) {
      var C = this._renderGrid
      const E = this._curRenderCells,
        J = this._lastRenderCells,
        F = this._viewport
      E.set(C.XToCell(F.getLeft()), C.YToCell(F.getTop()), C.XToCell(F.getRight()), C.YToCell(F.getBottom()))
      this._isRenderListUpToDate && E.equals(J) ? (C = this._lastRenderList) : ((C = this._GetRenderCellInstancesToDraw()), (this._isRenderListUpToDate = !0), J.copy(E))
      this._DrawInstances(z, C)
      C !== this._lastRenderList && e.shallowAssignArray(this._lastRenderList, C)
    }
    _DrawInstance(z, C, E) {
      C = C.GetRendererStateGroup()
      E.GetCurrentStateGroup() !== C && C.Apply()
      z.Draw(E)
    }
    _DrawInstanceWithEffectsAndRestore(z, C, E, J) {
      this._DrawInstanceWithEffects(z, C, E, J, null) && this._SetTransform(E)
    }
    _DrawInstanceWithEffects(z, C, E, J, F) {
      const I = C.GetInstanceEffectList().GetActiveEffectTypes()
      if (1 === I.length) {
        const L = I[0],
          N = L.GetShaderProgram()
        if (!N.NeedsPostDrawOrExtendsBox() && C.HasDefaultColor() && !z.MustPreDraw()) return this._DrawInstanceWithEffects_FastPath(z, C, L, N, E), !1
      }
      z = e.RenderEffectChain(E, this._runtime, z, J, I, F)
      E.SetBaseZ(this.GetZElevation())
      return z
    }
    _DrawInstanceWithEffects_FastPath(z, C, E, J, F) {
      F.SetProgram(J)
      F.SetBlendMode(C.GetBlendMode())
      J.IsAnimated() && this._runtime.UpdateRender()
      let I = 0,
        L = 0
      if (J.UsesAnySrcRectOrPixelSize()) {
        const [N, S] = z.GetCurrentSurfaceSize()
        I = 1 / N
        L = 1 / S
        ;(J = z.GetCurrentTexRect()) ? f.copy(J) : f.set(0, 0, 0, 0)
      }
      E = C.GetInstanceEffectList().GetEffectParametersForIndex(E.GetIndex())
      F.SetCurrentZ(C.GetZElevation())
      F.SetProgramParameters(null, d, f, f, C.GetBoundingBox(), I, L, this.GetOwnScale(), this.GetAngle(), this._runtime.GetGameTime(), E)
      z.Draw(F)
    }
    _DrawLayerOwnTextureToRenderTarget(z, C, E, J) {
      const F = this._effectList.GetActiveEffectTypes(),
        I = this._runtime
      if (this._CanFastPathDrawLayer(F)) {
        z.SetRenderTarget(E)
        if (1 === F.length) {
          var L = F[0]
          E = L.GetShaderProgram()
          z.SetProgram(E)
          f.set(0, 0, 1, 1)
          L = this._effectList.GetEffectParametersForIndex(L.GetIndex())
          z.SetProgramParameters(null, d, f, f, this._viewport, 1 / I.GetDrawWidth(), 1 / I.GetDrawHeight(), this.GetNormalScale(), this.GetAngle(), I.GetGameTime(), L)
          E.IsAnimated() && I.UpdateRender()
        } else z.SetTextureFillMode()
        J && 0 === this._blendMode && this.HasDefaultColor() && 0 === F.length ? z.CopyRenderTarget(C) : (z.SetBlendMode(this._blendMode), z.SetColor(this._premultipliedColor), z.DrawRenderTarget(C))
        z.InvalidateRenderTarget(C)
        I.ReleaseAdditionalRenderTarget(C)
      } else e.RenderEffectChain(z, I, this, E, F)
    }
    GetOwnScale() {
      return this._scale
    }
    SetOwnScale(z) {
      this._scale !== z && ((this._scale = z), this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetRenderScale() {
      return this.GetNormalScale() * this._runtime.GetRenderScale()
    }
    GetDisplayScale() {
      return this.GetNormalScale() * this._runtime.GetDisplayScale()
    }
    GetNormalScale() {
      return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
    }
    UpdateViewport() {
      var z = this._runtime.GetParallaxXOrigin(),
        C = this._runtime.GetParallaxYOrigin(),
        E = (this.GetScrollX() - z) * this._parallaxX + z,
        J = (this.GetScrollY() - C) * this._parallaxY + C
      z = this.GetNormalScale()
      C = this._runtime.GetViewportWidth() / z
      z = this._runtime.GetViewportHeight() / z
      E -= C / 2
      let F = J - z / 2
      this._runtime.IsPixelRoundingEnabled() && ((E = Math.round(E)), (F = Math.round(F)))
      J = this._viewportZ0
      J.set(E, F, E + C, F + z)
      C = this.GetAngle()
      0 !== C && (b.copy(J), b.offset(-J.midX(), -J.midY()), a.setFromRotatedRect(b, C), a.getBoundingBox(b), b.offset(J.midX(), J.midY()), J.copy(b))
      this.GetViewportForZ(this._zElevation, this._viewport)
    }
    CanvasCssToLayer(z, C, E = 0) {
      return this._CanvasToLayer(z, C, E, this.GetDisplayScale())
    }
    DrawSurfaceToLayer(z, C, E = 0) {
      return this._CanvasToLayer(z, C, E, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _CanvasToLayer(z, C, E, J) {
      var F = this._runtime,
        I = F.GetRenderer()
      const L = this.GetNormalScale(),
        N = F.GetViewportWidth() / L
      F = F.GetViewportHeight() / L
      k.set(p, 0, 0, N, F)
      z /= J
      C = p[3] - C / J
      J = this._GetProjectionMatrix(I)
      I = this._GetModelViewMatrix(I)
      return e.Gfx.UnprojectScreenToWorldZ(z, C, E, I, J, p, w) ? [w[0], w[1]] : [NaN, NaN]
    }
    CanvasCssToLayer_DefaultTransform(z, C) {
      const E = this._scale,
        J = this._scaleRate,
        F = this._parallaxX,
        I = this._parallaxY,
        L = this._angle
      this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1
      this._angle = 0
      this._SetMVMatrixChanged()
      z = this.CanvasCssToLayer(z, C)
      this._scale = E
      this._scaleRate = J
      this._parallaxX = F
      this._parallaxY = I
      this._angle = L
      this._SetMVMatrixChanged()
      return z
    }
    LayerToCanvasCss(z, C, E = 0) {
      return this._LayerToCanvas(z, C, E, this.GetDisplayScale())
    }
    LayerToDrawSurface(z, C, E = 0) {
      return this._LayerToCanvas(z, C, E, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _LayerToCanvas(z, C, E, J) {
      var F = this._runtime,
        I = F.GetRenderer()
      const L = this.GetNormalScale()
      var N = F.GetViewportWidth() / L
      F = F.GetViewportHeight() / L
      k.set(p, 0, 0, N, F)
      N = this._GetProjectionMatrix(I)
      I = this._GetModelViewMatrix(I)
      return e.Gfx.Project(z, C, E, I, N, p, w) ? [w[0] * J, (p[3] - w[1]) * J] : [NaN, NaN]
    }
    _GetLayerToDrawSurfaceScale(z, C) {
      z *= this.GetRenderScale() * this.GetDevicePixelRatio()
      0 !== C && (z *= this.Get2DScaleFactorToZ(C))
      return z
    }
    _GetViewFrustum() {
      this._isViewFrustumChanged && (this._UpdateViewFrustum(), (this._isViewFrustumChanged = !1))
      return this._viewFrustum
    }
    _UpdateViewFrustum() {
      var z = this._runtime.GetRenderer()
      const C = this._GetProjectionMatrix(z)
      z = this._GetModelViewMatrix(z)
      this._viewFrustum.CalculatePlanes(z, C)
    }
    _SaveToJson() {
      return {
        s: this.GetOwnScale(),
        a: this.GetOwnAngle(),
        vl: this._viewport.getLeft(),
        vt: this._viewport.getTop(),
        vr: this._viewport.getRight(),
        vb: this._viewport.getBottom(),
        v: this.IsVisible(),
        bc: this._backgroundColor.toJSON(),
        t: this.IsTransparent(),
        sx: this._scrollX,
        sy: this._scrollY,
        hosp: this._hasOwnScrollPosition,
        px: this.GetParallaxX(),
        py: this.GetParallaxY(),
        c: this._color.toJSON(),
        sr: this.GetScaleRate(),
        fx: this._effectList.SaveToJson(),
        cg: this._createdGlobalUids
      }
    }
    _LoadFromJson(z) {
      this._scale = z.s
      this._angle = z.a
      this._viewport.set(z.vl, z.vt, z.vr, z.vb)
      this._isVisible = !!z.v
      this._backgroundColor.setFromJSON(z.bc)
      this._isTransparent = !!z.t
      z.hasOwnProperty('sx') && (this._scrollX = z.sx)
      z.hasOwnProperty('sy') && (this._scrollY = z.sy)
      z.hasOwnProperty('hosp') && (this._hasOwnScrollPosition = !!z.hosp)
      this._parallaxX = z.px
      this._parallaxY = z.py
      this._color.setFromJSON(z.c)
      this._scaleRate = z.sr
      e.shallowAssignArray(this._createdGlobalUids, z.cg)
      e.shallowAssignArray(this._initialInstances, this._startupInitialInstances)
      const C = new Set(this._createdGlobalUids)
      let E = 0
      for (let J = 0, F = this._initialInstances.length; J < F; ++J) C.has(this._initialInstances[J][2]) || ((this._initialInstances[E] = this._initialInstances[J]), ++E)
      e.truncateArray(this._initialInstances, E)
      this._effectList.LoadFromJson(z.fx)
      this._SortInstancesByLastCachedZIndex(!1)
      this.SetZIndicesChanged()
    }
    GetILayer() {
      return this._iLayer
    }
    SortAndAddSceneGraphInstancesByZIndex(z) {
      z.GetWorldInfo()
      if (!this._instances.includes(z))
        if (z.HasChildren()) {
          const C = [...z.allChildren()]
          C.push(z)
          C.sort((E, J) => {
            E = E.GetWorldInfo().GetSceneGraphZIndex()
            J = J.GetWorldInfo().GetSceneGraphZIndex()
            return E - J
          })
          for (const E of C) this._AddInstance(E, !0)
        } else this._AddInstance(z, !0)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3Debugger,
    a = e.New(e.Rect),
    c = e.New(e.Rect),
    d = e.New(e.Rect),
    f = e.New(e.Color)
  e.Layout = class extends e.DefendedBase {
    constructor(g, h, k) {
      super()
      this._layoutManager = g
      this._runtime = g.GetRuntime()
      this._name = k[0]
      this._originalWidth = k[1]
      this._originalHeight = k[2]
      this._width = k[1]
      this._height = k[2]
      this._isUnboundedScrolling = !!k[3]
      this._vanishingPointX = k[4]
      this._vanishingPointY = k[5]
      this._eventSheetName = k[6]
      this._eventSheet = null
      this._sid = k[7]
      this._index = h
      this._scrollY = this._scrollX = 0
      this._scale = 1
      this._angle = 0
      this._initialObjectClasses = new Set()
      this._textureLoadedTypes = new Set()
      this._textureLoadPendingPromises = new Set()
      this._createdInstances = []
      this._initialNonWorld = []
      this._layers = []
      this._layersByName = new Map()
      this._layersBySid = new Map()
      this._effectList = e.New(e.EffectList, this, k[10])
      this._curRenderTarget = null
      this._persistData = {}
      this._isFirstVisit = !0
      this._iLayout = new self.ILayout(this)
      this._userScriptDispatcher = e.New(e.Event.Dispatcher)
      for (const m of k[8]) (g = e.Layer.Create(this, this._layers.length, m)), this._layers.push(g), this._layersByName.set(g.GetName().toLowerCase(), g), this._layersBySid.set(g.GetSID(), g)
      for (const m of k[9]) {
        k = this._runtime.GetObjectClassByIndex(m[1])
        if (!k) throw Error('missing nonworld object class')
        k.GetDefaultInstanceData() || k.SetDefaultInstanceData(m)
        this._initialNonWorld.push(m)
        this._AddInitialObjectClass(k)
      }
    }
    Release() {
      for (const g of this._layers) g.Release()
      e.clearArray(this._layers)
      this._textureLoadPendingPromises.clear()
      this._runtime = this._layoutManager = this._eventSheet = null
    }
    GetRuntime() {
      return this._runtime
    }
    GetName() {
      return this._name
    }
    GetSID() {
      return this._sid
    }
    GetIndex() {
      return this._index
    }
    GetEffectList() {
      return this._effectList
    }
    GetMinLayerScale() {
      let g = this._layers[0].GetNormalScale()
      for (let h = 1, k = this._layers.length; h < k; ++h) {
        const m = this._layers[h]
        if (0 !== m.GetParallaxX() || 0 !== m.GetParallaxY()) g = Math.min(g, m.GetNormalScale())
      }
      return g
    }
    _GetScrollBoundMarginHorizontal() {
      return (0.5 * this._runtime.GetViewportWidth()) / this.GetMinLayerScale()
    }
    _GetScrollBoundMarginVertical() {
      return (0.5 * this._runtime.GetViewportHeight()) / this.GetMinLayerScale()
    }
    GetScrollLeftBound() {
      return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginHorizontal()
    }
    GetScrollRightBound() {
      return this.IsUnboundedScrolling() ? Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
    }
    GetScrollTopBound() {
      return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
    }
    GetScrollBottomBound() {
      return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
    }
    SetScrollX(g) {
      const h = this.GetScrollLeftBound(),
        k = this.GetScrollRightBound()
      g > k && (g = k)
      g < h && (g = h)
      this._scrollX !== g && ((this._scrollX = g), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetScrollX() {
      return this._scrollX
    }
    SetScrollY(g) {
      const h = this.GetScrollTopBound(),
        k = this.GetScrollBottomBound()
      g > k && (g = k)
      g < h && (g = h)
      this._scrollY !== g && ((this._scrollY = g), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetScrollY() {
      return this._scrollY
    }
    IsUnboundedScrolling() {
      return this._isUnboundedScrolling
    }
    BoundScrolling() {
      this.SetScrollX(this.GetScrollX())
      this.SetScrollY(this.GetScrollY())
      for (const g of this._layers) g.IsOwnScrollPositionEnabled() && (g.SetScrollX(g.GetScrollX()), g.SetScrollY(g.GetScrollY()))
    }
    SetVanishingPointXY(g, h) {
      if (this._vanishingPointX !== g || this._vanishingPointY !== h) (this._vanishingPointX = g), (this._vanishingPointY = h), this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender()
    }
    GetVanishingPointX() {
      return this._vanishingPointX
    }
    GetVanishingPointY() {
      return this._vanishingPointY
    }
    HasVanishingPointOutsideViewport() {
      const g = this.GetVanishingPointX(),
        h = this.GetVanishingPointY()
      return 0 > g || 1 < g || 0 > h || 1 < h
    }
    GetScale() {
      return this._scale
    }
    SetScale(g) {
      this._scale !== g && ((this._scale = g), this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender())
    }
    SetAngle(g) {
      g = e.clampAngle(g)
      this._angle !== g && ((this._angle = g), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetAngle() {
      return this._angle
    }
    GetWidth() {
      return this._width
    }
    SetWidth(g) {
      !isFinite(g) || 1 > g || (this._width = g)
    }
    GetHeight() {
      return this._height
    }
    SetHeight(g) {
      !isFinite(g) || 1 > g || (this._height = g)
    }
    GetEventSheet() {
      return this._eventSheet
    }
    GetLayers() {
      return this._layers
    }
    GetLayerCount() {
      return this._layers.length
    }
    GetLayer(g) {
      return 'number' === typeof g ? this.GetLayerByIndex(g) : this.GetLayerByName(g.toString())
    }
    GetLayerByIndex(g) {
      g = e.clamp(Math.floor(g), 0, this._layers.length - 1)
      return this._layers[g]
    }
    GetLayerByName(g) {
      return this._layersByName.get(g.toLowerCase()) || null
    }
    GetLayerBySID(g) {
      return this._layersBySid.get(g) || null
    }
    _SetAllLayersProjectionChanged() {
      for (const g of this._layers) g._SetProjectionMatrixChanged()
    }
    _SetAllLayersMVChanged() {
      for (const g of this._layers) g._SetMVMatrixChanged()
    }
    SaveTransform() {
      return {
        scrollX: this.GetScrollX(),
        scrollY: this.GetScrollY(),
        scale: this.GetScale(),
        angle: this.GetAngle(),
        vpX: this.GetVanishingPointX(),
        vpY: this.GetVanishingPointY()
      }
    }
    RestoreTransform(g) {
      this.SetScrollX(g.scrollX)
      this.SetScrollY(g.scrollY)
      this.SetScale(g.scale)
      this.SetAngle(g.angle)
      this.SetVanishingPointXY(g.vpX, g.vpY)
    }
    HasOpaqueBottomLayer() {
      for (const g of this._layers) if (g.ShouldDraw()) return g._IsOpaque()
      return !1
    }
    GetLayoutBackgroundColor() {
      for (const g of this._layers) if (g.ShouldDraw() && g._IsOpaque()) return f.copyRgb(g.GetBackgroundColor()), f.setA(1), f
      f.setRgba(0, 0, 0, 0)
      return f
    }
    IsFirstVisit() {
      return this._isFirstVisit
    }
    _GetInitialObjectClasses() {
      return [...this._initialObjectClasses]
    }
    _AddInitialObjectClass(g) {
      if (g.IsInContainer()) for (const h of g.GetContainer().GetObjectTypes()) this._initialObjectClasses.add(h)
      else this._initialObjectClasses.add(g)
    }
    _GetTextureLoadedObjectTypes() {
      return [...this._textureLoadedTypes]
    }
    _Load(g, h) {
      if (g === this || !h) return Promise.resolve()
      g && (e.CopySet(this._textureLoadedTypes, g._textureLoadedTypes), g._textureLoadedTypes.clear())
      g = []
      for (const k of this._initialObjectClasses) this._textureLoadedTypes.has(k) || (g.push(k.LoadTextures(h)), this._textureLoadedTypes.add(k))
      return Promise.all(g)
    }
    async MaybeLoadTexturesFor(g) {
      if (g.IsFamily()) throw Error('cannot load textures for family')
      var h = this._runtime.GetRenderer()
      !h || h.IsContextLost() || this._textureLoadedTypes.has(g) || (this._textureLoadedTypes.add(g), (h = g.LoadTextures(h)), this._AddPendingTextureLoadPromise(h), await h, g.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender())
    }
    _AddPendingTextureLoadPromise(g) {
      this._textureLoadPendingPromises.add(g)
      g.then(() => this._textureLoadPendingPromises.delete(g)).catch(() => this._textureLoadPendingPromises.delete(g))
    }
    WaitForPendingTextureLoadsToComplete() {
      return Promise.all([...this._textureLoadPendingPromises])
    }
    MaybeUnloadTexturesFor(g) {
      if (g.IsFamily() || 0 < g.GetInstanceCount()) throw Error('cannot unload textures')
      const h = this._runtime.GetRenderer()
      h && this._textureLoadedTypes.has(g) && (this._textureLoadedTypes.delete(g), g.ReleaseTextures(h))
    }
    _Unload(g, h) {
      if (g !== this && h) for (const k of this._textureLoadedTypes) k.IsGlobal() || g._initialObjectClasses.has(k) || (k.ReleaseTextures(), this._textureLoadedTypes.delete(k))
    }
    _OnWebGLContextLost() {
      this._textureLoadedTypes.clear()
    }
    async _StartRunning(g) {
      const h = this._runtime,
        k = this._layoutManager,
        m = h.GetEventSheetManager()
      this._eventSheetName && ((this._eventSheet = m.GetEventSheetByName(this._eventSheetName)), this._eventSheet._UpdateDeepIncludes())
      k._SetMainRunningLayout(this)
      this._width = this._originalWidth
      this._height = this._originalHeight
      this._scrollX = h.GetOriginalViewportWidth() / 2
      this._scrollY = h.GetOriginalViewportHeight() / 2
      this.BoundScrolling()
      this._MoveGlobalObjectsToThisLayout(g)
      this._runtime.SetUsingCreatePromises(!0)
      this._CreateInitialInstances()
      this._isFirstVisit || this._CreatePersistedInstances()
      this._CreateAndLinkContainerInstances(this._createdInstances)
      this._CreateInitialNonWorldInstances()
      k.ClearPendingChangeLayout()
      h.FlushPendingInstances()
      this._runtime.SetUsingCreatePromises(!1)
      const r = this._runtime.GetCreatePromises()
      await Promise.all(r)
      e.clearArray(r)
      if (!h.IsLoadingState()) {
        for (const w of this._createdInstances) w.SetupInitialSceneGraphConnections()
        for (const w of this._createdInstances) w._TriggerOnCreated()
      }
      e.clearArray(this._createdInstances)
      await Promise.all([...this._initialObjectClasses].map(w => w.PreloadTexturesWithInstances(this._runtime.GetRenderer())))
      g && (h.Dispatcher().dispatchEvent(new e.Event('beforefirstlayoutstart')), await h.DispatchUserScriptEventAsyncWait(new e.Event('beforeprojectstart')))
      await this.DispatchUserScriptEventAsyncWait(new e.Event('beforelayoutstart'))
      h.IsLoadingState() || (await h.TriggerAsync(e.Plugins.System.Cnds.OnLayoutStart, null, null))
      await this.DispatchUserScriptEventAsyncWait(new e.Event('afterlayoutstart'))
      g && (h.Dispatcher().dispatchEvent(new e.Event('afterfirstlayoutstart')), await h.DispatchUserScriptEventAsyncWait(new e.Event('afterprojectstart')))
      m._RunQueuedTriggers(k)
      await this.WaitForPendingTextureLoadsToComplete()
      this._SetAllLayersProjectionChanged()
      this._SetAllLayersMVChanged()
      this._isFirstVisit = !1
    }
    _MoveGlobalObjectsToThisLayout(g) {
      for (const k of this._runtime.GetAllObjectClasses())
        if (!k.IsFamily() && k.IsWorldType())
          for (const m of k.GetInstances()) {
            const r = m.GetWorldInfo()
            var h = r.GetLayer()
            h = e.clamp(h.GetIndex(), 0, this._layers.length - 1)
            h = this._layers[h]
            r._SetLayer(h)
            h._MaybeAddInstance(m)
          }
      if (!g) for (const k of this._layers) k._SortInstancesByLastCachedZIndex(!1)
    }
    _CreateInitialInstances() {
      for (const g of this._layers) g.CreateInitialInstances(this._createdInstances), g.UpdateViewport(), g._Start()
    }
    _CreatePersistedInstances() {
      let g = !1
      for (const [k, m] of Object.entries(this._persistData)) {
        const r = this._runtime.GetObjectClassBySID(parseInt(k, 10))
        if (r && !r.IsFamily() && r.HasPersistBehavior()) {
          for (const w of m) {
            var h = null
            if (r.IsWorldType() && ((h = this.GetLayerBySID(w.w.l)), !h)) continue
            h = this._runtime.CreateInstanceFromData(r, h, !1, 0, 0, !0)
            h.LoadFromJson(w)
            g = !0
            this._createdInstances.push(h)
          }
          e.clearArray(m)
        }
      }
      for (const k of this._layers) k._SortInstancesByLastCachedZIndex(!0), k.SetZIndicesChanged()
      g && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
    }
    _CreateAndLinkContainerInstances(g) {
      for (const k of g) {
        if (!k.IsInContainer()) continue
        const m = k.GetWorldInfo(),
          r = k.GetIID()
        for (const w of k.GetObjectClass().GetContainer().objectTypes())
          if (w !== k.GetObjectClass()) {
            var h = w.GetInstances()
            h.length > r ? k._AddSibling(h[r]) : ((h = m ? this._runtime.CreateInstanceFromData(w, m.GetLayer(), !0, m.GetX(), m.GetY(), !0) : this._runtime.CreateInstanceFromData(w, null, !0, 0, 0, !0)), this._runtime.FlushPendingInstances(), w._UpdateIIDs(), k._AddSibling(h), g.push(h))
          }
      }
    }
    _CreateInitialNonWorldInstances() {
      for (const g of this._initialNonWorld) this._runtime.GetObjectClassByIndex(g[1]).IsInContainer() || this._runtime.CreateInstanceFromData(g, null, !0)
    }
    _CreateGlobalNonWorlds() {
      const g = [],
        h = this._initialNonWorld
      let k = 0
      for (let m = 0, r = h.length; m < r; ++m) {
        const w = h[m],
          p = this._runtime.GetObjectClassByIndex(w[1])
        p.IsGlobal() ? (p.IsInContainer() && p.GetContainer().HasAnyWorldType()) || g.push(this._runtime.CreateInstanceFromData(w, null, !0)) : ((h[k] = w), ++k)
      }
      e.truncateArray(h, k)
      this._runtime.FlushPendingInstances()
      this._CreateAndLinkContainerInstances(g)
    }
    RecreateInitialObjects(g, h, k, m, r, w) {
      if (k) return k.RecreateInitialObjects(g, h, m, r, w)
      k = []
      for (const p of this._layers) k.push(p.RecreateInitialObjects(g, h, m, r, w))
      return k.flat()
    }
    async _StopRunning() {
      const g = this._layoutManager
      this._runtime.IsLoadingState() || (await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnLayoutEnd, null, null))
      g.SetIsEndingLayout(!0)
      this._runtime.GetEventSheetManager().ClearAllScheduledWaits()
      this._isFirstVisit || this._SavePersistData()
      for (const h of this._layers) h._End()
      for (const h of this._runtime.GetAllObjectClasses())
        if (!(h.IsGlobal() || h.IsWorldType() || h.GetPlugin().IsSingleGlobal() || h.IsFamily())) {
          for (const k of h.GetInstances()) this._runtime.DestroyInstance(k)
          this._runtime.FlushPendingInstances()
        }
      g.SetIsEndingLayout(!1)
      g.GetMainRunningLayout() === this && g._SetMainRunningLayout(null)
    }
    _SaveInstanceToPersist(g) {
      const h = g.GetObjectClass().GetSID().toString()
      this._persistData.hasOwnProperty(h) || (this._persistData[h] = [])
      this._persistData[h].push(g.SaveToJson())
    }
    _SavePersistData() {
      for (const g of this._layers) {
        g._UpdateZIndices()
        for (const h of g._GetInstances()) {
          const k = h.GetObjectClass()
          !k.IsGlobal() && k.HasPersistBehavior() && this._SaveInstanceToPersist(h)
        }
      }
    }
    ResetPersistData() {
      this._persistData = {}
      this._isFirstVisit = !0
    }
    GetRenderTarget() {
      return this._curRenderTarget
    }
    UsesOwnTexture() {
      return (
        'low' === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality() ||
        this._runtime.UsesAnyBackgroundBlending() ||
        'low-latency' === this._runtime.GetCompositingMode() ||
        this._effectList.HasAnyActiveEffect() ||
        (this._runtime.GetRenderer().IsWebGL() && this._runtime.Uses3DFeatures())
      )
    }
    _CanFastPathDrawLayout(g) {
      return 0 === g.length ? !0 : 2 <= g.length ? !1 : !g[0].GetShaderProgram().MustPreDraw()
    }
    Draw(g) {
      var h = this._runtime.GetCanvasManager()
      const k = this.UsesOwnTexture()
      var m = null
      k
        ? ('low-latency' !== this._runtime.GetCompositingMode() && (g.SetRenderTarget(null), g.ClearRgba(0, 0, 0, 0)),
          (m = {
            sampling: this._runtime.GetSampling(),
            isSampled: g.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect()
          }),
          'low' === h.GetCurrentFullscreenScalingQuality() && ((m.width = h.GetDrawWidth()), (m.height = h.GetDrawHeight())),
          (m = this._runtime.GetAdditionalRenderTarget(m)),
          g.SetRenderTarget(m))
        : g.SetRenderTarget(null)
      g.Clear(this.GetLayoutBackgroundColor())
      this._runtime.Uses3DFeatures() && g.ClearDepth()
      this._curRenderTarget = m
      h = !0
      for (const r of this._layers) r.UpdateViewport(), r.ShouldDraw() && (r.Draw(g, m, h), (h = !1))
      k && (g.SetDepthEnabled(!1), this._DrawLayoutOwnTextureToRenderTarget(g, m))
      this._curRenderTarget = null
    }
    _DrawLayoutOwnTextureToRenderTarget(g, h) {
      const k = this._effectList.GetActiveEffectTypes(),
        m = this._runtime
      if (this._CanFastPathDrawLayout(k)) {
        g.SetRenderTarget(null)
        if (1 === k.length) {
          var r = k[0]
          const w = r.GetShaderProgram()
          g.SetProgram(w)
          c.set(0, 0, 1, 1)
          d.set(0, 0, m.GetViewportWidth(), m.GetViewportHeight())
          r = this._effectList.GetEffectParametersForIndex(r.GetIndex())
          g.SetProgramParameters(null, a, c, c, d, 1 / m.GetDrawWidth(), 1 / m.GetDrawHeight(), this.GetScale(), this.GetAngle(), m.GetGameTime(), r)
          w.IsAnimated() && m.UpdateRender()
        } else g.SetTextureFillMode()
        0 === k.length ? g.CopyRenderTarget(h) : (g.SetAlphaBlend(), g.ResetColor(), g.DrawRenderTarget(h))
        g.InvalidateRenderTarget(h)
        m.ReleaseAdditionalRenderTarget(h)
      } else e.RenderEffectChain(g, m, this, null, k)
    }
    _SaveToJson() {
      const g = {
        sx: this.GetScrollX(),
        sy: this.GetScrollY(),
        s: this.GetScale(),
        a: this.GetAngle(),
        w: this.GetWidth(),
        h: this.GetHeight(),
        vpX: this.GetVanishingPointX(),
        vpY: this.GetVanishingPointY(),
        fv: this._isFirstVisit,
        persist: this._persistData,
        fx: this._effectList.SaveToJson(),
        layers: {}
      }
      for (const h of this._layers) g.layers[h.GetSID().toString()] = h._SaveToJson()
      return g
    }
    _LoadFromJson(g) {
      this._scrollX = g.sx
      this._scrollY = g.sy
      this._scale = g.s
      this._angle = g.a
      this._width = g.w
      this._height = g.h
      g.hasOwnProperty('vpX') && (this._vanishingPointX = g.vpX)
      g.hasOwnProperty('vpY') && (this._vanishingPointY = g.vpY)
      this._isFirstVisit = !!g.fv
      this._persistData = g.persist
      this._effectList.LoadFromJson(g.fx)
      for (const [h, k] of Object.entries(g.layers)) (g = parseInt(h, 10)), (g = this.GetLayerBySID(g)) && g._LoadFromJson(k)
      this._SetAllLayersProjectionChanged()
      this._SetAllLayersMVChanged()
    }
    GetILayout() {
      return this._iLayout
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(g) {
      g.layout = this.GetILayout()
      var h = this._runtime
      ;(h = h.IsDebug() && !h.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime()
      this._userScriptDispatcher.dispatchEvent(g)
      h && b.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(g) {
      g.layout = this.GetILayout()
      return this._userScriptDispatcher.dispatchEventAndWaitAsync(g)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.LayoutManager = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._runtime = b
      this._allLayouts = []
      this._layoutsByName = new Map()
      this._layoutsBySid = new Map()
      this._mainRunningLayout = null
      this._runningSubLayouts = []
      this._firstLayout = null
      this._isEndingLayout = 0
      this._pendingChangeLayout = null
    }
    Release() {
      this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null
      e.clearArray(this._allLayouts)
      this._layoutsByName.clear()
      this._layoutsBySid.clear()
      e.clearArray(this._runningSubLayouts)
    }
    Create(b) {
      b = e.New(e.Layout, this, this._allLayouts.length, b)
      this._allLayouts.push(b)
      this._layoutsByName.set(b.GetName().toLowerCase(), b)
      this._layoutsBySid.set(b.GetSID(), b)
    }
    GetRuntime() {
      return this._runtime
    }
    SetFirstLayout(b) {
      this._firstLayout = b
    }
    GetFirstLayout() {
      if (this._firstLayout) return this._firstLayout
      if (this._allLayouts.length) return this._allLayouts[0]
      throw Error('no first layout')
    }
    GetLayoutByName(b) {
      return this._layoutsByName.get(b.toLowerCase()) || null
    }
    GetLayoutBySID(b) {
      return this._layoutsBySid.get(b) || null
    }
    GetLayoutByIndex(b) {
      b = e.clamp(Math.floor(b), 0, this._allLayouts.length - 1)
      return this._allLayouts[b]
    }
    GetLayout(b) {
      return 'number' === typeof b ? this.GetLayoutByIndex(b) : this.GetLayoutByName(b.toString())
    }
    GetAllLayouts() {
      return this._allLayouts
    }
    _SetMainRunningLayout(b) {
      this._mainRunningLayout = b
    }
    GetMainRunningLayout() {
      return this._mainRunningLayout
    }
    _AddRunningSubLayout(b) {
      if (this._runningSubLayouts.includes(b)) throw Error('layout already running')
      this._runningSubLayouts.push(b)
    }
    _RemoveRunningSubLayout(b) {
      b = this._runningSubLayouts.indexOf(b)
      if (-1 === b) throw Error('layout not running')
      this._runningSubLayouts.splice(b, 1)
    }
    *runningLayouts() {
      this._mainRunningLayout && (yield this._mainRunningLayout)
      this._runningSubLayouts.length && (yield* this._runningSubLayouts)
    }
    IsLayoutRunning(b) {
      return this._mainRunningLayout === b || this._runningSubLayouts.includes(b)
    }
    SetIsEndingLayout(b) {
      if (b) this._isEndingLayout++
      else {
        if (0 >= this._isEndingLayout) throw Error('already unset')
        this._isEndingLayout--
      }
    }
    IsEndingLayout() {
      return 0 < this._isEndingLayout
    }
    ChangeMainLayout(b) {
      this._pendingChangeLayout = b
    }
    ClearPendingChangeLayout() {
      this._pendingChangeLayout = null
    }
    IsPendingChangeMainLayout() {
      return !!this._pendingChangeLayout
    }
    GetPendingChangeMainLayout() {
      return this._pendingChangeLayout
    }
    SetAllLayerProjectionChanged() {
      const b = this.GetMainRunningLayout()
      b && b._SetAllLayersProjectionChanged()
    }
    SetAllLayerMVChanged() {
      const b = this.GetMainRunningLayout()
      b && b._SetAllLayersMVChanged()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor() {
      this.runtime = this.renderer = null
      this.surfaceHeight = this.surfaceWidth = this.drawHeight = this.drawWidth = 0
      this.layoutRect = new e.Rect()
      this.rcTexBounce = new e.Rect()
      this.rcTexDest = new e.Rect()
      this.rcTexOrigin = new e.Rect()
      this.screenRect = new e.Rect()
      this.clearRect = new e.Rect()
      this.srcRect = new e.Rect()
      this.fxTex = [null, null]
      this.fxIndex = 0
      this.otherFxIndex = 1
      this.layerAngle = this.layerScale = this.boxExtendVertical = this.boxExtendHorizontal = 0
      this.renderTarget = this.wi = this.inst = this.layer = this.layout = null
      this.didChangeTransform = this.postDraw = this.preDraw = !1
      this.opts = null
    }
    Clear() {
      this.opts = this.renderTarget = this.wi = this.inst = this.layer = this.layout = this.runtime = this.renderer = null
    }
    ShouldPreDraw(t) {
      t = t.GetShaderProgram()
      if (t.MustPreDraw()) return !0
      if (this.inst) return (t.UsesDest() && (0 !== this.wi.GetAngle() || 0 > this.wi.GetWidth() || 0 > this.wi.GetHeight())) || 0 !== this.boxExtendHorizontal || 0 !== this.boxExtendVertical || !this.wi.HasDefaultColor() || this.inst.MustPreDraw()
      if (this.layer) return !this.layer.HasDefaultColor()
    }
    ShouldPostDraw(t) {
      t = t.GetShaderProgram()
      return t.UsesDest() || t.UsesCrossSampling() || (this.layout && 'low' === this.runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality())
    }
    GetEffectRenderTarget(t) {
      if (0 !== t && 1 !== t) throw Error('invalid effect target')
      const x = this.fxTex
      if (!x[t]) {
        var v = this.runtime
        const u = v.GetCanvasManager()
        v = {
          sampling: v.GetSampling()
        }
        'low' === u.GetCurrentFullscreenScalingQuality() && ((v.width = u.GetDrawWidth()), (v.height = u.GetDrawHeight()))
        x[t] = u.GetAdditionalRenderTarget(v)
      }
      return x[t]
    }
    ReleaseEffectRenderTargets() {
      const t = this.fxTex,
        x = this.runtime.GetCanvasManager()
      t[0] && (x.ReleaseAdditionalRenderTarget(t[0]), (t[0] = null))
      t[1] && (x.ReleaseAdditionalRenderTarget(t[1]), (t[1] = null))
    }
  }
  const a = []
  let c = 0

  function d() {
    c === a.length && a.push(new b())
    return a[c++]
  }

  function f(t) {
    t.ReleaseEffectRenderTargets()
    t.Clear()
    c--
  }
  const g = new e.Quad()
  let h = !1
  async function k(t, x, v) {
    x = await e.Gfx.WebGLRenderTarget.DebugReadPixelsToBlob(x, v)
    x = URL.createObjectURL(x)
    console.log('[FX] ' + t + ' ' + (v ? '' : ' [to display]') + ': ', x)
  }
  e.RenderEffectChain = function (t, x, v, u, A, z) {
    const C = d()
    C.renderer = t
    C.runtime = x
    if (v instanceof e.Instance) (C.inst = v), (C.wi = C.inst.GetWorldInfo())
    else if (v instanceof e.Layer) C.layer = v
    else if (v instanceof e.Layout) C.layout = v
    else throw Error('invalid effects object')
    v = x.GetCanvasManager()
    C.renderTarget = u
    C.drawWidth = v.GetDrawWidth()
    C.drawHeight = v.GetDrawHeight()
    C.surfaceWidth = C.drawWidth
    C.surfaceHeight = C.drawHeight
    C.fxIndex = 0
    C.otherFxIndex = 1
    C.boxExtendHorizontal = 0
    C.boxExtendVertical = 0
    C.screenRect.set(0, 0, C.drawWidth, C.drawHeight)
    C.clearRect.set(0, 0, C.drawWidth, C.drawHeight)
    C.didChangeTransform = !1
    C.opts = z
    C.inst
      ? ((u = C.wi), (C.layerScale = u.GetLayer().GetRenderScale()), (C.layerAngle = u.GetLayer().GetAngle()), C.layoutRect.copy(u.GetBoundingBox()))
      : C.layer
      ? ((u = C.layer), (C.layerScale = u.GetRenderScale()), (C.layerAngle = u.GetAngle()), C.layoutRect.copy(u.GetViewport()))
      : ((u = C.layout), (C.layerScale = u.GetScale()), (C.layerAngle = u.GetAngle()), C.layoutRect.set(0, 0, C.drawWidth, C.drawHeight))
    C.inst ? m(C, A) : (C.rcTexBounce.set(0, 0, C.drawWidth / C.surfaceWidth, C.drawHeight / C.surfaceHeight), C.rcTexDest.copy(C.rcTexBounce), C.rcTexOrigin.copy(C.rcTexBounce), C.rcTexBounce.swapTopBottom(), C.rcTexDest.swapTopBottom(), C.rcTexOrigin.swapTopBottom())
    t.SetAlphaBlend()
    t.ResetColor()
    t.SetBaseZ(0)
    t.SetCurrentZ(0)
    C.preDraw = C.ShouldPreDraw(A[0])
    C.preDraw && r(C)
    t.ResetColor()
    u = A.length - 1
    C.postDraw = C.ShouldPostDraw(A[u])
    for (let E = 0, J = A.length; E < J; ++E)
      (z = A[E]), (v = z.GetShaderProgram()), t.SetProgram(v), v.IsAnimated() && x.UpdateRender(), 0 !== E || C.preDraw ? (t.SetCopyBlend(), p(C, z, E === u && !C.postDraw, E)) : w(C, z), 0 === C.fxIndex ? ((C.fxIndex = 1), (C.otherFxIndex = 0)) : ((C.fxIndex = 0), (C.otherFxIndex = 1))
    C.postDraw && q(C, A)
    t = C.didChangeTransform
    f(C)
    h = !1
    return t
  }

  function m(t, x) {
    for (let I = 0, L = x.length; I < L; ++I) {
      var v = x[I].GetShaderProgram()
      t.boxExtendHorizontal += v.GetBoxExtendHorizontal()
      t.boxExtendVertical += v.GetBoxExtendVertical()
    }
    var u = t.wi
    x = u.GetLayer()
    var A = x.GetAngle()
    v = u.GetBoundingBox()
    var z = u.GetTotalZElevation()
    u = u.GetDepth()
    let [C, E] = x.LayerToDrawSurface(v.getLeft(), v.getTop(), z),
      [J, F] = x.LayerToDrawSurface(v.getRight(), v.getBottom(), z)
    if (0 !== A || 0 < u) {
      const [I, L] = x.LayerToDrawSurface(v.getRight(), v.getTop(), z),
        [N, S] = x.LayerToDrawSurface(v.getLeft(), v.getBottom(), z)
      if (0 < u) {
        A = z + u
        const [V, U] = x.LayerToDrawSurface(v.getLeft(), v.getTop(), A),
          [X, ia] = x.LayerToDrawSurface(v.getRight(), v.getTop(), A),
          [ka, ya] = x.LayerToDrawSurface(v.getRight(), v.getBottom(), A),
          [ta, Ba] = x.LayerToDrawSurface(v.getLeft(), v.getBottom(), A)
        x = Math.min(C, J, I, N, V, X, ka, ta)
        J = Math.max(C, J, I, N, V, X, ka, ta)
        C = x
        x = Math.min(E, F, L, S, U, ia, ya, Ba)
        F = Math.max(E, F, L, S, U, ia, ya, Ba)
        E = x
      } else (x = Math.min(C, J, I, N)), (J = Math.max(C, J, I, N)), (C = x), (x = Math.min(E, F, L, S)), (F = Math.max(E, F, L, S)), (E = x)
    }
    x = t.screenRect
    v = t.rcTexOrigin
    A = t.rcTexDest
    z = t.clearRect
    u = t.rcTexBounce
    x.set(C, E, J, F)
    x.shuntY(t.drawHeight)
    v.copy(x)
    v.divide(t.surfaceWidth, t.surfaceHeight)
    v.swapTopBottom()
    x.inflate(t.boxExtendHorizontal, t.boxExtendVertical)
    A.copy(x)
    A.divide(t.surfaceWidth, t.surfaceHeight)
    A.swapTopBottom()
    z.copy(x)
    z.roundOuter()
    z.inflate(t.boxExtendHorizontal + 1, t.boxExtendVertical + 1)
    x.clamp(0, 0, t.drawWidth, t.drawHeight)
    z.clamp(0, 0, t.drawWidth, t.drawHeight)
    u.copy(x)
    u.divide(t.surfaceWidth, t.surfaceHeight)
    u.swapTopBottom()
  }

  function r(t) {
    const x = t.renderer
    x.SetTextureFillMode()
    const v = t.GetEffectRenderTarget(t.fxIndex)
    x.SetRenderTarget(v)
    var u = t.opts
    u && u.preTransform && u.preTransform()
    x.ClearRect2(t.clearRect)
    t.inst
      ? (x.SetColor(t.wi.GetPremultipliedColor()), x.SetCurrentZ(t.wi.GetTotalZElevation()), t.inst.Draw(x), x.SetCurrentZ(0))
      : ((u = (t.layer || t.layout).GetRenderTarget()), t.layer ? x.SetColor(t.layer.GetPremultipliedColor()) : x.ResetColor(), x.DrawRenderTarget(u), x.InvalidateRenderTarget(u), t.runtime.GetCanvasManager().ReleaseAdditionalRenderTarget(u))
    t.rcTexDest.clampFlipped(0, 1, 1, 0)
    t.fxIndex = 1
    t.otherFxIndex = 0
    h && k('Pre-draw', x, v)
  }

  function w(t, x) {
    const v = t.renderer,
      u = t.runtime,
      A = t.GetEffectRenderTarget(t.fxIndex)
    v.SetRenderTarget(A)
    var z = t.opts
    z && z.preTransform && z.preTransform()
    v.ClearRect2(t.clearRect)
    if (t.inst) {
      const [C, E] = t.inst.GetCurrentSurfaceSize()
      ;(z = t.inst.GetCurrentTexRect()) ? t.srcRect.copy(z) : t.srcRect.set(0, 0, 0, 0)
      x = t.wi.GetInstanceEffectList().GetEffectParametersForIndex(x.GetIndex())
      v.SetProgramParameters(t.renderTarget, t.rcTexDest, t.srcRect, t.srcRect, t.layoutRect, 1 / C, 1 / E, t.layerScale, t.layerAngle, u.GetGameTime(), x)
      v.SetCurrentZ(t.wi.GetTotalZElevation())
      t.inst.Draw(v)
      v.SetCurrentZ(0)
      t.rcTexDest.clampFlipped(0, 1, 1, 0)
      t.screenRect.shuntY(t.drawHeight)
    } else
      (x = (t.layer || t.layout).GetEffectList().GetEffectParametersForIndex(x.GetIndex())),
        v.SetProgramParameters(t.renderTarget, t.rcTexDest, t.rcTexBounce, t.rcTexOrigin, t.layoutRect, 1 / t.drawWidth, 1 / t.drawHeight, t.layerScale, t.layerAngle, u.GetGameTime(), x),
        (t = (t.layer || t.layout).GetRenderTarget()),
        h && k('Layer target', v, t),
        v.DrawRenderTarget(t),
        v.InvalidateRenderTarget(t),
        u.GetCanvasManager().ReleaseAdditionalRenderTarget(t)
    h && k('First bounce', v, A)
  }

  function p(t, x, v, u) {
    const A = t.renderer,
      z = t.runtime
    0 === u && t.preDraw && t.inst && t.screenRect.shuntY(t.drawHeight)
    v ? (t.inst ? A.SetBlendMode(t.wi.GetBlendMode()) : t.layer && A.SetBlendMode(t.layer.GetBlendMode()), (v = t.renderTarget), A.SetRenderTarget(v)) : ((v = t.GetEffectRenderTarget(t.fxIndex)), A.SetRenderTarget(v), A.ClearRect2(t.clearRect))
    x = t.inst ? t.wi.GetInstanceEffectList().GetEffectParametersForIndex(x.GetIndex()) : (t.layer || t.layout).GetEffectList().GetEffectParametersForIndex(x.GetIndex())
    A.SetProgramParameters(t.renderTarget, t.rcTexDest, t.rcTexBounce, t.rcTexOrigin, t.layoutRect, 1 / t.surfaceWidth, 1 / t.surfaceHeight, t.layerScale, t.layerAngle, z.GetGameTime(), x)
    x = t.GetEffectRenderTarget(t.otherFxIndex)
    A.SetTexture(x.GetTexture())
    z.GetCanvasManager().SetDeviceTransform(A)
    t.didChangeTransform = !0
    g.setFromRect(t.screenRect)
    A.Quad3(g, t.rcTexBounce)
    t.inst || A.InvalidateRenderTarget(x)
    h && k('Bounce ' + u, A, v)
  }

  function q(t, x) {
    x = t.renderer
    if (t.layout) x.SetTextureFillMode(), x.SetRenderTarget(t.renderTarget), (t = t.GetEffectRenderTarget(t.otherFxIndex)), x.CopyRenderTarget(t), x.InvalidateRenderTarget(t)
    else {
      var v = t.runtime.GetCanvasManager()
      'low' === v.GetCurrentFullscreenScalingQuality() ? (x.SetTextureFillMode(), v.SetDeviceTransform(x, v.GetDrawWidth(), v.GetDrawHeight()), (t.didChangeTransform = !0)) : x.SetDeviceTransformTextureFillMode()
      t.inst ? x.SetBlendMode(t.wi.GetBlendMode()) : t.layer && x.SetBlendMode(t.layer.GetBlendMode())
      x.SetRenderTarget(t.renderTarget)
      v = t.GetEffectRenderTarget(t.otherFxIndex)
      x.SetTexture(v.GetTexture())
      g.setFromRect(t.screenRect)
      x.Quad3(g, t.rcTexBounce)
      t.inst || x.InvalidateRenderTarget(v)
      h && k('Post-draw', x, t.renderTarget)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = /<(.+?)>/g
  e.TimelineManager = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._runtime = a
      this._timelineDataManager = e.New(e.TimelineDataManager)
      this._pluginInstance = null
      this._timelines = []
      this._timelinesByName = new Map()
      this._objectClassToTimelineMap = new Map()
      this._timelinesCreatedByTemplate = new Map()
      this._scheduledTimelines = []
      this._playingTimelines = []
      this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners = !1
      this._tickFunc = () => this._OnTick()
      this._tick2Func = () => this._OnTick2()
      this._beforeLayoutChange = () => this._OnBeforeChangeLayout()
      this._layoutChange = () => this._OnAfterChangeLayout()
      this._instanceDestroy = c => this._OnInstanceDestroy(c.instance)
      this._afterLoad = c => this._OnAfterLoad()
      this._destroyedWhileLoadingState = []
    }
    Release() {
      this.RemoveRuntimeListeners()
      this._afterLoad = this._instanceDestroy = this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null
      for (const a of this._timelines) a.Stop(), a.Release()
      e.clearArray(this._timelines)
      this._timelines = null
      this._timelineDataManager.Release()
      this._timelineDataManager = null
      e.clearArray(this._scheduledTimelines)
      this._scheduledTimelines = null
      e.clearArray(this._playingTimelines)
      this._playingTimelines = null
      this._timelinesByName.clear()
      this._timelinesByName = null
      this._objectClassToTimelineMap.clear()
      this._objectClassToTimelineMap = null
      this._timelinesCreatedByTemplate.clear()
      this._timelinesCreatedByTemplate = null
      e.clearArray(this._destroyedWhileLoadingState)
      this._runtime = this._destroyedWhileLoadingState = null
    }
    AddRuntimeListeners() {
      const a = this._runtime.Dispatcher()
      a.addEventListener('pretick', this._tickFunc)
      a.addEventListener('tick2', this._tick2Func)
      a.addEventListener('beforelayoutchange', this._beforeLayoutChange)
      a.addEventListener('layoutchange', this._layoutChange)
      a.addEventListener('instancedestroy', this._instanceDestroy)
      a.addEventListener('afterload', this._afterLoad)
    }
    RemoveRuntimeListeners() {
      const a = this._runtime.Dispatcher()
      a.removeEventListener('pretick', this._tickFunc)
      a.removeEventListener('tick2', this._tick2Func)
      a.removeEventListener('beforelayoutchange', this._beforeLayoutChange)
      a.removeEventListener('layoutchange', this._layoutChange)
      a.removeEventListener('instancedestroy', this._instanceDestroy)
      a.removeEventListener('afterload', this._afterLoad)
    }
    Create(a) {
      this._timelineDataManager.Add(a)
      a = e.TimelineState.CreateInitial(a, this)
      this.Add(a)
      this.SetTimelineObjectClassesToMap(a)
      this._timelinesCreatedByTemplate.set(a.GetName(), 0)
    }
    CreateFromTemplate(a) {
      var c = this.GetTimelineDataManager()
      a = a.GetTemplateName()
      c = c.Get(a)
      c = e.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, c, this)
      this._IncreaseTemplateTimelinesCount(a)
      this.Add(c)
      return c
    }
    _IncreaseTemplateTimelinesCount(a) {
      this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
    }
    _SetCreatedTemplateTimelinesCount() {
      for (const a of this._timelines) {
        if (a.IsTemplate()) continue
        const c = a.GetTemplateName()
        this._IncreaseTemplateTimelinesCount(c)
      }
    }
    _ClearCreatedTemplateTimelinesCount() {
      for (const a of this._timelinesCreatedByTemplate.keys()) this._timelinesCreatedByTemplate.set(a, 0)
    }
    Add(a) {
      this._timelines.push(a)
      this._timelinesByName.set(a.GetName().toLowerCase(), a)
    }
    Remove(a) {
      a.IsTemplate() || (e.arrayFindRemove(this._timelines, a), e.arrayFindRemove(this._scheduledTimelines, a), e.arrayFindRemove(this._playingTimelines, a), this._timelinesByName.delete(a.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(a), a.IsReleased() || a.Release())
    }
    Trigger(a) {
      this._runtime.Trigger(a, this._pluginInstance, null)
    }
    GetRuntime() {
      return this._runtime
    }
    GetTimelineDataManager() {
      return this._timelineDataManager
    }
    SetPluginInstance(a) {
      this._pluginInstance = a
    }
    GetPluginInstance() {
      return this._pluginInstance
    }
    *GetTimelines() {
      for (const a of this._timelines) yield a
    }
    SetTimelineObjectClassToMap(a, c) {
      this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set())
      this._objectClassToTimelineMap.get(a).add(c)
    }
    SetTimelineObjectClassesToMap(a) {
      for (const c of a.GetObjectClasses()) this.SetTimelineObjectClassToMap(c, a)
    }
    RemoveTimelineFromObjectClassMap(a) {
      for (const [c, d] of this._objectClassToTimelineMap.entries()) d.has(a) && (d.delete(a), 0 === d.size && this._objectClassToTimelineMap.delete(c))
    }
    GetTimelinesForObjectClass(a) {
      if (this._objectClassToTimelineMap.has(a)) return this._objectClassToTimelineMap.get(a)
    }
    GetTimelineOfTemplateForInstances(a, c) {
      if (c) for (const d of this._timelines) if (c.every(f => d.HasTrackInstance(f.instance, f.trackId)) && d.GetName().includes(a.GetName())) return d
    }
    GetTimelineByName(a) {
      return this._timelinesByName.get(a.toLowerCase()) || null
    }
    GetScheduledOrPlayingTimelineByName(a) {
      for (const c of this._scheduledTimelines) if (c.GetName() === a) return c
      for (const c of this._playingTimelines) if (c.GetName() === a) return c
      return null
    }
    *GetTimelinesByName(a) {
      if (b.test(a)) {
        b.lastIndex = 0
        let d
        var c = new Set()
        do
          if ((d = b.exec(a))) {
            const f = d[1].split(',')
            for (const g of f) c.add(g)
          }
        while (d)
        for (const f of c.values()) (a = this.GetTimelineByName(f)) && (yield a)
        c.clear()
      } else (c = this.GetTimelineByName(a)) && (yield c)
    }
    *GetTimelinesByTags(a) {
      for (const c of this._timelines) c.HasTags(a) && (yield c)
    }
    AddScheduledTimeline(a) {
      this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a)
      this._MaybeEnableRuntimeListeners()
    }
    RemovePlayingTimeline(a) {
      e.arrayFindRemove(this._playingTimelines, a)
      this._MaybeDisableRuntimeListeners()
    }
    ScheduleTimeline(a) {
      this._playingTimelines.includes(a) ? (a.SetPlaying(!0), a.SetScheduled(!1), a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1), a.SetScheduled(!0), a.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a))
      this._MaybeEnableRuntimeListeners()
    }
    DeScheduleTimeline(a) {
      a.SetPlaying(!1)
      a.SetScheduled(!1)
      a.ResolvePlayPromise()
      e.arrayFindRemove(this._scheduledTimelines, a)
      this._MaybeDisableRuntimeListeners()
    }
    CompleteTimeline(a) {
      a.SetPlaying(!1)
      a.SetScheduled(!1)
      a.SetMarkedForRemoval(!0)
    }
    CompleteTimelineAndResolve(a) {
      this.CompleteTimeline(a)
      a.ResolvePlayPromise()
    }
    _OnTick() {
      if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
        var a = !1
        for (this._isTickingTimelines = !0; this._scheduledTimelines.length; ) {
          var c = this._scheduledTimelines.pop()
          c.SetInitialState()
          this._playingTimelines.push(c)
        }
        c = this._runtime.GetDt()
        var d = this._runtime.GetTimeScale()
        for (const f of this._playingTimelines) {
          if (f.IsMarkedForRemoval()) continue
          const g = f.Tick(c, d)
          !a && g && (a = !0)
        }
        this._isTickingTimelines = !1
        a && this.GetRuntime().UpdateRender()
      }
    }
    _OnTick2() {
      if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
        var a
        for (const c of this._playingTimelines) c.IsMarkedForRemoval() && (a || (a = new Set()), this._MaybeExecuteTimelineFinishTriggers(c), a.add(c))
        a && e.arrayRemoveAllInSet(this._playingTimelines, a)
        this._MaybeDisableRuntimeListeners()
      }
    }
    _MaybeExecuteTimelineFinishTriggers(a) {
      a.IsReleased() || (a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() && a.FinishTriggers())
    }
    _MaybeEnableRuntimeListeners() {
      this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
    }
    _MaybeDisableRuntimeListeners() {
      this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
    }
    _OnBeforeChangeLayout() {
      for (this._changingLayout = !0; this._scheduledTimelines.length; ) this.DeScheduleTimeline(this._scheduledTimelines.pop())
      const a = new Set()
      for (const c of this._playingTimelines) c._OnBeforeChangeLayout() && a.add(c)
      e.arrayRemoveAllInSet(this._playingTimelines, a)
      this._MaybeDisableRuntimeListeners()
      for (const c of this._timelines) c.CleanCaches()
    }
    _OnAfterChangeLayout() {
      this._changingLayout = !1
    }
    _OnInstanceDestroy(a) {
      var c = a.GetObjectClass()
      if ((c = this.GetTimelinesForObjectClass(c)))
        if (this._runtime.IsLoadingState()) this._destroyedWhileLoadingState.push(a)
        else for (const d of c) d.IsTemplate() || (d.IsReleased() ? this.Remove(d) : d.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(d), this.Remove(d)))
    }
    _OnAfterLoad() {
      for (const a of this._destroyedWhileLoadingState) this._OnInstanceDestroy(a)
      e.clearArray(this._destroyedWhileLoadingState)
    }
    _SaveToJson() {
      return {
        timelinesJson: this._SaveTimelinesToJson(),
        scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
        playingTimelinesJson: this._SavePlayingTimelinesToJson(),
        hasRuntimeListeners: this._hasRuntimeListeners,
        changingLayout: this._changingLayout,
        isTickingTimelines: this._isTickingTimelines
      }
    }
    _LoadFromJson(a) {
      a &&
        (this._ClearCreatedTemplateTimelinesCount(),
        this._LoadTimelinesFromJson(a.timelinesJson),
        this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson),
        this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson),
        (this._hasRuntimeListeners = !a.hasRuntimeListeners),
        (this._changingLayout = !!a.changingLayout),
        (this._isTickingTimelines = !!a.isTickingTimelines),
        this._SetCreatedTemplateTimelinesCount(),
        this._MaybeEnableRuntimeListeners(),
        this._MaybeDisableRuntimeListeners())
    }
    _SaveTimelinesToJson() {
      return this._timelines.map(a => a._SaveToJson())
    }
    _LoadTimelinesFromJson(a) {
      for (const c of a) {
        a = this.GetTimelineByName(c.name)
        if (!a) {
          a = this._GetTemplateNameFromJson(c)
          if (!a) continue
          a = this.GetTimelineByName(a)
          a = this.CreateFromTemplate(a)
        }
        a._LoadFromJson(c)
        a.HasTracks() || this.Remove(a)
      }
    }
    _GetTemplateNameFromJson(a) {
      return (a = a.name.split(':')) && 2 === a.length ? a[0] : null
    }
    _SaveScheduledTimelinesToJson() {
      return this._SaveTimelines(this._scheduledTimelines)
    }
    _LoadScheduledTimelinesFromJson(a) {
      this._LoadTimelines(a, this._scheduledTimelines)
    }
    _SavePlayingTimelinesToJson() {
      return this._SaveTimelines(this._playingTimelines)
    }
    _LoadPlayingTimelinesFromJson(a) {
      this._LoadTimelines(a, this._playingTimelines)
    }
    _IsTimelineInJson(a, c) {
      for (const d of c) if (d === a.GetName()) return !0
      return !1
    }
    _SaveTimelines(a) {
      return a.map(c => c.GetName())
    }
    _LoadTimelines(a, c) {
      var d = new Set()
      for (const f of c) this._IsTimelineInJson(f, a) || d.add(f)
      e.arrayRemoveAllInSet(c, d)
      d = f => g => g.GetName() === f
      for (const f of a) (a = this.GetTimelineByName(f)) && (c.find(d(f)) || c.push(a))
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TimelineState = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      this._runtime = c.GetRuntime()
      this._timelineManager = c
      this._timelineDataItem = a
      this._name = b
      this._tracks = []
      for (const d of this._timelineDataItem.GetTrackData().trackDataItems()) this._tracks.push(e.TrackState.Create(this, d))
      this._playResolve = this._playPromise = null
      this._playheadTime = e.New(e.KahanSum)
      this._playheadTime.Set(0)
      this._playbackRate = 1
      this._pingPongState = 0
      this._currentRepeatCount = 1
      this._initialStateSet = this._isScheduled = this._isPlaying = !1
      this._complete = !0
      this._markedForRemoval = this._released = !1
      this._completedTick = -1
      this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1
      this._lastDelta = NaN
      this._tags = ['']
      this._stringTags = ''
      this._tagsChanged = !1
    }
    static CreateInitial(b, a) {
      var c = a.GetTimelineDataManager()
      const d = c.GetNameId()
      c = c.Get(b[d])
      b = e.New(e.TimelineState, b[d], c, a)
      b.SetIsTemplate(!0)
      return b
    }
    static CreateFromTemplate(b, a, c) {
      return e.New(e.TimelineState, b, a, c)
    }
    static get WORLD_INSTANCE_BOX_CHANGE() {
      return 1
    }
    static get LAYOUT_RENDER_CHANGE() {
      return e.nextHighestPowerOfTwo(1)
    }
    Release() {
      if (!this.IsReleased()) {
        this._timelineManager.DeScheduleTimeline(this)
        this._timelineManager.CompleteTimelineAndResolve(this)
        for (const b of this._tracks) b.Release()
        e.clearArray(this._tracks)
        this._tracks = null
        this._playheadTime.Release()
        this._timelineDataItem = this._timelineManager = this._runtime = this._playheadTime = null
        this._released = !0
        this._playResolve = this._playPromise = null
      }
    }
    GetTimelineManager() {
      return this._timelineManager
    }
    GetRuntime() {
      return this._runtime
    }
    GetTracks() {
      return this._tracks
    }
    GetSimilarPropertyTracks(b, a, c) {
      const d = []
      for (const f of this._tracks) {
        if (b !== f.GetInstance()) continue
        const g = f.GetPropertyTrack(c)
        g && a.constructor === g.GetSourceAdapter().constructor && d.push(g)
      }
      return d
    }
    HasTracks() {
      return !!this._tracks.length
    }
    GetTrackById(b) {
      for (const a of this._tracks) if (e.equalsNoCase(a.GetId(), b)) return a
      return null
    }
    SetName(b) {
      this._name = b
    }
    GetName() {
      return this._name
    }
    GetTimelineDataItem() {
      return this._timelineDataItem
    }
    GetTemplateName() {
      return this._timelineDataItem.GetName()
    }
    GetTotalTime() {
      return this._timelineDataItem.GetTotalTime()
    }
    SetTotalTime(b) {
      this._timelineDataItem.SetTotalTime(b)
    }
    GetStep() {
      return this._timelineDataItem.GetStep()
    }
    SetStep(b) {
      this._timelineDataItem.SetStep(b)
    }
    GetInterpolationMode() {
      return this._timelineDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(b) {
      this._timelineDataItem.SetInterpolationMode(b)
    }
    GetResultMode() {
      return this._timelineDataItem.GetResultMode()
    }
    SetResultMode(b) {
      this._timelineDataItem.GetResultMode(b)
    }
    SetEase(b) {
      for (const a of this.GetTracks()) a.SetEase(b)
    }
    GetLoop() {
      return this._timelineDataItem.GetLoop()
    }
    SetLoop(b) {
      return this._timelineDataItem.SetLoop(b)
    }
    GetPingPong() {
      return this._timelineDataItem.GetPingPong()
    }
    SetPingPong(b) {
      return this._timelineDataItem.SetPingPong(b)
    }
    GetRepeatCount() {
      return this._timelineDataItem.GetRepeatCount()
    }
    SetPlaybackRate(b) {
      return (this._playbackRate = b)
    }
    GetPlaybackRate() {
      return this._playbackRate
    }
    IsForwardPlayBack() {
      return this.IsPlaying() ? 0 < this._playbackRate : !0
    }
    GetPlayPromise() {
      return this._playPromise
        ? this._playPromise
        : (this._playPromise = new Promise(b => {
            this._playResolve = b
          }))
    }
    ResolvePlayPromise() {
      this._playPromise && (this._playResolve(), (this._playResolve = this._playPromise = null))
    }
    SetTags(b) {
      this._tags = e.TimelineState._GetTagArray(b)
      this._tagsChanged = !0
    }
    GetTags() {
      return this._tags
    }
    GetStringTags() {
      this._tagsChanged && (this._stringTags = this._tags.join(' '))
      this._tagsChanged = !1
      return this._stringTags
    }
    HasTags(b) {
      return this._tags && this._tags.length ? ((b = e.TimelineState._GetTagArray(b)) && b.length ? b.every(e.TimelineState._HasTag, this) : !1) : !1
    }
    OnStarted() {
      e.Plugins.Timeline.Cnds.SetTriggerTimeline(this)
      this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStarted)
      this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByName)
      this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineStartedByTags)
      this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineStarted)
      e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
      this._finishedTriggers ||
        ((this._finishedTriggers = !0),
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinished),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByName),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimelineFinishedByTags),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnAnyTimelineFinished),
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
    }
    SetPlaying(b) {
      this._isPlaying = b
    }
    IsCompletedTick() {
      return this._completedTick === this._runtime.GetTickCount()
    }
    IsPlaying(b = !1) {
      return this.IsCompletedTick() || (this.IsScheduled() && !b) ? !0 : this._isPlaying
    }
    _IsPlaying() {
      return this.IsPlaying(!0)
    }
    IsPaused() {
      return this._IsPaused()
    }
    _IsPaused() {
      return this.IsReleased() || this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
    }
    SetScheduled(b) {
      this._isScheduled = b
    }
    IsScheduled() {
      return this._isScheduled
    }
    SetComplete(b) {
      this._complete = b
      b = this.GetTime()
      if (0 >= b || b >= this.GetTotalTime()) this._complete = !0
    }
    IsComplete() {
      return this._complete
    }
    IsReleased() {
      return this._released
    }
    SetMarkedForRemoval(b) {
      this._markedForRemoval = b
    }
    IsMarkedForRemoval() {
      return this._markedForRemoval
    }
    SetImplicitPause(b) {
      this._implicitPause = b
    }
    IsImplicitPause() {
      return this._implicitPause
    }
    SetIsTemplate(b) {
      this._isTemplate = !!b
    }
    IsTemplate() {
      return this._isTemplate
    }
    InitialStateSet() {
      return this._initialStateSet
    }
    GetTime() {
      return this._playheadTime.Get()
    }
    SetTime(b) {
      const a = this.GetTime()
      this._SetTime(b)
      this.SetComplete(!1)
      this.IsComplete() || this.SetImplicitPause(!0)
      if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet)
        this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? (this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime())) : this.SetInitialStateFromSetTime()
      this._Interpolate(b, !1, !0, !0, a) && this.GetRuntime().UpdateRender()
      this._OnSetTime()
    }
    _SetTime(b) {
      0 > b ? this._playheadTime.Set(0) : b >= this.GetTotalTime() ? this._playheadTime.Set(this.GetTotalTime()) : this._playheadTime.Set(b)
    }
    _OnSetTime() {
      e.Plugins.Timeline &&
        this.constructor === e.TimelineState &&
        (e.Plugins.Timeline.Cnds.SetTriggerTimeline(this),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSet),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByName),
        this._timelineManager.Trigger(e.Plugins.Timeline.Cnds.OnTimeSetByTags),
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(null))
    }
    _CanResume() {
      if (!this.GetLoop())
        if (this.GetPingPong() && 1 === this._pingPongState)
          if (this.IsForwardPlayBack()) {
            if (this.GetTime() >= this.GetTotalTime()) return !1
          } else {
            if (0 >= this.GetTime()) return !1
          }
        else if (!this.GetLoop() && !this.GetPingPong())
          if (this.IsForwardPlayBack()) {
            if (this.GetTime() >= this.GetTotalTime()) return !1
          } else if (0 >= this.GetTime()) return !1
      return !0
    }
    Resume() {
      this.IsReleased() || (this._CanResume() && this.Play(!0))
    }
    Play(b = !1) {
      return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() || (!this.IsComplete() && !b && !this.IsImplicitPause()) ? !1 : this._ScheduleStoppedTimeline()
    }
    _SchedulePlayingTimeline() {
      this.SetImplicitPause(!1)
      this._timelineManager.RemovePlayingTimeline(this)
      this._timelineManager.ScheduleTimeline(this)
      this.GetPlayPromise()
      return !0
    }
    _ScheduleStoppedTimeline() {
      this.SetImplicitPause(!1)
      this._timelineManager.ScheduleTimeline(this)
      this.GetPlayPromise()
      return !0
    }
    Stop(b = !1) {
      this.IsReleased() || (this.SetComplete(b), this._timelineManager.CompleteTimeline(this), this.IsComplete() && this.ResolvePlayPromise())
    }
    Reset(b = !0, a = !1) {
      if (!this.IsReleased()) {
        if (!this._IsPlaying() && this.IsScheduled()) return this._timelineManager.DeScheduleTimeline(this)
        if (!this.IsComplete()) {
          this.Stop(!0)
          this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime())
          var c = this.GetTime()
          a = a ? this._InterpolateBeforeChangeLayout(c) : this._Interpolate(c, !1, !1, !0)
          b && this._OnSetTime()
          a && b && this.GetRuntime().UpdateRender()
        }
      }
    }
    ResetBeforeChangeLayout() {
      this.Reset(!1, !0)
    }
    _InterpolateBeforeChangeLayout(b) {
      this._Interpolate(b, !1, !1, !0, NaN, !1, !0)
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return !0
      if (this.HasValidGlobalTracks()) return !1
      this._timelineManager.CompleteTimeline(this)
      this.ResetBeforeChangeLayout()
      return !0
    }
    SetInitialStateFromSetTime() {
      this.SetInitialState(!0)
    }
    SetInitialState(b) {
      if (!this.IsMarkedForRemoval())
        if (b) {
          this._firstTick = this._initialStateSet = !0
          for (const a of this._tracks) a.SetInitialState()
        } else if ((this.SetPlaying(!0), this.SetScheduled(!1), this.OnStarted(), this.IsComplete())) {
          this._completedTick = -1
          this._pingPongState = 0
          this._currentRepeatCount = 1
          this._finishedTriggers = this._complete = !1
          this._firstTick = this._initialStateSet = !0
          this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime())
          for (const a of this._tracks) a.SetInitialState()
        } else {
          this._firstTick = !0
          for (const a of this._tracks) a.SetResumeState()
        }
    }
    Tick(b, a) {
      if (0 !== b || 0 !== this._lastDelta) {
        this._lastDelta = b
        var c = this.GetTime()
        this._SetTime(c + b * a * this._playbackRate)
        var d
        this.GetLoop() || this.GetPingPong()
          ? this.GetLoop() && !this.GetPingPong()
            ? (d = this._LoopCompleteCheck())
            : !this.GetLoop() && this.GetPingPong()
            ? (d = this._PingPongCompleteCheck())
            : this.GetLoop() && this.GetPingPong() && (d = this._LoopPingPongCompleteCheck())
          : (d = this._SimpleCompleteCheck())
        if (d) {
          for (const f of this._tracks) f.SetEndState()
          this.Stop(!0)
          this.OnCompleted()
          return !0
        }
        return this._Interpolate(this.GetTime(), !0, !1, !1, c, !0)
      }
    }
    _Interpolate(b, a = !1, c = !1, d = !1, f = NaN, g = !1, h = !1) {
      let k = !1
      for (var m of this._tracks) m.BeforeInterpolate()
      for (const r of this._tracks) {
        m = b
        if ('number' === typeof f) {
          const w = this.GetTime() - r.GetStartOffset(),
            p = f - r.GetStartOffset()
          0 > w && 0 < p && ((m = r.GetStartOffset()), this._SetTime(m))
        }
        m = r.Interpolate(m, a, c, d, this._firstTick, h)
        !k && m && (k = !0)
      }
      for (const r of this._tracks) r.AfterInterpolate()
      this._firstTick && g && (this._firstTick = !1)
      return k
    }
    _SimpleCompleteCheck() {
      if (this.IsForwardPlayBack()) {
        if (this.GetTime() >= this.GetTotalTime())
          if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(0)
          else return this._SetTime(this.GetTotalTime()), !0
      } else if (0 >= this.GetTime())
        if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, this._SetTime(this.GetTotalTime())
        else return this._SetTime(0), !0
      return !1
    }
    _LoopCompleteCheck() {
      this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && this._SetTime(0) : 0 >= this.GetTime() && this._SetTime(this.GetTotalTime())
      return !1
    }
    _PingPongCompleteCheck() {
      if (this.IsForwardPlayBack()) {
        if (this.GetTime() >= this.GetTotalTime())
          if ((this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState))
            if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, (this._pingPongState = 0)
            else return !0
          else 0 === this._pingPongState && (this._pingPongState = 1)
      } else if (0 >= this.GetTime())
        if ((this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), 1 === this._pingPongState))
          if (this._currentRepeatCount < this.GetRepeatCount()) this._currentRepeatCount++, (this._pingPongState = 0)
          else return !0
        else 0 === this._pingPongState && (this._pingPongState = 1)
      return !1
    }
    _LoopPingPongCompleteCheck() {
      this.IsForwardPlayBack() ? this.GetTime() >= this.GetTotalTime() && (this._SetTime(this.GetTotalTime()), this.SetPlaybackRate(-1 * this.GetPlaybackRate())) : 0 >= this.GetTime() && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()))
      return !1
    }
    AddTrack() {
      var b = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem()
      b = e.TrackState.Create(this, b)
      this._tracks.push(b)
      return b
    }
    CleanCaches() {
      for (const b of this._tracks) b.CleanCaches()
    }
    ClearTrackInstances() {
      for (const b of this._tracks) b.ClearInstance()
    }
    SetTrackInstance(b, a) {
      if (a)
        for (const c of this._tracks) {
          if (b) {
            if (c.GetId() !== b) continue
          } else if (c.HasInstance()) continue
          c.SetInstance(a)
          this._timelineManager.SetTimelineObjectClassToMap(a.GetObjectClass(), this)
          break
        }
    }
    HasTrackInstance(b, a) {
      for (const c of this._tracks)
        if (a) {
          if (a === c.GetId() && b === c.GetInstance()) return !0
        } else if (b === c.GetInstance()) return !0
      return !1
    }
    GetTrackInstance(b) {
      for (const a of this._tracks) if (b === a.GetInstance()) return a
      return null
    }
    HasValidTracks() {
      return this._tracks.some(b => b.CanInstanceBeValid())
    }
    HasValidGlobalTracks() {
      return this._tracks.some(b => (b.CanInstanceBeValid() ? ((b = b.GetObjectClass()) ? b.IsGlobal() : !1) : !1))
    }
    GetPropertyTrack(b) {
      for (const a of this.GetTracks()) for (const c of a.GetPropertyTracks()) if (c.GetPropertyName() === b) return c
    }
    GetKeyframeWithTags(b) {
      b = b ? b.split(' ') : []
      b = [...new Set(b.map(a => a.toLowerCase().trim())).values()]
      for (const a of this.GetTracks()) for (const c of a.GetKeyframeDataItems()) if (b.every(d => c.HasTag(d))) return c
    }
    GetObjectClasses() {
      const b = []
      for (const a of this.GetTracks()) b.push(a.GetObjectClass())
      return b.filter(a => a)
    }
    _SaveToJson() {
      return {
        tracksJson: this._SaveTracksToJson(),
        name: this._name,
        playheadTime: this.GetTime(),
        playbackRate: this._playbackRate,
        pingPongState: this._pingPongState,
        currentRepeatCount: this._currentRepeatCount,
        isPlaying: this._isPlaying,
        isScheduled: this._isScheduled,
        initialStateSet: this._initialStateSet,
        finishedTriggers: this._finishedTriggers,
        complete: this._complete,
        released: this._released,
        markedForRemoval: this._markedForRemoval,
        completedTick: this._completedTick,
        implicitPause: this._implicitPause,
        isTemplate: this._isTemplate,
        tags: this._tags.join(' '),
        stringTags: this._stringTags,
        tagsChanged: this._tagsChanged,
        firstTick: this._firstTick
      }
    }
    _LoadFromJson(b) {
      b &&
        (this._LoadTracksFromJson(b.tracksJson),
        (this._name = b.name),
        this._playheadTime.Set(b.playheadTime),
        (this._playbackRate = b.playbackRate),
        (this._pingPongState = b.pingPongState),
        (this._currentRepeatCount = b.currentRepeatCount),
        (this._isPlaying = !!b.isPlaying),
        (this._isScheduled = !!b.isScheduled),
        (this._initialStateSet = !!b.initialStateSet),
        (this._finishedTriggers = b.hasOwnProperty('finishedTriggers') ? !!b.finishedTriggers : !1),
        (this._complete = !!b.complete),
        (this._released = !!b.released),
        (this._markedForRemoval = !!b.markedForRemoval),
        (this._completedTick = b.completedTick),
        (this._implicitPause = !!b.implicitPause),
        (this._isTemplate = !!b.isTemplate),
        (this._tags = b.tags.split(' ')),
        (this._stringTags = b.stringTags),
        (this._tagsChanged = !!b.tagsChanged),
        (this._firstTick = !!b.firstTick))
    }
    _SaveTracksToJson() {
      return this._tracks.map(b => b._SaveToJson())
    }
    _LoadTracksFromJson(b) {
      b.forEach((a, c) => {
        this._tracks[c]._LoadFromJson(a)
      })
      this._tracks.filter(a => a.CanInstanceBeValid())
    }
    static _HasTag(b) {
      const a = this.GetTags()
      return '' === b ? 1 === a.length && '' === a[0] : a.includes(b)
    }
    static _GetTagArray(b) {
      if (e.IsArray(b)) return b.slice(0)
      if (e.IsString(b)) return b.split(' ')
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TrackState = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._timeline = b
      this._trackDataItem = a
      this._trackData = a.GetTrackData()
      this._objectClassIndex = this._instanceUid = NaN
      this._worldInfo = this._instance = null
      this._isNested = 0 < a.GetStartOffset()
      this._endStateOfNestedSet = this._initialStateOfNestedSet = !1
      this._lastKeyframeDataItem = null
      this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
      this._propertyTracks = []
      for (const c of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems()) this._propertyTracks.push(e.PropertyTrackState.Create(this, c))
    }
    static Create(b, a) {
      return e.New(e.TrackState, b, a)
    }
    Release() {
      this._keyframeDataItems = null
      for (const b of this._propertyTracks) b.Release()
      e.clearArray(this._propertyTracks)
      this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
    }
    CleanCaches() {
      for (const b of this._propertyTracks) b.CleanCaches()
      this._worldInfo = this._instance = null
    }
    GetTimeline() {
      return this._timeline
    }
    GetRuntime() {
      return this._timeline.GetRuntime()
    }
    GetKeyframeDataItems() {
      return this._keyframeDataItems ? this._keyframeDataItems : (this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray())
    }
    GetPropertyTracks() {
      return this._propertyTracks
    }
    GetPropertyTrack(b) {
      for (const a of this._propertyTracks) if (a.GetPropertyName() === b) return a
    }
    MaybeGetInstance() {
      this._instance || this.GetInstance()
    }
    IsInstanceValid() {
      return this._instance ? !this._instance.IsDestroyed() : !1
    }
    CanInstanceBeValid() {
      var b = this.GetInstanceUID()
      return (b = this.GetRuntime().GetInstanceByUID(b)) ? !b.IsDestroyed() : !1
    }
    GetObjectClass() {
      const b = this.GetObjectClassIndex()
      if (-1 !== b) return this.GetRuntime().GetObjectClassByIndex(b)
    }
    ClearInstance() {
      this._instance = null
      this._instanceUid = -1
      this._worldInfo = null
      this._objectClassIndex = -1
    }
    HasInstance() {
      return !!this._instance
    }
    GetInstance() {
      if (this._instance && this.IsInstanceValid()) return this._instance
      const b = this.GetInstanceUID()
      return (this._instance = this.GetRuntime().GetInstanceByUID(b))
    }
    SetInstance(b) {
      if (this._instance !== b) {
        this.CleanCaches()
        this._instance = b
        this._objectClassIndex = b.GetObjectClass().GetIndex()
        this._instanceUid = b.GetUID()
        this._worldInfo = b.GetWorldInfo()
        for (const g of this.propertyTrackItems()) {
          const h = g.sourceAdapter
          switch (g.propertyTrack.GetSourceAdapterId()) {
            case 'instance-variable':
              h.GetEditorIndex()
              var a = b.GetObjectClass(),
                c = a.GetInstanceVariableIndexByName(g.name),
                d = a.GetInstanceVariableName(c)
              a = a.GetInstanceVariableType(c)
              d === g.name && a === g.type && h.UpdateInstanceVariableIndex(c)
              break
            case 'behavior':
              var f = g.behaviorType
              c = this.GetObjectClass()
              d = b.GetObjectClass()
              a = h.GetBehaviorType(d)
              f && a && ((f = f.GetName()), c.GetBehaviorIndexByName(f), d.GetBehaviorIndexByName(f), h.GetEditorIndex(), h.UpdateBehaviorTypeSid(a.GetSID()))
          }
        }
      }
    }
    *propertyTrackItems() {
      for (const c of this._propertyTracks) {
        var b = c.GetSourceAdapter(),
          a = this.GetObjectClass()
        const d = {
          propertyTrack: c,
          sourceAdapter: b
        }
        switch (c.GetSourceAdapterId()) {
          case 'world-instance':
            d.property = c.GetPropertyName()
            break
          case 'instance-variable':
            b = b.GetEditorIndex()
            d.name = a.GetInstanceVariableName(b)
            d.type = a.GetInstanceVariableType(b)
            break
          case 'effect':
            a = a.GetEffectList()
            b = b.GetEffectType(a)
            d.effectType = b
            break
          case 'behavior':
            b = b.GetBehaviorType(a)
            d.behaviorType = b
            break
          case 'plugin':
            d.plugin = a.GetPlugin()
        }
        yield d
      }
    }
    GetWorldInfo() {
      if (this._worldInfo && this.IsInstanceValid()) return this._worldInfo
      const b = this.GetInstance()
      b && (this._worldInfo = b.GetWorldInfo())
      return this._worldInfo
    }
    GetTrackDataItem() {
      return this._trackDataItem
    }
    GetInstanceUID() {
      return this._instanceUid ? this._instanceUid : this._trackDataItem.GetInstanceUID()
    }
    SetInstanceUID(b) {
      this._trackDataItem.SetInstanceUID(b)
    }
    GetInterpolationMode() {
      return this._trackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(b) {
      this._trackDataItem.SetInterpolationMode(b)
    }
    GetResultMode() {
      return this._trackDataItem.GetResultMode()
    }
    GetId() {
      return this._trackDataItem.GetId()
    }
    GetStartOffset() {
      return this._trackDataItem.GetStartOffset()
    }
    GetLocalTotalTime() {
      return this._trackDataItem.GetLocalTotalTime()
    }
    SetLocalTotalTime(b) {
      this._trackDataItem.SetLocalTotalTime(b)
    }
    SetResultMode(b) {
      this._trackDataItem.SetResultMode(b)
    }
    SetEase(b) {
      for (const a of this.GetKeyframeDataItems()) a.SetEase(b)
      for (const a of this.GetPropertyTracks()) a.SetEase(b)
    }
    GetEnable() {
      return this._trackDataItem.GetEnable()
    }
    SetEnable(b) {
      this._trackDataItem.SetEnable(b)
    }
    GetObjectClassIndex() {
      return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
    }
    SetObjectClassIndex(b) {
      this._trackDataItem.SetObjectClassIndex(b)
    }
    SetOriginalWidth(b) {
      this._trackDataItem.SetOriginalWidth(b)
    }
    GetOriginalWidth() {
      const b = this.GetInstance()
      return b && b.GetSdkInstance().IsOriginalSizeKnown() ? b.GetSdkInstance().GetOriginalWidth() : this._trackDataItem.GetOriginalWidth()
    }
    SetOriginalHeight(b) {
      this._trackDataItem.SetOriginalHeight(b)
    }
    GetOriginalHeight() {
      const b = this.GetInstance()
      return b && b.GetSdkInstance().IsOriginalSizeKnown() ? b.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
    }
    SetInitialState() {
      this.MaybeGetInstance()
      if (this.IsInstanceValid()) {
        for (var b of this._propertyTracks) b.SetInitialState()
        b = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime()
        this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(b)
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1
        this.Interpolate(b)
      }
    }
    SetResumeState() {
      this.MaybeGetInstance()
      if (this.IsInstanceValid()) {
        this._timeline.IsForwardPlayBack()
        var b = this._timeline.GetTime() - this.GetStartOffset()
        this._lastKeyframeDataItem = this.GetLastKeyFrameBeforeTime(b)
        for (const a of this._propertyTracks) a.SetResumeState()
      }
    }
    SetEndState() {
      if (!this.GetTimeline().IsComplete() && (this.MaybeGetInstance(), this.IsInstanceValid() && !this._isNested)) {
        const b = this._timeline.GetTime(),
          a = this.GetStartOffset() + this.GetLocalTotalTime()
        b >= a ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0) : 0 >= b && this.Interpolate(0, !0, !1, !0)
      }
    }
    BeforeInterpolate() {
      for (const b of this._propertyTracks) b.BeforeInterpolate()
    }
    Interpolate(b, a = !1, c = !1, d = !1, f = !1, g = !1) {
      this.MaybeGetInstance()
      if (!this.IsInstanceValid() || (g && this.GetObjectClass().IsGlobal())) return !1
      b -= this.GetStartOffset()
      if (0 > b) return !1
      this.MaybeSetInitialStateOfNestedTrack(b, a)
      this.MaybeTriggerKeyframeReachedConditions(b, a, f)
      f = g = !1
      for (const h of this._propertyTracks) {
        const k = h.Interpolate(b, c, !1, d)
        g || 0 === (k & e.TimelineState.WORLD_INSTANCE_BOX_CHANGE) || (g = !0)
        f || 0 === (k & e.TimelineState.LAYOUT_RENDER_CHANGE) || (f = !0)
      }
      this.MaybeSetEndStateOfNestedTrack(b, a)
      g && (b = this.GetWorldInfo()) && b.SetBboxChanged()
      return f
    }
    AfterInterpolate() {
      for (const b of this._propertyTracks) b.AfterInterpolate()
    }
    MaybeSetInitialStateOfNestedTrack(b, a) {
      if (a && this._isNested && !this._initialStateOfNestedSet) {
        if (this.GetTimeline().IsForwardPlayBack()) {
          if (0 > b) return
          for (const c of this._propertyTracks) c.Interpolate(0, !1, !1, !0)
        } else {
          if (b > this.GetLocalTotalTime()) return
          for (const c of this._propertyTracks) c.Interpolate(this.GetLocalTotalTime(), !1, !1, !0)
        }
        for (const c of this._propertyTracks) c.SetInitialState()
        this._initialStateOfNestedSet = !0
      }
    }
    MaybeSetEndStateOfNestedTrack(b, a) {
      if (a && this._isNested && !this._endStateOfNestedSet)
        if (this.GetTimeline().IsForwardPlayBack()) {
          if (b >= this.GetLocalTotalTime()) {
            for (const c of this._propertyTracks) c.Interpolate(this.GetLocalTotalTime(), !1, !1, !0)
            this._endStateOfNestedSet = !0
          }
        } else if (0 >= b) {
          for (const c of this._propertyTracks) c.Interpolate(0, !1, !1, !0)
          this._endStateOfNestedSet = !0
        }
    }
    MaybeTriggerKeyframeReachedConditions(b, a, c) {
      if (!c && a) return (b = this.GetLastKeyFrameBeforeTime(b)), b !== this._lastKeyframeDataItem && this.OnKeyframeReached(b), (this._lastKeyframeDataItem = b)
    }
    GetLastKeyFrameBeforeTime(b) {
      const a = this.GetTimeline()
      let c = this._trackData.GetKeyFrameDataItemAtTime(b, this._trackDataItem)
      return c ? c : a.IsForwardPlayBack() ? this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(b, this._trackDataItem) : this._trackData.GetFirstKeyFrameDataItemHigherOrEqualThan(b, this._trackDataItem)
    }
    OnKeyframeReached(b) {
      if (e.Plugins.Timeline && this.GetTimeline().constructor === e.TimelineState) {
        var a = this.GetTimeline()
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(a)
        e.Plugins.Timeline.Cnds.SetTriggerKeyframe(b)
        b = a.GetTimelineManager()
        b.Trigger(e.Plugins.Timeline.Cnds.OnAnyKeyframeReached)
        b.Trigger(e.Plugins.Timeline.Cnds.OnKeyframeReached)
        e.Plugins.Timeline.Cnds.SetTriggerTimeline(null)
        e.Plugins.Timeline.Cnds.SetTriggerKeyframe(null)
      }
    }
    AddKeyframe() {
      return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
    }
    AddPropertyTrack() {
      var b = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem()
      b = e.PropertyTrackState.Create(this, b)
      this._propertyTracks.push(b)
      return b
    }
    DeleteKeyframes(b) {
      this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(b)
    }
    DeletePropertyKeyframes(b) {
      for (const a of this._propertyTracks) a.DeletePropertyKeyframes(b)
    }
    SaveState() {
      for (const b of this._propertyTracks) b.SaveState()
    }
    CompareInitialStateWithCurrent() {
      this.MaybeGetInstance()
      if (this.IsInstanceValid()) for (const b of this._propertyTracks) b.CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
      this.MaybeGetInstance()
      if (this.IsInstanceValid()) {
        var b = !1
        for (const a of this._propertyTracks) {
          const c = a.CompareSaveStateWithCurrent()
          !b && c && (b = !0)
        }
        b && ((b = this.AddKeyframe()), b.SetTime(this.GetTimeline().GetTime()), b.SetEase('noease'), b.SetEnable(!0), b.SetTags(''))
      }
    }
    _SaveToJson() {
      var b = this.GetInstance()
      b = b ? b.GetUID() : this.GetInstanceUID()
      return {
        propertyTracksJson: this._SavePropertyTracksToJson(),
        lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
        initialStateOfNestedSet: this._initialStateOfNestedSet,
        endStateOfNestedSet: this._endStateOfNestedSet,
        instanceUid: b
      }
    }
    _LoadFromJson(b) {
      b &&
        (this._LoadPropertyTracksFromJson(b.propertyTracksJson),
        this._LoadLastKeyframeDataItemFromJson(b.lastKeyframeDataItemJson),
        this._LoadInstanceFromJson(b.instanceUid),
        (this._initialStateOfNestedSet = !1),
        b.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = b.initialStateOfNestedSet),
        (this._endStateOfNestedSet = !1),
        b.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = b.endStateOfNestedSet))
    }
    _SaveLastKeyframeDataItemToJson() {
      return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
    }
    _SavePropertyTracksToJson() {
      return this._propertyTracks.map(b => b._SaveToJson())
    }
    _LoadPropertyTracksFromJson(b) {
      b.forEach((a, c) => {
        this._propertyTracks[c]._LoadFromJson(a)
      })
    }
    _LoadInstanceFromJson(b) {
      if (e.IsFiniteNumber(b) && (b = this.GetRuntime().GetInstanceByUID(b))) {
        var a = this.GetTimeline()
        a.ClearTrackInstances()
        a.SetTrackInstance(this._trackDataItem.GetId(), b)
      }
    }
    _LoadLastKeyframeDataItemFromJson(b) {
      this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.PropertyTrackState = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._track = b
      this._propertyTrackDataItem = a
      this._propertyTrackData = a.GetPropertyTrackData()
      this._sourceAdapter = this.GetSourceAdapter()
      this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
    }
    static Create(b, a) {
      return e.New(e.PropertyTrackState, b, a)
    }
    Release() {
      this._track = null
      this._sourceAdapter && (this._sourceAdapter.Release(), (this._sourceAdapter = null))
      this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
    }
    GetTrack() {
      return this._track
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem
    }
    GetPropertyTrackData() {
      return this._propertyTrackData
    }
    GetTimeline() {
      return this._track.GetTimeline()
    }
    GetRuntime() {
      return this._track.GetRuntime()
    }
    GetInstance() {
      return this._track.GetInstance()
    }
    GetSourceAdapter() {
      if (this._sourceAdapter) return this._sourceAdapter
      let b
      switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case 'behavior':
          b = new e.PropertyTrackState.BehaviorSourceAdapter(this)
          break
        case 'effect':
          b = new e.PropertyTrackState.EffectSourceAdapter(this)
          break
        case 'instance-variable':
          b = new e.PropertyTrackState.InstanceVariableSourceAdapter(this)
          break
        case 'plugin':
          b = new e.PropertyTrackState.PluginSourceAdapter(this)
          break
        case 'world-instance':
          b = new e.PropertyTrackState.WorldInstanceSourceAdapter(this)
          break
        case 'value':
          b = new e.PropertyTrackState.ValueSourceAdapter(this)
      }
      return (this._sourceAdapter = b)
    }
    GetSourceAdapterId() {
      return this._propertyTrackDataItem.GetSourceAdapterId()
    }
    SetSourceAdapterId(b) {
      this._propertyTrackDataItem.SetSourceAdapterId(b)
    }
    GetSourceAdapterArgs() {
      return this._propertyTrackDataItem.GetSourceAdapterArguments()
    }
    SetSourceAdapterArgs(b) {
      this._propertyTrackDataItem.SetSourceAdapterArguments(b)
    }
    GetSourceAdapterValue() {
      return this.GetSourceAdapter().GetValue()
    }
    GetPropertyName() {
      return this._propertyTrackDataItem.GetProperty()
    }
    SetPropertyName(b) {
      this._propertyTrackDataItem.SetProperty(b)
    }
    GetPropertyType() {
      return this._propertyTrackDataItem.GetType()
    }
    SetPropertyType(b) {
      this._propertyTrackDataItem.SetType(b)
    }
    GetPropertyKeyframeType() {
      return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
    }
    GetMin() {
      return this._propertyTrackDataItem.GetMin()
    }
    SetMin(b) {
      this._propertyTrackDataItem.SetMin(b)
    }
    GetMax() {
      return this._propertyTrackDataItem.GetMax()
    }
    SetMax(b) {
      this._propertyTrackDataItem.SetMax(b)
    }
    GetEnable() {
      return this._propertyTrackDataItem.GetEnable()
    }
    SetEnable(b) {
      this._propertyTrackDataItem.SetEnable(b)
    }
    GetInterpolationMode() {
      return this._propertyTrackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(b) {
      this._propertyTrackDataItem.SetInterpolationMode(b)
    }
    GetResultMode() {
      return this._propertyTrackDataItem.GetResultMode()
    }
    SetResultMode(b) {
      this._propertyTrackDataItem.SetResultMode(b)
    }
    SetEase(b) {
      for (const a of this.GetPropertyKeyframeDataItems()) a.SetEase(b)
    }
    GetPropertyKeyframeDataItems() {
      return this._propertyKeyframeDataItems ? this._propertyKeyframeDataItems : (this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray())
    }
    *GetPropertyKeyframeValues() {
      for (const b of this.GetPropertyKeyframeDataItems()) yield b.GetValueWithResultMode()
    }
    CleanCaches() {
      this.GetSourceAdapter().CleanCaches()
    }
    GetCurrentState() {
      return this.GetSourceAdapter().GetCurrentState()
    }
    SetInitialState() {
      this.GetSourceAdapter().SetInitialState()
    }
    SetResumeState() {
      this.GetSourceAdapter().SetResumeState()
    }
    BeforeInterpolate() {
      this.GetSourceAdapter().BeforeInterpolate()
    }
    Interpolate(b, a = !1, c = !1, d = !1) {
      var f = this._propertyTrackDataItem
      let g = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(b, f)
      g ? (f = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(b, f)) : ((g = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(b, f)), (f = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(b, f)))
      return this.GetSourceAdapter().Interpolate(b, g, f, a, c, d)
    }
    AfterInterpolate() {
      this.GetSourceAdapter().AfterInterpolate()
    }
    static GetStartPropertyKeyframeForTime(b, a) {
      const c = a.GetPropertyTrackDataItem()
      a = a._propertyTrackData
      let d = a.GetPropertyKeyFrameDataItemAtTime(b, c)
      d || (d = a.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(b, c))
      return d
    }
    static GetEndPropertyKeyframeForTime(b, a) {
      const c = a.GetPropertyTrackDataItem()
      a = a._propertyTrackData
      return a.GetPropertyKeyFrameDataItemAtTime(b, c) ? a.GetFirstPropertyKeyFrameDataItemHigherThan(b, c) : a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(b, c)
    }
    AddPropertyKeyframe() {
      return this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem()
    }
    DeletePropertyKeyframes(b) {
      this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(b)
    }
    SaveState() {
      this.GetSourceAdapter().SaveState()
    }
    CompareInitialStateWithCurrent() {
      if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
        const b = this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
          a = this.GetSourceAdapter().GetCurrentState()
        b.SetAbsoluteValue(a)
      }
    }
    CompareSaveStateWithCurrent() {
      const b = this.GetSourceAdapter().CompareSaveStateWithCurrent()
      b && this.AddPropertyKeyframeAtCurrentTime()
      this.GetSourceAdapter().ClearSaveState()
      return b
    }
    AddPropertyKeyframeAtCurrentTime() {
      const b = this.GetTimeline().GetTime(),
        a = this.GetSourceAdapter(),
        c = e.PropertyTrackState.GetStartPropertyKeyframeForTime(b, this),
        d = this.AddPropertyKeyframe()
      d.SetType(c.GetType())
      d.SetTime(b)
      d.SetEase(c.GetEase())
      d.SetEnable(!0)
      d.SetValue(a.GetValueAtTime())
      d.SetAbsoluteValue(a.GetCurrentState())
    }
    _SaveToJson() {
      return {
        sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
      }
    }
    _LoadFromJson(b) {
      b && this.GetSourceAdapter()._LoadFromJson(b.sourceAdapterJson)
    }
  }
}
{
  ;('use strict')
  const e = self.C3.PropertyTrackState
  e.PropertySourceAdapter = class {
    constructor(b) {
      this._propertyTrack = b
      this._propertyAdapter = null
    }
    Release() {
      this._propertyAdapter && (this._propertyAdapter.Release(), (this._propertyAdapter = null))
      this._propertyTrack = null
    }
    GetPropertyTrack() {
      return this._propertyTrack
    }
    CleanCaches() {
      this._propertyAdapter && this._propertyAdapter.CleanCaches()
    }
    GetPropertyAdapter() {
      return this._propertyAdapter ? this._propertyAdapter : (this._propertyAdapter = this._CreatePropertyAdapter())
    }
    GetEditorIndex() {}
    GetIndex() {
      return this.GetEditorIndex()
    }
    GetTarget() {}
    SetInitialState() {
      this.GetPropertyAdapter().SetInitialState()
    }
    SetResumeState() {
      this.GetPropertyAdapter().SetResumeState()
    }
    BeforeInterpolate() {
      this.GetPropertyAdapter().BeforeChangeProperty()
    }
    Interpolate(b, a, c, d, f, g) {
      const h = e.PropertySourceAdapter.GetInterpolateFunc(this._propertyTrack)(b, a, c, this._propertyTrack)
      return f ? h : this.GetPropertyAdapter().ChangeProperty(b, h, a, c, d, g)
    }
    AfterInterpolate() {
      this.GetPropertyAdapter().AfterChangeProperty()
    }
    SaveState() {
      this.GetPropertyAdapter().SetSaveState()
    }
    ClearSaveState() {
      this.GetPropertyAdapter().ClearSaveState()
    }
    GetCurrentState() {
      return this.GetPropertyAdapter().GetCurrentState()
    }
    CompareInitialStateWithCurrent() {
      return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent() {
      return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
    }
    GetValueAtTime() {
      return e.PropertySourceAdapter.GetValueAtTime(this._propertyTrack)
    }
    _CreatePropertyAdapter() {
      const b = this._propertyTrack.GetPropertyType()
      switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case 'combo':
        case 'boolean':
        case 'text':
        case 'string':
          return new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this)
        case 'numeric':
        case 'number':
        case 'angle':
          return 'combo' === b ? new e.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new e.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)
        case 'color':
        case 'offsetColor':
          return new e.PropertyInterpolationAdapter.ColorInterpolationAdapter(this)
      }
    }
    _SaveToJson() {
      return {
        propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
      }
    }
    _LoadFromJson(b) {
      b && this.GetPropertyAdapter()._LoadFromJson(b.propertyAdapterJson)
    }
    static GetValueAtTime(b) {
      const a = b.GetTrack().GetTimeline().GetTime(),
        c = e.GetStartPropertyKeyframeForTime(a, b),
        d = e.GetEndPropertyKeyframeForTime(a, b)
      return e.PropertySourceAdapter.GetInterpolateFunc(b)(a, c, d, b)
    }
    static GetValue(b, a, c) {
      let d = b.GetResultMode()
      'combo' === b.GetPropertyType() && (d = 'absolute')
      switch (d) {
        case 'relative':
          return a + c
        case 'absolute':
          return c
      }
    }
    static GetInterpolateFunc(b) {
      switch (b.GetPropertyKeyframeType()) {
        case 'numeric':
          return e.NumericTypeAdapter.Interpolate
        case 'angle':
          return e.AngleTypeAdapter.Interpolate
        case 'boolean':
          return e.BooleanTypeAdapter.Interpolate
        case 'color':
          return e.ColorTypeAdapter.Interpolate
        case 'text':
          return e.TextTypeAdapter.Interpolate
      }
    }
    static GetWillChangeFunc(b) {
      switch (b.GetPropertyKeyframeType()) {
        case 'numeric':
          return e.NumericTypeAdapter.WillChange
        case 'angle':
          return e.AngleTypeAdapter.WillChange
        case 'boolean':
          return e.BooleanTypeAdapter.WillChange
        case 'color':
          return e.ColorTypeAdapter.WillChange
        case 'text':
          return e.TextTypeAdapter.WillChange
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
    }
  }
  e.PropertyTrackState.WorldInstanceSourceAdapter = b
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
      this._updatedIndex = NaN
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetIndex() {
      return this._updatedIndex ? this._updatedIndex : super.GetIndex()
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance()
    }
    UpdateInstanceVariableIndex(a) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._updatedIndex = a)
    }
    Interpolate(a, c, d, f, g, h) {
      if (this.GetPropertyAdapter().CanChange(c.GetValue())) return super.Interpolate(a, c, d, f, g, h)
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        index: this._updatedIndex
      })
    }
    _LoadFromJson(a) {
      a && (super._LoadFromJson(a), (this._updatedIndex = a.index))
    }
  }
  e.PropertyTrackState.InstanceVariableSourceAdapter = b
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
      this._sid = NaN
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
      var a = this._propertyTrack.GetPropertyTrackDataItem(),
        c = this._propertyTrack.GetTrack()
      a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0]
      c = c.GetInstance()
      a = c.GetBehaviorIndexBySID(a)
      return c.GetBehaviorInstances()[a].GetSdkInstance()
    }
    GetBehaviorType(a) {
      const c = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2]
      return a.GetBehaviorTypeByName(c)
    }
    UpdateBehaviorTypeSid(a) {
      this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
    }
    Interpolate(a, c, d, f, g, h) {
      const k = this._propertyTrack.GetTrack().GetInstance()
      if (this.GetBehaviorType(k.GetObjectClass())) return super.Interpolate(a, c, d, f, g, h)
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        sid: this._sid
      })
    }
    _LoadFromJson(a) {
      a && (super._LoadFromJson(a), (this._sid = a.sid))
    }
  }
  e.PropertyTrackState.BehaviorSourceAdapter = b
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget() {
      const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList()
      var c = a.GetEffectList()
      c = this.GetEffectType(c).GetIndex()
      return a.IsEffectIndexActive(c) ? a.GetEffectParametersForIndex(c) : null
    }
    GetEffectType(a) {
      const c = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
      return a.GetEffectTypeByName(c)
    }
    Interpolate(a, c, d, f, g, h) {
      if (this._IsEffectActive()) return super.Interpolate(a, c, d, f, g, h)
    }
    _IsEffectActive() {
      const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList()
      var c = a.GetEffectList()
      if ((c = this.GetEffectType(c))) return (c = c.GetIndex()), a.IsEffectIndexActive(c)
    }
  }
  e.PropertyTrackState.EffectSourceAdapter = b
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
    }
    GetEditorIndex() {
      return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetTarget() {
      return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
    }
    Interpolate(a, c, d, f, g, h) {
      var k = this._propertyTrack.GetTrack()
      const m = k.GetObjectClass().GetPlugin()
      k = k.GetInstance().GetObjectClass().GetPlugin()
      if (m === k) return super.Interpolate(a, c, d, f, g, h)
    }
  }
  e.PropertyTrackState.PluginSourceAdapter = b
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertySourceAdapter {
    constructor(a) {
      super(a)
      this._value = 0
      this._init = !1
    }
    SetInitialState() {
      const a = this._propertyTrack.GetPropertyTrackData()
      let c = this._propertyTrack.GetPropertyTrackDataItem()
      c = a.GetFirstPropertyKeyframeDataItem(c)
      this._value = c.GetValueWithResultMode()
    }
    SetResumeState() {}
    GetValue() {
      this._init || this._propertyTrack.Interpolate(0)
      return this._value
    }
    Interpolate(a, c, d, f, g, h) {
      f = e.PropertyTrackState.NumericTypeAdapter.Interpolate
      this._value = f(a, c, d, this._propertyTrack)
      this._init = !0
    }
    SaveState() {}
    ClearSaveState() {}
    GetCurrentState() {
      return this._value
    }
    CompareInitialStateWithCurrent() {
      return !1
    }
    CompareSaveStateWithCurrent() {
      return !1
    }
    _SaveToJson() {
      return {
        value: this._value,
        init: this._init
      }
    }
    _LoadFromJson(a) {
      a && ((this._value = a.value), (this._init = a.hasOwnProperty('init') ? a.init : !0))
    }
  }
  e.PropertyTrackState.ValueSourceAdapter = b
}
;('use strict')
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
  constructor(e) {
    this._sourceAdapter = e
    this._propertyTrack = e.GetPropertyTrack()
    this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    this._property = this._propertyTrack.GetPropertyName()
    this._firstAbsoluteUpdate = !1
    this._target = this._saveState = null
  }
  Release() {
    this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
  }
  CleanCaches() {
    this._target = this._saveState = this._worldInfo = null
  }
  GetPropertyTrack() {
    return this._propertyTrack
  }
  GetWorldInfo() {
    return this._worldInfo ? this._worldInfo : (this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo())
  }
  SetFirstAbsoluteUpdate(e) {
    this._firstAbsoluteUpdate = !!e
  }
  GetFirstAbsoluteUpdate() {
    return this._firstAbsoluteUpdate
  }
  SetInitialState() {}
  SetResumeState() {}
  SetSaveState() {
    this._saveState = this.GetCurrentState()
  }
  ClearSaveState() {
    this._saveState = null
  }
  GetCurrentState() {}
  CompareInitialStateWithCurrent() {}
  CompareSaveStateWithCurrent() {}
  CanChange(e) {
    return typeof this._Getter() === typeof e
  }
  BeforeChangeProperty() {}
  ChangeProperty(e, b, a, c, d) {}
  AfterChangeProperty() {}
  _FirstKeyframeGetter() {
    return this._PickTimelinePlaybackMode(
      () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem()
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(e)
      },
      () => {
        const e = this._propertyTrack.GetPropertyTrackDataItem()
        return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)
      }
    ).GetAbsoluteValue()
  }
  _CurrentKeyframeGetter() {
    const e = this._propertyTrack.GetTimeline().GetTime() - this._propertyTrack.GetTrack().GetStartOffset()
    return this._PickTimelinePlaybackMode(
      () => {
        const b = this._propertyTrack.GetPropertyTrackDataItem()
        return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(e, b)
      },
      () => {
        const b = this._propertyTrack.GetPropertyTrackDataItem(),
          a = this._propertyTrack.GetPropertyTrackData(),
          c = a.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(e, b)
        return c ? c : a.GetLastPropertyKeyframeDataItem(b)
      }
    ).GetAbsoluteValue()
  }
  _PickTimelinePlaybackMode(e, b) {
    return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? e() : b()
  }
  _PickResultMode(e, b) {
    return 'relative' === this._propertyTrack.GetResultMode() ? e() : b()
  }
  _PickFirstAbsoluteUpdate(e, b) {
    return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), e()) : b()
  }
  _GetAbsoluteInitialValue(e) {}
  _GetIndex() {
    return this._sourceAdapter.GetIndex()
  }
  _GetTarget() {
    return this._target ? this._target : (this._target = this._sourceAdapter.GetTarget())
  }
  _PickSource(e, b, a, c, d) {
    switch (this._propertyTrack.GetSourceAdapterId()) {
      case 'behavior':
        return e()
      case 'effect':
        return b()
      case 'instance-variable':
        return a()
      case 'plugin':
        return c()
      case 'world-instance':
        return d()
    }
  }
  _SaveToJson() {
    return {
      firstAbsoluteUpdate: this._firstAbsoluteUpdate,
      saveState: this._saveState
    }
  }
  _LoadFromJson(e) {
    e && ((this._firstAbsoluteUpdate = e.firstAbsoluteUpdate), (this._saveState = e.saveState))
  }
  _GetPropertyKeyframeStubs(e, b = !1) {
    const a = []
    for (const c of e) {
      e = c.GetTrack().GetStartOffset()
      for (const d of c.GetPropertyKeyframeDataItems())
        b && 0 === d.GetTime()
          ? a.push({
              time: e + d.GetTime(),
              value: d.GetAbsoluteValue()
            })
          : b ||
            a.push({
              time: e + d.GetTime(),
              value: d.GetAbsoluteValue()
            })
    }
    return a.sort((c, d) => c.time - d.time)
  }
  _GetLastPropertyKeyframeStub(e, b, a) {
    return this._GetPropertyKeyframeStubLowerThanPlayhead(b, a)
  }
  _GetPropertyKeyframeStubLowerThanPlayhead(e, b) {
    for (let a = b.length - 1; 0 <= a; a--) if (b[a].time <= e) return b[a]
    return null
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map(),
    a = [0, 0, 0]
  class c extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(d) {
      super(d)
    }
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
      const d = this._propertyTrack.GetSourceAdapterId(),
        f = this._GetTarget(),
        g = this._GetIndex()
      switch (d) {
        case 'behavior':
          return this._ToColorArray(f.GetPropertyValueByIndex(g))
        case 'effect':
          return this._ToColorArray(f[g])
        case 'plugin':
          return this._ToColorArray(f.GetPropertyValueByIndex(g))
        case 'world-instance':
          return this._ToColorArray(this._Getter())
      }
    }
    CompareInitialStateWithCurrent() {
      const d = this._FirstKeyframeGetter()
      return !this._CompareColors(d, this._Getter())
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
    }
    _CompareColors(d, f) {
      return d.equalsIgnoringAlpha(f)
    }
    _FirstKeyframeGetter() {
      const d = super._FirstKeyframeGetter()
      return this._GetColorFromArray(d)
    }
    _CurrentKeyframeGetter() {
      const d = super._CurrentKeyframeGetter()
      return this._GetColorFromArray(d)
    }
    _GetAbsoluteInitialValue(d) {}
    _ToColorArray(d) {
      return e.IsInstanceOf(d, e.Color) ? d.toArray().slice(0, 3) : d.slice(0, 3)
    }
    _GetColorFromArray(d) {
      return e.IsInstanceOf(d, e.Color) ? d : new e.Color(d[0], d[1], d[2], 1)
    }
    CanChange(d) {
      return !0
    }
    BeforeChangeProperty() {
      var d = this._propertyTrack.GetInstance()
      b.has(d) || b.set(d, new Map())
      d = b.get(d)
      const f = this._propertyTrack.GetSourceAdapterId()
      d.has(f) || d.set(f, new Map())
      d = d.get(f)
      d.has(this._property) ||
        d.set(this._property, {
          used: !1,
          color: new e.Color(0, 0, 0, 1)
        })
    }
    _GetTmpColor(d, f, g) {
      d = b.get(d).get(f).get(g)
      d.used = !0
      return d.color
    }
    ChangeProperty(d, f, g, h, k) {
      k = this._propertyTrack.GetTimeline()
      h = this._propertyTrack.GetTrack()
      d = this._propertyTrack.GetInstance()
      var m = this._propertyTrack.GetSourceAdapter()
      g = this._propertyTrack.GetSourceAdapterId()
      m = k.GetSimilarPropertyTracks(d, m, this._property)
      if (1 < m.length) {
        if (((m = this._GetPropertyKeyframeStubs(m, !0)), (k = this._GetLastPropertyKeyframeStub(k, k.GetTime(), m))))
          if (((h = h.GetStartOffset()), (m = k.time - h), 0 === m)) this._GetTmpColor(d, g, this._property).addRgb(f[0], f[1], f[2])
          else {
            if (0 > m) return
            k = f[0]
            h = f[1]
            f = f[2]
            m = this._propertyTrack.Interpolate(m, !1, !0)
            k = e.Color.DiffChannel(k, m[0])
            h = e.Color.DiffChannel(h, m[1])
            f = e.Color.DiffChannel(f, m[2])
            this._GetTmpColor(d, g, this._property).addRgb(k, h, f)
          }
      } else this._Setter(f[0], f[1], f[2])
      return e.TimelineState.LAYOUT_RENDER_CHANGE
    }
    AfterChangeProperty() {
      const d = this._propertyTrack.GetInstance()
      if (b.has(d)) {
        var f = b.get(d),
          g = this._propertyTrack.GetSourceAdapterId()
        if (f.has(g)) {
          var h = f.get(g)
          if (h.has(this._property)) {
            var k = h.get(this._property),
              m = k.color
            k.used && this._Setter(m.getR(), m.getG(), m.getB())
            0 === h.size && f.delete(g)
            0 === f.size && b.delete(d)
          }
        }
      }
    }
    _Getter() {
      const d = this._propertyTrack.GetSourceAdapterId(),
        f = this._GetTarget(),
        g = this._GetIndex()
      switch (d) {
        case 'behavior':
          return this._GetColorFromArray(f.GetPropertyValueByIndex(g))
        case 'effect':
          return f[g].clone()
        case 'plugin':
          return this._GetColorFromArray(f.GetPropertyValueByIndex(g))
        case 'world-instance':
          return this.GetWorldInfo().GetUnpremultipliedColor().clone()
      }
    }
    _Setter(d, f, g) {
      const h = this._propertyTrack.GetSourceAdapterId(),
        k = this._GetTarget(),
        m = this._GetIndex()
      switch (h) {
        case 'behavior':
          a[0] = d
          a[1] = f
          a[2] = g
          k.SetPropertyValueByIndex(m, a)
          break
        case 'effect':
          k[m].setRgb(d, f, g)
          break
        case 'plugin':
          a[0] = d
          a[1] = f
          a[2] = g
          k.SetPropertyValueByIndex(m, a)
          break
        case 'world-instance':
          this.GetWorldInfo().SetUnpremultipliedColorRGB(d, f, g)
      }
    }
    _SaveToJson() {}
    _LoadFromJson(d) {}
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = c
}
{
  ;('use strict')
  const e = self.C3
  class b extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a) {
      super(a)
    }
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState() {
      return this._Getter()
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    ChangeProperty(a, c, d, f, g) {
      d = e.PropertyTrackState.PropertySourceAdapter.GetWillChangeFunc(this._propertyTrack)
      var h = this._propertyTrack
      const k = h.GetTrack()
      f = h.GetSourceAdapterId()
      g = h.GetTimeline()
      var m = k.GetInstance()
      h = h.GetSourceAdapter()
      m = g.GetSimilarPropertyTracks(m, h, this._property)
      1 < m.length && ((m = this._GetPropertyKeyframeStubs(m)), (a += k.GetStartOffset()), (a = this._GetLastPropertyKeyframeStub(g, a, m))) && (c = a.value)
      if (d(this._GetIndex(), this._GetTarget(), c, f))
        switch ((this._Setter(c), f)) {
          case 'plugin':
            return e.TimelineState.LAYOUT_RENDER_CHANGE
        }
    }
    _Getter() {
      const a = this._propertyTrack.GetSourceAdapterId(),
        c = this._GetTarget(),
        d = this._GetIndex()
      switch (a) {
        case 'behavior':
          return c.GetPropertyValueByIndex(d)
        case 'effect':
          return c[d]
        case 'instance-variable':
          return c.GetInstanceVariableValue(d)
        case 'plugin':
          return c.GetPropertyValueByIndex(d)
      }
    }
    _Setter(a) {
      const c = this._propertyTrack.GetSourceAdapterId(),
        d = this._GetTarget(),
        f = this._GetIndex()
      switch (c) {
        case 'behavior':
          d.SetPropertyValueByIndex(f, a)
          break
        case 'effect':
          d[f] = a
          break
        case 'instance-variable':
          d.SetInstanceVariableValue(f, a)
          break
        case 'plugin':
          d.SetPropertyValueByIndex(f, a)
      }
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = b
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map(),
    a = (d, f, g, h, k) =>
      b.set(d, {
        setter: f,
        absolute_setter: g,
        getter: h,
        round: k
      })
  a(
    'offsetX',
    (d, f) => d.OffsetX(f),
    (d, f) => d.SetX(f),
    d => d.GetX(),
    !0
  )
  a(
    'offsetY',
    (d, f) => d.OffsetY(f),
    (d, f) => d.SetY(f),
    d => d.GetY(),
    !0
  )
  a(
    'offsetWidth',
    (d, f) => d.OffsetWidth(f),
    (d, f) => d.SetWidth(f),
    d => d.GetWidth(),
    !0
  )
  a(
    'offsetHeight',
    (d, f) => d.OffsetHeight(f),
    (d, f) => d.SetHeight(f),
    d => d.GetHeight(),
    !0
  )
  a(
    'offsetAngle',
    (d, f) => d.OffsetAngle(f),
    (d, f) => d.SetAngle(f),
    d => d.GetAngle(),
    !1
  )
  a(
    'offsetOpacity',
    (d, f, g, h) => {
      g = d.GetOpacity() + f
      0 === h._clampAccumulator
        ? (1 < g ? (h._clampAccumulator += g - 1) : 0 > g && (h._clampAccumulator += g), d.OffsetOpacity(f))
        : ((d = d.GetOpacity() + f),
          0 < f && 0 < h._clampAccumulator
            ? 1 < d && (h._clampAccumulator += d - 1)
            : 0 < f && 0 > h._clampAccumulator
            ? ((h._clampAccumulator += f), 0 < h._clampAccumulator && (h._clampAccumulator = 0))
            : 0 > f && 0 < h._clampAccumulator
            ? ((h._clampAccumulator += f), 0 > h._clampAccumulator && (h._clampAccumulator = 0))
            : 0 > f && 0 > h._clampAccumulator && 0 > d && (h._clampAccumulator += d))
    },
    (d, f) => {
      d.SetOpacity(f)
    },
    d => d.GetOpacity(),
    !1
  )
  a(
    'offsetOriginX',
    (d, f) => d.OffsetOriginX(f),
    (d, f) => d.SetOriginX(f),
    d => d.GetOriginX(),
    !1
  )
  a(
    'offsetOriginY',
    (d, f) => d.OffsetOriginY(f),
    (d, f) => d.SetOriginY(f),
    d => d.GetOriginY(),
    !1
  )
  a(
    'offsetZElevation',
    (d, f) => d.OffsetZElevation(f),
    (d, f) => d.SetZElevation(f),
    d => d.GetZElevation(),
    !0
  )
  a(
    'offsetScaleX',
    (d, f, g, h) => {
      h = 0 > d.GetWidth() ? -1 : 1
      d.GetTransformWithParentWidth()
      d.OffsetWidth(g.GetOriginalWidth() * h * f)
    },
    (d, f, g) => {
      d.SetWidth(g.GetOriginalWidth() * f)
    },
    (d, f) => {
      const g = 0 > d.GetWidth() ? -1 : 1
      if (d.GetTransformWithParentWidth()) {
        var h = d.GetParent(),
          k = f.GetTimeline().GetTrackInstance(h.GetInstance())
        k ? (h = h.GetWidth() / k.GetOriginalWidth()) : ((k = h.GetInstance().GetSdkInstance()), (h = k.IsOriginalSizeKnown() ? h.GetWidth() / k.GetOriginalWidth() : 1))
        return (d.GetWidth() * g) / (f.GetOriginalWidth() * h)
      }
      return (d.GetWidth() * g) / f.GetOriginalWidth()
    },
    !1
  )
  a(
    'offsetScaleY',
    (d, f, g, h) => {
      h = 0 > d.GetHeight() ? -1 : 1
      d.GetTransformWithParentHeight()
      d.OffsetHeight(g.GetOriginalHeight() * h * f)
    },
    (d, f, g) => {
      d.SetHeight(g.GetOriginalHeight() * f)
    },
    (d, f) => {
      const g = 0 > d.GetHeight() ? -1 : 1
      if (d.GetTransformWithParentHeight()) {
        var h = d.GetParent(),
          k = f.GetTimeline().GetTrackInstance(h.GetInstance())
        k ? (h = h.GetHeight() / k.GetOriginalHeight()) : ((k = h.GetInstance().GetSdkInstance()), (h = k.IsOriginalSizeKnown() ? h.GetHeight() / k.GetOriginalHeight() : 1))
        return (d.GetHeight() * g) / (f.GetOriginalHeight() * h)
      }
      return (d.GetHeight() * g) / f.GetOriginalHeight()
    },
    !1
  )
  class c extends e.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(d) {
      super(d)
      this._clampAccumulator = this._lastValue = 0
      this._instance_absolute_setter = this._instance_setter = this._instance_getter = null
      this._round = !1
      e.IsInstanceOf(this._propertyTrack.GetTimeline(), e.Tween)
        ? (this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this))
        : (this._typeAdapter = new e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this))
      d = this._propertyTrack.GetPropertyName()
      'world-instance' === this._propertyTrack.GetSourceAdapterId() && ((d = b.get(d)), (this._instance_getter = d.getter), (this._instance_setter = d.setter), (this._instance_absolute_setter = d.absolute_setter), (this._round = d.round))
    }
    Release() {
      this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null
      super.Release()
    }
    GetLastValue() {
      return this._lastValue
    }
    SetLastValue(d) {
      this._lastValue = d
    }
    SetInitialState() {
      const d = this._typeAdapter.SetInitialState()
      'number' === typeof d && (this._lastValue = d)
      this._clampAccumulator = 0
    }
    SetResumeState() {
      const d = this._typeAdapter.SetResumeState()
      'number' === typeof d && (this._lastValue = d)
    }
    GetCurrentState() {
      return this._Getter()
    }
    CompareInitialStateWithCurrent() {
      return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent() {
      return e.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    BeforeChangeProperty() {
      this._typeAdapter.BeforeChangeProperty()
    }
    ChangeProperty(d, f, g, h, k, m, r) {
      return this._typeAdapter.ChangeProperty(d, f, g, h, k, m, r)
    }
    AfterChangeProperty() {
      this._typeAdapter.AfterChangeProperty()
    }
    _Getter() {
      const d = this._GetTarget(),
        f = this._GetIndex(),
        g = this._propertyTrack.GetTrack(),
        h = this.GetWorldInfo()
      return this._PickSource(
        () => d.GetPropertyValueByIndex(f),
        () => d[f],
        () => d.GetInstanceVariableValue(f),
        () => d.GetPropertyValueByIndex(f),
        () => this._instance_getter(h, g)
      )
    }
    _Setter(d, f, g) {
      const h = this._GetTarget(),
        k = this._GetIndex(),
        m = this._propertyTrack.GetTrack(),
        r = this.GetWorldInfo()
      this._PickSource(
        () => h.OffsetPropertyValueByIndex(k, d),
        () => (h[k] += d),
        () => h.SetInstanceVariableOffset(k, d),
        () => h.OffsetPropertyValueByIndex(k, d),
        () => this._instance_setter(r, d, m, this)
      )
    }
    _SetterAbsolute(d, f, g) {
      const h = this._GetTarget(),
        k = this._GetIndex(),
        m = this._propertyTrack.GetTrack(),
        r = this.GetWorldInfo()
      this._PickSource(
        () => h.SetPropertyValueByIndex(k, d),
        () => (h[k] = d),
        () => h.SetInstanceVariableValue(k, d),
        () => h.SetPropertyValueByIndex(k, d),
        () => this._instance_absolute_setter(r, d, m)
      )
    }
    _MaybeEnsureValue(d, f, g, h, k, m) {
      this._typeAdapter._MaybeEnsureValue(d, f, g, h, k, m)
    }
    _AddDelta(d, f, g) {
      var h = (d.toString().split('.')[1] || '').length
      d = this._Getter()
      h = 0 === h ? (this._round ? Math.round(d) : d) : e.toFixed(d, h)
      this._Setter(h - d, f, g)
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        v: this._lastValue,
        a: this._clampAccumulator
      })
    }
    _LoadFromJson(d) {
      d && (super._LoadFromJson(d), (this._lastValue = d.v), (this._clampAccumulator = d.a))
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = c
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map()
  class a {
    constructor(c) {
      this._numericInterpolationAdapter = c
    }
    Release() {
      this._numericInterpolationAdapter = null
    }
    SetInitialState() {
      const c = this._numericInterpolationAdapter,
        d = this._numericInterpolationAdapter.GetPropertyTrack()
      return c._PickResultMode(
        () =>
          c._PickTimelinePlaybackMode(
            () => 0,
            () => e.PropertyTrackState.PropertySourceAdapter.GetValueAtTime(d)
          ),
        () => {}
      )
    }
    SetResumeState() {}
    BeforeChangeProperty() {
      const c = this._numericInterpolationAdapter,
        d = this._numericInterpolationAdapter.GetPropertyTrack(),
        f = d.GetPropertyName()
      c._PickResultMode(
        () => {},
        () => {
          var g = d.GetInstance()
          b.has(g) || b.set(g, new Map())
          g = b.get(g)
          const h = d.GetSourceAdapterId()
          g.has(h) || g.set(h, new Map())
          g = g.get(h)
          g.has(f) ||
            g.set(f, {
              used: !1,
              value: 0
            })
        }
      )
    }
    _GetTmpAbsoluteValueObject(c, d, f) {
      c = b.get(c).get(d).get(f)
      c.used = !0
      return c
    }
    ChangeProperty(c, d, f, g, h, k) {
      const m = this._numericInterpolationAdapter,
        r = this._numericInterpolationAdapter.GetPropertyTrack(),
        w = r.GetPropertyName()
      m._PickResultMode(
        () => {
          const p = m.GetLastValue()
          m._Setter(d - p, f, g)
          k && this._MaybeEnsureValue(c, f, g, h, p, d)
          m.SetLastValue(d)
        },
        () => {
          var p = r.GetTimeline(),
            q = r.GetTrack()
          const t = r.GetInstance()
          var x = r.GetSourceAdapter()
          const v = r.GetSourceAdapterId()
          x = p.GetSimilarPropertyTracks(t, x, w)
          if (1 < x.length) {
            if (((x = m._GetPropertyKeyframeStubs(x, !0)), (p = m._GetLastPropertyKeyframeStub(p, p.GetTime(), x))))
              (q = q.GetStartOffset()), (q = p.time - q), 0 === q ? (this._GetTmpAbsoluteValueObject(t, v, w).value += d) : 0 > q || ((q = r.Interpolate(q, !1, !0)), (this._GetTmpAbsoluteValueObject(t, v, w).value += d - q))
          } else m._SetterAbsolute(d)
        }
      )
      return m._PickSource(
        () => {},
        () => e.TimelineState.LAYOUT_RENDER_CHANGE,
        () => {},
        () => e.TimelineState.LAYOUT_RENDER_CHANGE,
        () => e.TimelineState.LAYOUT_RENDER_CHANGE
      )
    }
    AfterChangeProperty() {
      const c = this._numericInterpolationAdapter,
        d = this._numericInterpolationAdapter.GetPropertyTrack(),
        f = d.GetPropertyName()
      c._PickResultMode(
        () => {},
        () => {
          const g = d.GetInstance()
          if (b.has(g)) {
            var h = b.get(g),
              k = d.GetSourceAdapterId()
            if (h.has(k)) {
              var m = h.get(k)
              if (m.has(f)) {
                var r = m.get(f),
                  w = r.value
                r.used && c._SetterAbsolute(w)
                m.delete(f)
                0 === m.size && h.delete(k)
                0 === h.size && b.delete(g)
              }
            }
          }
        }
      )
    }
    _MaybeEnsureValue(c, d, f, g, h, k) {
      const m = this._numericInterpolationAdapter
      g || (d && c === d.GetTime() ? m._AddDelta(d.GetValueWithResultMode(), d, f) : f && c === f.GetTime() ? m._AddDelta(f.GetValueWithResultMode(), d, f) : 0 === k - h && m._AddDelta(d.GetValueWithResultMode(), d, f))
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = a
}
{
  ;('use strict')
  const e = self.C3
  new Map()
  class b {
    constructor(a) {
      this._numericInterpolationAdapter = a
    }
    Release() {
      this._numericInterpolationAdapter = null
    }
    SetInitialState() {
      const a = this._numericInterpolationAdapter
      a.SetFirstAbsoluteUpdate(!0)
      return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
    }
    SetResumeState() {
      const a = this._numericInterpolationAdapter
      if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter()) return a.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, c, d, f, g, h) {
      const k = this._numericInterpolationAdapter,
        m = k.GetLastValue()
      k._PickResultMode(
        () => {
          k._Setter(c - m, d, f)
          h && this._MaybeEnsureValue(a, d, f, g, m, c)
        },
        () => {
          k._PickFirstAbsoluteUpdate(
            () => {
              k._Setter(m, d, f)
            },
            () => {
              k._Setter(c - m, d, f)
              h && this._MaybeEnsureValue(a, d, f, g, m, c)
            }
          )
        }
      )
      k.SetLastValue(c)
      return k._PickSource(
        () => {},
        () => e.TimelineState.LAYOUT_RENDER_CHANGE,
        () => {},
        () => e.TimelineState.LAYOUT_RENDER_CHANGE,
        () => e.TimelineState.LAYOUT_RENDER_CHANGE
      )
    }
    AfterChangeProperty() {}
    _GetAbsoluteInitialValue(a) {
      return a - this._numericInterpolationAdapter.GetCurrentState()
    }
    _MaybeEnsureValue(a, c, d, f, g, h) {
      const k = this._numericInterpolationAdapter
      f
        ? c && a === c.GetTime()
          ? k._AddDelta(c.GetValueWithResultMode(), c, d)
          : d && a === d.GetTime()
          ? k._AddDelta(d.GetValueWithResultMode(), c, d)
          : d || k._AddDelta(c.GetValueWithResultMode(), c, d)
        : c && a === c.GetTime()
        ? k._AddDelta(c.GetValueWithResultMode(), c, d)
        : d && a === d.GetTime()
        ? k._AddDelta(d.GetValueWithResultMode(), c, d)
        : 0 === h - g && k._AddDelta(c.GetValueWithResultMode(), c, d)
    }
  }
  e.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = b
}
{
  ;('use strict')
  const e = self.C3,
    b = self.Ease
  e.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(a, c, d, f) {
      let g
      switch (f) {
        case 'behavior':
          g = c.GetPropertyValueByIndex(a)
          break
        case 'effect':
          g = c[a]
          break
        case 'instance-variable':
          g = c.GetInstanceVariableValue(a)
          break
        case 'plugin':
          g = c.GetPropertyValueByIndex(a)
      }
      return g === d ? !1 : !0
    }
    static Interpolate(a, c, d, f) {
      if (!d) return (d = f.GetPropertyTrackDataItem()), (d = f.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(d)), d.GetValueWithResultMode()
      var g = f.GetInterpolationMode()
      'default' === g && (g = 'continuous')
      'combo' === f.GetPropertyType() && (g = 'discrete')
      if ('discrete' === g) return c.GetValueWithResultMode()
      if ('continuous' === g || 'step' === g) {
        'step' === g && ((g = f.GetTimeline().GetStep()), 0 !== g && ((g = 1 / g), (a = Math.floor(a * g) / g)))
        var h = c.GetTime()
        const k = d.GetTime()
        g = c.GetValueWithResultMode()
        const m = d.GetValueWithResultMode()
        if (g === m) return g
        a = e.normalize(a, h, k)
        const r = c.GetEase()
        c = c.GetAddOn('cubic-bezier')
        d = d.GetAddOn('cubic-bezier')
        c && c.GetStartEnable() && d && d.GetEndEnable() ? ((h = k - h), (h = b.GetRuntimeEase(r)(h * a, 0, 1, h)), (h = b.GetRuntimeEase('cubicbezier')(h, g, g + c.GetStartAnchor(), m + d.GetEndAnchor(), m))) : (h = b.GetRuntimeEase(r)((k - h) * a, g, m - g, k - h))
        return 'integer' === f.GetPropertyType() ? Math.floor(h) : h
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(b, a, c, d) {
      let f
      switch (d) {
        case 'behavior':
          f = a.GetPropertyValueByIndex(b)
          break
        case 'effect':
          f = a[b]
          break
        case 'instance-variable':
          f = a.GetInstanceVariableValue(b)
          break
        case 'plugin':
          f = a.GetPropertyValueByIndex(b)
      }
      return f === c ? !1 : !0
    }
    static Interpolate(b, a, c, d) {
      if (!c) return (a = d.GetPropertyTrackDataItem()), (a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a)), a.GetValueWithResultMode()
      var f = d.GetInterpolationMode()
      'default' === f && (f = 'continuous')
      'combo' === d.GetPropertyType() && (f = 'discrete')
      if ('discrete' === f) return a.GetValueWithResultMode()
      if ('continuous' === f || 'step' === f) {
        'step' === f && ((d = d.GetTimeline().GetStep()), 0 !== d && ((d = 1 / d), (b = Math.floor(b * d) / d)))
        const g = a.GetTime(),
          h = c.GetTime()
        d = a.GetValueWithResultMode()
        c = c.GetValueWithResultMode()
        if ((f = a.GetAddOn('angle'))) {
          const k = f.GetRevolutions()
          if (d === c && 0 === k) return d
          b = e.normalize(b, g, h)
          a = self.Ease.GetRuntimeEase(a.GetEase())(b, 0, 1, 1)
          switch (f.GetDirection()) {
            case 'closest':
              return e.angleLerp(d, c, a, k)
            case 'clockwise':
              return e.angleLerpClockwise(d, c, a, k)
            case 'anti-clockwise':
              return e.angleLerpAntiClockwise(d, c, a, k)
          }
        } else {
          if (d === c) return d
          b = e.normalize(b, g, h)
          a = self.Ease.GetRuntimeEase(a.GetEase())
          return e.angleLerp(d, c, a(b, 0, 1, 1))
        }
      }
    }
  }
}
;('use strict')
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
  constructor() {}
  static WillChange(e, b, a, c) {
    let d
    switch (c) {
      case 'behavior':
        d = b.GetPropertyValueByIndex(e)
        break
      case 'effect':
        d = b[e]
        break
      case 'instance-variable':
        d = b.GetInstanceVariableValue(e)
        break
      case 'plugin':
        d = b.GetPropertyValueByIndex(e)
    }
    return !!d === !!a ? !1 : !0
  }
  static Interpolate(e, b, a, c) {
    return a ? (b.GetValueWithResultMode() ? 1 : 0) : ((e = c.GetPropertyTrackDataItem()), (e = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)), e.GetValueWithResultMode() ? 1 : 0)
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = [0, 0, 0],
    a = [0, 0, 0],
    c = [0, 0, 0]
  e.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {}
    static WillChange(d, f, g, h) {
      let k
      switch (h) {
        case 'behavior':
          k = f.GetPropertyValueByIndex(d)
          break
        case 'effect':
          k = f[d]
          break
        case 'instance-variable':
          k = f.GetInstanceVariableValue(d)
          break
        case 'plugin':
          k = f.GetPropertyValueByIndex(d)
      }
      Array.isArray(g) ? ((b[0] = g[0]), (b[1] = g[1]), (b[2] = g[2])) : (c.parseCommaSeparatedRgb(g), (b[0] = Math.floor(255 * c.getR())), (b[1] = Math.floor(255 * c.getG())), (b[2] = Math.floor(255 * c.getB())))
      Array.isArray(k) ? ((a[0] = k[0]), (a[1] = k[1]), (a[2] = k[2])) : (c.parseCommaSeparatedRgb(k), (a[0] = Math.floor(255 * c.getR())), (a[1] = Math.floor(255 * c.getG())), (a[2] = Math.floor(255 * c.getB())))
      return b[0] !== a[0] || b[1] !== a[1] || b[2] !== a[2] ? !0 : !1
    }
    static Interpolate(d, f, g, h) {
      if (!g) {
        var k = h.GetPropertyTrackDataItem()
        k = h.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(k)
        h = k.GetValueWithResultMode()
        b[0] = h[0]
        b[1] = h[1]
        b[2] = h[2]
        return b
      }
      k = h.GetInterpolationMode()
      'default' === k && (k = 'continuous')
      if ('discrete' === k) return (h = f.GetValueWithResultMode()), (b[0] = h[0]), (b[1] = h[1]), (b[2] = h[2]), b
      if ('continuous' === k || 'step' === k) {
        'step' === k && ((h = h.GetTimeline().GetStep()), 0 !== h && ((h = 1 / h), (d = Math.floor(d * h) / h)))
        h = f.GetTime()
        k = g.GetTime()
        var m = f.GetValueWithResultMode(),
          r = g.GetValueWithResultMode()
        d = e.normalize(d, h, k)
        var w = f.GetEase()
        f = m[0]
        g = m[1]
        m = m[2]
        const p = r[0],
          q = r[1]
        r = r[2]
        w = self.Ease.GetRuntimeEase(w)
        h = k - h
        k = h * d
        b[0] = f === p ? f : w(k, f, p - f, h)
        b[1] = g === q ? g : w(k, g, q - g, h)
        b[2] = m === r ? m : w(k, m, r - m, h)
        return b
      }
    }
  }
}
;('use strict')
self.C3.PropertyTrackState.TextTypeAdapter = class {
  constructor() {}
  static WillChange(e, b, a, c) {
    let d
    switch (c) {
      case 'behavior':
        d = b.GetPropertyValueByIndex(e)
        break
      case 'effect':
        d = b[e]
        break
      case 'instance-variable':
        d = b.GetInstanceVariableValue(e)
        break
      case 'plugin':
        d = b.GetPropertyValueByIndex(e)
    }
    return d === a ? !1 : !0
  }
  static Interpolate(e, b, a, c) {
    return a ? b.GetValueWithResultMode() : ((e = c.GetPropertyTrackDataItem()), (e = c.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e)), e.GetValueWithResultMode())
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TimelineDataManager = class {
    constructor() {
      this._timelineDataItems = new Map()
    }
    Release() {
      for (const b of this._timelineDataItems.values()) b.Release()
      this._timelineDataItems.clear()
      this._timelineDataItems = null
    }
    Add(b) {
      b = new e.TimelineDataItem(b)
      const a = b.GetName()
      this._timelineDataItems.set(a, b)
    }
    Get(b) {
      return this._timelineDataItems.get(b)
    }
    GetNameId() {
      return 0
    }
    static _CreateDataItems(b, a, c, d) {
      if (a) for (const f of a) e.TimelineDataManager._CreateDataItem('create', f, b, c, d)
    }
    static _LoadDataItemsFromJson(b, a, c, d) {
      b.length
        ? a.forEach((f, g) => {
            b[g]._LoadFromJson(f)
          })
        : a.forEach(f => {
            e.TimelineDataManager._CreateDataItem('load', f, b, c, d)
          })
    }
    static _CreateDataItem(b, a, c, d, f) {
      let g
      if ('function' === typeof d)
        switch (b) {
          case 'load':
            g = new d(null, f)
            break
          case 'create':
            g = new d(a, f)
        }
      else if ('object' === typeof d)
        switch (((d = d.map.get(a[d.prop])), b)) {
          case 'load':
            g = new d(null, f)
            break
          case 'create':
            g = new d(a, f)
        }
      switch (b) {
        case 'load':
          g._LoadFromJson(a)
          c.push(g)
          break
        case 'create':
          if ('function' === typeof g.GetEnable && !g.GetEnable()) return g.Release()
          c.push(g)
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TimelineDataItem = class {
    constructor(b) {
      this._name = ''
      this._totalTime = NaN
      this._step = 0
      this._resultMode = this._interpolationMode = 'default'
      this._pingPong = this._loop = !1
      this._repeatCount = 1
      this._trackData = null
      b && ((this._name = b[0]), (this._totalTime = b[1]), (this._step = b[2]), (this._interpolationMode = b[3]), (this._resultMode = b[4]), (this._loop = !!b[6]), (this._pingPong = !!b[7]), (this._repeatCount = b[8]), (this._trackData = new e.TrackData(b[5], this)))
    }
    Release() {
      this._trackData.Release()
      this._trackData = null
    }
    GetTrackData() {
      this._trackData || (this._trackData = new e.TrackData(null, this))
      return this._trackData
    }
    GetName() {
      return this._name
    }
    SetName(b) {
      this._name = b
    }
    GetTotalTime() {
      return this._totalTime
    }
    SetTotalTime(b) {
      this._totalTime = b
    }
    GetStep() {
      return this._step
    }
    SetStep(b) {
      this._step = b
    }
    GetInterpolationMode() {
      return this._interpolationMode
    }
    SetInterpolationMode(b) {
      this._interpolationMode = b
    }
    GetResultMode() {
      return this._resultMode
    }
    SetResultMode(b) {
      this._resultMode = b
    }
    GetLoop() {
      return this._loop
    }
    SetLoop(b) {
      this._loop = b
    }
    GetPingPong() {
      return this._pingPong
    }
    SetPingPong(b) {
      this._pingPong = b
    }
    GetRepeatCount() {
      return this._repeatCount
    }
    _SaveToJson() {
      return {
        trackDataJson: this._trackData._SaveToJson(),
        name: this._name,
        totalTime: this._totalTime,
        step: this._step,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        loop: this._loop,
        pingPong: this._pingPong,
        repeatCount: this._repeatCount
      }
    }
    _LoadFromJson(b) {
      b &&
        (this.GetTrackData()._LoadFromJson(b.trackDataJson),
        (this._name = b.name),
        (this._totalTime = b.totalTime),
        (this._step = b.step),
        (this._interpolationMode = b.interpolationMode),
        (this._resultMode = b.resultMode),
        (this._loop = b.loop),
        (this._pingPong = b.pingPong),
        (this._repeatCount = b.repeatCount))
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(a, c) {
      this._trackData = c
      this._additionalInstanceData = this._instanceData = null
      this._objectClassIndex = this._instanceUid = NaN
      this._resultMode = this._interpolationMode = 'default'
      this._enabled = !1
      this._propertyTrackData = this._keyframeData = null
      this._id = ''
      this._nestedData = null
      this._startOffset = 0
      this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime()
      a &&
        ((this._instanceData = a[0]),
        (this._instanceUid = a[0][2]),
        (this._objectClassIndex = a[0][1]),
        (this._interpolationMode = a[1]),
        (this._resultMode = a[2]),
        (this._enabled = !!a[3]),
        a[6] && (this._id = a[6]),
        a[7] && ((this._nestedData = a[7]), (this._startOffset = a[7][0]), (this._localTotalTime = a[7][1])),
        a[8] && (this._additionalInstanceData = a[8]),
        (this._keyframeData = new e.KeyframeData(a[4], this)),
        (this._propertyTrackData = new e.PropertyTrackData(a[5], this)))
    }
    Release() {
      this._trackData = this._instanceData = null
      this._keyframeData && (this._keyframeData.Release(), (this._keyframeData = null))
      this._propertyTrackData && (this._propertyTrackData.Release(), (this._propertyTrackData = null))
      this._nestedData = null
    }
    GetTrackData() {
      return this._trackData
    }
    GetKeyframeData() {
      this._keyframeData || (this._keyframeData = new e.KeyframeData(null, this))
      return this._keyframeData
    }
    GetPropertyTrackData() {
      this._propertyTrackData || (this._propertyTrackData = new e.PropertyTrackData(null, this))
      return this._propertyTrackData
    }
    GetInstanceData() {
      return this._instanceData
    }
    GetObjectClassIndex() {
      return this._objectClassIndex
    }
    SetObjectClassIndex(a) {
      this._objectClassIndex = a
    }
    GetInstanceUID() {
      return this._instanceUid
    }
    SetInstanceUID(a) {
      this._instanceUid = a
    }
    GetInterpolationMode() {
      return this._interpolationMode
    }
    SetInterpolationMode(a) {
      this._interpolationMode = a
    }
    GetResultMode() {
      return this._resultMode
    }
    SetResultMode(a) {
      this._resultMode = a
    }
    GetEnable() {
      return this._enabled
    }
    SetEnable(a) {
      this._enabled = !!a
    }
    GetId() {
      return this._id
    }
    GetStartOffset() {
      return this._startOffset
    }
    GetLocalTotalTime() {
      return this._localTotalTime
    }
    SetLocalTotalTime(a) {
      this._localTotalTime = a
    }
    GetOriginalWidth() {
      return this._additionalInstanceData[0]
    }
    SetOriginalWidth(a) {
      this._additionalInstanceData || (this._additionalInstanceData = [])
      this._additionalInstanceData[0] = a
    }
    GetOriginalHeight() {
      this._additionalInstanceData || (this._additionalInstanceData = [])
      return this._additionalInstanceData[1]
    }
    SetOriginalHeight(a) {
      this._additionalInstanceData || (this._additionalInstanceData = [])
      this._additionalInstanceData[1] = a
    }
    _SaveToJson() {
      return {
        keyframeDataJson: this._keyframeData._SaveToJson(),
        propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
        instanceData: this._instanceData,
        additionalInstanceData: this._additionalInstanceData,
        instanceUid: this._instanceUid,
        objectClassIndex: this._objectClassIndex,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        enabled: this._enabled,
        id: this._id,
        nestedData: this._nestedData
      }
    }
    _LoadFromJson(a) {
      a &&
        ((this._instanceData = a.instanceData),
        (this._instanceUid = a.instanceUid),
        (this._objectClassIndex = a.objectClassIndex),
        (this._interpolationMode = a.interpolationMode),
        (this._resultMode = a.resultMode),
        (this._enabled = a.enabled),
        (this._id = a.id),
        (this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime()),
        a.nestedData && ((this._nestedData = a.nestedData), (this._startOffset = this._nestedData[0]), (this._localTotalTime = this._nestedData[1])),
        a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData),
        this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson),
        this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
    }
  }
  e.TrackData = class {
    constructor(a, c) {
      this._timelineDataItem = c
      this._trackDataItems = []
      this._keyframeTimeMap = new Map()
      e.TimelineDataManager._CreateDataItems(this._trackDataItems, a, b, this)
    }
    Release() {
      this._timelineDataItem = null
      for (const a of this._trackDataItems) a.Release()
      e.clearArray(this._trackDataItems)
      this._trackDataItems = null
      this._keyframeTimeMap.clear()
      this._keyframeTimeMap = null
    }
    GetTimelineDataItem() {
      return this._timelineDataItem
    }
    AddEmptyTrackDataItem() {
      const a = new b(null, this)
      this._trackDataItems.push(a)
      return a
    }
    GetFirstKeyframeDataItem(a) {
      return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
    }
    GetLastKeyframeDataItem(a) {
      a = a.GetKeyframeData().GetKeyframeDataItemArray()
      return a[a.length - 1]
    }
    GetKeyFrameDataItemAtTime(a, c) {
      const d = this._keyframeTimeMap.get(c)
      if (d && d.has(a)) return d.get(a)
      for (const f of c.GetKeyframeData().keyframeDataItems()) if (f.GetTime() === a) return d || this._keyframeTimeMap.set(c, new Map()), this._keyframeTimeMap.get(c).set(a, f), f
    }
    GetFirstKeyFrameDataItemHigherThan(a, c) {
      for (const d of c.GetKeyframeData().keyframeDataItems()) if (d.GetTime() > a) return d
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(a, c) {
      for (const d of c.GetKeyframeData().keyframeDataItems()) if (d.GetTime() >= a) return d
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(a, c) {
      for (const d of c.GetKeyframeData().keyframeDataItemsReverse()) if (d.GetTime() <= a) return d
    }
    *trackDataItems() {
      for (const a of this._trackDataItems) yield a
    }
    _SaveToJson() {
      return {
        trackDataItemsJson: this._trackDataItems.map(a => a._SaveToJson())
      }
    }
    _LoadFromJson(a) {
      a && e.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, b, this)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(a, c) {
      this._propertyTrackData = c
      this._sourceAdapterId = ''
      this._type = this._property = this._sourceAdapterArguments = null
      this._max = this._min = NaN
      this._resultMode = this._interpolationMode = 'default'
      this._enabled = !1
      this._propertyKeyframeData = null
      a &&
        ((this._sourceAdapterId = a[0][0]),
        (this._sourceAdapterArguments = a[0].slice(1)),
        (this._property = a[1]),
        (this._type = a[2]),
        (this._min = a[3]),
        (this._max = a[4]),
        (this._interpolationMode = a[5]),
        (this._resultMode = a[6]),
        (this._enabled = !!a[7]),
        (this._propertyKeyframeData = new e.PropertyKeyframeData(a[8], this)))
    }
    Release() {
      this._propertyKeyframeData.Release()
      this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
    }
    GetPropertyTrackData() {
      return this._propertyTrackData
    }
    GetPropertyKeyframeData() {
      this._propertyKeyframeData || (this._propertyKeyframeData = new e.PropertyKeyframeData(null, this))
      return this._propertyKeyframeData
    }
    GetSourceAdapterId() {
      return this._sourceAdapterId
    }
    SetSourceAdapterId(a) {
      this._sourceAdapterId = a
    }
    GetSourceAdapterArguments() {
      return this._sourceAdapterArguments
    }
    SetSourceAdapterArguments(a) {
      this._sourceAdapterArguments = a
    }
    GetProperty() {
      return this._property
    }
    SetProperty(a) {
      this._property = a
    }
    GetType() {
      return this._type
    }
    SetType(a) {
      this._type = a
    }
    GetMin() {
      return this._min
    }
    SetMin(a) {
      this._min = a
    }
    GetMax() {
      return this._max
    }
    SetMax(a) {
      this._max = a
    }
    GetInterpolationMode() {
      return this._interpolationMode
    }
    SetInterpolationMode(a) {
      this._interpolationMode = a
    }
    GetResultMode() {
      return this._resultMode
    }
    SetResultMode(a) {
      this._resultMode = a
    }
    GetEnable() {
      return this._enabled
    }
    SetEnable(a) {
      this._enabled = !!a
    }
    _SaveToJson() {
      return {
        propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
        sourceAdapterId: this._sourceAdapterId,
        sourceAdapterArguments: this._sourceAdapterArguments,
        property: this._property,
        type: this._type,
        min: this._min,
        max: this._max,
        interpolationMode: this._interpolationMode,
        resultMode: this._resultMode,
        enabled: this._enabled
      }
    }
    _LoadFromJson(a) {
      a &&
        ((this._sourceAdapterId = a.sourceAdapterId),
        (this._sourceAdapterArguments = a.sourceAdapterArguments),
        (this._property = a.property),
        (this._type = a.type),
        (this._min = a.min),
        (this._max = a.max),
        (this._interpolationMode = a.interpolationMode),
        (this._resultMode = a.resultMode),
        (this._enabled = a.enabled),
        this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
    }
  }
  e.PropertyTrackData = class {
    constructor(a, c) {
      this._trackDataItem = c
      this._propertyTrackDataItems = []
      this._propertyKeyframeTimeMap = new Map()
      e.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, b, this)
    }
    Release() {
      this._trackDataItem = null
      for (const a of this._propertyTrackDataItems) a.Release()
      e.clearArray(this._propertyTrackDataItems)
      this._propertyTrackDataItems = null
      this._propertyKeyframeTimeMap.clear()
      this._propertyKeyframeTimeMap = null
    }
    GetTrackDataItem() {
      return this._trackDataItem
    }
    AddEmptyPropertyTrackDataItem() {
      const a = new b(null, this)
      this._propertyTrackDataItems.push(a)
      return a
    }
    GetFirstPropertyKeyframeDataItem(a) {
      return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
    }
    GetLastPropertyKeyframeDataItem(a) {
      a = a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
      return a[a.length - 1]
    }
    GetPropertyKeyFrameDataItemAtTime(a, c) {
      const d = this._propertyKeyframeTimeMap.get(c)
      if (d && d.has(a)) return d.get(a)
      const f = c.GetPropertyKeyframeData()
      for (const g of f.propertyKeyframeDataItems()) if (g.GetTime() === a) return d || this._propertyKeyframeTimeMap.set(c, new Map()), this._propertyKeyframeTimeMap.get(c).set(a, g), g
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(a, c) {
      c = c.GetPropertyKeyframeData()
      for (const d of c.propertyKeyframeDataItems()) if (d.GetTime() > a) return d
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, c) {
      c = c.GetPropertyKeyframeData()
      for (const d of c.propertyKeyframeDataItems()) if (d.GetTime() >= a) return d
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, c) {
      c = c.GetPropertyKeyframeData()
      for (const d of c.propertyKeyframeDataItemsReverse()) if (d.GetTime() <= a) return d
    }
    *propertyTrackDataItems() {
      for (const a of this._propertyTrackDataItems) yield a
    }
    _SaveToJson() {
      return {
        propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a => a._SaveToJson())
      }
    }
    _LoadFromJson(a) {
      a && e.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, a.propertyTrackDataItemsJson, b, this)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(a, c) {
      this._keyframeData = c
      this._time = -1
      this._ease = 'noease'
      this._enable = !1
      this._lowerTags = this._tags = null
      a && ((this._time = a[0]), (this._ease = a[1]), (this._enable = !!a[2]), (this._tags = (a = a[3]) ? a.split(' ') : []), (this._lowerTags = new Set(this._tags.map(d => d.toLowerCase()))))
    }
    Release() {
      this._keyframeData = null
      e.clearArray(this._tags)
      this._tags = null
      this._lowerTags.clear()
      this._lowerTags = null
    }
    GetKeyframeData() {
      return this._keyframeData
    }
    GetTime() {
      return this._time
    }
    SetTime(a) {
      this._time = a
    }
    GetEase() {
      return this._ease
    }
    SetEase(a) {
      this._ease = a
    }
    GetEnable() {
      return this._enable
    }
    SetEnable(a) {
      this._enable = !!a
    }
    GetTags() {
      return this._tags
    }
    SetTags(a) {
      this._tags = a ? a.split(' ') : []
      this._lowerTags = new Set(this._tags.map(c => c.toLowerCase()))
    }
    GetLowerTags() {
      return this._lowerTags
    }
    HasTag(a) {
      return this._lowerTags.has(a.toLowerCase())
    }
    _SaveToJson() {
      return {
        time: this._time,
        ease: this._ease,
        enable: this._enable,
        tags: this._tags
      }
    }
    _LoadFromJson(a) {
      a && ((this._time = a.time), (this._ease = a.ease), (this._enable = a.enable), (this._tags = a.tags), (this._lowerTags = new Set(this._tags.map(c => c.toLowerCase()))))
    }
  }
  e.KeyframeData = class {
    constructor(a, c) {
      this._trackDataItem = c
      this._keyframeDataItems = []
      e.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, b, this)
    }
    Release() {
      this._trackDataItem = null
      for (const a of this._keyframeDataItems) a.Release()
      e.clearArray(this._keyframeDataItems)
      this._keyframeDataItems = null
    }
    GetTrackDataItem() {
      return this._trackDataItem
    }
    GetKeyframeDataItemCount() {
      return this._keyframeDataItems.length
    }
    GetKeyframeDataItemArray() {
      return this._keyframeDataItems
    }
    AddEmptyKeyframeDataItem() {
      const a = new b(null, this)
      this._keyframeDataItems.push(a)
      return a
    }
    DeleteKeyframeDataItems(a) {
      for (const c of this._keyframeDataItems) {
        if (!a(c)) continue
        const d = this._keyframeDataItems.indexOf(c)
        ;-1 !== d && (c.Release(), this._keyframeDataItems.splice(d, 1))
      }
      this.SortKeyframeDataItems()
    }
    SortKeyframeDataItems() {
      this._keyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime())
    }
    GetKeyframeDataItemIndex(a) {
      return this._keyframeDataItems.indexOf(a)
    }
    GetKeyframeDataItemFromIndex(a) {
      return this._keyframeDataItems[a]
    }
    *keyframeDataItems() {
      for (const a of this._keyframeDataItems) yield a
    }
    *keyframeDataItemsReverse() {
      for (let a = this._keyframeDataItems.length - 1; 0 <= a; a--) yield this._keyframeDataItems[a]
    }
    _SaveToJson() {
      return {
        keyframeDataItemsJson: this._keyframeDataItems.map(a => a._SaveToJson())
      }
    }
    _LoadFromJson(a) {
      a && e.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, b, this)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(a, c) {
      this._propertyKeyframeData = c
      this._aValue = this._value = null
      this._type = ''
      this._time = NaN
      this._ease = 'noease'
      this._enable = !1
      this._addonData = null
      a && ((this._value = a[0][0]), (this._aValue = a[0][1]), (this._type = a[0][2]), (this._time = a[1]), (this._ease = a[2]), (this._enable = !!a[3]), (this._addonData = null), a[4] && (this._addonData = new e.AddonData(a[4], this)))
    }
    Release() {
      this._propertyKeyframeData = null
      this._addonData && (this._addonData.Release(), (this._addonData = null))
    }
    GetAddonData() {
      return this._addonData
    }
    GetValue() {
      return this._value
    }
    SetValue(a) {
      'color' === this._type && e.IsFiniteNumber(a) ? ((this._value[0] = e.GetRValue(a)), (this._value[1] = e.GetGValue(a)), (this._value[2] = e.GetBValue(a))) : (this._value = a)
    }
    GetAbsoluteValue() {
      return this._aValue
    }
    SetAbsoluteValue(a) {
      'color' === this._type && e.IsFiniteNumber(a) ? ((this._aValue[0] = e.GetRValue(a)), (this._aValue[1] = e.GetGValue(a)), (this._aValue[2] = e.GetBValue(a))) : (this._aValue = a)
    }
    GetValueWithResultMode() {
      const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode()
      if ('relative' === a) return this.GetValue()
      if ('absolute' === a) return this.GetAbsoluteValue()
    }
    GetType() {
      return this._type
    }
    SetType(a) {
      this._type = a
    }
    GetTime() {
      return this._time
    }
    SetTime(a) {
      this._time = a
    }
    GetEase() {
      return this._ease
    }
    SetEase(a) {
      this._ease = a
    }
    GetEnable() {
      return this._enable
    }
    SetEnable(a) {
      this._enable = !!a
    }
    GetAddOn(a) {
      if (this.GetAddonData()) for (const c of this.GetAddonData().addonDataItems()) if (c.GetId() === a) return c
    }
    _SaveToJson() {
      const a = this._addonData
      return {
        addonDataJson: a ? a._SaveToJson() : a,
        value: this._value,
        aValue: this._aValue,
        type: this._type,
        time: this._time,
        ease: this._ease,
        enable: this._enable
      }
    }
    _LoadFromJson(a) {
      a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson), (this._value = a.value), (this._aValue = a.aValue), (this._type = a.type), (this._time = a.time), (this._ease = a.ease), (this._enable = a.enable))
    }
  }
  e.PropertyKeyframeData = class {
    constructor(a, c) {
      this._propertyTrackDataItem = c
      this._propertyKeyframeDataItems = []
      e.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, b, this)
    }
    Release() {
      this._propertyTrackDataItem = null
      for (const a of this._propertyKeyframeDataItems) a.Release()
      e.clearArray(this._propertyKeyframeDataItems)
      this._propertyKeyframeDataItems = null
    }
    AddEmptyPropertyKeyframeDataItem() {
      const a = new b(null, this)
      this._propertyKeyframeDataItems.push(a)
      return a
    }
    DeletePropertyKeyframeDataItems(a) {
      for (const c of this._propertyKeyframeDataItems) {
        if (!a(c)) continue
        const d = this._propertyKeyframeDataItems.indexOf(c)
        ;-1 !== d && (c.Release(), this._propertyKeyframeDataItems.splice(d, 1))
      }
      this.SortPropertyKeyFrameDataItems()
    }
    SortPropertyKeyFrameDataItems() {
      this._propertyKeyframeDataItems.sort((a, c) => a.GetTime() - c.GetTime())
    }
    GetPropertyTrackDataItem() {
      return this._propertyTrackDataItem
    }
    GetPropertyKeyframeDataItemCount() {
      return this._propertyKeyframeDataItems.length
    }
    GetPropertyKeyframeDataItemArray() {
      return this._propertyKeyframeDataItems
    }
    *propertyKeyframeDataItems() {
      for (const a of this._propertyKeyframeDataItems) yield a
    }
    *propertyKeyframeDataItemsReverse() {
      for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--) yield this._propertyKeyframeDataItems[a]
    }
    _SaveToJson() {
      return {
        propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(a => a._SaveToJson())
      }
    }
    _LoadFromJson(a) {
      a && e.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, b, this)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(d, f) {
      this._addonData = f
      this._id = d[0]
      this._data = d[1]
    }
    Release() {
      this._data = this._addonData = null
    }
    GetAddonData() {
      return this._addonData
    }
    GetId() {
      return this._id
    }
    _SaveToJson() {
      return {
        id: this._id,
        data: this._data
      }
    }
    _LoadFromJson(d) {
      d && ((this._id = d.id), (this._data = d.data))
    }
  }
  class a extends b {
    constructor(d, f) {
      super(d, f)
      this._startAnchor = this._data[0]
      this._startEnable = !!this._data[1]
      this._endAnchor = this._data[2]
      this._endEnable = !!this._data[3]
    }
    Release() {
      super.Release()
    }
    GetStartAnchor() {
      return this._startAnchor
    }
    GetStartEnable() {
      return this._startEnable
    }
    GetEndAnchor() {
      return this._endAnchor
    }
    GetEndEnable() {
      return this._endEnable
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        startAnchor: this._startAnchor,
        startEnable: !!this._startEnable,
        endAnchor: this._endAnchor,
        endEnable: !!this._endEnable
      })
    }
    _LoadFromJson(d) {
      d && (super._LoadFromJson(d), (this._startAnchor = d.startAnchor), (this._startEnable = !!d.startEnable), (this._endAnchor = d.endAnchor), (this._endEnable = !!d.endEnable))
    }
  }
  class c extends b {
    constructor(d, f) {
      super(d, f)
      this._direction = this._data[0]
      this._revolutions = this._data[1]
    }
    Release() {
      super.Release()
    }
    GetDirection() {
      return this._direction
    }
    GetRevolutions() {
      return this._revolutions
    }
    _SaveToJson() {
      return Object.assign(super._SaveToJson(), {
        direction: this._direction,
        revolutions: this._revolutions
      })
    }
    _LoadFromJson(d) {
      d && (super._LoadFromJson(d), (this._direction = d.direction), (this._revolutions = d.revolutions))
    }
  }
  e.AddonData = class {
    constructor(d, f) {
      this._propertyKeyframeDataItem = f
      this._addonDataItems = []
      e.TimelineDataManager._CreateDataItems(
        this._addonDataItems,
        d,
        {
          prop: 0,
          map: new Map([
            ['cubic-bezier', a],
            ['angle', c]
          ])
        },
        this
      )
    }
    Release() {
      this._propertyKeyframeDataItem = null
      for (const d of this._addonDataItems) d.Release()
      e.clearArray(this._addonDataItems)
      this._addonDataItems = null
    }
    GetPropertyKeyframeDataItem() {
      return this._propertyKeyframeDataItem
    }
    *addonDataItems() {
      for (const d of this._addonDataItems) yield d
    }
    _SaveToJson() {
      return {
        addonDataItemsJson: this._addonDataItems.map(d => d._SaveToJson())
      }
    }
    _LoadFromJson(d) {
      d &&
        e.TimelineDataManager._LoadDataItemsFromJson(
          this._addonDataItems,
          d.addonDataItemsJson,
          {
            prop: 'id',
            map: new Map([
              ['cubic-bezier', a],
              ['angle', c]
            ])
          },
          this
        )
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = 0
  e.Tween = class extends e.TimelineState {
    constructor(a, c) {
      super(`tween-${b++}`, a, c)
      this._id = ''
      this._destroyInstanceOnComplete = !1
      this._initialValueMode = 'start-value'
      this._on_started_callbacks = this._on_completed_callbacks = null
    }
    GetInstance() {
      var a = this.GetTracks()
      if (a && a.length && (a = a[0])) {
        var c = a.GetInstance()
        return a.IsInstanceValid() ? c : null
      }
    }
    AddStartedCallback(a) {
      this._on_started_callbacks || (this._on_started_callbacks = [])
      this._on_started_callbacks.push(a)
    }
    AddCompletedCallback(a) {
      this._on_completed_callbacks || (this._on_completed_callbacks = [])
      this._on_completed_callbacks.push(a)
    }
    RemoveStartedCallback(a) {
      this._on_started_callbacks && ((a = this._on_started_callbacks.indexOf(a)), -1 !== a && this._on_started_callbacks.splice(a, 1))
    }
    RemoveCompletedCallback(a) {
      this._on_completed_callbacks && ((a = this._on_completed_callbacks.indexOf(a)), -1 !== a && this._on_completed_callbacks.splice(a, 1))
    }
    SetStartValue(a, c) {
      for (const f of this._tracks)
        for (const g of f._propertyTracks) {
          if (g.GetPropertyName() !== c) continue
          var d = g.GetPropertyTrackData()
          const h = g.GetPropertyTrackDataItem()
          d = d.GetFirstPropertyKeyframeDataItem(h)
          d.SetValue(a)
          d.SetAbsoluteValue(a)
        }
    }
    _GetPropertyTrackState(a) {
      for (const c of this._tracks) for (const d of c._propertyTracks) if (d.GetPropertyName() === a) return d
    }
    BeforeSetEndValues(a) {
      for (const f of a) (a = this._GetPropertyTrackState(f)), this.SetStartValue(a.GetCurrentState(), f)
      if (this.IsForwardPlayBack()) {
        var c = this.GetTotalTime() - this.GetTime()
        this.SetTotalTime(c)
        for (var d of this._tracks) d.SetLocalTotalTime(c)
        this._SetTime(0)
      } else {
        d = this.GetTime()
        this.SetTotalTime(d)
        for (c of this._tracks) c.SetLocalTotalTime(d)
        this._SetTime(d)
      }
      this.SetInitialStateFromSetTime()
    }
    SetEndValue(a, c) {
      var d = this._GetPropertyTrackState(c)
      c = d.GetPropertyTrackData()
      d = d.GetPropertyTrackDataItem()
      c = c.GetLastPropertyKeyframeDataItem(d)
      c.SetTime(this.GetTotalTime())
      c.SetValue(a)
      c.SetAbsoluteValue(a)
    }
    SetId(a) {
      this._id = a
    }
    GetId() {
      return this._id
    }
    SetInitialValueMode(a) {
      this._initialValueMode = a
    }
    GetInitialValueMode() {
      return this._initialValueMode
    }
    SetDestroyInstanceOnComplete(a) {
      this._destroyInstanceOnComplete = a
    }
    GetDestroyInstanceOnComplete() {
      return this._destroyInstanceOnComplete
    }
    OnStarted() {
      if (this._on_started_callbacks) for (const a of this._on_started_callbacks) a(this)
      if (!this.IsComplete()) for (const a of this._tracks) a.CompareSaveStateWithCurrent()
    }
    OnCompleted() {
      this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers() {
      if (!this._finishedTriggers && ((this._finishedTriggers = !0), this._on_completed_callbacks)) for (const a of this._on_completed_callbacks) a(this)
    }
    SetTime(a) {
      this._DeleteIntermediateKeyframes()
      super.SetTime(a)
    }
    SetInitialState(a) {
      if (!this.InitialStateSet() && 'current-state' === this.GetInitialValueMode()) for (const c of this._tracks) c.CompareInitialStateWithCurrent()
      super.SetInitialState(a)
    }
    Stop(a = !1) {
      super.Stop(a)
      if (!this.IsComplete()) for (const c of this._tracks) c.SaveState()
    }
    Reset(a = !0, c = !1) {
      this._DeleteIntermediateKeyframes()
      super.Reset(a, c)
    }
    _DeleteIntermediateKeyframes() {
      for (const a of this._tracks) {
        const c = d => {
          d = d.GetTime()
          const f = this.GetTotalTime()
          return 0 !== d && d !== f
        }
        a.DeleteKeyframes(c)
        a.DeletePropertyKeyframes(c)
      }
    }
    _OnBeforeChangeLayout() {
      if (this.IsReleased()) return !0
      const a = this.GetInstance()
      if (a && a.GetObjectClass().IsGlobal()) return !1
      this._timelineManager.CompleteTimeline(this)
      this.ResetBeforeChangeLayout()
      return !0
    }
    MaybeTriggerKeyframeReachedConditions() {}
    Tick(a, c) {
      a = this.GetInstance()
      a = this.GetRuntime().GetDt(a)
      super.Tick(a, 1)
    }
    _SaveToJson() {
      const a = super._SaveToJson(),
        c = this.GetTimelineDataItem()
      return Object.assign(a, {
        tweenDataItemJson: c._SaveToJson(),
        id: this._id,
        destroyInstanceOnComplete: this._destroyInstanceOnComplete,
        initialValueMode: this._initialValueMode
      })
    }
    _LoadFromJson(a) {
      a && (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson), super._LoadFromJson(a), (this._id = a.id), (this._destroyInstanceOnComplete = a.destroyInstanceOnComplete), (this._initialValueMode = a.initialValueMode))
    }
    static IsPlaying(a) {
      return a.IsPlaying()
    }
    static IsPaused(a) {
      return a.IsPaused()
    }
    static Build(a) {
      var c = a.runtime.GetTimelineManager(),
        d = new e.TimelineDataItem()
      if (a.json) {
        d._LoadFromJson(a.json.tweenDataItemJson)
        var f = new e.Tween(d, c)
        f._LoadFromJson(a.json)
        return f
      }
      c = new e.Tween(d, c)
      e.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig])
      c.SetId(a.id)
      c.SetTags(a.tags)
      c.SetInitialValueMode(a.initialValueMode)
      c.SetDestroyInstanceOnComplete(a.releaseOnComplete)
      c.SetLoop(a.loop)
      c.SetPingPong(a.pingPong)
      c.SetTotalTime(a.time)
      c.SetStep(0)
      c.SetInterpolationMode('default')
      c.SetResultMode(a.propertyTracksConfig[0].resultMode)
      d = c.AddTrack()
      d.SetInstanceUID(a.instance.GetUID())
      d.SetInterpolationMode('default')
      d.SetResultMode(a.propertyTracksConfig[0].resultMode)
      d.SetEnable(!0)
      d.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex())
      var g = a.instance.GetSdkInstance(),
        h = g.IsOriginalSizeKnown() ? g.GetOriginalWidth() : a.instance.GetWorldInfo().GetWidth()
      g = g.IsOriginalSizeKnown() ? g.GetOriginalHeight() : a.instance.GetWorldInfo().GetHeight()
      d.SetOriginalWidth(h)
      d.SetOriginalHeight(g)
      h = d.AddKeyframe()
      h.SetTime(0)
      h.SetEase('noease')
      h.SetEnable(!0)
      h.SetTags('')
      h = d.AddKeyframe()
      h.SetTime(a.time)
      h.SetEase('noease')
      h.SetEnable(!0)
      h.SetTags('')
      for (f of a.propertyTracksConfig)
        (h = d.AddPropertyTrack()),
          h.SetSourceAdapterId(f.sourceId),
          h.SetSourceAdapterArgs(f.sourceArgs),
          h.SetPropertyName(f.property),
          h.SetPropertyType(f.type),
          h.SetMin(NaN),
          h.SetMax(NaN),
          h.SetInterpolationMode('default'),
          h.SetResultMode(f.resultMode),
          h.SetEnable(!0),
          (g = h.AddPropertyKeyframe()),
          g.SetType(f.valueType),
          g.SetTime(0),
          g.SetEase(f.ease),
          g.SetEnable(!0),
          g.SetValue(f.startValue),
          g.SetAbsoluteValue(f.startValue),
          (h = h.AddPropertyKeyframe()),
          h.SetType(f.valueType),
          h.SetTime(a.time),
          h.SetEase(f.ease),
          h.SetEnable(!0),
          h.SetValue(f.endValue),
          h.SetAbsoluteValue(f.endValue)
      return c
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.Ease
  e.Transition = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._name = a[0]
      this._transitionKeyframes = []
      for (const c of a[1]) (a = e.TransitionKeyframe.Create(this, c)), this._transitionKeyframes.push(a)
      this._precalculatedSamples = new Map()
      this._transitionKeyframeCache = new Map()
      this._PreCalcSamples()
      b.AddCustomEase(this._name, (c, d, f, g) => this.Interpolate(c, d, f, g))
    }
    static Create(a) {
      return e.New(e.Transition, a)
    }
    Release() {
      for (const a of this._transitionKeyframes) a.Release()
      e.clearArray(this._transitionKeyframes)
      this._transitionKeyframes = null
      this._precalculatedSamples.clear()
      this._precalculatedSamples = null
      this._transitionKeyframeCache.clear()
      this._transitionKeyframeCache = null
    }
    GetTransitionKeyFrameAt(a) {
      const c = this._transitionKeyframeCache.get(a)
      if (c) return c
      for (const d of this._transitionKeyframes) if (d.GetValueX() === a) return this._transitionKeyframeCache.set(a, d), d
    }
    GetFirstTransitionKeyFrameHigherThan(a) {
      for (const c of this._transitionKeyframes) if (c.GetValueX() > a) return c
    }
    GetFirstTransitionKeyFrameHigherOrEqualThan(a) {
      for (const c of this._transitionKeyframes) if (c.GetValueX() >= a) return c
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(a) {
      for (let c = this._transitionKeyframes.length - 1; 0 <= c; c--) {
        const d = this._transitionKeyframes[c]
        if (d.GetValueX() <= a) return d
      }
    }
    Interpolate(a, c, d, f) {
      var g = a / f
      ;(a = this.GetTransitionKeyFrameAt(g)) ? (f = this.GetFirstTransitionKeyFrameHigherThan(g)) : ((a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(g)), (f = this.GetFirstTransitionKeyFrameHigherOrEqualThan(g)))
      var h = f.GetValueX() - a.GetValueX()
      g = e.mapToRange(g, a.GetValueX(), f.GetValueX(), 0, h)
      h = a.GetValueX()
      const k = a.GetValueY(),
        m = a.GetValueX() + a.GetStartAnchorX(),
        r = a.GetValueY() + a.GetStartAnchorY(),
        w = f.GetValueX() + f.GetEndAnchorX(),
        p = f.GetValueY() + f.GetEndAnchorY(),
        q = f.GetValueX()
      f = f.GetValueY()
      f = b.GetRuntimeEase('spline')(g, h, k, m, r, w, p, q, f, this._precalculatedSamples.get(a))
      f += a.GetValueY()
      return (1 - f) * c + f * (c + d)
    }
    _PreCalcSamples() {
      this._precalculatedSamples.clear()
      for (let d = 0; d < this._transitionKeyframes.length - 1; d++) {
        var a = this._transitionKeyframes[d]
        if (!a.GetStartEnable()) continue
        var c = this._transitionKeyframes[d + 1]
        const f = a.GetValueX(),
          g = a.GetValueX() + a.GetStartAnchorX(),
          h = c.GetValueX() + c.GetEndAnchorX()
        c = c.GetValueX()
        this._precalculatedSamples.set(a, b.GetBezierSamples(f, g, h, c))
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TransitionKeyframe = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._transition = b
      this._valueX = a[0]
      this._valueY = a[1]
      this._startAnchorX = a[2]
      this._startAnchorY = a[3]
      this._endAnchorX = a[4]
      this._endAnchorY = a[5]
      this._startEnable = a[6]
      this._endEnable = a[7]
    }
    Release() {
      this._transition = null
    }
    static Create(b, a) {
      return e.New(e.TransitionKeyframe, b, a)
    }
    GetValueX() {
      return this._valueX
    }
    GetValueY() {
      return this._valueY
    }
    GetStartAnchorX() {
      return this._startAnchorX
    }
    GetStartAnchorY() {
      return this._startAnchorY
    }
    GetEndAnchorX() {
      return this._endAnchorX
    }
    GetEndAnchorY() {
      return this._endAnchorY
    }
    GetStartEnable() {
      return this._startEnable
    }
    GetEndEnable() {
      return this._endEnable
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.TransitionManager = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._runtime = b
      this._transitions = []
    }
    Release() {
      for (const b of this._transitions) b.Release()
      e.clearArray(this._transitions)
      this._transitions = null
    }
    Create(b) {
      this._transitions.push(e.Transition.Create(b))
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SolStack = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._objectClass = b
      this._stack = []
      this._stack.push(e.New(e.Sol, this))
      this._index = 0
      this._current = this._stack[0]
    }
    Release() {
      for (const b of this._stack) b.Release()
      e.clearArray(this._stack)
      this._objectClass = this._current = null
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetCurrentSol() {
      return this._current
    }
    Clear() {
      this.GetCurrentSol().Clear()
    }
    PushClean() {
      var b = this._stack,
        a = ++this._index
      a === b.length ? ((a = e.New(e.Sol, this)), b.push(a), (this._current = a)) : ((b = b[a]), b.Reset(), (this._current = b))
    }
    PushCopy() {
      const b = this._stack,
        a = ++this._index
      a === b.length && b.push(e.New(e.Sol, this))
      const c = b[a]
      c.Copy(b[a - 1])
      this._current = c
    }
    Pop() {
      this._current = this._stack[--this._index]
    }
    RemoveInstances(b) {
      const a = this._stack
      for (let c = 0, d = a.length; c < d; ++c) a[c].RemoveInstances(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Sol = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._stack = b
      this._objectClass = this._stack.GetObjectClass()
      this._eventStack = this._objectClass.GetRuntime().GetEventStack()
      this._selectAll = !0
      this._instances = []
      this._elseInstances = []
    }
    Release() {
      this.ClearArrays()
      this._eventStack = this._objectClass = this._stack = null
    }
    ClearArrays() {
      e.clearArray(this._instances)
      e.clearArray(this._elseInstances)
    }
    GetObjectClass() {
      return this._objectClass
    }
    IsSelectAll() {
      return this._selectAll
    }
    HasAnyInstances() {
      return this._selectAll ? !!this._objectClass.GetInstanceCount() : !!this._instances.length
    }
    GetInstances() {
      return this._selectAll ? this._objectClass.GetInstances() : this._instances
    }
    HasAnyElseInstances() {
      return !!this._elseInstances.length
    }
    GetElseInstances() {
      return this._elseInstances
    }
    GetExpressionInstances() {
      const b = this.GetInstances()
      return b.length ? b : this._elseInstances
    }
    Reset() {
      this._selectAll = !0
      e.clearArray(this._elseInstances)
    }
    Clear() {
      this._selectAll = !0
    }
    Copy(b) {
      b.IsSelectAll() ? this.Reset() : ((this._selectAll = !1), e.shallowAssignArray(this._instances, b._instances), e.clearArray(this._elseInstances))
    }
    _PushInstance(b) {
      this._instances.push(b)
    }
    _PushElseInstance(b) {
      this._elseInstances.push(b)
    }
    _SetSelectAll(b) {
      this._selectAll = !!b
    }
    _GetOwnInstances() {
      return this._instances
    }
    _GetOwnElseInstances() {
      return this._elseInstances
    }
    SetSinglePicked(b) {
      this._selectAll = !1
      e.clearArray(this._instances)
      this._instances.push(b)
    }
    SetArrayPicked(b) {
      this._selectAll = !1
      e.shallowAssignArray(this._instances, b)
    }
    SetSetPicked(b) {
      this._selectAll = !1
      e.clearArray(this._instances)
      for (const a of b) this._instances.push(a)
    }
    AddElseInstances(b, a) {
      for (const c of a) b.has(c) || this._elseInstances.push(c)
    }
    TransferElseInstancesToOwn(b) {
      for (const a of b) this._instances.push(a)
      e.arrayRemoveAllInSet(this._elseInstances, b)
    }
    PickOne(b) {
      b &&
        (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock()
          ? (this.IsSelectAll() && (e.clearArray(this._instances), e.shallowAssignArray(this._elseInstances, b.GetObjectClass().GetInstances()), (this._selectAll = !1)),
            (b = this._elseInstances.indexOf(b)),
            -1 !== b && (this._instances.push(this._elseInstances[b]), this._elseInstances.splice(b, 1)))
          : this.SetSinglePicked(b))
    }
    RemoveInstances(b) {
      e.arrayRemoveAllInSet(this._instances, b)
      e.arrayRemoveAllInSet(this._elseInstances, b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.EventStack = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._eventSheetManager = b
      this._runtime = this._eventSheetManager.GetRuntime()
      this._stack = []
      this._stack.push(e.New(e.EventStackFrame, this, null))
      this._index = 0
      this._expFuncStack = []
    }
    Release() {
      for (const b of this._stack) b.Release()
      e.clearArray(this._stack)
      e.clearArray(this._expFuncStack)
      this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
      return this._eventSheetManager
    }
    GetRuntime() {
      return this._runtime
    }
    GetCurrentStackFrame() {
      return this._stack[this._index]
    }
    Push(b) {
      var a = this._stack
      const c = ++this._index
      if (c === a.length) return (b = e.New(e.EventStackFrame, this, b)), a.push(b), b
      a = a[c]
      a.Reset(b)
      return a
    }
    Pop() {
      --this._index
    }
    PushExpFunc(b) {
      this._expFuncStack.push(b)
    }
    PopExpFunc() {
      this._expFuncStack.pop()
    }
    GetCurrentExpFuncStackFrame() {
      const b = this._expFuncStack
      return 0 === b.length ? null : b[b.length - 1]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.EventStackFrame = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._stack = b
      this._runtime = this._stack.GetRuntime()
      this._currentEvent = a
      this._actIndex = this._cndIndex = 0
      this._elseBranchRan = this._lastEventTrue = !1
      this._expressionObjectClass = null
      this._functionReturnValue = this._functionReturnType = 0
    }
    Release() {
      this.Reset(null)
      this._runtime = this._stack = null
    }
    Reset(b) {
      this._currentEvent = b
      this._actIndex = this._cndIndex = 0
      this._elseBranchRan = this._lastEventTrue = !1
    }
    _Restore(b, a) {
      this._currentEvent = b
      this._cndIndex = 0
      this._actIndex = a
    }
    ResetQuick() {
      this._actIndex = this._cndIndex = 0
    }
    GetCurrentEvent() {
      return this._currentEvent
    }
    SetCurrentEvent(b) {
      this._currentEvent = b
    }
    GetConditionIndex() {
      return this._cndIndex
    }
    SetConditionIndex(b) {
      this._cndIndex = b
    }
    GetActionIndex() {
      return this._actIndex
    }
    SetActionIndex(b) {
      this._actIndex = b
    }
    SetLastEventTrue(b) {
      this._lastEventTrue = !!b
    }
    GetLastEventTrue() {
      return this._lastEventTrue
    }
    SetElseBranchRan(b) {
      this._elseBranchRan = !!b
    }
    GetElseBranchRan() {
      return this._elseBranchRan
    }
    SetExpressionObjectClass(b) {
      this._expressionObjectClass = b
    }
    GetExpressionObjectClass() {
      return this._expressionObjectClass
    }
    InitCallFunctionExpression(b, a) {
      this._functionReturnType = b
      this._functionReturnValue = a
    }
    GetFunctionReturnType() {
      return this._functionReturnType
    }
    SetFunctionReturnValue(b) {
      this._functionReturnValue = b
    }
    GetFunctionReturnValue() {
      return this._functionReturnValue
    }
    IsSolModifierAfterCnds() {
      const b = this._currentEvent
      return b.IsSolWriterAfterCnds() ? !0 : this._cndIndex < b.GetConditionCount() - 1 ? !!b.GetSolModifiers().length : !1
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.LocalVarStack = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._eventSheetManager = b
      this._runtime = this._eventSheetManager.GetRuntime()
      this._stack = []
      this._index = -1
      this._current = null
      this._initialValues = []
    }
    Release() {
      e.clearArray(this._stack)
      this._runtime = this._eventSheetManager = null
    }
    _SetInitialValues(b) {
      this._initialValues = b
      b = this._initialValues.slice(0)
      this._stack.push(b)
      this._index = 0
      this._current = b
    }
    GetEventSheetManager() {
      return this._eventSheetManager
    }
    GetRuntime() {
      return this._runtime
    }
    GetCurrent() {
      return this._current
    }
    Push() {
      const b = ++this._index,
        a = this._stack
      b === a.length ? a.push(this._initialValues.slice(0)) : e.shallowAssignArray(a[b], this._initialValues)
      this._current = a[b]
    }
    Pop() {
      this._current = this._stack[--this._index]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.LoopStack = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._eventSheetManager = b
      this._runtime = this._eventSheetManager.GetRuntime()
      this._stack = []
      this._index = -1
    }
    Release() {
      e.clearArray(this._stack)
      this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager() {
      return this._eventSheetManager
    }
    GetRuntime() {
      return this._runtime
    }
    IsInLoop() {
      return 0 <= this._index
    }
    GetCurrent() {
      return this._stack[this._index]
    }
    Push() {
      ++this._index
      if (this._index === this._stack.length) {
        var b = e.New(e.Loop, this)
        this._stack.push(b)
        return b
      }
      b = this._stack[this._index]
      b.Reset()
      return b
    }
    Pop() {
      --this._index
    }
    FindByName(b) {
      const a = this._stack
      for (let c = this._index; 0 <= c; --c) {
        const d = a[c]
        if (d.GetName() === b) return d
      }
      return null
    }
    _GetStack() {
      return this._stack.slice(0, this._index + 1)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Loop = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._loopStack = b
      this._name = ''
      this._index = 0
      this._isStopped = !1
      this._end = NaN
    }
    Reset() {
      this._name = ''
      this._index = 0
      this._isStopped = !1
      this._end = NaN
    }
    SetName(b) {
      this._name = b
    }
    GetName() {
      return this._name
    }
    SetIndex(b) {
      this._index = b
    }
    GetIndex() {
      return this._index
    }
    Stop() {
      this._isStopped = !0
    }
    IsStopped() {
      return this._isStopped
    }
    SetEnd(b) {
      this._end = b
    }
    GetEnd() {
      return this._end
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.ArrayStack = class extends e.DefendedBase {
    constructor() {
      super()
      this._stack = []
      this._index = -1
    }
    Release() {
      e.clearArray(this._stack)
    }
    GetCurrent() {
      return this._stack[this._index]
    }
    Push() {
      ++this._index
      if (this._index === this._stack.length) {
        const b = []
        this._stack.push(b)
        return b
      }
      return this._stack[this._index]
    }
    Pop() {
      --this._index
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(c, d) {
    return c.GetIndex() - d.GetIndex()
  }

  function a(c, d) {
    for (let f = 0, g = c.length; f < g; ++f) if (c[f] !== d[f]) return !1
    return !0
  }
  e.EventSheetManager = class extends e.DefendedBase {
    constructor(c) {
      super()
      this._runtime = c
      this._allSheets = []
      this._sheetsByName = new Map()
      this._allGroups = []
      this._groupsByName = new Map()
      this._blocksBySid = new Map()
      this._cndsBySid = new Map()
      this._actsBySid = new Map()
      this._allUniqueSolModifiers = new Map()
      this._eventVarsBySid = new Map()
      this._nextLocalVarIndex = 0
      this._allGlobalVars = []
      this._allLocalVars = []
      this._localVarInitialValues = []
      this._functionBlocksByName = new Map()
      this._eventStack = e.New(e.EventStack, this)
      this._localVarStack = e.New(e.LocalVarStack, this)
      this._loopStack = e.New(e.LoopStack, this)
      this._triggersToPostInit = []
      this._queuedTriggers = []
      this._queuedDebugTriggers = []
      this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0
      this._scheduledWaits = []
      this._asyncActionPromises = []
      self.c3_callFunction = (d, f) => this._InvokeFunctionFromJS(d, f)
    }
    Release() {
      this.ClearAllScheduledWaits()
      this._eventStack.Release()
      this._eventStack = null
      this._localVarStack.Release()
      this._localVarStack = null
      e.clearArray(this._queuedTriggers)
      e.clearArray(this._queuedDebugTriggers)
      this._runtime = null
      e.clearArray(this._allSheets)
      this._sheetsByName.clear()
    }
    Create(c) {
      c = e.New(e.EventSheet, this, c)
      this._allSheets.push(c)
      this._sheetsByName.set(c.GetName().toLowerCase(), c)
    }
    _AddTriggerToPostInit(c) {
      this._triggersToPostInit.push(c)
    }
    _PostInit() {
      for (const c of this._functionBlocksByName.values()) c._PostInit(!1)
      for (const c of this._allSheets) c._PostInit()
      for (const c of this._allSheets) c._UpdateDeepIncludes()
      for (const c of this._triggersToPostInit) c._PostInit(!1)
      e.clearArray(this._triggersToPostInit)
      this._localVarStack._SetInitialValues(this._localVarInitialValues)
    }
    GetRuntime() {
      return this._runtime
    }
    GetEventSheetByName(c) {
      return this._sheetsByName.get(c.toLowerCase()) || null
    }
    _RegisterGroup(c) {
      this._allGroups.push(c)
      this._groupsByName.set(c.GetGroupName(), c)
    }
    _RegisterEventBlock(c) {
      this._blocksBySid.set(c.GetSID(), c)
    }
    _RegisterCondition(c) {
      this._cndsBySid.set(c.GetSID(), c)
    }
    _RegisterAction(c) {
      this._actsBySid.set(c.GetSID(), c)
    }
    _RegisterFunctionBlock(c) {
      this._functionBlocksByName.set(c.GetFunctionName().toLowerCase(), c)
    }
    _RegisterEventVariable(c) {
      this._eventVarsBySid.set(c.GetSID(), c)
      c.IsGlobal() ? this._allGlobalVars.push(c) : this._allLocalVars.push(c)
    }
    _DeduplicateSolModifierList(c) {
      2 <= c.length && c.sort(b)
      let d = this._allUniqueSolModifiers.get(c.length)
      d || ((d = []), this._allUniqueSolModifiers.set(c.length, d))
      for (let f = 0, g = d.length; f < g; ++f) {
        const h = d[f]
        if (a(c, h)) return h
      }
      d.push(c)
      return c
    }
    _GetNextLocalVarIndex(c) {
      this._localVarInitialValues.push(c.GetInitialValue())
      return this._nextLocalVarIndex++
    }
    GetEventStack() {
      return this._eventStack
    }
    GetCurrentEventStackFrame() {
      return this.GetEventStack().GetCurrentStackFrame()
    }
    GetCurrentEvent() {
      return this.GetCurrentEventStackFrame().GetCurrentEvent()
    }
    GetCurrentCondition() {
      const c = this.GetCurrentEventStackFrame()
      return c.GetCurrentEvent().GetConditionAt(c.GetConditionIndex())
    }
    GetCurrentAction() {
      const c = this.GetCurrentEventStackFrame()
      return c.GetCurrentEvent().GetActionAt(c.GetActionIndex())
    }
    GetLocalVarStack() {
      return this._localVarStack
    }
    GetLoopStack() {
      return this._loopStack
    }
    GetAllLocalVariablesInScope(c) {
      const d = []
      for (c = c.GetScopeParent(); c; ) e.appendArray(d, c._GetAllLocalVariablesInScope()), (c = c.GetScopeParent())
      return d
    }
    _GetLocalVariablesScriptInterface(c) {
      const d = {}
      for (const f of this.GetAllLocalVariablesInScope(c)) d[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor()
      return Object.create(Object.prototype, d)
    }
    GetEventVariableBySID(c) {
      return this._eventVarsBySid.get(c) || null
    }
    GetEventBlockBySID(c) {
      return this._blocksBySid.get(c) || null
    }
    GetConditionBySID(c) {
      return this._cndsBySid.get(c) || null
    }
    GetActionBySID(c) {
      return this._actsBySid.get(c) || null
    }
    GetFunctionBlockByName(c) {
      return this._functionBlocksByName.get(c.toLowerCase()) || null
    }
    GetAllGlobalVariables() {
      return this._allGlobalVars
    }
    GetAllLocalVariables() {
      return this._allLocalVars
    }
    ResetAllGlobalsToInitialValue() {
      for (const c of this._allGlobalVars) c.ResetToInitialValue()
    }
    GetEventGroupByName(c) {
      return this._groupsByName.get(c.toLowerCase()) || null
    }
    GetEventGroupBySID(c) {
      return (c = this._blocksBySid.get(c)) && c.IsGroup() ? c : null
    }
    GetAllGroups() {
      return this._allGroups
    }
    ResetAllGroupsInitialActivation() {
      for (const c of this._allGroups) c.ResetInitialActivation()
    }
    _ResetAllHasRunFlags() {
      for (const c of this._allSheets) c._ResetHasRunFlag()
    }
    RunEvents(c) {
      this._ResetAllHasRunFlags()
      this._runningEventsDepth++
      for (const d of c.runningLayouts()) if ((c = d.GetEventSheet())) this._runtime.PushCurrentLayout(d), c.Run(), this._runtime.PopCurrentLayout()
      this._runningEventsDepth--
    }
    async DebugRunEvents(c) {
      this._ResetAllHasRunFlags()
      this._runningEventsDepth++
      for (const d of this._DebugRunEventsGen(c)) await this._runtime.DebugBreak(d)
      this._runningEventsDepth--
    }
    *_DebugRunEventsGen(c) {
      for (const d of c.runningLayouts()) if ((c = d.GetEventSheet())) this._runtime.PushCurrentLayout(d), yield* c.DebugRun(), this._runtime.PopCurrentLayout()
    }
    _Trigger(c, d, f, g) {
      let h = !1
      if (!c.GetMainRunningLayout()) return this.QueueTrigger(d, f, g)
      this._executingTriggerDepth++
      for (const k of c.runningLayouts())
        if ((c = k.GetEventSheet())) {
          this._runtime.PushCurrentLayout(k)
          for (const m of c.deepIncludes()) {
            const r = m._Trigger(d, f, g)
            h = h || r
          }
          c = c._Trigger(d, f, g)
          h = h || c
          this._runtime.PopCurrentLayout()
        }
      this._executingTriggerDepth--
      return h
    }
    *_DebugTrigger(c, d, f, g) {
      let h = !1
      if (!c.GetMainRunningLayout()) return this.QueueTrigger(d, f, g)
      this._executingTriggerDepth++
      for (const k of c.runningLayouts())
        if ((c = k.GetEventSheet())) {
          this._runtime.PushCurrentLayout(k)
          for (const m of c.deepIncludes()) {
            const r = yield* m._DebugTrigger(d, f, g)
            h = h || r
          }
          c = yield* c._DebugTrigger(d, f, g)
          h = h || c
          this._runtime.PopCurrentLayout()
        }
      this._executingTriggerDepth--
      return h
    }
    QueueTrigger(c, d, f) {
      this._queuedTriggers.push([c, d, f])
      return !1
    }
    QueueDebugTrigger(c, d, f) {
      let g = null
      const h = new Promise(k => (g = k))
      this._queuedDebugTriggers.push([c, d, f, g])
      return h
    }
    *_RunQueuedDebugTriggersGen() {
      if (this._runtime.HitBreakpoint()) throw Error('should not be in breakpoint')
      const c = this._runtime.GetLayoutManager()
      for (; this._queuedDebugTriggers.length; ) {
        const [d, f, g, h] = this._queuedDebugTriggers.shift(),
          k = yield* this._DebugTrigger(c, d, f, g)
        h(k)
      }
    }
    async RunQueuedDebugTriggersAsync() {
      for (const c of this._RunQueuedDebugTriggersGen()) await this._runtime.DebugBreak(c)
    }
    _FastTrigger(c, d, f, g) {
      let h = !1
      var k = c.GetMainRunningLayout()
      if ((c = k.GetEventSheet())) {
        this._executingTriggerDepth++
        this._runtime.PushCurrentLayout(k)
        k = c.deepIncludes()
        for (let m = 0, r = k.length; m < r; ++m) {
          const w = k[m]._FastTrigger(d, f, g)
          h = h || w
        }
        d = c._FastTrigger(d, f, g)
        h = h || d
        this._runtime.PopCurrentLayout()
        this._executingTriggerDepth--
        return h
      }
    }
    *_DebugFastTrigger(c, d, f, g) {
      let h = !1
      var k = c.GetMainRunningLayout()
      if ((c = k.GetEventSheet())) {
        this._executingTriggerDepth++
        this._runtime.PushCurrentLayout(k)
        k = c.deepIncludes()
        for (let m = 0, r = k.length; m < r; ++m) {
          const w = yield* k[m]._DebugFastTrigger(d, f, g)
          h = h || w
        }
        d = yield* c._DebugFastTrigger(d, f, g)
        h = h || d
        this._runtime.PopCurrentLayout()
        this._executingTriggerDepth--
        return h
      }
    }
    GetTriggerDepth() {
      return this._executingTriggerDepth
    }
    IsInTrigger() {
      return 0 < this.GetTriggerDepth()
    }
    _IncTriggerDepth() {
      return ++this._executingTriggerDepth
    }
    _DecTriggerDepth() {
      --this._executingTriggerDepth
    }
    IsRunningEvents() {
      return 0 < this._runningEventsDepth
    }
    IsInEventEngine() {
      return this.IsRunningEvents() || this.IsInTrigger()
    }
    _RunQueuedTriggers(c) {
      for (const [d, f, g] of this._queuedTriggers) this._Trigger(c, d, f, g)
      e.clearArray(this._queuedTriggers)
    }
    BlockFlushingInstances(c) {
      c ? this._blockFlushingDepth++ : this._blockFlushingDepth--
    }
    IsFlushingBlocked() {
      return 0 < this._blockFlushingDepth
    }
    ClearSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().Clear()
    }
    PushCleanSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().PushClean()
    }
    PushCopySol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().PushCopy()
    }
    PopSol(c) {
      for (let d = 0, f = c.length; d < f; ++d) c[d].GetSolStack().Pop()
    }
    AddScheduledWait() {
      const c = e.New(e.ScheduledWait, this)
      this._scheduledWaits.push(c)
      return c
    }
    scheduledWaits() {
      return this._scheduledWaits
    }
    RunScheduledWaits() {
      if (this._scheduledWaits.length) {
        var c = this.GetCurrentEventStackFrame(),
          d = !1
        this._runningEventsDepth++
        for (let f = 0, g = this._scheduledWaits.length; f < g; ++f) {
          const h = this._scheduledWaits[f]
          h._ShouldRun() && h._Run(c)
          h.ShouldRelease() && (d = !0)
        }
        d && this._FilterScheduledWaitsToRelease()
        this._runningEventsDepth--
      }
    }
    async DebugRunScheduledWaits() {
      if (this._scheduledWaits.length) {
        var c = this.GetCurrentEventStackFrame(),
          d = !1
        this._runningEventsDepth++
        for (let f = 0, g = this._scheduledWaits.length; f < g; ++f) {
          const h = this._scheduledWaits[f]
          h._ShouldRun() && (await h._DebugRun(c))
          h.ShouldRelease() && (d = !0)
        }
        d && this._FilterScheduledWaitsToRelease()
        this._runningEventsDepth--
      }
    }
    _FilterScheduledWaitsToRelease() {
      const c = e.arrayFilterOut(this._scheduledWaits, d => d.ShouldRelease())
      for (const d of c) d.Release()
    }
    ClearAllScheduledWaits() {
      for (const c of this._scheduledWaits) c.Release()
      e.clearArray(this._scheduledWaits)
    }
    RemoveInstancesFromScheduledWaits(c) {
      for (const d of this._scheduledWaits) d.RemoveInstances(c)
    }
    AddAsyncActionPromise(c) {
      this._asyncActionPromises.push(c)
    }
    ClearAsyncActionPromises() {
      e.clearArray(this._asyncActionPromises)
    }
    GetPromiseForAllAsyncActions() {
      const c = Promise.all(this._asyncActionPromises)
      this._asyncActionPromises = []
      return c
    }
    _SaveToJson() {
      return {
        groups: this._SaveGroupsToJson(),
        cnds: this._SaveCndsToJson(),
        acts: this._SaveActsToJson(),
        vars: this._SaveVarsToJson(),
        waits: this._SaveScheduledWaitsToJson()
      }
    }
    _LoadFromJson(c) {
      this._LoadGroupsFromJson(c.groups)
      this._LoadCndsFromJson(c.cnds)
      this._LoadActsFromJson(c.acts)
      this._LoadVarsFromJson(c.vars)
      this._LoadScheduledWaitsFromJson(c.waits)
    }
    _SaveGroupsToJson() {
      const c = {}
      for (const d of this.GetAllGroups()) c[d.GetSID().toString()] = d.IsGroupActive()
      return c
    }
    _LoadGroupsFromJson(c) {
      for (const [d, f] of Object.entries(c)) (c = parseInt(d, 10)), (c = this.GetEventGroupBySID(c)) && c.SetGroupActive(f)
    }
    _SaveCndsToJson() {
      const c = {}
      for (const [d, f] of this._cndsBySid) {
        const g = f._SaveToJson()
        g && (c[d.toString()] = g)
      }
      return c
    }
    _LoadCndsFromJson(c) {
      const d = new Map()
      for (const [f, g] of Object.entries(c)) d.set(parseInt(f, 10), g)
      for (const [f, g] of this._cndsBySid) g._LoadFromJson(d.get(f) || null)
    }
    _SaveActsToJson() {
      const c = {}
      for (const [d, f] of this._actsBySid) {
        const g = f._SaveToJson()
        g && (c[d.toString()] = g)
      }
      return c
    }
    _LoadActsFromJson(c) {
      const d = new Map()
      for (const [f, g] of Object.entries(c)) d.set(parseInt(f, 10), g)
      for (const [f, g] of this._actsBySid) g._LoadFromJson(d.get(f) || null)
    }
    _SaveVarsToJson() {
      const c = {}
      for (const [d, f] of this._eventVarsBySid) f.IsConstant() || (!f.IsGlobal() && !f.IsStatic()) || (c[d.toString()] = f.GetValue())
      return c
    }
    _LoadVarsFromJson(c) {
      for (const [d, f] of Object.entries(c)) (c = parseInt(d, 10)), (c = this.GetEventVariableBySID(c)) && c.SetValue(f)
    }
    _SaveScheduledWaitsToJson() {
      return this._scheduledWaits.filter(c => !c.IsPromise()).map(c => c._SaveToJson())
    }
    _LoadScheduledWaitsFromJson(c) {
      this.ClearAllScheduledWaits()
      for (const d of c) (c = e.ScheduledWait._CreateFromJson(this, d)) && this._scheduledWaits.push(c)
    }
    _GetPerfRecords() {
      return [...this._runtime.GetLayoutManager().runningLayouts()]
        .map(c => c.GetEventSheet())
        .filter(c => c)
        .map(c => c._GetPerfRecord())
    }
    FindFirstFunctionBlockParent(c) {
      for (; c; ) if (((c = c.GetScopeParent()), c instanceof e.FunctionBlock)) return c
      return null
    }
    _InvokeFunctionFromJS(c, d) {
      Array.isArray(d) || (d = [])
      c = this.GetFunctionBlockByName(c.toLowerCase())
      if (!c) return null
      if (!c.IsEnabled()) return c.GetDefaultReturnValue()
      var f = c.GetFunctionParameters()
      if (d.length < f.length) {
        d = d.slice(0)
        do d.push(f[d.length].GetInitialValue())
        while (d.length < f.length)
      }
      f = c.GetEventBlock()
      return f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(), c.GetReturnType(), c.GetDefaultReturnValue(), ...d)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.EventSheet = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._eventSheetManager = b
      this._runtime = b.GetRuntime()
      this._name = a[0]
      this._events = []
      this._triggers = new Map()
      this._fastTriggers = new Map()
      this._eventsByDisplayNumber = new Map()
      this._hasRun = !1
      this._shallowIncludes = []
      this._deepIncludes = []
      this._alreadyIncludedSheets = new Set()
      for (const c of a[1]) this._CreateEvent(c, null, this._events)
      this._perfRecord = this._runtime.IsDebug()
        ? {
            type: 'sheet',
            name: this._name,
            totalTimeCounter: 0,
            children: []
          }
        : null
    }
    Release() {
      this._runtime = this._eventSheetManager = null
    }
    _CreateEvent(b, a, c) {
      switch (b[0]) {
        case 0:
        case 3:
          this._CreateEventBlock(b, a, c)
          break
        case 1:
          this._CreateEventVariable(b, a, c)
          break
        case 2:
          this._CreateInclude(b, a, c)
          break
        case 4:
          this._CreateFunctionBlock(b, a)
          break
        case 5:
          this._CreateScriptBlock(b, a, c)
          break
        default:
          throw Error('invalid event type')
      }
    }
    _CreateEventBlock(b, a, c) {
      b = e.EventBlock.Create(this, a, b)
      if (b.IsOrBlock()) {
        c.push(b)
        c = b.GetConditions()
        for (let d = 0, f = c.length; d < f; ++d) c[d].IsTrigger() && this._InitTrigger(b, d)
      } else b.IsTrigger() ? this._InitTrigger(b, 0) : c.push(b)
    }
    _CreateFunctionBlock(b, a) {
      b = e.FunctionBlock.Create(this, a, b)
      this._eventSheetManager._RegisterFunctionBlock(b)
    }
    _CreateEventVariable(b, a, c) {
      b = e.EventVariable.Create(this, a, b)
      c.push(b)
    }
    _CreateInclude(b, a, c) {
      b = e.EventInclude.Create(this, a, b)
      c.push(b)
    }
    _CreateScriptBlock(b, a, c) {
      b = e.EventScript.Create(this, a, b)
      c.push(b)
    }
    _InitTrigger(b, a) {
      b.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(b)
      var c = b.GetConditionAt(a),
        d = c._GetFunc(),
        f = c.GetObjectClass()
      if (c.IsFastTrigger()) {
        var g = this._fastTriggers.get(f)
        g || ((g = new Map()), this._fastTriggers.set(f, g))
        c = c.GetFastTriggerValue().toLowerCase()
        f = g.get(d)
        f || ((f = new Map()), g.set(d, f))
        d = f.get(c)
        d || ((d = []), f.set(c, d))
        d.push([b, a])
      } else
        (g = this._triggers.get(f)),
          g ||
            ((g = {
              methodMap: new Map(),
              behaviors: new Map()
            }),
            this._triggers.set(f, g)),
          (f = c.GetBehaviorType()) ? ((c = g.behaviors.get(f)), c || ((c = new Map()), g.behaviors.set(f, c))) : (c = g.methodMap),
          (g = c.get(d)),
          g || ((g = []), c.set(d, g)),
          g.push([b, a])
    }
    _PostInit() {
      const b = this._events
      for (let a = 0, c = b.length; a < c; ++a) {
        const d = a < c - 1 && b[a + 1] instanceof e.EventBlock && b[a + 1].IsElseBlock()
        b[a]._PostInit(d)
      }
    }
    _AddShallowInclude(b) {
      this._shallowIncludes.push(b)
    }
    _UpdateDeepIncludes() {
      e.clearArray(this._deepIncludes)
      this._AddDeepIncludes(this)
      this._alreadyIncludedSheets.clear()
    }
    _AddDeepIncludes(b) {
      const a = b._deepIncludes,
        c = b._alreadyIncludedSheets
      for (const d of this._shallowIncludes) {
        const f = d.GetIncludeSheet()
        d.IsActive() && b !== f && !c.has(f) && (c.add(f), f._AddDeepIncludes(b), a.push(f))
      }
    }
    deepIncludes() {
      return this._deepIncludes
    }
    GetEventSheetManager() {
      return this._eventSheetManager
    }
    GetRuntime() {
      return this._runtime
    }
    GetName() {
      return this._name
    }
    _RegisterEventByDisplayNumber(b, a) {
      this._eventsByDisplayNumber.set(a, b)
    }
    _GetEventByDisplayNumber(b) {
      return this._eventsByDisplayNumber.get(b) || null
    }
    _ResetHasRunFlag() {
      this._hasRun = !1
    }
    Run() {
      if (!this._hasRun) {
        var b = this._runtime,
          a = b.IsCPUProfiling(),
          c = a ? performance.now() : 0
        this._hasRun = !0
        var d = this.GetEventSheetManager(),
          f = d.GetCurrentEventStackFrame()
        for (const g of this._events) g.Run(f), d.ClearSol(g.GetSolModifiers()), d.ClearAsyncActionPromises(), b.FlushPendingInstances()
        f.Reset(null)
        a && (this._perfRecord.totalTimeCounter += performance.now() - c)
      }
    }
    *DebugRun() {
      if (!this._hasRun) {
        this._hasRun = !0
        var b = this._runtime,
          a = this.GetEventSheetManager(),
          c = a.GetCurrentEventStackFrame()
        for (const d of this._events) yield* d.DebugRun(c), a.ClearSol(d.GetSolModifiers()), a.ClearAsyncActionPromises(), b.FlushPendingInstances()
        c.Reset(null)
      }
    }
    _Trigger(b, a, c) {
      if (a) {
        const d = a.GetObjectClass()
        this._TriggerForClass(b, a, d, c)
        for (const f of d.GetFamilies()) this._TriggerForClass(b, a, f, c)
      } else return this._TriggerForClass(b, a, null, null)
    }
    _TriggerForClass(b, a, c, d) {
      c = this._triggers.get(c)
      if (!c) return !1
      d = d ? c.behaviors.get(d) : c.methodMap
      if (!d) return !1
      d = d.get(b)
      if (!d) return !1
      b = !1
      for (const [f, g] of d) (d = this._ExecuteTrigger(a, f, g)), (b = b || d)
      return b
    }
    *_DebugTrigger(b, a, c) {
      if (a) {
        const d = a.GetObjectClass()
        yield* this._DebugTriggerForClass(b, a, d, c)
        for (const f of d.GetFamilies()) yield* this._DebugTriggerForClass(b, a, f, c)
      } else return yield* this._DebugTriggerForClass(b, a, null, null)
    }
    *_DebugTriggerForClass(b, a, c, d) {
      c = this._triggers.get(c)
      if (!c) return !1
      d = d ? c.behaviors.get(d) : c.methodMap
      if (!d) return !1
      d = d.get(b)
      if (!d) return !1
      b = !1
      for (const [f, g] of d) (d = f.DebugCanRunFast() ? this._ExecuteTrigger(a, f, g) : yield* this._DebugExecuteTrigger(a, f, g)), (b = b || d)
      return b
    }
    _FastTrigger(b, a, c) {
      a = a.GetObjectClass()
      a = this._fastTriggers.get(a)
      if (!a) return !1
      b = a.get(b)
      if (!b) return !1
      c = b.get(c)
      if (!c) return !1
      b = !1
      for (let d = 0, f = c.length; d < f; ++d) (a = c[d]), (a = this._ExecuteTrigger(null, a[0], a[1])), (b = b || a)
      return b
    }
    *_DebugFastTrigger(b, a, c) {
      a = a.GetObjectClass()
      a = this._fastTriggers.get(a)
      if (!a) return !1
      b = a.get(b)
      if (!b) return !1
      c = b.get(c)
      if (!c) return !1
      b = !1
      for (let f = 0, g = c.length; f < g; ++f) {
        var d = c[f]
        a = d[0]
        d = d[1]
        a = a.DebugCanRunFast() ? this._ExecuteTrigger(null, a, d) : yield* this._DebugExecuteTrigger(null, a, d)
        b = b || a
      }
      return b
    }
    _ExecuteTrigger(b, a, c) {
      const d = this._runtime,
        f = this._eventSheetManager,
        g = f.GetCurrentEvent(),
        h = f.GetEventStack(),
        k = f.GetTriggerDepth()
      let m = !1
      g && f.PushCleanSol(g.GetSolModifiersIncludingParents())
      f.PushCleanSol(a.GetSolModifiersIncludingParents())
      const r = 1 < k
      r && f.GetLocalVarStack().Push()
      const w = h.Push(a)
      b && (a.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(b), b.IsInContainer() && b.SetSiblingsSinglePicked())
      b = !0
      if (a.GetParent()) {
        const p = a.GetTriggerParents()
        for (let q = 0, t = p.length; q < t; ++q)
          if (!p[q].RunPreTrigger(w)) {
            b = !1
            break
          }
      }
      b && (d.IncrementExecCount(), a.IsOrBlock() ? a.RunOrBlockTrigger(w, c) : a.Run(w), (m = w.GetLastEventTrue()))
      h.Pop()
      r && f.GetLocalVarStack().Pop()
      f.PopSol(a.GetSolModifiersIncludingParents())
      g && f.PopSol(g.GetSolModifiersIncludingParents())
      g || 1 !== k || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || d.FlushPendingInstances())
      return m
    }
    *_DebugExecuteTrigger(b, a, c) {
      const d = this._runtime,
        f = this._eventSheetManager,
        g = f.GetCurrentEvent(),
        h = f.GetEventStack(),
        k = f.GetTriggerDepth()
      let m = !1
      g && f.PushCleanSol(g.GetSolModifiersIncludingParents())
      f.PushCleanSol(a.GetSolModifiersIncludingParents())
      const r = 1 < k
      r && f.GetLocalVarStack().Push()
      const w = h.Push(a)
      b && (a.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(b), b.IsInContainer() && b.SetSiblingsSinglePicked())
      b = !0
      if (a.GetParent()) {
        const p = a.GetTriggerParents()
        for (let q = 0, t = p.length; q < t; ++q)
          if (!(yield* p[q].DebugRunPreTrigger(w))) {
            b = !1
            break
          }
      }
      b && (d.IncrementExecCount(), a.IsOrBlock() ? yield* a.DebugRunOrBlockTrigger(w, c) : yield* a.DebugRun(w), (m = w.GetLastEventTrue()))
      h.Pop()
      r && f.GetLocalVarStack().Pop()
      f.PopSol(a.GetSolModifiersIncludingParents())
      g && f.PopSol(g.GetSolModifiersIncludingParents())
      g || 1 !== k || (f.ClearAsyncActionPromises(), f.IsFlushingBlocked() || d.FlushPendingInstances())
      return m
    }
    _GetPerfRecord() {
      return this._perfRecord
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []

  function a(d, f) {
    return !0
  }

  function* c(d, f) {
    return !0
  }
  e.EventBlock = class extends e.DefendedBase {
    constructor(d, f, g) {
      super()
      this._eventSheet = d
      this._runtime = d.GetRuntime()
      this._parent = f
      this._scopeParent = null
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack()
      this._solModifiers = []
      this._solModifiersIncludingParents = []
      this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1
      this._isOrBlock = !!g[2]
      this._isElseBlock = !1
      this._triggerParents = null
      this._conditions = []
      this._actions = []
      this._subEvents = []
      this._RunActions = a
      this._DebugRunActions = c
      this._isInitiallyActive = this._isGroup = !1
      this._groupName = ''
      this._isGroupActive = !1
      this._perfRecord = this._containedIncludes = null
      this._sid = g[4]
      this._displayNumber = g[5]
      this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber)
      this._debugData = this._runtime.IsDebug()
        ? {
            isBreakpoint: g[3][0],
            isBreakable: g[3][1],
            canRunAllConditionsFast: !1,
            canRunAllActionsFast: !1,
            canRunAllSubEventsFast: !1,
            canRunSelfFast: !1
          }
        : null
      this.GetEventSheetManager()._RegisterEventBlock(this)
      3 === g[0] && this._InitGroup(g[1])
      d = 0
      for (var h of g[6]) (f = e.Condition.Create(this, h, d++)), this._conditions.push(f), this._AddSolModifier(f.GetObjectClass())
      d = 0
      for (const k of g[7]) (h = e.Action.Create(this, k, d++)), this._actions.push(h)
      if (9 === g.length) {
        g = g[8]
        for (const k of g) this._eventSheet._CreateEvent(k, this, this._subEvents)
      }
      this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() && this._conditions[0]._GetFunc() === e.Plugins.System.Cnds.Else)
      0 === this._conditions.length && (this._conditions = b)
      0 === this._actions.length && (this._actions = b)
      0 === this._subEvents.length && (this._subEvents = b)
    }
    static Create(d, f, g) {
      return e.New(e.EventBlock, d, f, g)
    }
    _InitGroup(d) {
      this._isGroup = !0
      this._isGroupActive = this._isInitiallyActive = !!d[0]
      this._groupName = d[1].toLowerCase()
      this._containedIncludes = []
      this.GetEventSheetManager()._RegisterGroup(this)
      this._runtime.IsDebug() &&
        (this._perfRecord = {
          type: 'group',
          name: d[1],
          totalTimeCounter: 0,
          children: []
        })
    }
    _AddContainedInclude(d) {
      this._containedIncludes.push(d)
    }
    _AddContainerSolModifierToList(d, f) {
      for (const g of d.GetContainer().objectTypes()) f.includes(g) || f.push(g)
    }
    _AddSolModifierToList(d, f) {
      if (d)
        if ((f.includes(d) || f.push(d), d.IsFamily())) for (const g of d.GetFamilyMembers()) g.IsInContainer() && this._AddContainerSolModifierToList(g, f)
        else d.IsInContainer() && this._AddContainerSolModifierToList(d, f)
    }
    _AddSolModifier(d) {
      this._AddSolModifierToList(d, this._solModifiers)
    }
    _AddParentSolModifier(d) {
      this._AddSolModifierToList(d, this._solModifiersIncludingParents)
    }
    SetAllSolModifiers() {
      this._solModifiers = this._runtime.GetAllObjectClasses()
    }
    _PostInit(d) {
      this._hasElseBlock = !!d
      this._IdentifyTopLevelGroup()
      this._IdentifyTriggerParents()
      for (const g of this._conditions) g._PostInit()
      if (0 < this._actions.length) {
        d = !1
        for (var f of this._actions) f._PostInit(), f.HasReturnType() && (d = !0)
        d ? ((this._RunActions = this._RunActions_ReturnValue), (this._DebugRunActions = this._DebugRunActions_ReturnValue)) : ((this._RunActions = this._RunActions_Fast), (this._DebugRunActions = this._DebugRunActions_Fast))
      }
      f = this._subEvents
      for (let g = 0, h = f.length; g < h; ++g) (d = g < h - 1 && f[g + 1] instanceof e.EventBlock && f[g + 1].IsElseBlock()), f[g]._PostInit(d)
      this._debugData && this._UpdateCanRunFast()
      this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
    }
    _GetPerfRecord() {
      return this._perfRecord
    }
    _GetPerfRecordParent() {
      let d = this.GetParent()
      for (; d; ) {
        if (d.IsGroup()) return d
        d = d.GetParent()
      }
      return this._eventSheet
    }
    _UpdateCanRunFast() {
      const d = this._debugData
      d.canRunAllConditionsFast = this._conditions.every(f => f.DebugCanRunFast())
      d.canRunAllActionsFast = this._actions.every(f => f.DebugCanRunFast())
      d.canRunAllSubEventsFast = this._subEvents.every(f => f.DebugCanRunFast())
      d.canRunSelfFast = d.canRunAllConditionsFast && d.canRunAllActionsFast && d.canRunAllSubEventsFast
    }
    _UpdateCanRunFastRecursive() {
      let d = this
      do d._UpdateCanRunFast(), (d = d.GetParent())
      while (d)
    }
    _IdentifyTopLevelGroup() {
      if (this.IsGroup()) {
        var d = this.GetParent()
        for (this._isTopLevelGroup = !0; d; ) {
          if (!d.IsGroup()) {
            this._isTopLevelGroup = !1
            break
          }
          d = d.GetParent()
        }
      }
    }
    _IdentifySolModifiersIncludingParents() {
      var d = this._runtime.GetAllObjectClasses()
      if (this._solModifiers === d) this._solModifiersIncludingParents = d
      else {
        this._solModifiersIncludingParents = e.cloneArray(this._solModifiers)
        for (d = this.GetParent(); d; ) {
          for (var f of d._solModifiers) this._AddParentSolModifier(f)
          d = d.GetParent()
        }
        f = this.GetEventSheetManager()
        this._solModifiers = f._DeduplicateSolModifierList(this._solModifiers)
        this._solModifiersIncludingParents = f._DeduplicateSolModifierList(this._solModifiersIncludingParents)
      }
    }
    _IdentifyTriggerParents() {
      if (this.HasAnyTriggeredCondition()) {
        this._triggerParents = []
        for (var d = this.GetParent(); d; ) this._triggerParents.push(d), (d = d.GetParent())
        this._triggerParents.reverse()
      }
    }
    SetSolWriterAfterCnds() {
      this._isSolWriterAfterCnds = !0
      this._parent && this._parent.SetSolWriterAfterCnds()
    }
    IsSolWriterAfterCnds() {
      return this._isSolWriterAfterCnds
    }
    GetSolModifiers() {
      return this._solModifiers
    }
    GetSolModifiersIncludingParents() {
      this._hasGotSolModifiersIncludingParents || ((this._hasGotSolModifiersIncludingParents = !0), this._IdentifySolModifiersIncludingParents())
      return this._solModifiersIncludingParents
    }
    HasSolModifier(d) {
      return this._solModifiers.includes(d)
    }
    GetTriggerParents() {
      return this._triggerParents
    }
    GetEventSheet() {
      return this._eventSheet
    }
    GetEventSheetManager() {
      return this._eventSheet.GetEventSheetManager()
    }
    GetRuntime() {
      return this._runtime
    }
    GetParent() {
      return this._parent
    }
    _SetScopeParent(d) {
      this._scopeParent = d
    }
    GetScopeParent() {
      return this._scopeParent || this._parent
    }
    GetDisplayNumber() {
      return this._displayNumber
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(d) {
      this._debugData.isBreakpoint = !!d
      this._UpdateCanRunFastRecursive()
    }
    IsGroup() {
      return this._isGroup
    }
    IsTopLevelGroup() {
      return this._isTopLevelGroup
    }
    IsElseBlock() {
      return this._isElseBlock
    }
    HasElseBlock() {
      return this._hasElseBlock
    }
    GetGroupName() {
      return this._groupName
    }
    IsGroupActive() {
      return this._isGroupActive
    }
    ResetInitialActivation() {
      this.SetGroupActive(this._isInitiallyActive)
    }
    SetGroupActive(d) {
      d = !!d
      if (!this._isGroup) throw Error('not a group')
      if (this._isGroupActive !== d) {
        this._isGroupActive = d
        for (const f of this._containedIncludes) f.UpdateActive()
        this._containedIncludes.length && (d = this._runtime.GetCurrentLayout().GetEventSheet()) && d._UpdateDeepIncludes()
      }
    }
    GetSID() {
      return this._sid
    }
    IsOrBlock() {
      return this._isOrBlock
    }
    IsTrigger() {
      return this._conditions.length && this._conditions[0].IsTrigger()
    }
    IsForFunctionBlock() {
      return this._scopeParent && this._scopeParent instanceof e.FunctionBlock
    }
    HasAnyTriggeredCondition() {
      return this.IsForFunctionBlock() || this._conditions.some(d => d.IsTrigger())
    }
    GetConditions() {
      return this._conditions
    }
    GetConditionCount() {
      return this._conditions.length
    }
    GetConditionAt(d) {
      d = Math.floor(d)
      if (0 > d || d >= this._conditions.length) throw new RangeError('invalid condition index')
      return this._conditions[d]
    }
    GetConditionByDebugIndex(d) {
      return this.GetConditionAt(d)
    }
    IsFirstConditionOfType(d) {
      let f = d.GetIndex()
      if (0 === f) return !0
      for (--f; 0 <= f; --f) if (this._conditions[f].GetObjectClass() === d.GetObjectClass()) return !1
      return !0
    }
    GetActions() {
      return this._actions
    }
    GetActionCount() {
      return this._actions.length
    }
    GetActionAt(d) {
      d = Math.floor(d)
      if (0 > d || d >= this._actions.length) throw new RangeError('invalid action index')
      return this._actions[d]
    }
    GetActionByDebugIndex(d) {
      d = Math.floor(d)
      const f = this._actions.find(g => g.GetDebugIndex() === d)
      if (!f) throw new RangeError('invalid action debug index')
      return f
    }
    _HasActionIndex(d) {
      d = Math.floor(d)
      return 0 <= d && d < this._actions.length
    }
    GetSubEvents() {
      return this._subEvents
    }
    _GetAllLocalVariablesInScope() {
      return this._subEvents.filter(d => d instanceof e.EventVariable)
    }
    RunPreTrigger(d) {
      d.SetCurrentEvent(this)
      let f = !1
      const g = this._conditions
      for (let h = 0, k = g.length; h < k; ++h) {
        const m = g[h]
        d.SetConditionIndex(h)
        if (m.IsLooping()) throw Error('trigger cannot be used as sub-event to a loop')
        if (m.Run()) f = !0
        else if (!this._isOrBlock) return !1
      }
      return this._isOrBlock ? f : !0
    }
    RunOrBlockTrigger(d, f) {
      d.SetCurrentEvent(this)
      this._conditions[f].Run() && (this._RunActions(d, 0) && this._RunSubEvents(d), d.SetLastEventTrue(!0))
    }
    *DebugRunPreTrigger(d) {
      d.SetCurrentEvent(this)
      let f = !1
      const g = this._conditions
      for (let h = 0, k = g.length; h < k; ++h) {
        const m = g[h]
        d.SetConditionIndex(h)
        if (m.IsLooping()) throw Error('trigger cannot be used as sub-event to a loop')
        if (m.DebugCanRunFast() ? m.Run() : yield* m.DebugRun()) f = !0
        else if (!this._isOrBlock) return !1
      }
      return this._isOrBlock ? f : !0
    }
    *DebugRunOrBlockTrigger(d, f) {
      d.SetCurrentEvent(this)
      f = this._conditions[f]
      if (f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun()) (this.DebugCanRunActionsFast() ? this._RunActions(d, 0) : yield* this._DebugRunActions(d, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), d.SetLastEventTrue(!0)
    }
    Run(d) {
      d.SetCurrentEvent(this)
      this._isElseBlock || d.SetElseBranchRan(!1)
      this._isOrBlock ? this._RunOrBlock(d) : this._RunAndBlock(d)
    }
    *DebugRun(d) {
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this
      d.SetCurrentEvent(this)
      this._isElseBlock || d.SetElseBranchRan(!1)
      this._isOrBlock ? yield* this._DebugRunOrBlock(d) : yield* this._DebugRunAndBlock(d)
    }
    _RunOrBlock(d) {
      const f = this._conditions
      let g = 0 === f.length
      for (let k = 0, m = f.length; k < m; ++k) {
        var h = f[k]
        h.IsTrigger() || (d.SetConditionIndex(k), (h = h.Run()), (g = g || h))
      }
      d.SetLastEventTrue(g)
      g && (this._RunActions(d, 0) && this._RunSubEvents(d), this._hasElseBlock && d.SetElseBranchRan(!0))
    }
    *_DebugRunOrBlock(d) {
      const f = this._conditions
      let g = 0 === f.length
      for (let k = 0, m = f.length; k < m; ++k) {
        var h = f[k]
        h.IsTrigger() || (d.SetConditionIndex(k), (h = h.DebugCanRunFast() ? h.Run() : yield* h.DebugRun()), (g = g || h))
      }
      d.SetLastEventTrue(g)
      g && ((this.DebugCanRunActionsFast() ? this._RunActions(d, 0) : yield* this._DebugRunActions(d, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents()), this._hasElseBlock && d.SetElseBranchRan(!0))
    }
    _RunAndBlock(d) {
      const f = this._conditions
      for (let g = 0, h = f.length; g < h; ++g) {
        const k = f[g]
        d.SetConditionIndex(g)
        if (!k.Run()) {
          d.SetLastEventTrue(!1)
          return
        }
      }
      d.SetLastEventTrue(!0)
      this._RunActions(d, 0) && this._RunSubEvents(d)
      d.GetLastEventTrue() && this._hasElseBlock && d.SetElseBranchRan(!0)
    }
    *_DebugRunAndBlock(d) {
      const f = this._conditions
      for (let g = 0, h = f.length; g < h; ++g) {
        const k = f[g]
        d.SetConditionIndex(g)
        if (k.DebugCanRunFast() ? !k.Run() : !(yield* k.DebugRun())) {
          d.SetLastEventTrue(!1)
          return
        }
      }
      d.SetLastEventTrue(!0)
      ;(this.DebugCanRunActionsFast() ? this._RunActions(d, 0) : yield* this._DebugRunActions(d, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents())
      d.GetLastEventTrue() && this._hasElseBlock && d.SetElseBranchRan(!0)
    }
    _RunActions_Fast(d, f) {
      const g = this._actions
      for (let h = f, k = g.length; h < k; ++h) (f = g[h]), d.SetActionIndex(h), f.Run()
      return !0
    }
    *_DebugRunActions_Fast(d, f) {
      const g = this._actions
      for (let h = f, k = g.length; h < k; ++h) (f = g[h]), d.SetActionIndex(h), f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun()
      return !0
    }
    _RunActions_ReturnValue(d, f) {
      const g = this.GetEventSheetManager(),
        h = this._actions
      for (let k = f, m = h.length; k < m; ++k) {
        f = h[k]
        d.SetActionIndex(k)
        const r = f.Run()
        if (f.CanBailOut() && !0 === r) return !1
        f.IsAsync() && r instanceof Promise && g.AddAsyncActionPromise(r)
      }
      return !0
    }
    *_DebugRunActions_ReturnValue(d, f) {
      const g = this.GetEventSheetManager(),
        h = this._actions
      for (let k = f, m = h.length; k < m; ++k) {
        f = h[k]
        d.SetActionIndex(k)
        let r
        r = f.DebugCanRunFast() ? f.Run() : yield* f.DebugRun()
        if (f.CanBailOut() && !0 === r) return !1
        f.IsAsync() && r instanceof Promise && g.AddAsyncActionPromise(r)
      }
      return !0
    }
    _ResumeActionsAndSubEvents(d) {
      this._RunActions(d, d.GetActionIndex()) && this._RunSubEvents()
    }
    *_DebugResumeActionsAndSubEvents(d) {
      if (yield* this._DebugRunActions(d, d.GetActionIndex())) yield* this._DebugRunSubEvents()
    }
    _RunSubEvents() {
      if (this._subEvents.length) {
        var d = this.IsGroup() && this._runtime.IsCPUProfiling(),
          f = d ? performance.now() : 0,
          g = this._eventStack,
          h = g.Push(this)
        this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(h) : this._RunSubEvents_Fast(h)
        g.Pop()
        d && (this._perfRecord.totalTimeCounter += performance.now() - f)
      }
    }
    _RunSubEvents_SolWriterAfterCnds(d) {
      const f = this._isGroup,
        g = this._isTopLevelGroup,
        h = this.GetEventSheetManager(),
        k = this._subEvents
      for (let m = 0, r = k.length, w = r - 1; m < r; ++m) {
        const p = k[m],
          q = p.GetSolModifiers(),
          t = !g || (!f && m < w)
        t && h.PushCopySol(q)
        p.Run(d)
        t ? h.PopSol(q) : h.ClearSol(q)
      }
    }
    _RunSubEvents_Fast(d) {
      const f = this._subEvents
      for (let g = 0, h = f.length; g < h; ++g) f[g].Run(d)
    }
    *_DebugRunSubEvents() {
      if (this._subEvents.length) {
        var d = this._eventStack,
          f = d.Push(this)
        this._isSolWriterAfterCnds ? yield* this._DebugRunSubEvents_SolWriterAfterCnds(f) : yield* this._DebugRunSubEvents_Fast(f)
        d.Pop()
      }
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(d) {
      const f = this._isGroup,
        g = this._isTopLevelGroup,
        h = this.GetEventSheetManager(),
        k = this._subEvents
      for (let m = 0, r = k.length, w = r - 1; m < r; ++m) {
        const p = k[m],
          q = p.GetSolModifiers(),
          t = !g || (!f && m < w)
        t && h.PushCopySol(q)
        yield* p.DebugRun(d)
        t ? h.PopSol(q) : h.ClearSol(q)
      }
    }
    *_DebugRunSubEvents_Fast(d) {
      const f = this._subEvents
      for (let g = 0, h = f.length; g < h; ++g) yield* f[g].DebugRun(d)
    }
    Retrigger(d, f) {
      this._runtime.IncrementExecCount()
      f.ResetQuick()
      const g = this._conditions
      if (!this.IsOrBlock()) for (let h = d.GetConditionIndex() + 1, k = g.length; h < k; ++h) if (((d = g[h]), f.SetConditionIndex(h), !d.Run())) return !1
      this._RunActions(f, 0) && this._RunSubEvents(f)
      return !0
    }
    *DebugRetrigger(d, f) {
      this._runtime.IncrementExecCount()
      f.ResetQuick()
      const g = this._conditions
      if (!this.IsOrBlock()) for (let h = d.GetConditionIndex() + 1, k = g.length; h < k; ++h) if (((d = g[h]), f.SetConditionIndex(h), d.DebugCanRunFast() ? !d.Run() : !(yield* d.DebugRun()))) return !1
      ;(this.DebugCanRunActionsFast() ? this._RunActions(f, 0) : yield* this._DebugRunActions(f, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield* this._DebugRunSubEvents())
      return !0
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
    }
    DebugCanRunActionsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
    }
    DebugCanRunSubEventsFast() {
      return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
    }
    _CheckParentsOKToRun(d) {
      if (this.GetParent()) {
        const f = this.GetTriggerParents()
        for (let g = 0, h = f.length; g < h; ++g) if (!f[g].RunPreTrigger(d)) return !1
      }
      return !0
    }
    *_DebugCheckParentsOKToRun(d) {
      if (this.GetParent()) {
        const f = this.GetTriggerParents()
        for (let g = 0, h = f.length; g < h; ++g) if (!(yield* f[g].DebugRunPreTrigger(d))) return !1
      }
      return !0
    }
    _EvaluateFunctionCallParameters(d, f, g) {
      0 < f.length ? (g ? ((f = f.map(h => h.Get(0))), d.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(f)) : this._scopeParent.EvaluateFunctionParameters(f)) : g && d.GetLocalVarStack().Push()
    }
    RunAsFunctionCall(d, f) {
      let g, h
      const k = 0 < d.length
      var m = this._runtime
      const r = this._eventStack,
        w = m.GetEventSheetManager(),
        p = 1 < w._IncTriggerDepth()
      this._EvaluateFunctionCallParameters(w, f, p)
      k && w.PushCleanSol(d)
      f = r.Push(this)
      this._CheckParentsOKToRun(f) && (m.IncrementExecCount(), f.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) && ([h, g] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(f), m && this._scopeParent.MaybeFinishAsyncFunctionCall(h))
      r.Pop()
      p && w.GetLocalVarStack().Pop()
      k && w.PopSol(d)
      w._DecTriggerDepth()
      return g
    }
    *DebugRunAsFunctionCall(d, f) {
      let g, h
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this
      const k = 0 < d.length
      var m = this._runtime
      const r = this._eventStack,
        w = m.GetEventSheetManager(),
        p = 1 < w._IncTriggerDepth()
      this._EvaluateFunctionCallParameters(w, f, p)
      k && w.PushCleanSol(d)
      f = r.Push(this)
      if (yield* this._DebugCheckParentsOKToRun(f)) m.IncrementExecCount(), f.SetCurrentEvent(this), (m = this._scopeParent.IsAsync()) && ([h, g] = this._scopeParent.StartAsyncFunctionCall()), yield* this._DebugRunAndBlock(f), m && this._scopeParent.MaybeFinishAsyncFunctionCall(h)
      r.Pop()
      p && w.GetLocalVarStack().Pop()
      k && w.PopSol(d)
      w._DecTriggerDepth()
      return g
    }
    RunAsMappedFunctionCall(d) {
      const f = this.GetSolModifiersIncludingParents(),
        g = 0 < f.length,
        h = this._runtime,
        k = this._eventStack,
        m = h.GetEventSheetManager(),
        r = 1 < m._IncTriggerDepth()
      r && m.GetLocalVarStack().Push()
      this._scopeParent.SetFunctionParameters(d)
      g && m.PushCleanSol(f)
      d = k.Push(this)
      this._CheckParentsOKToRun(d) && (h.IncrementExecCount(), d.SetCurrentEvent(this), this._RunAndBlock(d))
      k.Pop()
      r && m.GetLocalVarStack().Pop()
      g && m.PopSol(f)
      m._DecTriggerDepth()
    }
    *DebugRunAsMappedFunctionCall(d) {
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this
      const f = this.GetSolModifiersIncludingParents(),
        g = 0 < f.length,
        h = this._runtime,
        k = this._eventStack,
        m = h.GetEventSheetManager(),
        r = 1 < m._IncTriggerDepth()
      r && m.GetLocalVarStack().Push()
      this._scopeParent.SetFunctionParameters(d)
      g && m.PushCleanSol(f)
      d = k.Push(this)
      if (yield* this._DebugCheckParentsOKToRun(d)) h.IncrementExecCount(), d.SetCurrentEvent(this), yield* this._DebugRunAndBlock(d)
      k.Pop()
      r && m.GetLocalVarStack().Pop()
      g && m.PopSol(f)
      m._DecTriggerDepth()
    }
    RunAsExpressionFunctionCall(d, f, g, ...h) {
      let k, m
      const r = 0 < d.length,
        w = this._runtime,
        p = this._eventStack,
        q = w.GetEventSheetManager(),
        t = 1 < q._IncTriggerDepth()
      t && q.GetLocalVarStack().Push()
      0 < h.length && this._scopeParent.SetFunctionParameters(h)
      r && q.PushCleanSol(d)
      h = p.Push(this)
      h.InitCallFunctionExpression(f, g)
      p.PushExpFunc(h)
      w.SetDebuggingEnabled(!1)
      this._CheckParentsOKToRun(h) && (w.IncrementExecCount(), h.SetCurrentEvent(this), (f = this._scopeParent.IsAsync()) && ([m, k] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(h), f && this._scopeParent.MaybeFinishAsyncFunctionCall(m))
      w.SetDebuggingEnabled(!0)
      p.Pop()
      p.PopExpFunc()
      t && q.GetLocalVarStack().Pop()
      r && q.PopSol(d)
      q._DecTriggerDepth()
      return k || h.GetFunctionReturnValue()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []
  let a = !1
  e.EventScript = class extends e.DefendedBase {
    constructor(c, d, f) {
      super()
      const g = c.GetRuntime(),
        h = c.GetEventSheetManager()
      this._eventSheet = c
      this._eventSheetManager = h
      this._runtime = c.GetRuntime()
      this._parent = d
      this._func = g.GetObjectReference(f[1])
      this._displayNumber = f[2]
      this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber)
      this._debugData = g.IsDebug()
        ? {
            isBreakpoint: f[3][0],
            isBreakable: f[3][1]
          }
        : null
    }
    static Create(c, d, f) {
      return e.New(e.EventScript, c, d, f)
    }
    _PostInit() {
      const c = this._func,
        d = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this)
      this._func = c.bind(null, this._runtime.GetIRuntime(), d)
    }
    GetParent() {
      return this._parent
    }
    GetScopeParent() {
      return this._parent
    }
    GetEventSheet() {
      return this._eventSheet
    }
    GetDisplayNumber() {
      return this._displayNumber
    }
    IsDebugBreakable() {
      return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint() {
      return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(c) {
      this._debugData.isBreakpoint = !!c
    }
    IsElseBlock() {
      return !1
    }
    GetSolModifiers() {
      return b
    }
    GetSolModifiersIncludingParents() {
      return this._parent ? this._parent.GetSolModifiersIncludingParents() : b
    }
    Run(c) {
      c.SetCurrentEvent(this)
      this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
    }
    async _RunUserScript() {
      try {
        await this._func()
      } catch (c) {
        console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, 'font-size: 1.2em; font-weight: bold;', c),
          self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
          a || (console.info('%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()', 'font-weight: bold; text-decoration: underline', '', 'font-weight: bold'), (a = !0))
      }
    }
    *DebugRun(c) {
      c.SetCurrentEvent(this)
      if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext()) yield this
      this.Run(c)
    }
    DebugCanRunFast() {
      return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
    }
    static HadUserScriptException() {
      return a
    }
    static SetHadUserScriptException() {
      a = !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.FunctionBlock = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      this._eventSheet = b
      this._runtime = b.GetRuntime()
      this._parent = a
      const d = c[1]
      this._functionName = d[0]
      this._returnType = d[1]
      this._functionParameters = d[2].map(f => e.EventVariable.Create(b, this, f))
      this._isEnabled = d[3]
      this._innerLocalVariables = []
      this._isAsync = d[4]
      this._nextAsyncId = 0
      this._currentAsyncId = -1
      this._asyncMap = new Map()
      this._eventBlock = e.EventBlock.Create(b, a, c)
      this._eventBlock._SetScopeParent(this)
    }
    static Create(b, a, c) {
      return e.New(e.FunctionBlock, b, a, c)
    }
    _PostInit() {
      for (const b of this._functionParameters) b._PostInit()
      this._eventBlock._PostInit(!1)
    }
    _GetAllLocalVariablesInScope() {
      return this._functionParameters
    }
    GetFunctionParameters() {
      return this._functionParameters
    }
    GetFunctionParameterCount() {
      return this._functionParameters.length
    }
    _RegisterLocalVariable(b) {
      this._innerLocalVariables.push(b)
    }
    _GetAllInnerLocalVariables() {
      return this._innerLocalVariables
    }
    EvaluateFunctionParameters(b) {
      const a = this._functionParameters
      for (let c = 0, d = a.length; c < d; ++c) a[c].SetValue(b[c].Get(0))
    }
    SetFunctionParameters(b) {
      const a = this._functionParameters
      for (let c = 0, d = a.length; c < d; ++c) a[c].SetValue(b[c])
    }
    CaptureFunctionParameters() {
      return this._functionParameters.map(b => b.GetValue())
    }
    GetParent() {
      return this._parent
    }
    GetScopeParent() {
      return this._parent
    }
    GetFunctionName() {
      return this._functionName
    }
    GetReturnType() {
      return this._returnType
    }
    IsEnabled() {
      return this._isEnabled
    }
    GetDefaultReturnValue() {
      switch (this._returnType) {
        case 0:
          return null
        case 2:
          return ''
        default:
          return 0
      }
    }
    GetEventBlock() {
      return this._eventBlock
    }
    IsAsync() {
      return this._isAsync
    }
    StartAsyncFunctionCall() {
      const b = this._nextAsyncId++
      this._currentAsyncId = b
      let a
      const c = new Promise(d => (a = d))
      this._asyncMap.set(b, {
        resolve: a,
        pauseCount: 0
      })
      return [b, c]
    }
    MaybeFinishAsyncFunctionCall(b) {
      const a = this._asyncMap.get(b)
      0 === a.pauseCount && (a.resolve(), this._asyncMap.delete(b))
      this._currentAsyncId = -1
    }
    PauseCurrentAsyncFunction() {
      this._asyncMap.get(this._currentAsyncId).pauseCount++
      return this._currentAsyncId
    }
    ResumeAsyncFunction(b) {
      this._currentAsyncId = b
      this._asyncMap.get(b).pauseCount--
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []
  e.EventVariable = class extends e.DefendedBase {
    constructor(a, c, d) {
      super()
      const f = a.GetEventSheetManager()
      this._eventSheet = a
      this._eventSheetManager = f
      this._runtime = a.GetRuntime()
      this._parent = c
      this._localVarStack = f.GetLocalVarStack()
      this._name = d[1]
      this._type = d[2]
      this._initialValue = d[3]
      this._isStatic = !!d[4]
      this._isConstant = !!d[5]
      this._isFunctionParameter = c instanceof e.FunctionBlock
      this._sid = d[6]
      this._jsPropName = this._runtime.GetJsPropName(d[8])
      this._scriptSetter = g => this.SetValue(g)
      this._scriptGetter = () => this.GetValue()
      this._hasSingleValue = !this._parent || this._isStatic || this._isConstant
      this._value = this._initialValue
      this._localIndex = -1
      this.IsBoolean() && (this._value = this._value ? 1 : 0)
      !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = f._GetNextLocalVarIndex(this))
      f._RegisterEventVariable(this)
    }
    static Create(a, c, d) {
      return e.New(e.EventVariable, a, c, d)
    }
    _PostInit() {
      if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() && !this.IsFunctionParameter()) {
        const a = this._eventSheetManager.FindFirstFunctionBlockParent(this)
        a && a._RegisterLocalVariable(this)
      }
    }
    GetName() {
      return this._name
    }
    GetJsPropName() {
      return this._jsPropName
    }
    GetParent() {
      return this._parent
    }
    GetScopeParent() {
      return this.GetParent()
    }
    IsGlobal() {
      return !this.GetParent()
    }
    IsLocal() {
      return !this.IsGlobal()
    }
    IsFunctionParameter() {
      return this._isFunctionParameter
    }
    IsStatic() {
      return this._isStatic
    }
    IsConstant() {
      return this._isConstant
    }
    IsNumber() {
      return 0 === this._type
    }
    IsString() {
      return 1 === this._type
    }
    IsBoolean() {
      return 2 === this._type
    }
    IsElseBlock() {
      return !1
    }
    GetSID() {
      return this._sid
    }
    GetInitialValue() {
      return this._initialValue
    }
    GetSolModifiers() {
      return b
    }
    Run(a) {
      !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
    }
    DebugCanRunFast() {
      return !0
    }
    *DebugRun(a) {
      this.Run(a)
    }
    SetValue(a) {
      this.IsNumber() ? 'number' !== typeof a && (a = parseFloat(a)) : this.IsString() ? 'string' !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0)
      this._hasSingleValue ? (this._value = a) : (this._localVarStack.GetCurrent()[this._localIndex] = a)
    }
    GetValue() {
      return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
    }
    GetTypedValue() {
      let a = this.GetValue()
      this.IsBoolean() && (a = !!a)
      return a
    }
    ResetToInitialValue() {
      this._value = this._initialValue
    }
    _GetScriptInterfaceDescriptor() {
      return {
        configurable: !1,
        enumerable: !0,
        get: this._scriptGetter,
        set: this._scriptSetter
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []
  e.EventInclude = class extends e.DefendedBase {
    constructor(a, c, d) {
      super()
      const f = a.GetEventSheetManager()
      this._eventSheet = a
      this._eventSheetManager = f
      this._runtime = a.GetRuntime()
      this._parent = c
      this._includeSheet = null
      this._includeSheetName = d[1]
      this._isActive = !0
    }
    static Create(a, c, d) {
      return e.New(e.EventInclude, a, c, d)
    }
    _PostInit() {
      this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName)
      this._eventSheet._AddShallowInclude(this)
      let a = this.GetParent()
      for (; a; ) a instanceof e.EventBlock && a.IsGroup() && a._AddContainedInclude(this), (a = a.GetParent())
      this.UpdateActive()
      this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
    }
    GetParent() {
      return this._parent
    }
    GetSolModifiers() {
      return b
    }
    GetIncludeSheet() {
      return this._includeSheet
    }
    Run(a) {
      a = !!this.GetParent()
      const c = this._runtime.GetAllObjectClasses()
      a && this._eventSheetManager.PushCleanSol(c)
      this._includeSheet.Run()
      a && this._eventSheetManager.PopSol(c)
    }
    *DebugRun(a) {
      a = !!this.GetParent()
      const c = this._runtime.GetAllObjectClasses()
      a && this._eventSheetManager.PushCleanSol(c)
      yield* this._includeSheet.DebugRun()
      a && this._eventSheetManager.PopSol(c)
    }
    DebugCanRunFast() {
      return !1
    }
    IsActive() {
      return this._isActive
    }
    UpdateActive() {
      let a = this.GetParent()
      for (; a; ) {
        if (a instanceof e.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
          this._isActive = !1
          return
        }
        a = a.GetParent()
      }
      this._isActive = !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.ExpNode = class extends e.DefendedBase {
    constructor(k) {
      super()
      this._owner = k
      this._runtime = k.GetRuntime()
    }
    _PostInit() {}
    static CreateNode(k, m) {
      return e.New([g, d, f, h, b, a][m[0]], k, m)
    }
  }
  class b extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._systemPlugin = this._runtime.GetSystemPlugin()
      this._func = this._runtime.GetObjectReference(m[1])
      ;(this._func !== e.Plugins.System.Exps.random && this._func !== e.Plugins.System.Exps.choose) || this._owner.SetVariesPerInstance()
    }
    GetBoundMethod() {
      return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
    }
  }
  class a extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._functionBlock = null
      this._functionName = m[1]
      this._owner.SetVariesPerInstance()
    }
    _PostInit() {
      const k = this._runtime.GetEventSheetManager()
      this._functionBlock = k.GetFunctionBlockByName(this._functionName)
      this._functionName = null
      const m = this._owner.GetEventBlock(),
        r = this._functionBlock.GetEventBlock()
      this._combinedSolModifiers = [...new Set([...m.GetSolModifiersIncludingParents(), ...r.GetSolModifiersIncludingParents()])]
      this._combinedSolModifiers = k._DeduplicateSolModifierList(this._combinedSolModifiers)
    }
    GetBoundMethod() {
      const k = this._functionBlock
      if (k.IsEnabled()) {
        const m = k.GetEventBlock()
        return e.EventBlock.prototype.RunAsExpressionFunctionCall.bind(m, this._combinedSolModifiers, k.GetReturnType(), k.GetDefaultReturnValue())
      }
      {
        const m = k.GetDefaultReturnValue()
        return () => m
      }
    }
  }

  function c(k, m) {
    if (k >= m) return k % m
    0 > k && (k <= -m && (k %= m), 0 > k && (k += m))
    return k
  }
  class d extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1])
      this._func = this._runtime.GetObjectReference(m[2])
      this._returnsString = !!m[3]
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack()
      this._owner._MaybeVaryFor(this._objectClass)
    }
    GetBoundMethod() {
      return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
    }
    ExpObject(...k) {
      const m = this._objectClass,
        r = m.GetCurrentSol().GetExpressionInstances()
      var w = r.length
      if (0 === w) return this._returnsString ? '' : 0
      w = c(this._owner.GetSolIndex(), w)
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m)
      return this._func.apply(r[w].GetSdkInstance(), k)
    }
    ExpObject_InstExpr(k, ...m) {
      const r = this._objectClass,
        w = r.GetInstances(),
        p = w.length
      if (0 === p) return this._returnsString ? '' : 0
      k = c(k, p)
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r)
      return this._func.apply(w[k].GetSdkInstance(), m)
    }
  }
  class f extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1])
      this._varIndex = m[3]
      this._returnsString = !!m[2]
      this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpInstVar() {
      const k = this._objectClass.GetCurrentSol().GetExpressionInstances()
      var m = k.length
      if (0 === m) return this._returnsString ? '' : 0
      m = c(this._owner.GetSolIndex(), m)
      return k[m]._GetInstanceVariableValueUnchecked(this._varIndex)
    }
    ExpInstVar_Family() {
      var k = this._objectClass,
        m = k.GetCurrentSol().GetExpressionInstances(),
        r = m.length
      if (0 === r) return this._returnsString ? '' : 0
      r = c(this._owner.GetSolIndex(), r)
      m = m[r]
      k = m.GetObjectClass().GetFamilyInstanceVariableOffset(k.GetFamilyIndex())
      return m._GetInstanceVariableValueUnchecked(this._varIndex + k)
    }
    ExpInstVar_InstExpr(k) {
      const m = this._objectClass
      var r = m.GetInstances()
      const w = r.length
      if (0 === w) return this._returnsString ? '' : 0
      k = c(k, w)
      r = r[k]
      k = 0
      m.IsFamily() && (k = r.GetObjectClass().GetFamilyInstanceVariableOffset(m.GetFamilyIndex()))
      return r._GetInstanceVariableValueUnchecked(this._varIndex + k)
    }
  }
  class g extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._objectClass = this._runtime.GetObjectClassByIndex(m[1])
      this._behaviorType = this._objectClass.GetBehaviorTypeByName(m[2])
      this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(m[2])
      this._func = this._runtime.GetObjectReference(m[3])
      this._returnsString = !!m[4]
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack()
      this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpBehavior(...k) {
      const m = this._objectClass
      var r = m.GetCurrentSol().GetExpressionInstances(),
        w = r.length
      if (0 === w) return this._returnsString ? '' : 0
      w = c(this._owner.GetSolIndex(), w)
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(m)
      r = r[w]
      w = 0
      m.IsFamily() && (w = r.GetObjectClass().GetFamilyBehaviorOffset(m.GetFamilyIndex()))
      return this._func.apply(r.GetBehaviorInstances()[this._behaviorIndex + w].GetSdkInstance(), k)
    }
    ExpBehavior_InstExpr(k, ...m) {
      const r = this._objectClass
      var w = r.GetInstances()
      const p = w.length
      if (0 === p) return this._returnsString ? '' : 0
      k = c(k, p)
      this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(r)
      w = w[k]
      k = 0
      r.IsFamily() && (k = w.GetObjectClass().GetFamilyBehaviorOffset(r.GetFamilyIndex()))
      return this._func.apply(w.GetBehaviorInstances()[this._behaviorIndex + k].GetSdkInstance(), m)
    }
  }
  class h extends e.ExpNode {
    constructor(k, m) {
      super(k)
      this._eventVar = null
      this._eventVarSid = m[1]
    }
    _PostInit() {
      this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetVar() {
      return this._eventVar
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Parameter = class extends e.DefendedBase {
    constructor(v, u, A) {
      super()
      this._owner = v
      this._index = A
      this._type = u
      this.Get = null
      this._isConstant = this._variesPerInstance = !1
    }
    static Create(v, u, A) {
      const z = u[0]
      return e.New([a, c, r, f, h, d, k, a, f, f, w, p, r, t, c, m, g, q, x][z], v, z, A, u)
    }
    _PostInit() {}
    SetVariesPerInstance() {
      this._variesPerInstance = !0
    }
    _MaybeVaryFor(v) {
      this._variesPerInstance || !v || v.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
    }
    VariesPerInstance() {
      return this._variesPerInstance
    }
    GetIndex() {
      return this._index
    }
    GetRuntime() {
      return this._owner.GetRuntime()
    }
    GetEventBlock() {
      return this._owner.GetEventBlock()
    }
    IsConstant() {
      return this._isConstant
    }
  }

  function b(v) {
    v = self.C3_ExpressionFuncs[v]
    if (!v) throw Error('invalid expression number')
    return v
  }
  class a extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._solIndex = 0
      v = z[1]
      this._expressionNumber = v[0]
      this._numberedNodes = []
      this._expressionFunc = null
      for (let C = 1, E = v.length; C < E; ++C) this._numberedNodes.push(e.ExpNode.CreateNode(this, v[C]))
      this._numberedNodes.length ? (this.Get = this.GetExpression) : ((this.Get = b(this._expressionNumber)), (this._isConstant = !0))
    }
    _GetNode(v) {
      if (0 > v || v >= this._numberedNodes.length) throw new RangeError('invalid numbered node')
      return this._numberedNodes[v]
    }
    _PostInit() {
      for (var v of this._numberedNodes) v._PostInit()
      v = b(this._expressionNumber)
      this._expressionFunc = this._numberedNodes.length ? v(this) : v
    }
    GetSolIndex() {
      return this._solIndex
    }
    GetExpression(v) {
      this._solIndex = v
      return this._expressionFunc()
    }
  }
  class c extends a {
    constructor(v, u, A, z) {
      super(v, u, A, z)
      this.Get = this.GetStringExpression
      14 === u && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof e.Action && this.GetEventBlock().SetSolWriterAfterCnds())
    }
    GetStringExpression(v) {
      this._solIndex = v
      v = this._expressionFunc()
      return 'string' === typeof v ? v : ''
    }
    _GetFastTriggerValue() {
      return b(this._expressionNumber)()
    }
  }
  class d extends a {
    constructor(v, u, A, z) {
      super(v, u, A, z)
      this.Get = this.GetLayer
      this._isConstant = !1
    }
    GetLayer(v) {
      this._solIndex = v
      v = this._expressionFunc()
      return this.GetRuntime().GetCurrentLayout().GetLayer(v)
    }
  }
  class f extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._combo = z[1]
      this.Get = this.GetCombo
      this._isConstant = !0
    }
    GetCombo() {
      return this._combo
    }
  }
  class g extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._bool = z[1]
      this.Get = this.GetBoolean
      this._isConstant = !0
    }
    GetBoolean() {
      return this._bool
    }
  }
  class h extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._objectClass = this.GetRuntime().GetObjectClassByIndex(z[1])
      this.Get = this.GetObjectClass
      v = this.GetEventBlock()
      v._AddSolModifier(this._objectClass)
      this._owner instanceof e.Action ? v.SetSolWriterAfterCnds() : v.GetParent() && v.GetParent().SetSolWriterAfterCnds()
      this._isConstant = !0
    }
    GetObjectClass() {
      return this._objectClass
    }
  }
  class k extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(z[1])
      this.Get = this.GetLayout
      this._isConstant = !0
    }
    GetLayout() {
      return this._layout
    }
  }
  class m extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(z[1])
      this.Get = this.GetTimeline
      this._isConstant = !0
    }
    GetTimeline() {
      return this._timeline
    }
  }
  class r extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._fileInfo = z[1]
      this.Get = this.GetFile
      this._isConstant = !0
    }
    GetFile() {
      return this._fileInfo
    }
  }
  class w extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._instVarIndex = z[1]
      ;(v = this._owner.GetObjectClass()) && v.IsFamily() ? ((this.Get = this.GetFamilyInstanceVariable), this.SetVariesPerInstance()) : ((this.Get = this.GetInstanceVariable), (this._isConstant = !0))
    }
    GetInstanceVariable() {
      return this._instVarIndex
    }
    GetFamilyInstanceVariable(v) {
      v = v || 0
      const u = this._owner.GetObjectClass()
      var A = u.GetCurrentSol()
      const z = A.GetInstances()
      if (z.length) v = z[v % z.length].GetObjectClass()
      else if (A.HasAnyElseInstances()) (A = A.GetElseInstances()), (v = A[v % A.length].GetObjectClass())
      else if (0 < u.GetInstanceCount()) (A = u.GetInstances()), (v = A[v % A.length].GetObjectClass())
      else return 0
      return this._instVarIndex + v.GetFamilyInstanceVariableOffset(u.GetFamilyIndex())
    }
  }
  class p extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._eventVarSid = z[1]
      this._eventVar = null
      this.Get = this.GetEventVariable
      this._isConstant = !0
    }
    _PostInit() {
      this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetEventVariable() {
      return this._eventVar
    }
  }
  class q extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._functionBlockName = z[1]
      this._functionBlock = null
      this.Get = this.GetFunction
      this._isConstant = !0
    }
    _PostInit() {
      this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName)
      this._functionBlockName = null
    }
    GetFunction() {
      return this._functionBlock
    }
  }
  class t extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._subParams = []
      this._variadicRet = []
      this._isConstant = !0
      for (let C = 1, E = z.length; C < E; ++C) (v = e.Parameter.Create(this._owner, z[C], 0)), this._subParams.push(v), this._variadicRet.push(0), v.IsConstant() || (this._isConstant = !1)
      this.Get = this.GetVariadic
    }
    _PostInit() {
      for (const v of this._subParams) v._PostInit()
    }
    GetVariadic() {
      const v = this._subParams,
        u = this._variadicRet
      for (let A = 0, z = v.length; A < z; ++A) u[A] = v[A].Get(0)
      return u
    }
  }
  class x extends e.Parameter {
    constructor(v, u, A, z) {
      super(v, u, A)
      this._easeIndex = z[1]
      this.Get = this.GetEase
      this._isConstant = !0
    }
    GetEase() {
      return this._easeIndex
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(d, f) {
    for (let g = 0, h = d.length; g < h; ++g) f[g] = d[g].Get(0)
  }
  const a = [],
    c = function () {}
  e.Condition = class extends e.DefendedBase {
    constructor(d, f, g) {
      super()
      this._eventBlock = d
      this._runtime = d.GetRuntime()
      this._index = g
      this._func = this._runtime.GetObjectReference(f[1])
      this._isTrigger = 0 < f[3]
      this._isFastTrigger = 2 === f[3]
      this._isLooping = !!f[4]
      this._isInverted = !!f[5]
      this._isStatic = !!f[6]
      this._sid = f[7]
      this._isInOrBlock = this._eventBlock.IsOrBlock()
      this._behaviorType = this._objectClass = null
      this._behaviorIndex = -1
      this._systemPlugin = null
      this.DebugRun = this.Run = c
      this._parameters = []
      this._results = []
      this._anyParamVariesPerInstance = !1
      this._unsavedData = this._savedData = null
      this._debugData = this._runtime.IsDebug()
        ? {
            isBreakpoint: f[8][0],
            canDebug: f[8][1]
          }
        : null
      ;-1 === f[0]
        ? (this._systemPlugin = this._runtime.GetSystemPlugin())
        : ((this._objectClass = this._runtime.GetObjectClassByIndex(f[0])),
          f[2] && ((this._behaviorType = this._objectClass.GetBehaviorTypeByName(f[2])), (this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(f[2]))),
          this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds())
      if (10 === f.length) {
        d = f[9]
        for (let h of d) this._parameters.push(e.Parameter.Create(this, h, this._parameters.length)), this._results.push(0)
      }
      0 === this._parameters.length && (this._results = this._parameters = a)
      this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
    }
    static Create(d, f, g) {
      return e.New(e.Condition, d, f, g)
    }
    _PostInit() {
      for (const d of this._parameters) d._PostInit(), d.VariesPerInstance() && (this._anyParamVariesPerInstance = !0)
      this._isFastTrigger
        ? ((this.Run = this._RunFastTrigger), (this.DebugRun = this._DebugRunFastTrigger))
        : this._systemPlugin
        ? (this._SetSystemRunMethod(), (this.DebugRun = this._DebugRunSystem))
        : this._objectClass.GetPlugin().IsSingleGlobal()
        ? (this._SetSingleGlobalRunMethod(), (this.DebugRun = this._DebugRunSingleGlobal))
        : this._isStatic
        ? ((this.Run = this._RunStatic), (this.DebugRun = this._DebugRunStatic))
        : ((this.Run = this._RunObject), (this.DebugRun = this._DebugRunObject))
    }
    _SetSystemRunMethod() {
      this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
      const d = this._objectClass.GetPlugin(),
        f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance()
      this._SetRunMethodForBoundFunc(d, f, this._RunSingleGlobal)
    }
    _SetRunMethodForBoundFunc(d, f, g) {
      const h = this._func,
        k = this._isInverted,
        m = this._parameters
      if (0 === m.length) {
        const r = d._GetBoundACEMethod(h, f)
        this.Run = k
          ? function () {
              return e.xor(r(), k)
            }
          : r
      } else if (1 === m.length) {
        const r = m[0]
        if (!k && r.IsConstant()) this.Run = d._GetBoundACEMethod_1param(h, f, r.Get(0))
        else {
          const w = d._GetBoundACEMethod(h, f)
          this.Run = function () {
            return e.xor(w(r.Get(0)), k)
          }
        }
      } else if (2 === m.length) {
        const r = m[0],
          w = m[1]
        if (!k && r.IsConstant() && w.IsConstant()) this.Run = d._GetBoundACEMethod_2params(h, f, r.Get(0), w.Get(0))
        else {
          const p = d._GetBoundACEMethod(h, f)
          this.Run = function () {
            return e.xor(p(r.Get(0), w.Get(0)), k)
          }
        }
      } else if (3 === m.length) {
        const r = m[0],
          w = m[1],
          p = m[2]
        if (!k && r.IsConstant() && w.IsConstant() && p.IsConstant()) this.Run = d._GetBoundACEMethod_3params(h, f, r.Get(0), w.Get(0), p.Get(0))
        else {
          const q = d._GetBoundACEMethod(h, f)
          this.Run = function () {
            return e.xor(q(r.Get(0), w.Get(0), p.Get(0)), k)
          }
        }
      } else this.Run = g
    }
    GetSID() {
      return this._sid
    }
    _GetFunc() {
      return this._func
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetBehaviorType() {
      return this._behaviorType
    }
    GetEventBlock() {
      return this._eventBlock
    }
    GetRuntime() {
      return this._runtime
    }
    GetIndex() {
      return this._index
    }
    GetDebugIndex() {
      return this.GetIndex()
    }
    IsTrigger() {
      return this._isTrigger
    }
    IsFastTrigger() {
      return this._isFastTrigger
    }
    IsInverted() {
      return this._isInverted
    }
    IsLooping() {
      return this._isLooping
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint
    }
    _SetBreakpoint(d) {
      this._debugData.isBreakpoint = !!d
      this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map())
      return this._savedData
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map())
      return this._unsavedData
    }
    _RunSystem() {
      const d = this._results
      b(this._parameters, d)
      return e.xor(this._func.apply(this._systemPlugin, d), this._isInverted)
    }
    *_DebugRunSystem() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        var d = this._results
        b(this._parameters, d)
        d = this._func.apply(this._systemPlugin, d)
        e.IsIterator(d) && (d = yield* d)
        return e.xor(d, this._isInverted)
      }
      return this.Run()
    }
    _RunSingleGlobal() {
      const d = this._results
      b(this._parameters, d)
      const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance()
      return e.xor(this._func.apply(f, d), this._isInverted)
    }
    *_DebugRunSingleGlobal() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        var d = this._results
        b(this._parameters, d)
        const f = this._objectClass.GetSingleGlobalInstance().GetSdkInstance()
        d = this._func.apply(f, d)
        e.IsIterator(d) && (d = yield* d)
        return e.xor(d, this._isInverted)
      }
      return this.Run()
    }
    _RunFastTrigger() {
      return !0
    }
    *_DebugRunFastTrigger() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      return !0
    }
    _RunStatic() {
      var d = this._results
      b(this._parameters, d)
      d = this._func.apply(this._behaviorType || this._objectClass, d)
      this._objectClass.ApplySolToContainer()
      return d
    }
    *_DebugRunStatic() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        var d = this._results
        b(this._parameters, d)
        d = this._func.apply(this._behaviorType || this._objectClass, d)
        e.IsIterator(d) && (d = yield* d)
        this._objectClass.ApplySolToContainer()
        return d
      }
      return this.Run()
    }
    _RunObject() {
      const d = this._parameters,
        f = this._results,
        g = this._objectClass.GetCurrentSol()
      for (let h = 0, k = d.length; h < k; ++h) {
        const m = d[h]
        m.VariesPerInstance() || (f[h] = m.Get(0))
      }
      return g.IsSelectAll() ? this._RunObject_FirstFilter(g) : this._RunObject_NextFilter(g)
    }
    *_DebugRunObject() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      return this._RunObject()
    }
    _EvaluateVaryingParameters(d) {
      const f = this._parameters,
        g = this._results
      for (let h = 0, k = f.length; h < k; ++h) {
        const m = f[h]
        m.VariesPerInstance() && (g[h] = m.Get(d))
      }
    }
    _RunObject_FirstFilter(d) {
      const f = this._objectClass,
        g = f.IsFamily(),
        h = f.GetFamilyIndex(),
        k = this._behaviorIndex,
        m = 0 <= k,
        r = f.GetInstances(),
        w = this._anyParamVariesPerInstance,
        p = this._results,
        q = this._func,
        t = this._isInverted,
        x = this._isInOrBlock && !this._isTrigger
      d.ClearArrays()
      for (let u = 0, A = r.length; u < A; ++u) {
        const z = r[u]
        w && this._EvaluateVaryingParameters(u)
        var v = void 0
        m ? ((v = g ? z.GetObjectClass().GetFamilyBehaviorOffset(h) : 0), (v = q.apply(z.GetBehaviorInstances()[k + v].GetSdkInstance(), p))) : (v = q.apply(z.GetSdkInstance(), p))
        e.xor(v, t) ? d._PushInstance(z) : x && d._PushElseInstance(z)
      }
      f.FinishCondition(!0)
      d._SetSelectAll(!1)
      f.ApplySolToContainer()
      return d.HasAnyInstances()
    }
    _RunObject_NextFilter(d) {
      const f = this._objectClass
      var g = f.IsFamily()
      const h = f.GetFamilyIndex(),
        k = f.IsInContainer(),
        m = this._behaviorIndex,
        r = 0 <= m,
        w = this._anyParamVariesPerInstance,
        p = this._results,
        q = this._func,
        t = this._isInverted,
        x = this._isInOrBlock && !this._isTrigger,
        v = d._GetOwnInstances(),
        u = d._GetOwnElseInstances(),
        A = x && !this._eventBlock.IsFirstConditionOfType(this),
        z = A ? u : v
      let C = 0,
        E = !1
      for (let F = 0, I = z.length; F < I; ++F) {
        const L = z[F]
        w && this._EvaluateVaryingParameters(F)
        var J = void 0
        r ? ((J = g ? L.GetObjectClass().GetFamilyBehaviorOffset(h) : 0), (J = q.apply(L.GetBehaviorInstances()[m + J].GetSdkInstance(), p))) : (J = q.apply(L.GetSdkInstance(), p))
        e.xor(J, t) ? ((E = !0), A ? (v.push(L), k && L._PushSiblingsToSolInstances()) : ((z[C] = L), k && L._SetSiblingsToSolInstancesIndex(C), ++C)) : A ? ((z[C] = L), k && L._SetSiblingsToSolElseInstancesIndex(C), ++C) : x && (u.push(L), k && L._PushSiblingsToSolElseInstances())
      }
      e.truncateArray(z, C)
      k && f._TruncateContainerSols(A, C)
      g = E
      A && !E && (E = this._OrBlockCheckInstances(v))
      f.FinishCondition(g || x)
      return x ? E : d.HasAnyInstances()
    }
    _OrBlockCheckInstances(d) {
      var f = this._objectClass
      const g = f.IsFamily()
      f = f.GetFamilyIndex()
      const h = this._anyParamVariesPerInstance,
        k = this._behaviorIndex,
        m = 0 <= k,
        r = this._results,
        w = this._func,
        p = this._isInverted
      for (let t = 0, x = d.length; t < x; ++t) {
        var q = d[t]
        h && this._EvaluateVaryingParameters(t)
        if (m) {
          const v = g ? q.GetObjectClass().GetFamilyBehaviorOffset(f) : 0
          q = w.apply(q.GetBehaviorInstances()[k + v].GetSdkInstance(), r)
        } else q = w.apply(q.GetSdkInstance(), r)
        if (e.xor(q, p)) return !0
      }
      return !1
    }
    ReevaluateParameter(d, f) {
      return this._parameters[d].Get(f)
    }
    GetFastTriggerValue() {
      const d = this._parameters
      if (!d.length) throw Error('no parameters')
      return d[0]._GetFastTriggerValue()
    }
    _SaveToJson() {
      if (!this._savedData || !this._savedData.size) return null
      const d = {}
      for (const [f, g] of this._savedData.entries()) {
        let h = g
        'collmemory' === f && (h = [...g.entries()].map(k => [k[0].GetUID(), k[1].GetUID(), k[2]]))
        d[f] = h
      }
      return {
        ex: d
      }
    }
    _LoadFromJson(d) {
      this._savedData && (this._savedData.clear(), (this._savedData = null))
      if (d) {
        var f = this._runtime,
          g = d.ex
        if (g) {
          d = this.GetSavedDataMap()
          d.clear()
          for (const [h, k] of Object.entries(g))
            (g = k),
              'collmemory' === h &&
                (g = e.New(
                  e.PairMap,
                  k.map(m => [f.GetInstanceByUID(m[0]), f.GetInstanceByUID(m[1]), m[2]]).filter(m => m[0] && m[1])
                )),
              d.set(h, g)
        }
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(f, g) {
    for (let h = 0, k = f.length; h < k; ++h) g[h] = f[h].Get(0)
  }
  const a = [],
    c = function () {},
    d = function* () {}
  e.Action = class extends e.DefendedBase {
    constructor(f, g, h) {
      super()
      this._eventBlock = f
      this._runtime = f = f.GetRuntime()
      this._index = h
      this._sid = 4 <= g.length ? g[3] : -1
      this._actionReturnType = 5 <= g.length ? g[4] : 0
      this._behaviorType = this._objectClass = this._func = null
      this._behaviorIndex = -1
      this._systemPlugin = null
      this._callFunctionName = ''
      this._combinedSolModifiers = this._callEventBlock = null
      this.DebugRun = this.Run = c
      this._parameters = []
      this._results = []
      this._anyParamVariesPerInstance = !1
      this._unsavedData = this._savedData = null
      const k = (h = -3 === g[0]) ? g[2] : g[5]
      this._debugData =
        f.IsDebug() || h
          ? {
              isBreakpoint: k[0],
              canDebug: k[1],
              index: k[2]
            }
          : null
      ;-1 === g[0]
        ? ((this._systemPlugin = f.GetSystemPlugin()), (this._func = f.GetObjectReference(g[1])))
        : -2 === g[0]
        ? (this._callFunctionName = g[1])
        : h
        ? ((this._func = f.GetObjectReference(g[1])), (this.Run = this.RunUserScript), (this.DebugRun = this.DebugRunUserScript), (this._actionReturnType = 1))
        : ((this._func = f.GetObjectReference(g[1])), (this._objectClass = f.GetObjectClassByIndex(g[0])), g[2] && ((this._behaviorType = this._objectClass.GetBehaviorTypeByName(g[2])), (this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(g[2]))))
      if (7 === g.length) {
        g = g[6]
        for (const m of g) this._parameters.push(e.Parameter.Create(this, m, this._parameters.length)), this._results.push(0)
      }
      0 === this._parameters.length && (this._results = this._parameters = a)
      this._eventBlock.GetEventSheetManager()._RegisterAction(this)
    }
    static Create(f, g, h) {
      return e.New(e.Action, f, g, h)
    }
    _PostInit() {
      for (var f of this._parameters) f._PostInit(), f.VariesPerInstance() && (this._anyParamVariesPerInstance = !0)
      if (this._systemPlugin) this._SetSystemRunMethod(), (this.DebugRun = this._DebugRunSystem)
      else if (this._callFunctionName) this._SetCallFunctionRunMethod(), (this._callFunctionName = '')
      else if (this.Run === this.RunUserScript) {
        f = this._func
        const g = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock)
        this._func = f.bind(null, this._runtime.GetIRuntime(), g)
      } else
        this._behaviorType
          ? this.IsAsync()
            ? ((this.Run = this._RunBehavior_Async), (this.DebugRun = this._DebugRunBehavior_Async))
            : ((this.Run = this._RunBehavior), (this.DebugRun = this._DebugRunBehavior))
          : this._objectClass.GetPlugin().IsSingleGlobal()
          ? (this._SetSingleGlobalRunMethod(), (this.DebugRun = this._DebugRunSingleGlobal))
          : this.IsAsync()
          ? ((this.Run = this._RunObject_Async), (this.DebugRun = this._DebugRunObject_Async))
          : this._parameters.length
          ? this._parameters.every(g => g.VariesPerInstance())
            ? ((this.Run = this._RunObject_AllParamsVary), (this.DebugRun = this._DebugRunObject_AllParamsVary))
            : this._anyParamVariesPerInstance
            ? ((this.Run = this._RunObject_SomeParamsVary), (this.DebugRun = this._DebugRunObject_SomeParamsVary))
            : this._parameters.every(g => g.IsConstant())
            ? (b(this._parameters, this._results), (this.Run = this._RunObject_ParamsConst), (this.DebugRun = this._DebugRunObject_ParamsConst))
            : ((this.Run = this._RunObject_ParamsDontVary), (this.DebugRun = this._DebugRunObject_ParamsDontVary))
          : ((this.Run = this._RunObject_ParamsConst), (this.DebugRun = this._DebugRunObject_ParamsConst))
    }
    _SetSystemRunMethod() {
      this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod() {
      const f = this._objectClass.GetPlugin(),
        g = this._objectClass.GetSingleGlobalInstance().GetSdkInstance()
      this._SetRunMethodForBoundFunc(f, g, this._RunSingleGlobal)
    }
    _SetCallFunctionRunMethod() {
      const f = this._eventBlock.GetEventSheetManager(),
        g = f.GetFunctionBlockByName(this._callFunctionName)
      g.IsEnabled()
        ? ((this._callEventBlock = g.GetEventBlock()),
          (this._combinedSolModifiers = [...new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents()])]),
          (this._combinedSolModifiers = f._DeduplicateSolModifierList(this._combinedSolModifiers)),
          (this.Run = e.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, this._combinedSolModifiers, this._parameters)),
          (this.DebugRun = this._DebugRunCallFunction))
        : ((this.Run = c), (this.DebugRun = d))
    }
    _SetRunMethodForBoundFunc(f, g, h) {
      const k = this._func,
        m = this._parameters
      if (0 === m.length) this.Run = f._GetBoundACEMethod(k, g)
      else if (1 === m.length) {
        const r = m[0]
        if (r.IsConstant()) this.Run = f._GetBoundACEMethod_1param(k, g, r.Get(0))
        else {
          const w = f._GetBoundACEMethod(k, g)
          this.Run = function () {
            return w(r.Get(0))
          }
        }
      } else if (2 === m.length) {
        const r = m[0],
          w = m[1]
        if (r.IsConstant() && w.IsConstant()) this.Run = f._GetBoundACEMethod_2params(k, g, r.Get(0), w.Get(0))
        else {
          const p = f._GetBoundACEMethod(k, g)
          this.Run = function () {
            return p(r.Get(0), w.Get(0))
          }
        }
      } else if (3 === m.length) {
        const r = m[0],
          w = m[1],
          p = m[2]
        if (r.IsConstant() && w.IsConstant() && p.IsConstant()) this.Run = f._GetBoundACEMethod_3params(k, g, r.Get(0), w.Get(0), p.Get(0))
        else {
          const q = f._GetBoundACEMethod(k, g)
          this.Run = function () {
            return q(r.Get(0), w.Get(0), p.Get(0))
          }
        }
      } else this.Run = h
    }
    GetSID() {
      return this._sid
    }
    IsAsync() {
      return 1 === this._actionReturnType
    }
    CanBailOut() {
      return 2 === this._actionReturnType
    }
    HasReturnType() {
      return 0 !== this._actionReturnType
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetEventBlock() {
      return this._eventBlock
    }
    GetRuntime() {
      return this._runtime
    }
    GetIndex() {
      return this._index
    }
    GetDebugIndex() {
      return this._debugData.index
    }
    GetCombinedSolModifiers() {
      return this._combinedSolModifiers
    }
    IsBreakpoint() {
      return this._debugData.isBreakpoint
    }
    _SetBreakpoint(f) {
      this._debugData.isBreakpoint = !!f
      this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator() {
      return this._debugData.canDebug
    }
    DebugCanRunFast() {
      return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map())
      return this._savedData
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map())
      return this._unsavedData
    }
    _RunSystem() {
      const f = this._results
      b(this._parameters, f)
      return this._func.apply(this._systemPlugin, f)
    }
    *_DebugRunSystem() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._results
        b(this._parameters, f)
        return yield* this._func.apply(this._systemPlugin, f)
      }
      return this.Run()
    }
    *_DebugRunCallFunction() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      return yield* this._callEventBlock.DebugRunAsFunctionCall(this._combinedSolModifiers, this._parameters)
    }
    _RunSingleGlobal() {
      const f = this._results
      b(this._parameters, f)
      return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), f)
    }
    *_DebugRunSingleGlobal() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._results
        b(this._parameters, f)
        return yield* this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), f)
      }
      return this.Run()
    }
    _RunObject_ParamsConst() {
      const f = this._results,
        g = this._objectClass.GetCurrentSol().GetInstances()
      for (let h = 0, k = g.length; h < k; ++h) this._func.apply(g[h].GetSdkInstance(), f)
    }
    *_DebugRunObject_ParamsConst() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._results,
          g = this._objectClass.GetCurrentSol().GetInstances()
        for (let h = 0, k = g.length; h < k; ++h) yield* this._func.apply(g[h].GetSdkInstance(), f)
      } else this._RunObject_ParamsConst()
    }
    _RunObject_ParamsDontVary() {
      const f = this._results
      b(this._parameters, f)
      const g = this._objectClass.GetCurrentSol().GetInstances()
      for (let h = 0, k = g.length; h < k; ++h) this._func.apply(g[h].GetSdkInstance(), f)
    }
    *_DebugRunObject_ParamsDontVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._results
        b(this._parameters, f)
        const g = this._objectClass.GetCurrentSol().GetInstances()
        for (let h = 0, k = g.length; h < k; ++h) yield* this._func.apply(g[h].GetSdkInstance(), f)
      } else this._RunObject_ParamsDontVary()
    }
    _RunObject_AllParamsVary() {
      const f = this._parameters,
        g = this._results,
        h = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances()
      for (let m = 0, r = k.length; m < r; ++m) {
        const w = k[m]
        for (let p = 0, q = f.length; p < q; ++p) g[p] = f[p].Get(m)
        h.apply(w.GetSdkInstance(), g)
      }
    }
    *_DebugRunObject_AllParamsVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._parameters,
          g = this._results,
          h = this._func,
          k = this._objectClass.GetCurrentSol().GetInstances()
        for (let m = 0, r = k.length; m < r; ++m) {
          const w = k[m]
          for (let p = 0, q = f.length; p < q; ++p) g[p] = f[p].Get(m)
          yield* h.apply(w.GetSdkInstance(), g)
        }
      } else this._RunObject_AllParamsVary()
    }
    _RunObject_SomeParamsVary() {
      const f = this._parameters,
        g = this._results,
        h = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances()
      for (let r = 0, w = f.length; r < w; ++r) {
        var m = f[r]
        m.VariesPerInstance() || (g[r] = m.Get(0))
      }
      for (let r = 0, w = k.length; r < w; ++r) {
        m = k[r]
        for (let p = 0, q = f.length; p < q; ++p) {
          const t = f[p]
          t.VariesPerInstance() && (g[p] = t.Get(r))
        }
        h.apply(m.GetSdkInstance(), g)
      }
    }
    *_DebugRunObject_SomeParamsVary() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const g = this._parameters,
          h = this._results,
          k = this._func,
          m = this._objectClass.GetCurrentSol().GetInstances()
        for (let r = 0, w = g.length; r < w; ++r) {
          var f = g[r]
          f.VariesPerInstance() || (h[r] = f.Get(0))
        }
        for (let r = 0, w = m.length; r < w; ++r) {
          f = m[r]
          for (let p = 0, q = g.length; p < q; ++p) {
            const t = g[p]
            t.VariesPerInstance() && (h[p] = t.Get(r))
          }
          yield* k.apply(f.GetSdkInstance(), h)
        }
      } else this._RunObject_SomeParamsVary()
    }
    _RunBehavior() {
      var f = this._objectClass
      const g = f.IsFamily(),
        h = f.GetFamilyIndex(),
        k = this._parameters,
        m = this._anyParamVariesPerInstance,
        r = this._results,
        w = this._func,
        p = this._behaviorIndex
      f = f.GetCurrentSol().GetInstances()
      for (let x = 0, v = k.length; x < v; ++x) {
        var q = k[x]
        q.VariesPerInstance() || (r[x] = q.Get(0))
      }
      for (let x = 0, v = f.length; x < v; ++x) {
        q = f[x]
        if (m)
          for (let u = 0, A = k.length; u < A; ++u) {
            var t = k[u]
            t.VariesPerInstance() && (r[u] = t.Get(x))
          }
        t = g ? q.GetObjectClass().GetFamilyBehaviorOffset(h) : 0
        w.apply(q.GetBehaviorInstances()[p + t].GetSdkInstance(), r)
      }
    }
    *_DebugRunBehavior() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        var f = this._objectClass
        const k = f.IsFamily(),
          m = f.GetFamilyIndex(),
          r = this._parameters,
          w = this._anyParamVariesPerInstance,
          p = this._results,
          q = this._func,
          t = this._behaviorIndex
        f = f.GetCurrentSol().GetInstances()
        for (let x = 0, v = r.length; x < v; ++x) {
          var g = r[x]
          g.VariesPerInstance() || (p[x] = g.Get(0))
        }
        for (let x = 0, v = f.length; x < v; ++x) {
          g = f[x]
          if (w)
            for (let u = 0, A = r.length; u < A; ++u) {
              var h = r[u]
              h.VariesPerInstance() && (p[u] = h.Get(x))
            }
          h = k ? g.GetObjectClass().GetFamilyBehaviorOffset(m) : 0
          yield* q.apply(g.GetBehaviorInstances()[t + h].GetSdkInstance(), p)
        }
      } else this._RunBehavior()
    }
    _RunObject_Async() {
      const f = this._parameters,
        g = this._results,
        h = this._func,
        k = this._objectClass.GetCurrentSol().GetInstances(),
        m = []
      for (let r = 0, w = k.length; r < w; ++r) {
        const p = k[r]
        for (let q = 0, t = f.length; q < t; ++q) g[q] = f[q].Get(r)
        m.push(h.apply(p.GetSdkInstance(), g))
      }
      return Promise.all(m)
    }
    *_DebugRunObject_Async() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        const f = this._parameters,
          g = this._results,
          h = this._func,
          k = this._objectClass.GetCurrentSol().GetInstances(),
          m = []
        for (let r = 0, w = k.length; r < w; ++r) {
          const p = k[r]
          for (let q = 0, t = f.length; q < t; ++q) g[q] = f[q].Get(r)
          m.push(yield* h.apply(p.GetSdkInstance(), g))
        }
        return Promise.all(m)
      }
      return this._RunObject_Async()
    }
    _RunBehavior_Async() {
      var f = this._objectClass
      const g = f.IsFamily(),
        h = f.GetFamilyIndex(),
        k = this._parameters,
        m = this._results,
        r = this._func,
        w = this._behaviorIndex
      f = f.GetCurrentSol().GetInstances()
      const p = []
      for (let q = 0, t = f.length; q < t; ++q) {
        const x = f[q]
        for (let u = 0, A = k.length; u < A; ++u) m[u] = k[u].Get(q)
        const v = g ? x.GetObjectClass().GetFamilyBehaviorOffset(h) : 0
        p.push(r.apply(x.GetBehaviorInstances()[w + v].GetSdkInstance(), m))
      }
      return Promise.all(p)
    }
    *_DebugRunBehavior_Async() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      if (this._DebugReturnsGenerator()) {
        var f = this._objectClass
        const g = f.IsFamily(),
          h = f.GetFamilyIndex(),
          k = this._parameters,
          m = this._results,
          r = this._func,
          w = this._behaviorIndex
        f = f.GetCurrentSol().GetInstances()
        const p = []
        for (let q = 0, t = f.length; q < t; ++q) {
          const x = f[q]
          for (let u = 0, A = k.length; u < A; ++u) m[u] = k[u].Get(q)
          const v = g ? x.GetObjectClass().GetFamilyBehaviorOffset(h) : 0
          p.push(yield* r.apply(x.GetBehaviorInstances()[w + v].GetSdkInstance(), m))
        }
        return Promise.all(p)
      }
      return this._RunBehavior_Async()
    }
    async RunUserScript() {
      try {
        await this._func()
      } catch (f) {
        console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, 'font-size: 1.2em; font-weight: bold;', f),
          self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
          e.EventScript.HadUserScriptException() || (console.info('%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()', 'font-weight: bold; text-decoration: underline', '', 'font-weight: bold'), e.EventScript.SetHadUserScriptException())
      }
    }
    *DebugRunUserScript() {
      if (this.IsBreakpoint() || this._runtime.DebugBreakNext()) yield this
      return this.RunUserScript()
    }
    _SaveToJson() {
      return this._savedData && this._savedData.size
        ? {
            ex: e.ToSuperJSON(this._savedData)
          }
        : null
    }
    _LoadFromJson(f) {
      this._savedData && (this._savedData.clear(), (this._savedData = null))
      f && (f = f.ex) && (this._savedData = e.FromSuperJSON(f))
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new e.Color()

  function a(O, Q) {
    return e.compare(this.GetWorldInfo().GetX(), O, Q)
  }

  function c(O, Q) {
    return e.compare(this.GetWorldInfo().GetY(), O, Q)
  }

  function d() {
    const O = this.GetWorldInfo()
    return O.IsInViewport(O.GetLayer().GetViewport(), O.GetLayout().HasVanishingPointOutsideViewport())
  }

  function f() {
    var O = this.GetWorldInfo()
    const Q = O.GetLayout()
    O = O.GetBoundingBox()
    return 0 > O.getRight() || 0 > O.getBottom() || O.getLeft() > Q.GetWidth() || O.getTop() > Q.GetHeight()
  }

  function g(O, Q, Y) {
    const ba = this.GetCurrentSol(),
      fa = ba.GetInstances()
    if (!fa.length) return !1
    let ha = fa[0]
    var ea = ha.GetWorldInfo()
    let ua = ha,
      sa = e.distanceSquared(ea.GetX(), ea.GetY(), Q, Y)
    for (let xa = 1, Ha = fa.length; xa < Ha; ++xa) if (((ha = fa[xa]), (ea = ha.GetWorldInfo()), (ea = e.distanceSquared(ea.GetX(), ea.GetY(), Q, Y)), (0 === O && ea < sa) || (1 === O && ea > sa))) (sa = ea), (ua = ha)
    ba.PickOne(ua)
    return !0
  }

  function h(O) {
    const Q = this.GetWorldInfo()
    Q.GetX() !== O && (Q.SetX(O), Q.SetBboxChanged())
  }

  function k(O) {
    const Q = this.GetWorldInfo()
    Q.GetY() !== O && (Q.SetY(O), Q.SetBboxChanged())
  }

  function m(O, Q) {
    const Y = this.GetWorldInfo()
    Y.EqualsXY(O, Q) || (Y.SetXY(O, Q), Y.SetBboxChanged())
  }

  function r(O, Q) {
    if (O && (O = O.GetPairedInstance(this._inst))) {
      var [Y, ba] = O.GetImagePoint(Q)
      Q = this.GetWorldInfo()
      if (Q.GetX() !== Y || Q.GetY() !== ba) Q.SetXY(Y, ba), Q.SetBboxChanged()
    }
  }

  function w(O) {
    if (0 !== O) {
      var Q = this.GetWorldInfo()
      Q.OffsetXY(Q.GetCosAngle() * O, Q.GetSinAngle() * O)
      Q.SetBboxChanged()
    }
  }

  function p(O, Q) {
    if (0 !== Q) {
      var Y = this.GetWorldInfo()
      O = e.toRadians(O)
      Y.OffsetXY(Math.cos(O) * Q, Math.sin(O) * Q)
      Y.SetBboxChanged()
    }
  }

  function q() {
    return this.GetWorldInfo().GetX()
  }

  function t() {
    return this.GetWorldInfo().GetY()
  }

  function x() {
    return this._runtime.GetDt(this._inst)
  }

  function v(O, Q) {
    return e.compare(this.GetWorldInfo().GetWidth(), O, Q)
  }

  function u(O, Q) {
    return e.compare(this.GetWorldInfo().GetHeight(), O, Q)
  }

  function A(O) {
    const Q = this.GetWorldInfo()
    Q.GetWidth() !== O && (Q.SetWidth(O), Q.SetBboxChanged())
  }

  function z(O) {
    const Q = this.GetWorldInfo()
    Q.GetHeight() !== O && (Q.SetHeight(O), Q.SetBboxChanged())
  }

  function C(O, Q) {
    const Y = this.GetWorldInfo()
    if (Y.GetWidth() !== O || Y.GetHeight() !== Q) Y.SetSize(O, Q), Y.SetBboxChanged()
  }

  function E() {
    return this.GetWorldInfo().GetWidth()
  }

  function J() {
    return this.GetWorldInfo().GetHeight()
  }

  function F() {
    return this.GetWorldInfo().GetBoundingBox().getLeft()
  }

  function I() {
    return this.GetWorldInfo().GetBoundingBox().getTop()
  }

  function L() {
    return this.GetWorldInfo().GetBoundingBox().getRight()
  }

  function N() {
    return this.GetWorldInfo().GetBoundingBox().getBottom()
  }

  function S(O, Q) {
    return e.angleDiff(this.GetWorldInfo().GetAngle(), e.toRadians(Q)) <= e.toRadians(O)
  }

  function V(O) {
    return e.angleClockwise(this.GetWorldInfo().GetAngle(), e.toRadians(O))
  }

  function U(O, Q) {
    O = e.toRadians(O)
    Q = e.toRadians(Q)
    const Y = this.GetWorldInfo().GetAngle()
    return e.angleClockwise(Q, O) ? e.angleClockwise(Y, O) && !e.angleClockwise(Y, Q) : !(!e.angleClockwise(Y, O) && e.angleClockwise(Y, Q))
  }

  function X(O) {
    const Q = this.GetWorldInfo()
    O = e.clampAngle(e.toRadians(O))
    isNaN(O) || Q.GetAngle() === O || (Q.SetAngle(O), Q.SetBboxChanged())
  }

  function ia(O) {
    if (!isNaN(O) && 0 !== O) {
      var Q = this.GetWorldInfo()
      Q.SetAngle(Q.GetAngle() + e.toRadians(O))
      Q.SetBboxChanged()
    }
  }

  function ka(O) {
    if (!isNaN(O) && 0 !== O) {
      var Q = this.GetWorldInfo()
      Q.SetAngle(Q.GetAngle() - e.toRadians(O))
      Q.SetBboxChanged()
    }
  }

  function ya(O, Q) {
    const Y = this.GetWorldInfo(),
      ba = Y.GetAngle()
    O = e.angleRotate(ba, e.toRadians(Q), e.toRadians(O))
    isNaN(O) || ba === O || (Y.SetAngle(O), Y.SetBboxChanged())
  }

  function ta(O, Q, Y) {
    const ba = this.GetWorldInfo(),
      fa = ba.GetAngle()
    Q -= ba.GetX()
    Y -= ba.GetY()
    O = e.angleRotate(fa, Math.atan2(Y, Q), e.toRadians(O))
    isNaN(O) || fa === O || (ba.SetAngle(O), ba.SetBboxChanged())
  }

  function Ba(O, Q) {
    const Y = this.GetWorldInfo(),
      ba = Y.GetAngle()
    O -= Y.GetX()
    Q -= Y.GetY()
    Q = Math.atan2(Q, O)
    isNaN(Q) || ba === Q || (Y.SetAngle(Q), Y.SetBboxChanged())
  }

  function Ea() {
    return e.toDegrees(this.GetWorldInfo().GetAngle())
  }

  function Ca(O, Q) {
    return e.compare(e.round6dp(100 * this.GetWorldInfo().GetOpacity()), O, Q)
  }

  function Aa() {
    return this.GetWorldInfo().IsVisible()
  }

  function ja(O) {
    const Q = this.GetWorldInfo()
    O = 2 === O ? !Q.IsVisible() : 0 !== O
    Q.IsVisible() !== O && (Q.SetVisible(O), this._runtime.UpdateRender())
  }

  function Fa(O) {
    O = e.clamp(O / 100, 0, 1)
    const Q = this.GetWorldInfo()
    Q.GetOpacity() !== O && (Q.SetOpacity(O), this._runtime.UpdateRender())
  }

  function wa(O) {
    b.setFromRgbValue(O)
    O = this.GetWorldInfo()
    O.GetUnpremultipliedColor().equalsIgnoringAlpha(b) || (O.SetUnpremultipliedColor(b), this._runtime.UpdateRender())
  }

  function Da() {
    const O = this.GetWorldInfo().GetUnpremultipliedColor()
    return e.PackRGBAEx(O.getR(), O.getG(), O.getB(), O.getA())
  }

  function Pa() {
    return e.round6dp(100 * this.GetWorldInfo().GetOpacity())
  }

  function Qa(O) {
    return O ? this.GetWorldInfo().GetLayer() === O : !1
  }

  function Ra(O) {
    const Q = this.GetCurrentSol(),
      Y = Q.GetInstances()
    if (!Y.length) return !1
    let ba = Y[0]
    for (let fa = 1, ha = Y.length; fa < ha; ++fa) {
      const ea = Y[fa],
        ua = ea.GetWorldInfo(),
        sa = ba.GetWorldInfo(),
        xa = ua.GetLayer().GetIndex(),
        Ha = sa.GetLayer().GetIndex()
      if (0 === O) {
        if (xa > Ha || (xa === Ha && ua.GetZIndex() > sa.GetZIndex())) ba = ea
      } else if (xa < Ha || (xa === Ha && ua.GetZIndex() < sa.GetZIndex())) ba = ea
    }
    Q.PickOne(ba)
    return !0
  }

  function Ja(O, Q, Y) {
    const ba = this.GetWorldInfo()
    O = 0 === O ? ba.GetZElevation() : ba.GetTotalZElevation()
    return e.compare(O, Q, Y)
  }

  function Sa() {
    this.GetWorldInfo().ZOrderMoveToTop()
  }

  function Ta() {
    this.GetWorldInfo().ZOrderMoveToBottom()
  }

  function Ua(O) {
    O && this.GetWorldInfo().ZOrderMoveToLayer(O)
  }

  function Va(O, Q) {
    O = 0 === O
    Q && (Q = Q.GetFirstPicked(this.GetInstance())) && this.GetWorldInfo().ZOrderMoveAdjacentToInstance(Q, O)
  }

  function Wa(O) {
    const Q = this.GetWorldInfo()
    Q.GetZElevation() !== O && (Q.SetZElevation(O), this._runtime.UpdateRender())
  }

  function Xa() {
    return this.GetWorldInfo().GetLayer().GetIndex()
  }

  function Ya() {
    return this.GetWorldInfo().GetLayer().GetName()
  }

  function Ka() {
    return this.GetWorldInfo().GetZIndex()
  }

  function Za() {
    return this.GetWorldInfo().GetZElevation()
  }

  function $a() {
    return this.GetWorldInfo().GetTotalZElevation()
  }

  function ab(O, Q) {
    if ((Q = this.GetObjectClass().GetEffectList().GetEffectTypeByName(Q))) {
      Q = Q.GetIndex()
      O = 1 === O
      var Y = this.GetWorldInfo().GetInstanceEffectList()
      Y.IsEffectIndexActive(Q) !== O && (Y.SetEffectIndexActive(Q, O), Y.UpdateActiveEffects(), this._runtime.UpdateRender())
    }
  }

  function bb(O, Q, Y) {
    var ba = this.GetObjectClass().GetEffectList().GetEffectTypeByName(O)
    if (ba) {
      O = ba.GetIndex()
      var fa = this.GetWorldInfo().GetInstanceEffectList(),
        ha = fa.GetEffectParametersForIndex(O)
      Q = Math.floor(Q)
      if (!(0 > Q || Q >= ha.length)) {
        ba = ba.GetShaderProgram().GetParameterType(Q)
        if ('color' === ba) {
          b.setFromRgbValue(Y)
          Q = ha[Q]
          if (b.equalsIgnoringAlpha(Q)) return
          Q.copyRgb(b)
        } else {
          'percent' === ba && (Y /= 100)
          if (ha[Q] === Y) return
          ha[Q] = Y
        }
        fa.IsEffectIndexActive(O) && this._runtime.UpdateRender()
      }
    }
  }

  function cb() {
    return this.GetWorldInfo().HasParent()
  }

  function db() {
    return this.GetWorldInfo().HasChildren()
  }

  function eb(O, Q) {
    const Y = this.GetCurrentSol().GetInstances()
    if (0 === Y.length) return !1
    const ba = O.GetCurrentSol()
    var fa = ba.GetInstances()
    if (0 === fa.length) return !1
    fa = new Set(fa)
    const ha = new Set()
    for (let ua = 0, sa = Y.length; ua < sa; ++ua) {
      var ea = Y[ua]
      if (1 === Q) for (const xa of ea.parents()) xa.BelongsToObjectClass(O) && fa.has(xa) && ha.add(xa)
      else {
        if (0 === Q) {
          if (((ea = ea.GetParent()), null === ea)) continue
        } else ea = ea.GetTopParent()
        ea.BelongsToObjectClass(O) && fa.has(ea) && ha.add(ea)
      }
    }
    if (0 === ha.size) return !1
    ba.SetSetPicked(ha)
    O.ApplySolToContainer()
    return !0
  }

  function fb(O, Q) {
    const Y = this.GetCurrentSol().GetInstances()
    if (0 === Y.length) return !1
    const ba = O.GetCurrentSol()
    var fa = ba.GetInstances()
    if (ba.IsSelectAll()) {
      var ha = [...this._runtime.instancesPendingCreateForObjectClass(O)]
      0 < ha.length && (fa = fa.concat(ha))
    }
    if (0 === fa.length) return !1
    fa = new Set(fa)
    ha = new Set()
    for (let ea = 0, ua = Y.length; ea < ua; ++ea) {
      const sa = Y[ea]
      2 === Q && !sa.HasChildren() && sa.BelongsToObjectClass(O) && fa.has(sa) && ha.add(sa)
      for (const xa of 0 === Q ? sa.children() : sa.allChildren()) (2 === Q && xa.HasChildren()) || (xa.BelongsToObjectClass(O) && fa.has(xa) && ha.add(xa))
    }
    if (0 === ha.size) return !1
    ba.SetSetPicked(ha)
    O.ApplySolToContainer()
    return !0
  }

  function gb(O, Q) {
    const Y = this.GetCurrentSol().GetInstances()
    if (0 === Y.length) return !1
    const ba = O.GetCurrentSol()
    var fa = ba.GetInstances()
    if (ba.IsSelectAll()) {
      var ha = [...this._runtime.instancesPendingCreateForObjectClass(O)]
      0 < ha.length && (fa = fa.concat(ha))
    }
    if (0 === fa.length) return !1
    fa = new Set(fa)
    ha = []
    for (let ea = 0, ua = Y.length; ea < ua; ++ea) {
      const sa = Y[ea].GetChildAt(Q)
      null !== sa && sa.BelongsToObjectClass(O) && fa.has(sa) && ha.push(sa)
    }
    if (0 === ha.length) return !1
    ba.SetArrayPicked(ha)
    O.ApplySolToContainer()
    return !0
  }

  function hb(O, Q) {
    return e.compare(this._inst.GetChildCount(), O, Q)
  }

  function ib(O, Q, Y, ba, fa, ha, ea, ua) {
    const sa = this._inst,
      xa = this._runtime.GetCurrentAction().GetObjectClass()
    for (const Ha of O.allCorrespondingInstances(sa, xa)) {
      if (!Ha.GetPlugin().SupportsSceneGraph()) break
      sa.AddChild(Ha, {
        transformX: Q,
        transformY: Y,
        transformWidth: ba,
        transformHeight: fa,
        transformAngle: ha,
        transformZElevation: ea,
        destroyWithParent: ua
      })
    }
  }

  function jb(O) {
    const Q = this._inst,
      Y = this._runtime.GetCurrentAction().GetObjectClass()
    for (const ba of O.allCorrespondingInstances(Q, Y)) Q.RemoveChild(ba)
  }

  function na() {
    this._inst.HasParent() && this._inst.GetParent().RemoveChild(this._inst)
  }

  function Ga() {
    return this._inst.GetChildCount()
  }

  function kb(O, Q) {
    O = Math.floor(O)
    Q = Math.floor(Q)
    const Y = this.GetWorldInfo()
    2 > O || 2 > Q || !isFinite(O) || !isFinite(Q) ? (Y.ReleaseMesh(), Y.SetBboxChanged()) : Y.CreateMesh(O, Q)
  }

  function lb(O, Q, Y, ba, fa, ha, ea, ua) {
    const sa = this.GetWorldInfo()
    sa.SetMeshPoint(O, Q, {
      mode: 0 === Y ? 'absolute' : 'relative',
      x: ba,
      y: fa,
      zElevation: ha,
      u: ea,
      v: ua
    }) && sa.SetBboxChanged()
  }

  function mb() {
    const O = this.GetWorldInfo()
    return O.HasMesh() ? O.GetSourceMesh().GetHSize() : 0
  }

  function nb() {
    const O = this.GetWorldInfo()
    return O.HasMesh() ? O.GetSourceMesh().GetVSize() : 0
  }

  function ob(O) {
    const Q = this.GetWorldInfo()
    O = 2 === O ? !Q.IsVisible() : 0 !== O
    Q.IsVisible() !== O && Q.SetVisible(O)
  }

  function pb(O, Q) {
    this.SetElementCSSStyle(O, Q)
  }

  function La(O, Q) {
    this.SetElementAttribute(O, '' + Q)
  }

  function Ma(O) {
    this.RemoveElementAttribute(O)
  }

  function Na() {
    this.FocusElement()
  }

  function Oa() {
    this.BlurElement()
  }

  function Ia() {
    return this.IsElementFocused()
  }

  function l(O) {
    this._SetEnabled(0 !== O)
  }

  function n() {
    return this._IsEnabled()
  }

  function y(O, Q, Y) {
    return e.compare(this.GetInstance().GetInstanceVariableValue(O), Q, Y)
  }

  function B(O) {
    return !!this.GetInstance().GetInstanceVariableValue(O)
  }

  function D(O, Q) {
    const Y = this.GetCurrentSol(),
      ba = Y.GetInstances()
    if (!ba.length) return !1
    let fa = ba[0],
      ha = fa,
      ea = fa.GetInstanceVariableValue(Q)
    for (let ua = 1, sa = ba.length; ua < sa; ++ua) {
      fa = ba[ua]
      const xa = fa.GetInstanceVariableValue(Q)
      if ((0 === O && xa < ea) || (1 === O && xa > ea)) (ea = xa), (ha = fa)
    }
    Y.PickOne(ha)
    return !0
  }

  function G(O) {
    return this._runtime.GetCurrentCondition().IsInverted() ? K(this, O) : H(this, O)
  }

  function H(O, Q) {
    Q = O.GetRuntime().GetInstanceByUID(Q)
    if (!Q) return !1
    const Y = O.GetCurrentSol()
    if (!Y.IsSelectAll() && !Y._GetOwnInstances().includes(Q)) return !1
    if (O.IsFamily()) {
      if (Q.GetObjectClass().BelongsToFamily(O)) return Y.PickOne(Q), O.ApplySolToContainer(), !0
    } else if (Q.GetObjectClass() === O) return Y.PickOne(Q), O.ApplySolToContainer(), !0
    return !1
  }

  function K(O, Q) {
    const Y = O.GetCurrentSol()
    if (Y.IsSelectAll()) {
      Y._SetSelectAll(!1)
      Y.ClearArrays()
      var ba = O.GetInstances()
      for (let ha = 0, ea = ba.length; ha < ea; ++ha) {
        var fa = ba[ha]
        fa.GetUID() === Q ? Y._PushElseInstance(fa) : Y._PushInstance(fa)
      }
      O.ApplySolToContainer()
      return !!Y._GetOwnInstances().length
    }
    ba = Y._GetOwnInstances()
    fa = 0
    for (let ha = 0, ea = ba.length; ha < ea; ++ha) {
      const ua = ba[ha]
      ba[fa] = ua
      ua.GetUID() === Q ? Y._PushElseInstance(ua) : ++fa
    }
    e.truncateArray(ba, fa)
    O.ApplySolToContainer()
    return !!ba.length
  }

  function M() {
    this._runtime.DestroyInstance(this._inst)
  }

  function P() {
    return !0
  }

  function R() {
    return !0
  }

  function T(O, Q) {
    this.GetInstance().SetInstanceVariableValue(O, Q)
  }

  function Z(O, Q) {
    const Y = this.GetInstance(),
      ba = Y.GetInstanceVariableValue(O)
    'number' === typeof ba && 'number' !== typeof Q ? (Q = parseFloat(Q)) : 'string' === typeof ba && 'string' !== typeof Q && (Q = Q.toString())
    Y.SetInstanceVariableValue(O, ba + Q)
  }

  function W(O, Q) {
    const Y = this.GetInstance(),
      ba = Y.GetInstanceVariableValue(O)
    'number' === typeof ba && ('number' !== typeof Q && (Q = parseFloat(Q)), Y.SetInstanceVariableValue(O, ba - Q))
  }

  function da(O, Q) {
    this.GetInstance().SetInstanceVariableValue(O, Q ? 1 : 0)
  }

  function ca(O) {
    const Q = this.GetInstance()
    Q.SetInstanceVariableValue(O, 0 === Q.GetInstanceVariableValue(O) ? 1 : 0)
  }

  function aa(O) {
    let Q
    try {
      Q = JSON.parse(O)
    } catch (Y) {
      console.error('Failed to load from JSON string: ', Y)
      return
    }
    O = this.GetInstance()
    O._OnBeforeLoad('state')
    O.LoadFromJson(Q, 'state')
  }

  function ra() {
    return JSON.stringify(this.GetInstance().SaveToJson('state'))
  }

  function ma() {
    return this.GetInstance().GetObjectClass().GetName()
  }

  function pa() {
    const O = this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass()
    let Q = O.GetInstanceCount()
    for (const Y of this._runtime.instancesPendingCreateForObjectClass(O)) ++Q
    return Q
  }

  function qa() {
    return this._runtime.GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
  }

  function oa() {
    return this._inst.GetIID()
  }

  function za() {
    return this._inst.GetUID()
  }
  e.AddCommonACEs = function (O, Q) {
    const Y = O[1],
      ba = O[4],
      fa = O[5],
      ha = O[6],
      ea = O[7],
      ua = O[8],
      sa = O[10],
      xa = O[11],
      Ha = O[12],
      qb = O[13],
      rb = O[14],
      va = Q.Cnds,
      la = Q.Acts
    Q = Q.Exps
    O[3] && ((va.CompareX = a), (va.CompareY = c), (va.IsOnScreen = d), (va.IsOutsideLayout = f), (va.PickDistance = g), (la.SetX = h), (la.SetY = k), (la.SetPos = m), (la.SetPosToObject = r), (la.MoveForward = w), (la.MoveAtAngle = p), (Q.X = q), (Q.Y = t), (Q.dt = x))
    ba && ((va.CompareWidth = v), (va.CompareHeight = u), (la.SetWidth = A), (la.SetHeight = z), (la.SetSize = C), (Q.Width = E), (Q.Height = J), (Q.BBoxLeft = F), (Q.BBoxTop = I), (Q.BBoxRight = L), (Q.BBoxBottom = N))
    fa && ((va.AngleWithin = S), (va.IsClockwiseFrom = V), (va.IsBetweenAngles = U), (la.SetAngle = X), (la.RotateClockwise = ia), (la.RotateCounterclockwise = ka), (la.RotateTowardAngle = ya), (la.RotateTowardPosition = ta), (la.SetTowardPosition = Ba), (Q.Angle = Ea))
    ha && ((va.IsVisible = Aa), (va.CompareOpacity = Ca), (la.SetVisible = ja), (la.SetOpacity = Fa), (la.SetDefaultColor = wa), (Q.Opacity = Pa), (Q.ColorValue = Da))
    ea &&
      ((va.IsOnLayer = Qa),
      (va.PickTopBottom = Ra),
      (va.CompareZElevation = Ja),
      (la.MoveToTop = Sa),
      (la.MoveToBottom = Ta),
      (la.MoveToLayer = Ua),
      (la.ZMoveToObject = Va),
      (la.SetZElevation = Wa),
      (Q.LayerNumber = Xa),
      (Q.LayerName = Ya),
      (Q.ZIndex = Ka),
      (Q.ZElevation = Za),
      (Q.TotalZElevation = $a))
    ua && ((la.SetEffectEnabled = ab), (la.SetEffectParam = bb))
    qb && ((va.HasParent = cb), (va.HasChildren = db), (va.PickParent = eb), (va.PickChildren = fb), (va.PickNthChild = gb), (va.CompareChildCount = hb), (la.AddChild = ib), (la.RemoveChild = jb), (la.RemoveFromParent = na), (Q.ChildCount = Ga))
    rb && ((la.SetMeshSize = kb), (la.SetMeshPoint = lb), (Q.MeshColumns = mb), (Q.MeshRows = nb))
    sa && ((va.IsVisible = Aa), (la.SetVisible = ob), (la.SetCSSStyle = pb), (la.SetElemAttribute = La), (la.RemoveElemAttribute = Ma))
    xa && ((va.IsFocused = Ia), (la.SetFocus = Na), (la.SetBlur = Oa))
    Ha && ((va.IsEnabled = n), (la.SetEnabled = l))
    Y ||
      ((va.CompareInstanceVar = y),
      (va.IsBoolInstanceVarSet = B),
      (va.PickInstVarHiLow = D),
      (va.PickByUID = G),
      (la.SetInstanceVar = T),
      (la.AddInstanceVar = Z),
      (la.SubInstanceVar = W),
      (la.SetBoolInstanceVar = da),
      (la.ToggleBoolInstanceVar = ca),
      (va.OnCreated = P),
      (va.OnDestroyed = R),
      (la.Destroy = M),
      la.LoadFromJsonString || (la.LoadFromJsonString = aa),
      Q.AsJSON || (Q.AsJSON = ra),
      (Q.Count = pa),
      (Q.PickedCount = qa),
      (Q.IID = oa),
      (Q.UID = za),
      (Q.ObjectTypeName = ma))
  }
}
{
  ;('use strict')
  const e = self.C3
  e.ScheduledWait = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._eventSheetManager = b
      this._type = ''
      this._time = -1
      this._signalTag = ''
      this._isSignalled = !1
      this._event = null
      this._actIndex = 0
      this._solModifiers = []
      this._sols = new Map()
      this._callingFunctionBlock = null
      this._asyncId = -1
      this._functionInnerLocalVars = this._functionParameters = null
      this._shouldRelease = !1
    }
    Release() {
      this._type = ''
      this._time = -1
      this._signalTag = ''
      this._functionInnerLocalVars = this._functionParameters = this._callingFunctionBlock = this._event = null
      this._asyncId = -1
      e.clearArray(this._solModifiers)
      for (const b of this._sols.values()) b.Release()
      this._sols.clear()
    }
    _Init() {
      var b = this._eventSheetManager,
        a = b.GetRuntime().GetAllObjectClasses()
      const c = b.GetCurrentEventStackFrame()
      this._event = c.GetCurrentEvent()
      this._actIndex = c.GetActionIndex() + 1
      if ((b = b.FindFirstFunctionBlockParent(this._event)))
        (this._callingFunctionBlock = b), (this._functionParameters = b.CaptureFunctionParameters()), (this._functionInnerLocalVars = b._GetAllInnerLocalVariables().map(d => d.GetValue())), b.IsAsync() && (this._asyncId = b.PauseCurrentAsyncFunction())
      for (const d of a) if (((a = d.GetCurrentSol()), !a.IsSelectAll() || this._event.HasSolModifier(d))) this._solModifiers.push(d), this._sols.set(d, e.New(e.SolState, a))
    }
    InitTimer(b) {
      this._type = 'timer'
      this._Init()
      this._time = this._eventSheetManager.GetRuntime().GetGameTime() + b
    }
    InitSignal(b) {
      this._type = 'signal'
      this._Init()
      this._signalTag = b.toLowerCase()
    }
    InitPromise(b) {
      this._type = 'promise'
      this._Init()
      b.then(() => this.SetSignalled()).catch(a => {
        console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", a)
        this.SetSignalled()
      })
    }
    IsTimer() {
      return 'timer' === this._type
    }
    IsSignal() {
      return 'signal' === this._type
    }
    IsPromise() {
      return 'promise' === this._type
    }
    GetSignalTag() {
      return this._signalTag
    }
    IsSignalled() {
      return this._isSignalled
    }
    SetSignalled() {
      this._isSignalled = !0
    }
    _ShouldRun() {
      return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() : this.IsSignalled()
    }
    _RestoreState(b) {
      b._Restore(this._event, this._actIndex)
      for (const [a, c] of this._sols.entries()) (b = a.GetCurrentSol()), c._Restore(b)
      if ((b = this._callingFunctionBlock)) b.SetFunctionParameters(this._functionParameters), b._GetAllInnerLocalVariables().map((a, c) => a.SetValue(this._functionInnerLocalVars[c])), b.IsAsync() && b.ResumeAsyncFunction(this._asyncId)
    }
    _Run(b) {
      this._RestoreState(b)
      this._event._ResumeActionsAndSubEvents(b)
      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId)
      this._eventSheetManager.ClearSol(this._solModifiers)
      this._shouldRelease = !0
    }
    async _DebugRun(b) {
      this._RestoreState(b)
      for (const a of this._event._DebugResumeActionsAndSubEvents(b)) await this._eventSheetManager.GetRuntime().DebugBreak(a)
      this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId)
      this._eventSheetManager.ClearSol(this._solModifiers)
      this._shouldRelease = !0
    }
    ShouldRelease() {
      return this._shouldRelease
    }
    RemoveInstances(b) {
      for (const a of this._sols.values()) a.RemoveInstances(b)
    }
    _SaveToJson() {
      const b = {},
        a = {
          t: this._time,
          st: this._signalTag,
          s: this._isSignalled,
          ev: this._event.GetSID(),
          sm: this._solModifiers.map(c => c.GetSID()),
          sols: b
        }
      this._event._HasActionIndex(this._actIndex) && (a.act = this._event.GetActionAt(this._actIndex).GetSID())
      for (const [c, d] of this._sols) b[c.GetSID().toString()] = d._SaveToJson()
      return a
    }
    static _CreateFromJson(b, a) {
      const c = b.GetRuntime()
      var d = b.GetEventBlockBySID(a.ev)
      if (!d) return null
      let f = 0
      if (a.hasOwnProperty('act')) {
        var g = b.GetActionBySID(a.act)
        if (!g) return null
        f = g.GetIndex()
      }
      g = e.New(e.ScheduledWait, b)
      g._time = a.t
      g._type = -1 === g._time ? 'signal' : 'timer'
      g._signalTag = a.st
      g._isSignalled = a.s
      g._event = d
      g._actIndex = f
      for (var h of a.sm) (d = c.GetObjectClassBySID(h)) && g._solModifiers.push(d)
      for (const [k, m] of Object.entries(a.sols)) if (((a = parseInt(k, 10)), (a = c.GetObjectClassBySID(a)))) (h = e.New(e.SolState, null)), h._LoadFromJson(b, m), g._sols.set(a, h)
      return g
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SolState = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._objectClass = null
      this._isSelectAll = !0
      this._instances = []
      b && ((this._objectClass = b.GetObjectClass()), (this._isSelectAll = b.IsSelectAll()), e.shallowAssignArray(this._instances, b._GetOwnInstances()))
    }
    Release() {
      this._objectClass = null
      e.clearArray(this._instances)
    }
    _Restore(b) {
      b._SetSelectAll(this._isSelectAll)
      e.shallowAssignArray(b._GetOwnInstances(), this._instances)
    }
    RemoveInstances(b) {
      e.arrayRemoveAllInSet(this._instances, b)
    }
    _SaveToJson() {
      return {
        sa: this._isSelectAll,
        insts: this._instances.map(b => b.GetUID())
      }
    }
    _LoadFromJson(b, a) {
      b = b.GetRuntime()
      this._isSelectAll = !!a.sa
      e.clearArray(this._instances)
      for (const c of a.insts) (a = b.GetInstanceByUID(c)) && this._instances.push(a)
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a, c) {
    let d = a.get(c)
    d || ((d = new Map()), a.set(c, d))
    return d
  }
  e.SDKPluginBase = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._runtime = a.runtime
      this._isSingleGlobal = !!a.isSingleGlobal
      this._isWorldType = !!a.isWorld
      this._isRotatable = !!a.isRotatable
      this._mustPredraw = !!a.mustPredraw
      this._hasEffects = !!a.hasEffects
      this._supportsSceneGraph = !!a.supportsSceneGraph
      this._supportsMesh = !!a.supportsMesh
      this._singleGlobalObjectClass = null
      this._boundACEMethodCache = new Map()
      this._boundACEMethodCache_1param = new Map()
      this._boundACEMethodCache_2params = new Map()
      this._boundACEMethodCache_3params = new Map()
    }
    Release() {
      this._runtime = null
    }
    GetRuntime() {
      return this._runtime
    }
    OnCreate() {}
    IsSingleGlobal() {
      return this._isSingleGlobal
    }
    IsWorldType() {
      return this._isWorldType
    }
    IsRotatable() {
      return this._isRotatable
    }
    MustPreDraw() {
      return this._mustPredraw
    }
    HasEffects() {
      return this._hasEffects
    }
    SupportsSceneGraph() {
      return this._supportsSceneGraph
    }
    SupportsMesh() {
      return this._supportsMesh
    }
    _GetBoundACEMethod(a, c) {
      if (!c) throw Error("missing 'this' binding")
      let d = this._boundACEMethodCache.get(a)
      if (d) return d
      d = a.bind(c)
      this._boundACEMethodCache.set(a, d)
      return d
    }
    _GetBoundACEMethod_1param(a, c, d) {
      if (!c) throw Error("missing 'this' binding")
      const f = b(this._boundACEMethodCache_1param, a)
      let g = f.get(d)
      if (g) return g
      g = a.bind(c, d)
      f.set(d, g)
      return g
    }
    _GetBoundACEMethod_2params(a, c, d, f) {
      if (!c) throw Error("missing 'this' binding")
      var g = b(this._boundACEMethodCache_2params, a)
      g = b(g, d)
      let h = g.get(f)
      if (h) return h
      h = a.bind(c, d, f)
      g.set(f, h)
      return h
    }
    _GetBoundACEMethod_3params(a, c, d, f, g) {
      if (!c) throw Error("missing 'this' binding")
      var h = b(this._boundACEMethodCache_3params, a)
      h = b(h, d)
      h = b(h, f)
      let k = h.get(g)
      if (k) return k
      k = a.bind(c, d, f, g)
      h.set(g, k)
      return k
    }
    _SetSingleGlobalObjectClass(a) {
      if (!this.IsSingleGlobal()) throw Error('must be single-global plugin')
      this._singleGlobalObjectClass = a
    }
    GetSingleGlobalObjectClass() {
      if (!this.IsSingleGlobal()) throw Error('must be single-global plugin')
      return this._singleGlobalObjectClass
    }
    GetSingleGlobalInstance() {
      if (!this.IsSingleGlobal()) throw Error('must be single-global plugin')
      return this._singleGlobalObjectClass.GetSingleGlobalInstance()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKDOMPluginBase = class extends e.SDKPluginBase {
    constructor(b, a) {
      super(b)
      this._domComponentId = a
      this._nextElementId = 0
      this._instMap = new Map()
      this.AddElementMessageHandler('elem-focused', c => c._OnElemFocused())
      this.AddElementMessageHandler('elem-blurred', c => {
        c && c._OnElemBlurred()
      })
    }
    Release() {
      super.Release()
    }
    _AddElement(b) {
      const a = this._nextElementId++
      this._instMap.set(a, b)
      return a
    }
    _RemoveElement(b) {
      this._instMap.delete(b)
    }
    AddElementMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, c => {
        const d = this._instMap.get(c.elementId)
        a(d, c)
      })
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKTypeBase = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._objectClass = b
      this._runtime = b.GetRuntime()
      this._plugin = b.GetPlugin()
    }
    Release() {
      this._plugin = this._runtime = this._objectClass = null
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetRuntime() {
      return this._runtime
    }
    GetPlugin() {
      return this._plugin
    }
    GetImageInfo() {
      return this._objectClass.GetImageInfo()
    }
    FinishCondition(b) {}
    LoadTextures(b) {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances(b) {}
    LoadTilemapData() {}
    GetScriptInterfaceClass() {
      return null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKInstanceBase = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._inst = b
      this._domComponentId = a
      this._runtime = b.GetRuntime()
      this._objectClass = this._inst.GetObjectClass()
      this._sdkType = this._objectClass.GetSdkType()
      this._tick2Func = this._tickFunc = null
      this._isTicking2 = this._isTicking = !1
      this._disposables = null
      this._wasReleased = !1
    }
    Release() {
      this._wasReleased = !0
      this._StopTicking()
      this._StopTicking2()
      this._tick2Func = this._tickFunc = null
      this._disposables && (this._disposables.Release(), (this._disposables = null))
      this._sdkType = this._objectClass = this._runtime = this._inst = null
    }
    WasReleased() {
      return this._wasReleased
    }
    GetInstance() {
      return this._inst
    }
    GetRuntime() {
      return this._runtime
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetPlugin() {
      return this._sdkType.GetPlugin()
    }
    GetSdkType() {
      return this._sdkType
    }
    GetScriptInterface() {
      return this._inst.GetInterfaceClass()
    }
    Trigger(b) {
      return this._runtime.Trigger(b, this._inst, null)
    }
    DebugTrigger(b) {
      return this._runtime.DebugTrigger(b, this._inst, null)
    }
    TriggerAsync(b) {
      return this._runtime.TriggerAsync(b, this._inst, null)
    }
    FastTrigger(b, a) {
      return this._runtime.FastTrigger(b, this._inst, a)
    }
    DebugFastTrigger(b, a) {
      return this._runtime.DebugFastTrigger(b, this._inst, a)
    }
    ScheduleTriggers(b) {
      return this._runtime.ScheduleTriggers(b)
    }
    AddDOMMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, a)
    }
    AddDOMMessageHandlers(b) {
      for (const [a, c] of b) this.AddDOMMessageHandler(a, c)
    }
    PostToDOM(b, a) {
      this._runtime.PostComponentMessageToDOM(this._domComponentId, b, a)
    }
    PostToDOMAsync(b, a) {
      return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, b, a)
    }
    _PostToDOMMaybeSync(b, a) {
      if (this._runtime.IsInWorker()) this.PostToDOM(b, a)
      else
        return window.c3_runtimeInterface._OnMessageFromRuntime({
          type: 'event',
          component: this._domComponentId,
          handler: b,
          data: a,
          responseId: null
        })
    }
    Tick() {}
    Tick2() {}
    _StartTicking() {
      this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener('tick', this._tickFunc), (this._isTicking = !0))
    }
    _StopTicking() {
      this._isTicking && (this._runtime.Dispatcher().removeEventListener('tick', this._tickFunc), (this._isTicking = !1))
    }
    IsTicking() {
      return this._isTicking
    }
    _StartTicking2() {
      this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener('tick2', this._tick2Func), (this._isTicking2 = !0))
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime.Dispatcher().removeEventListener('tick2', this._tick2Func), (this._isTicking2 = !1))
    }
    IsTicking2() {
      return this._isTicking2
    }
    GetDebuggerProperties() {
      return []
    }
    SaveToJson() {
      return null
    }
    LoadFromJson(b) {}
    GetPropertyValueByIndex(b) {}
    SetPropertyValueByIndex(b, a) {}
    OffsetPropertyValueByIndex(b, a) {
      if (0 !== a) {
        var c = this.GetPropertyValueByIndex(b)
        if ('number' !== typeof c) throw Error('expected number')
        this.SetPropertyValueByIndex(b, c + a)
      }
    }
    SetPropertyColorOffsetValueByIndex(b, a, c, d) {}
    CallAction(b, ...a) {
      b.call(this, ...a)
    }
    CallExpression(b, ...a) {
      return b.call(this, ...a)
    }
    GetScriptInterfaceClass() {
      return null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKWorldInstanceBase = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, a)
      this._worldInfo = b.GetWorldInfo()
      this._webglcontextrestored_handler = this._webglcontextlost_handler = null
    }
    Release() {
      if (this._webglcontextlost_handler) {
        const b = this._runtime.Dispatcher()
        b.removeEventListener('webglcontextlost', this._webglcontextlost_handler)
        b.removeEventListener('webglcontextrestored', this._webglcontextrestored_handler)
        this._webglcontextrestored_handler = this._webglcontextlost_handler = null
      }
      this._worldInfo = null
      super.Release()
    }
    HandleWebGLContextLoss() {
      if (!this._webglcontextlost_handler) {
        this._webglcontextlost_handler = () => this.OnWebGLContextLost()
        this._webglcontextrestored_handler = () => this.OnWebGLContextRestored()
        var b = this._runtime.Dispatcher()
        b.addEventListener('webglcontextlost', this._webglcontextlost_handler)
        b.addEventListener('webglcontextrestored', this._webglcontextrestored_handler)
      }
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    GetWorldInfo() {
      return this._worldInfo
    }
    IsOriginalSizeKnown() {
      return !1
    }
    GetOriginalWidth() {
      if (!this.IsOriginalSizeKnown()) throw Error('original size not known')
      const b = this.GetCurrentImageInfo()
      if (b) return b.GetWidth()
    }
    GetOriginalHeight() {
      if (!this.IsOriginalSizeKnown()) throw Error('original size not known')
      const b = this.GetCurrentImageInfo()
      if (b) return b.GetHeight()
    }
    GetCurrentImageInfo() {
      return null
    }
    GetCurrentSurfaceSize() {
      var b = this.GetCurrentImageInfo()
      return b && (b = b.GetTexture()) ? [b.GetWidth(), b.GetHeight()] : [100, 100]
    }
    GetCurrentTexRect() {
      const b = this.GetCurrentImageInfo()
      return b ? b.GetTexRect() : null
    }
    GetImagePoint(b) {
      b = this._inst.GetWorldInfo()
      return [b.GetX(), b.GetY()]
    }
    LoadTilemapData(b, a, c) {}
    TestPointOverlapTile(b, a) {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Rect)
  e.SDKDOMInstanceBase = class extends e.SDKWorldInstanceBase {
    constructor(a, c) {
      super(a, c)
      this._elementId = this.GetPlugin()._AddElement(this)
      this._isElementShowing = !0
      this._autoFontSize = this._elemHasFocus = !1
      this._lastRect = e.New(e.Rect, 0, 0, -1, -1)
      a = this._runtime.GetCanvasManager()
      this._lastWindowWidth = a.GetLastWidth()
      this._lastWindowHeight = a.GetLastHeight()
      this._isPendingUpdateState = !1
      this._StartTicking()
    }
    Release() {
      this.GetPlugin()._RemoveElement(this._elementId)
      this.PostToDOMElement('destroy')
      this._elementId = -1
      super.Release()
    }
    _GetElementInDOMMode() {
      if (this._runtime.IsInWorker()) throw Error('not valid in worker mode')
      return this._PostToDOMElementMaybeSync('get-element')
    }
    PostToDOMElement(a, c) {
      c || (c = {})
      c.elementId = this._elementId
      this.PostToDOM(a, c)
    }
    _PostToDOMElementMaybeSync(a, c) {
      c || (c = {})
      c.elementId = this._elementId
      return this._PostToDOMMaybeSync(a, c)
    }
    PostToDOMElementAsync(a, c) {
      c || (c = {})
      c.elementId = this._elementId
      return this.PostToDOMAsync(a, c)
    }
    CreateElement(a) {
      a || (a = {})
      const c = this.GetWorldInfo().IsVisible()
      a.elementId = this._elementId
      a.isVisible = c
      Object.assign(a, this.GetElementState())
      this._isElementShowing = !!a.isVisible
      this._PostToDOMMaybeSync('create', a)
      this._UpdatePosition(!0)
    }
    SetElementVisible(a) {
      a = !!a
      this._isElementShowing !== a &&
        ((this._isElementShowing = a),
        this.PostToDOMElement('set-visible', {
          isVisible: a
        }))
    }
    Tick() {
      this._UpdatePosition(!1)
    }
    _ShouldPreserveElement() {
      const a = this._runtime.GetCanvasManager().GetFullscreenMode()
      return 'Android' === e.Platform.OS && ('scale-inner' === a || 'scale-outer' === a || 'crop' === a)
    }
    _UpdatePosition(a) {
      var c = this.GetWorldInfo()
      const d = c.GetLayer()
      var f = c.GetX(),
        g = c.GetY()
      let [h, k] = d.LayerToCanvasCss(f, g),
        [m, r] = d.LayerToCanvasCss(f + c.GetWidth(), g + c.GetHeight())
      f = this._runtime.GetCanvasManager()
      g = f.GetCssWidth()
      const w = f.GetCssHeight()
      if (c.IsVisible() && d.IsVisible()) {
        if (!this._ShouldPreserveElement()) {
          if (0 >= m || 0 >= r || h >= g || k >= w) {
            this.SetElementVisible(!1)
            return
          }
          1 > h && (h = 1)
          1 > k && (k = 1)
          m >= g && (m = g - 1)
          r >= w && (r = w - 1)
        }
        b.set(h, k, m, r)
        c = f.GetLastWidth()
        g = f.GetLastHeight()
        !a && b.equals(this._lastRect) && this._lastWindowWidth === c && this._lastWindowHeight === g
          ? this.SetElementVisible(!0)
          : (this._lastRect.copy(b),
            (this._lastWindowWidth = c),
            (this._lastWindowHeight = g),
            this.SetElementVisible(!0),
            (a = null),
            this._autoFontSize && (a = d.GetDisplayScale() - 0.2),
            this.PostToDOMElement('update-position', {
              left: Math.round(this._lastRect.getLeft()) + f.GetCanvasClientX(),
              top: Math.round(this._lastRect.getTop()) + f.GetCanvasClientY(),
              width: Math.round(this._lastRect.width()),
              height: Math.round(this._lastRect.height()),
              fontSize: a
            }))
      } else this.SetElementVisible(!1)
    }
    FocusElement() {
      this._PostToDOMElementMaybeSync('focus', {
        focus: !0
      })
    }
    BlurElement() {
      this._PostToDOMElementMaybeSync('focus', {
        focus: !1
      })
    }
    _OnElemFocused() {
      this._elemHasFocus = !0
    }
    _OnElemBlurred() {
      this._elemHasFocus = !1
    }
    IsElementFocused() {
      return this._elemHasFocus
    }
    SetElementCSSStyle(a, c) {
      this.PostToDOMElement('set-css-style', {
        prop: e.CSSToCamelCase(a),
        val: c
      })
    }
    SetElementAttribute(a, c) {
      this.PostToDOMElement('set-attribute', {
        name: a,
        val: c
      })
    }
    RemoveElementAttribute(a) {
      this.PostToDOMElement('remove-attribute', {
        name: a
      })
    }
    UpdateElementState() {
      this._isPendingUpdateState ||
        ((this._isPendingUpdateState = !0),
        Promise.resolve().then(() => {
          this._isPendingUpdateState = !1
          this.PostToDOMElement('update-state', this.GetElementState())
        }))
    }
    GetElementState() {}
    GetElementId() {
      return this._elementId
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.IBehavior
  e.SDKBehaviorBase = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._runtime = a.runtime
      this._myObjectClasses = e.New(e.ArraySet)
      this._myInstances = e.New(e.ArraySet)
      this._iBehavior = null
      this._scriptInterfaceClass = a.scriptInterfaceClass || null
    }
    Release() {
      this._myInstances.Release()
      this._myObjectClasses.Release()
      this._runtime = null
    }
    GetRuntime() {
      return this._runtime
    }
    OnCreate() {}
    _AddObjectClass(a) {
      this._myObjectClasses.Add(a)
    }
    GetObjectClasses() {
      return this._myObjectClasses.GetArray()
    }
    _AddInstance(a) {
      this._myInstances.Add(a)
    }
    _RemoveInstance(a) {
      this._myInstances.Delete(a)
    }
    GetInstances() {
      return this._myInstances.GetArray()
    }
    GetIBehavior() {
      if (null === this._iBehavior) {
        const a = this._scriptInterfaceClass
        if (a) {
          if (((this._iBehavior = new a(this)), !(this._iBehavior instanceof b))) throw new TypeError('script interface class must derive from IBehavior')
        } else this._iBehavior = new b(this)
      }
      return this._iBehavior
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKBehaviorTypeBase = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._runtime = b.GetRuntime()
      this._behaviorType = b
      this._objectClass = b.GetObjectClass()
      this._behavior = b.GetBehavior()
      this._behavior._AddObjectClass(this._objectClass)
    }
    Release() {
      this._behavior = this._objectClass = this._behaviorType = this._runtime = null
    }
    GetBehaviorType() {
      return this._behaviorType
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetRuntime() {
      return this._runtime
    }
    GetBehavior() {
      return this._behavior
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SDKBehaviorInstanceBase = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._behInst = b
      this._domComponentId = a
      this._inst = b.GetObjectInstance()
      this._runtime = b.GetRuntime()
      this._behaviorType = b.GetBehaviorType()
      this._sdkType = this._behaviorType.GetSdkType()
      this._isPostTicking = this._isTicking2 = this._isTicking = !1
      this._disposables = null
    }
    Release() {
      this._StopTicking()
      this._StopTicking2()
      this._StopPostTicking()
      this._disposables && (this._disposables.Release(), (this._disposables = null))
      this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
    }
    GetBehavior() {
      return this._behaviorType.GetBehavior()
    }
    GetBehaviorInstance() {
      return this._behInst
    }
    GetObjectInstance() {
      return this._inst
    }
    GetObjectClass() {
      return this._inst.GetObjectClass()
    }
    GetWorldInfo() {
      return this._inst.GetWorldInfo()
    }
    GetRuntime() {
      return this._runtime
    }
    GetBehaviorType() {
      return this._behaviorType
    }
    GetSdkType() {
      return this._sdkType
    }
    GetScriptInterface() {
      return this._behInst.GetScriptInterface()
    }
    Trigger(b) {
      return this._runtime.Trigger(b, this._inst, this._behaviorType)
    }
    DebugTrigger(b) {
      return this._runtime.DebugTrigger(b, this._inst, this._behaviorType)
    }
    TriggerAsync(b) {
      return this._runtime.TriggerAsync(b, this._inst, this._behaviorType)
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking() {
      this._isTicking || (this._runtime._AddBehInstToTick(this), (this._isTicking = !0))
    }
    _StopTicking() {
      this._isTicking && (this._runtime._RemoveBehInstToTick(this), (this._isTicking = !1))
    }
    IsTicking() {
      return this._isTicking
    }
    _StartTicking2() {
      this._isTicking2 || (this._runtime._AddBehInstToTick2(this), (this._isTicking2 = !0))
    }
    _StopTicking2() {
      this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), (this._isTicking2 = !1))
    }
    IsTicking2() {
      return this._isTicking2
    }
    _StartPostTicking() {
      this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), (this._isPostTicking = !0))
    }
    _StopPostTicking() {
      this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), (this._isPostTicking = !1))
    }
    IsPostTicking() {
      return this._isPostTicking
    }
    GetDebuggerProperties() {
      return []
    }
    AddDOMMessageHandler(b, a) {
      this._runtime.AddDOMComponentMessageHandler(this._domComponentId, b, a)
    }
    OnSpriteFrameChanged(b, a) {}
    SaveToJson() {
      return null
    }
    LoadFromJson(b) {}
    GetPropertyValueByIndex(b) {}
    SetPropertyValueByIndex(b, a) {}
    OffsetPropertyValueByIndex(b, a) {
      if (0 !== a) {
        var c = this.GetPropertyValueByIndex(b)
        if ('number' !== typeof c) throw Error('expected number')
        this.SetPropertyValueByIndex(b, c + a)
      }
    }
    SetPropertyColorOffsetValueByIndex(b, a, c, d) {}
    CallAction(b, ...a) {
      b.call(this, ...a)
    }
    CallExpression(b, ...a) {
      return b.call(this, ...a)
    }
    GetScriptInterfaceClass() {
      return null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins = {}
  e.Behaviors = {}
  e.PluginManager = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._runtime = b
      this._allPlugins = []
      this._pluginsByCtor = new Map()
      this._systemPlugin = null
      this._allBehaviors = []
      this._behaviorsByCtor = new Map()
      this._jumpthruBehavior = this._solidBehavior = null
    }
    CreatePlugin(b) {
      const a = this._runtime.GetObjectReference(b[0])
      if (!a) throw Error('missing plugin')
      e.AddCommonACEs(b, a)
      b = e.New(a, {
        runtime: this._runtime,
        isSingleGlobal: b[1],
        isWorld: b[2],
        isRotatable: b[5],
        hasEffects: b[8],
        mustPredraw: b[9],
        supportsSceneGraph: b[13],
        supportsMesh: b[14]
      })
      b.OnCreate()
      this._allPlugins.push(b)
      this._pluginsByCtor.set(a, b)
    }
    CreateSystemPlugin() {
      this._systemPlugin = e.New(e.Plugins.System, {
        runtime: this._runtime,
        isSingleGlobal: !0
      })
      this._systemPlugin.OnCreate()
    }
    CreateBehavior(b) {
      b = this._runtime.GetObjectReference(b[1])
      if (!b) throw Error('missing behavior')
      const a = e.New(b, {
        runtime: this._runtime
      })
      a.OnCreate()
      this._allBehaviors.push(a)
      this._behaviorsByCtor.set(b, a)
      !this._solidBehavior && e.Behaviors.solid && a instanceof e.Behaviors.solid ? (this._solidBehavior = a) : !this._jumpthruBehavior && e.Behaviors.jumpthru && a instanceof e.Behaviors.jumpthru && (this._jumpthruBehavior = a)
    }
    GetPluginByConstructorFunction(b) {
      return this._pluginsByCtor.get(b) || null
    }
    HasBehaviorByConstructorFunction(b) {
      return this._behaviorsByCtor.has(b)
    }
    GetBehaviorByConstructorFunction(b) {
      return this._behaviorsByCtor.get(b) || null
    }
    GetSystemPlugin() {
      return this._systemPlugin
    }
    GetSolidBehavior() {
      return this._solidBehavior
    }
    GetJumpthruBehavior() {
      return this._jumpthruBehavior
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set()
  e.ImageInfo = class extends e.DefendedBase {
    constructor() {
      super()
      this._url = ''
      this._height = this._width = this._offsetY = this._offsetX = this._pixelFormat = this._size = 0
      this._hasMetaData = !1
      this._imageAsset = null
      this._textureState = ''
      this._rcTex = e.New(e.Rect)
      b.add(this)
    }
    Release() {
      this.ReleaseTexture()
      this._imageAsset = null
      b.delete(this)
    }
    static OnWebGLContextLost() {
      for (const a of b) (a._textureState = ''), a._rcTex.set(0, 0, 0, 0)
    }
    LoadData(a) {
      this._url = a[0]
      this._size = a[1]
      this._pixelFormat = a[2]
      this._offsetX = a[3]
      this._offsetY = a[4]
      this._width = a[5]
      this._height = a[6]
      this._hasMetaData = !0
    }
    LoadAnimationFrameData(a) {
      this._url = a[0]
      this._size = a[1]
      this._offsetX = a[2]
      this._offsetY = a[3]
      this._width = a[4]
      this._height = a[5]
      this._pixelFormat = a[11]
      this._hasMetaData = !0
    }
    LoadDynamicAsset(a, c) {
      if (this._imageAsset) throw Error('already loaded asset')
      this._url = c
      const d = {}
      e.IsAbsoluteURL(c) && (d.loadPolicy = 'remote')
      this.LoadAsset(a, d)
      return this._imageAsset.Load()
    }
    ReplaceWith(a) {
      if (a === this) throw Error('cannot replace with self')
      this.ReleaseTexture()
      this._url = a._url
      this._size = a._size
      this._pixelFormat = a._pixelFormat
      this._offsetX = a._offsetX
      this._offsetY = a._offsetY
      this._width = a._width
      this._height = a._height
      this._hasMetaData = a._hasMetaData
      this._imageAsset = a._imageAsset
      this._textureState = a._textureState
      this._rcTex = a._rcTex
    }
    GetURL() {
      return this._url
    }
    GetSize() {
      return this._size
    }
    GetPixelFormat() {
      return this._pixelFormat
    }
    GetOffsetX() {
      return this._offsetX
    }
    GetOffsetY() {
      return this._offsetY
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    GetSheetWidth() {
      return this._imageAsset.GetWidth()
    }
    GetSheetHeight() {
      return this._imageAsset.GetHeight()
    }
    LoadAsset(a, c) {
      if (this._imageAsset) throw Error('already got asset')
      c = Object.assign({}, c, {
        url: this.GetURL(),
        size: this.GetSize()
      })
      this._imageAsset = a.LoadImage(c)
    }
    IsLoaded() {
      return this._imageAsset && this._imageAsset.IsLoaded()
    }
    async LoadStaticTexture(a, c) {
      if (!this._imageAsset) throw Error('no asset')
      if (this._textureState) throw Error('already loaded texture')
      this._textureState = 'loading'
      a = await this._imageAsset.LoadStaticTexture(a, c)
      if (!a) return (this._textureState = ''), null
      this._textureState = 'loaded'
      this._hasMetaData || ((this._width = a.GetWidth()), (this._height = a.GetHeight()), (this._hasMetaData = !0))
      this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + this._width, this._offsetY + this._height)
      this._rcTex.divide(a.GetWidth(), a.GetHeight())
      return a
    }
    ReleaseTexture() {
      this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(), (this._textureState = ''), this._rcTex.set(0, 0, 0, 0))
    }
    GetTexture() {
      return this._imageAsset ? this._imageAsset.GetTexture() : null
    }
    GetTexRect() {
      return this._rcTex
    }
    async ExtractImageToCanvas() {
      const a = await this._imageAsset.LoadToDrawable(),
        c = e.CreateCanvas(this._width, this._height)
      c.getContext('2d').drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height)
      return c
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.AnimationInfo = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._name = b[0]
      this._speed = b[1]
      this._isLooping = !!b[2]
      this._repeatCount = b[3]
      this._repeatTo = b[4]
      this._isPingPong = !!b[5]
      this._sid = b[6]
      this._frames = b[7].map(a => e.New(e.AnimationFrameInfo, a))
    }
    Release() {
      for (const b of this._frames) b.Release()
      e.clearArray(this._frames)
    }
    LoadAllAssets(b) {
      for (const a of this._frames) a.GetImageInfo().LoadAsset(b)
    }
    LoadAllTextures(b, a) {
      return Promise.all(this._frames.map(c => c.GetImageInfo().LoadStaticTexture(b, a)))
    }
    ReleaseAllTextures() {
      for (const b of this._frames) b.GetImageInfo().ReleaseTexture()
    }
    GetName() {
      return this._name
    }
    GetSID() {
      return this._sid
    }
    GetFrameCount() {
      return this._frames.length
    }
    GetFrames() {
      return this._frames
    }
    GetFrameAt(b) {
      b = Math.floor(b)
      if (0 > b || b >= this._frames.length) throw new RangeError('invalid frame')
      return this._frames[b]
    }
    GetSpeed() {
      return this._speed
    }
    IsLooping() {
      return this._isLooping
    }
    GetRepeatCount() {
      return this._repeatCount
    }
    GetRepeatTo() {
      return this._repeatTo
    }
    IsPingPong() {
      return this._isPingPong
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.AnimationFrameInfo = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._imageInfo = e.New(e.ImageInfo)
      this._imageInfo.LoadAnimationFrameData(b)
      this._duration = b[6]
      this._origin = e.New(e.Vector2, b[7], b[8])
      this._imagePoints = b[9].map(a => e.New(e.ImagePoint, this, a))
      this._imagePointsByName = new Map()
      for (const a of this._imagePoints) this._imagePointsByName.set(a.GetName().toLowerCase(), a)
      this._collisionPoly = null
      b = b[10]
      6 <= b.length && (this._collisionPoly = e.New(e.CollisionPoly, b))
    }
    Release() {
      this._collisionPoly && (this._collisionPoly.Release(), (this._collisionPoly = null))
      this._imageInfo.Release()
      this._imageInfo = null
    }
    GetImageInfo() {
      return this._imageInfo
    }
    GetDuration() {
      return this._duration
    }
    GetOriginX() {
      return this._origin.getX()
    }
    GetOriginY() {
      return this._origin.getY()
    }
    GetCollisionPoly() {
      return this._collisionPoly
    }
    GetImagePointByName(b) {
      return this._imagePointsByName.get(b.toLowerCase()) || null
    }
    GetImagePointByIndex(b) {
      b = Math.floor(b)
      return 0 > b || b >= this._imagePoints.length ? null : this._imagePoints[b]
    }
    GetImagePointCount() {
      return this._imagePoints.length
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.ImagePoint = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._afi = b
      this._name = a[0]
      this._pos = e.New(e.Vector2, a[1], a[2])
    }
    Release() {}
    GetName() {
      return this._name
    }
    GetX() {
      return this._pos.getX()
    }
    GetY() {
      return this._pos.getY()
    }
    GetVec2() {
      return this._pos
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3Debugger,
    a = self.IObjectClass
  e.ObjectClass = class extends e.DefendedBase {
    constructor(c, d, f) {
      super()
      const g = c.GetObjectReference(f[1])
      this._runtime = c
      this._plugin = c.GetPluginManager().GetPluginByConstructorFunction(g)
      this._sdkType = null
      this._instSdkCtor = g.Instance
      this._index = d
      this._sid = f[11]
      this._name = f[0]
      this._jsPropName = this._runtime.GetJsPropName(f[14])
      this._isGlobal = !!f[9]
      this._isFamily = !!f[2]
      this._isOnLoaderLayout = !!f[10]
      this._instVars = f[3].map(h => ({
        sid: h[0],
        type: h[1],
        name: h[2],
        jsPropName: c.GetJsPropName(h[3])
      }))
      this._behaviorsCount = f[4]
      this._effectsCount = f[5]
      this._isWorldType = this._plugin.IsWorldType()
      this._effectList = null
      this._collisionGrid = e.New(e.SparseGrid, c.GetOriginalViewportWidth(), c.GetOriginalViewportHeight())
      this._anyCollisionCellChanged = !0
      this._anyInstanceParallaxed = !1
      this._familyMembersSet = this._familyMembers = null
      this._familyIndex = -1
      this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet = this._families = null
      this._isInContainer = !1
      this._container = null
      this._behaviorTypes = f[8].map(h => e.BehaviorType.Create(this, h))
      this._behaviorTypesIncludingInherited = []
      this._behaviorsByName = new Map()
      this._behaviorNameToIndex = new Map()
      this._usedBehaviorCtors = new Set()
      this._solStack = e.New(e.SolStack, this)
      this._defaultInstanceData = null
      this._defaultLayerIndex = 0
      this._isContained = !1
      this._animationsBySid = this._animationsByName = this._animations = this._imageInfo = this._container = null
      this._textureRefCount = 0
      this._savedData = new Map()
      this._unsavedData = new Map()
      this._instances = []
      this._iidsStale = !0
      this._plugin.HasEffects() && (this._effectList = e.New(e.EffectList, this, f[12]))
      f[6] && ((this._imageInfo = e.New(e.ImageInfo)), this._imageInfo.LoadData(f[6]))
      if (f[7]) {
        this._animations = f[7].map(h => e.New(e.AnimationInfo, h))
        this._animationsByName = new Map()
        this._animationsBySid = new Map()
        for (const h of this._animations) this._animationsByName.set(h.GetName().toLowerCase(), h), this._animationsBySid.set(h.GetSID(), h)
      }
      this._isFamily ? ((this._familyMembers = []), (this._familyMembersSet = new Set()), (this._familyIndex = this._runtime._GetNextFamilyIndex())) : ((this._families = []), (this._familiesSet = new Set()), (this._familyInstVarMap = []), (this._familyBehaviorMap = []), (this._familyEffectMap = []))
      this._sdkType = e.New(g.Type, this, f[15])
      this._instanceUserScriptClass = this._iObjectClass = null
      this._userScriptDispatcher = e.New(e.Event.Dispatcher)
      if ((d = this._sdkType.GetScriptInterfaceClass())) {
        if (((this._iObjectClass = new d(this)), !(this._iObjectClass instanceof a))) throw new TypeError('script interface class must derive from IObjectClass')
      } else this._iObjectClass = new a(this)
      f[13] && (d = f[13]) && this._sdkType.LoadTilemapData(d[0], d[1])
      ;(this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType) || this.OnCreate()
      this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this), this._CreateSingleGlobalInstance(f))
    }
    static Create(c, d, f) {
      return e.New(e.ObjectClass, c, d, f)
    }
    Release() {
      this._imageInfo && (this._imageInfo.Release(), (this._imageInfo = null))
      if (this._animations) {
        for (const c of this._animations) c.Release()
        e.clearArray(this._animations)
        this._animationsByName.clear()
        this._animationsBySid.clear()
      }
      this._solStack.Release()
      this._solStack = null
      this._savedData.clear()
      this._unsavedData.clear()
      this._runtime = this._container = null
    }
    _LoadFamily(c) {
      for (let d = 1, f = c.length; d < f; ++d) {
        const g = this._runtime.GetObjectClassByIndex(c[d])
        this._familyMembers.push(g)
        this._familyMembersSet.add(g)
        g._families.push(this)
        g._familiesSet.add(this)
      }
    }
    _SetContainer(c) {
      this._isInContainer = !0
      this._container = c
    }
    IsInContainer() {
      return this._isInContainer
    }
    GetContainer() {
      return this._container
    }
    _OnAfterCreate() {
      var c = 0
      if (!this._isFamily)
        for (var d of this._families)
          for (var f of d.GetBehaviorTypes()) {
            const k = f.GetName().toLowerCase()
            this._behaviorsByName.set(k, f)
            this._behaviorNameToIndex.set(k, c)
            this._behaviorTypesIncludingInherited.push(f)
            ++c
          }
      for (var g of this.GetBehaviorTypes()) (d = g.GetName().toLowerCase()), this._behaviorsByName.set(d, g), this._behaviorNameToIndex.set(d, c), this._behaviorTypesIncludingInherited.push(g), ++c
      for (var h of this._behaviorTypesIncludingInherited) this._usedBehaviorCtors.add(h.GetBehavior().constructor)
      if (!this._isFamily && this._families.length) {
        c = this._runtime.GetFamilyCount()
        e.extendArray(this._familyInstVarMap, c, 0)
        e.extendArray(this._familyBehaviorMap, c, 0)
        e.extendArray(this._familyEffectMap, c, 0)
        c = []
        d = h = g = 0
        for (const k of this._families)
          if (((f = k.GetFamilyIndex()), (this._familyInstVarMap[f] = g), (g += k.GetInstanceVariablesCount()), (this._familyBehaviorMap[f] = h), (h += k.GetBehaviorTypesCount()), (this._familyEffectMap[f] = d), (d += k.GetEffectTypesCount()), (f = k.GetEffectList()) && this._effectList))
            for (const m of f.GetAllEffectTypes()) c.push(m.Clone(this._effectList))
        this._effectList && this._effectList.PrependEffectTypes(c)
      }
    }
    _CreateSingleGlobalInstance(c) {
      const d = this._runtime._GetNewUID(),
        f = e.New(e.Instance, {
          runtime: this._runtime,
          objectType: this,
          uid: d
        })
      f._CreateSdkInstance(c[16], [])
      this._runtime._MapInstanceByUID(d, f)
      this._instances.push(f)
    }
    GetSdkType() {
      return this._sdkType
    }
    IsOnLoaderLayout() {
      return this._isOnLoaderLayout
    }
    OnCreate() {
      this._isFamily || this._sdkType.OnCreate()
    }
    HasLoadedTextures() {
      return 0 < this._textureRefCount
    }
    LoadTextures(c) {
      if (this._isFamily) return Promise.resolve()
      this._textureRefCount++
      return 1 === this._textureRefCount ? this._sdkType.LoadTextures(c) || Promise.resolve() : Promise.resolve()
    }
    ReleaseTextures() {
      if (!this._isFamily) {
        this._textureRefCount--
        if (0 > this._textureRefCount) throw Error('released textures too many times')
        0 === this._textureRefCount && this._sdkType.ReleaseTextures()
      }
    }
    OnDynamicTextureLoadComplete() {
      if (this._isFamily) throw Error('not applicable to family')
      this._sdkType.OnDynamicTextureLoadComplete()
    }
    PreloadTexturesWithInstances(c) {
      return this._isFamily ? Promise.resolve() : this._sdkType.PreloadTexturesWithInstances(c)
    }
    GetRuntime() {
      return this._runtime
    }
    GetPlugin() {
      return this._plugin
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor
    }
    GetName() {
      return this._name
    }
    GetJsPropName() {
      return this._jsPropName
    }
    GetIndex() {
      return this._index
    }
    GetSID() {
      return this._sid
    }
    IsFamily() {
      return this._isFamily
    }
    IsGlobal() {
      return this._isGlobal
    }
    IsWorldType() {
      return this._isWorldType
    }
    GetFamilyIndex() {
      return this._familyIndex
    }
    GetBehaviorTypes() {
      return this._behaviorTypes
    }
    GetBehaviorTypesCount() {
      return this._behaviorsCount
    }
    UsesBehaviorByCtor(c) {
      return c && this._usedBehaviorCtors.has(c)
    }
    GetInstanceVariablesCount() {
      return this._instVars.length
    }
    GetInstanceVariableSIDs() {
      return this._instVars.map(c => c.sid)
    }
    GetInstanceVariableIndexBySID(c) {
      return this._instVars.findIndex(d => d.sid === c)
    }
    GetInstanceVariableIndexByName(c) {
      return this._instVars.findIndex(d => d.name === c)
    }
    _GetAllInstanceVariableNames() {
      return this._instVars.map(c => c.name)
    }
    _GetAllInstanceVariableJsPropNames() {
      return this._instVars.map(c => c.jsPropName)
    }
    GetInstanceVariableType(c) {
      c = Math.floor(c)
      if (0 > c || c >= this._instVars.length) throw new RangeError('invalid instance variable index')
      return this._instVars[c].type
    }
    GetInstanceVariableName(c) {
      c = Math.floor(c)
      if (0 > c || c >= this._instVars.length) throw new RangeError('invalid instance variable index')
      return this._instVars[c].name
    }
    GetEffectTypesCount() {
      return this._effectsCount
    }
    GetBehaviorTypesIncludingInherited() {
      return this._behaviorTypesIncludingInherited
    }
    GetBehaviorTypeByName(c) {
      return this._behaviorsByName.get(c.toLowerCase()) || null
    }
    GetBehaviorIndexByName(c) {
      c = this._behaviorNameToIndex.get(c.toLowerCase())
      return 'undefined' === typeof c ? -1 : c
    }
    GetEffectList() {
      return this._effectList
    }
    HasEffects() {
      return this._plugin.HasEffects()
    }
    UsesEffects() {
      return this._effectList && this._effectList.HasAnyEffectType()
    }
    GetSolStack() {
      return this._solStack
    }
    GetCurrentSol() {
      return this._solStack.GetCurrentSol()
    }
    GetImageInfo() {
      return this._imageInfo
    }
    SetDefaultInstanceData(c) {
      this._defaultInstanceData = c
    }
    GetDefaultInstanceData() {
      return this._defaultInstanceData
    }
    _SetDefaultLayerIndex(c) {
      this._defaultLayerIndex = c
    }
    GetDefaultLayerIndex() {
      return this._defaultLayerIndex
    }
    GetAnimations() {
      return this._animations
    }
    GetAnimationCount() {
      return this._animations.length
    }
    GetFamilies() {
      return this._families
    }
    BelongsToFamily(c) {
      return this._familiesSet.has(c)
    }
    GetFamilyMembers() {
      return this._familyMembers
    }
    FamilyHasMember(c) {
      return this._familyMembersSet.has(c)
    }
    GetFamilyBehaviorOffset(c) {
      return this._familyBehaviorMap[c]
    }
    GetFamilyInstanceVariableOffset(c) {
      return this._familyInstVarMap[c]
    }
    GetAnimationByName(c) {
      if (!this._animations) throw Error('no animations')
      return this._animationsByName.get(c.toLowerCase()) || null
    }
    GetAnimationBySID(c) {
      if (!this._animations) throw Error('no animations')
      return this._animationsBySid.get(c) || null
    }
    GetFirstAnimationFrame() {
      if (!this._animations) throw Error('no animations')
      return this._animations[0].GetFrameAt(0)
    }
    GetDefaultInstanceSize() {
      if (this._animations) {
        const c = this.GetFirstAnimationFrame().GetImageInfo()
        return [c.GetWidth(), c.GetHeight()]
      }
      return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
    }
    GetSingleGlobalInstance() {
      if (!this._plugin.IsSingleGlobal()) throw Error('not a single-global plugin')
      return this._instances[0]
    }
    GetInstances() {
      return this._instances
    }
    *instances() {
      yield* this._instances
    }
    *instancesIncludingPendingCreate() {
      yield* this._instances
      for (const c of this._runtime._GetInstancesPendingCreate()) c.GetObjectClass() === this && (yield c)
    }
    GetInstanceCount() {
      return this._instances.length
    }
    _AddInstance(c) {
      this._instances.push(c)
    }
    _SetIIDsStale() {
      this._iidsStale = !0
    }
    _UpdateIIDs() {
      if (this._iidsStale && !this._isFamily) {
        var c = this._instances,
          d = 0
        for (let f = c.length; d < f; ++d) c[d]._SetIID(d)
        c = this._runtime._GetInstancesPendingCreate()
        for (const f of c) f.GetObjectClass() === this && f._SetIID(d++)
        this._iidsStale = !1
      }
    }
    GetInstanceByIID(c) {
      var d = this._instances
      if (c < d.length) return d[c]
      c -= d.length
      d = this._runtime._GetInstancesPendingCreate()
      for (const f of d)
        if (f.GetObjectClass() === this) {
          if (0 === c) return f
          --c
        }
      return null
    }
    GetFirstPicked(c) {
      if (c && c.IsInContainer() && c.GetObjectClass() !== this) for (const d of c.siblings()) if (d.GetObjectClass() === this) return d
      c = this.GetCurrentSol().GetInstances()
      return c.length ? c[0] : null
    }
    GetPairedInstance(c) {
      const d = this.GetCurrentSol().GetInstances()
      return 0 < d.length ? d[c.GetIID() % d.length] : null
    }
    *allCorrespondingInstances(c, d) {
      const f = this.GetCurrentSol().GetInstances()
      var g = f.length
      const h = d.GetCurrentSol(),
        k = d.GetCurrentSol().GetInstances(),
        m = k.length
      var r = c.GetIID()
      if (d.IsFamily() || !h.IsSelectAll()) r = k.indexOf(c)
      c = Math.ceil(g / m)
      g %= m
      0 === g || r < g ? ((r *= c), (g = c)) : ((r = g * c + (r - g) * (c - 1)), (g = c - 1))
      for (let w = r, p = r + g; w < p; ++w) yield f[w]
    }
    FinishCondition(c) {
      this._sdkType.FinishCondition(c)
    }
    ApplySolToContainer() {
      if (this._isInContainer && !this._isFamily) {
        this._UpdateIIDs()
        var c = this.GetCurrentSol(),
          d = c._GetOwnInstances(),
          f = c.IsSelectAll(),
          g = this._runtime.GetCurrentEventStackFrame()
        g = g && g.GetCurrentEvent() && g.GetCurrentEvent().IsOrBlock()
        for (const m of this._container.objectTypes())
          if (m !== this) {
            m._UpdateIIDs()
            var h = m.GetCurrentSol()
            h._SetSelectAll(f)
            if (!f) {
              var k = h._GetOwnInstances()
              e.clearArray(k)
              for (const r of d) k.push(m.GetInstanceByIID(r.GetIID()))
              if (g) {
                k = c._GetOwnElseInstances()
                h = h._GetOwnElseInstances()
                e.clearArray(h)
                for (const r of k) h.push(m.GetInstanceByIID(r.GetIID()))
              }
            }
          }
      }
    }
    _TruncateContainerSols(c, d) {
      for (const f of this.GetContainer().objectTypes()) {
        const g = f.GetCurrentSol()
        c ? e.truncateArray(g._GetOwnElseInstances(), d) : e.truncateArray(g._GetOwnInstances(), d)
      }
    }
    _GetCollisionCellGrid() {
      return this._collisionGrid
    }
    _SetAnyCollisionCellChanged(c) {
      this._anyCollisionCellChanged = !!c
    }
    _SetAnyInstanceParallaxed(c) {
      this._anyInstanceParallaxed = !!c
    }
    IsAnyInstanceParallaxed() {
      return this._anyInstanceParallaxed
    }
    _UpdateAllCollisionCells() {
      if (this._anyCollisionCellChanged && this._isWorldType) {
        for (const c of this._instances) c.GetWorldInfo()._UpdateCollisionCell()
        for (const c of this._runtime._GetInstancesPendingCreate()) c.GetObjectClass() === this && c.GetWorldInfo()._UpdateCollisionCell()
        this._anyCollisionCellChanged = !1
      }
    }
    GetSavedDataMap() {
      this._savedData || (this._savedData = new Map())
      return this._savedData
    }
    GetUnsavedDataMap() {
      this._unsavedData || (this._unsavedData = new Map())
      return this._unsavedData
    }
    HasSolidBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.solid)
    }
    HasNoSaveBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.NoSave)
    }
    HasPersistBehavior() {
      return this.UsesBehaviorByCtor(e.Behaviors.Persist)
    }
    _SaveToJson() {
      const c = {
        instances: this._instances.map(d => d.SaveToJson())
      }
      this._savedData && this._savedData.size && (c.ex = e.ToSuperJSON(this._savedData))
      return c
    }
    _LoadFromJson(c) {
      this._savedData && (this._savedData.clear(), (this._savedData = null))
      var d = c.ex
      d && (this._savedData = e.FromSuperJSON(d))
      d = this._instances
      c = c.instances
      for (let f = 0, g = Math.min(d.length, c.length); f < g; ++f) d[f].LoadFromJson(c[f])
      for (let f = c.length, g = d.length; f < g; ++f) this._runtime.DestroyInstance(d[f])
      for (let f = d.length, g = c.length; f < g; ++f) {
        d = c[f]
        let h = null
        if (this.IsWorldType() && ((h = this._runtime.GetMainRunningLayout().GetLayerBySID(d.w.l)), !h)) continue
        this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, h, !1, 0, 0, !0).LoadFromJson(d)
      }
      this._SetIIDsStale()
    }
    GetIObjectClass() {
      return this._iObjectClass
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher
    }
    _GetUserScriptInstanceClass() {
      return this._instanceUserScriptClass
    }
    _SetUserScriptInstanceClass(c) {
      this._instanceUserScriptClass = c
    }
    DispatchUserScriptEvent(c) {
      var d = this._runtime
      ;(d = d.IsDebug() && !d.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime()
      this._userScriptDispatcher.dispatchEvent(c)
      d && b.AddScriptTime()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Container = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._runtime = b
      this._objectTypes = a
      for (const c of this._objectTypes) c._SetContainer(this)
    }
    Release() {
      this._runtime = null
    }
    GetRuntime() {
      return this._runtime
    }
    GetObjectTypes() {
      return this._objectTypes
    }
    objectTypes() {
      return this._objectTypes
    }
    HasAnyWorldType() {
      return this._objectTypes.some(b => b.IsWorldType())
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3Debugger,
    a = self.IInstance,
    c = []
  let d = 0
  const f = new WeakMap(),
    g = new WeakMap()
  e.Instance = class extends e.DefendedBase {
    constructor(h) {
      super()
      this._runtime = h.runtime
      this._objectType = h.objectType
      this._iScriptInterface = this._sdkInst = this._worldInfo = null
      this._iid = 0
      this._uid = h.uid
      this._puid = d++
      this._flags = 0
      this._behaviorInstances = this._instVarValues = c
      var k = this._objectType.GetBehaviorTypesIncludingInherited()
      0 < k.length &&
        (this._behaviorInstances = k.map((m, r) =>
          e.New(e.BehaviorInstance, {
            runtime: this._runtime,
            behaviorType: m,
            instance: this,
            index: r
          })
        ))
      this._siblings = this._objectType.IsInContainer() ? [] : null
      this._timeScale = -1
      this._dispatcher = null
      k = this.GetPlugin()
      k.MustPreDraw() && (this._flags |= 4)
      if (k.IsWorldType())
        if (((this._worldInfo = e.New(e.WorldInfo, this, h.layer)), h.worldData)) this._worldInfo.Init(h.worldData)
        else {
          this._worldInfo.InitNoData()
          const [m, r] = this._objectType.GetDefaultInstanceSize()
          this._worldInfo.SetSize(m, r)
          this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
        }
      h.instVarData ? this._LoadInstanceVariableData(h.instVarData) : this._LoadDefaultInstanceVariables()
    }
    Release() {
      this._iScriptInterface && (this._iScriptInterface._Release(), (this._iScriptInterface = null))
      if (0 < this._behaviorInstances.length) {
        for (var h of this._behaviorInstances) h.Release()
        e.clearArray(this._behaviorInstances)
      }
      this._sdkInst.Release()
      this._sdkInst = null
      if ((h = f.get(this))) h.clear(), f.delete(this)
      if ((h = g.get(this))) h.clear(), g.delete(this)
      this._siblings && e.clearArray(this._siblings)
      this._dispatcher && (this._dispatcher.Release(), (this._dispatcher = null))
      this._objectType = this._runtime = null
      0 < this._instVarValues.length && e.clearArray(this._instVarValues)
      this._worldInfo && (this._worldInfo.Release(), (this._worldInfo = null))
    }
    _LoadInstanceVariableData(h) {
      0 < h.length && ((this._instVarValues = []), e.shallowAssignArray(this._instVarValues, h))
    }
    _LoadDefaultInstanceVariables() {
      const h = this._objectType.GetInstanceVariablesCount()
      if (0 !== h) {
        this._instVarValues = []
        var k = [0, 0, '']
        for (let m = 0; m < h; ++m) this._instVarValues.push(k[this._objectType.GetInstanceVariableType(m)])
      }
    }
    _CreateSdkInstance(h, k) {
      if (this._sdkInst) throw Error('already got sdk instance')
      for (let m = 0, r = this._behaviorInstances.length; m < r; ++m) this._behaviorInstances[m]._CreateSdkInstance(k ? k[m] : null)
      this._sdkInst = e.New(this._objectType.GetInstanceSdkCtor(), this, h)
      if (!(this._sdkInst instanceof e.SDKInstanceBase)) throw Error('sdk type must derive from SDKInstanceBase')
      for (let m = 0, r = this._behaviorInstances.length; m < r; ++m) this._behaviorInstances[m].PostCreate()
      this._objectType._GetUserScriptInstanceClass() && this._InitUserScriptInterface()
    }
    GetSdkInstance() {
      return this._sdkInst
    }
    GetWorldInfo() {
      return this._worldInfo
    }
    GetRuntime() {
      return this._runtime
    }
    GetTimeScale() {
      return this._timeScale
    }
    GetActiveTimeScale() {
      const h = this._timeScale
      return -1 === h ? this.GetRuntime().GetTimeScale() : h
    }
    SetTimeScale(h) {
      h = +h
      if (0 > h || !isFinite(h)) h = 0
      this._timeScale = h
    }
    RestoreTimeScale() {
      this._timeScale = -1
    }
    Dispatcher() {
      this._dispatcher || (this._dispatcher = e.New(e.Event.Dispatcher))
      return this._dispatcher
    }
    Draw(h) {
      this._sdkInst.Draw(h)
    }
    OnCreate(h) {
      this._sdkInst.OnCreate(h)
    }
    _SetHasTilemap() {
      this._flags |= 2
    }
    HasTilemap() {
      return 0 !== (this._flags & 2)
    }
    _MarkDestroyed() {
      this._flags |= 1
    }
    IsDestroyed() {
      return 0 !== (this._flags & 1)
    }
    MustPreDraw() {
      return 0 !== (this._flags & 4)
    }
    _IsSolidEnabled() {
      return 0 !== (this._flags & 8)
    }
    _SetSolidEnabled(h) {
      this._flags = h ? this._flags | 8 : this._flags & -9
    }
    _IsJumpthruEnabled() {
      return 0 !== (this._flags & 16)
    }
    _SetJumpthruEnabled(h) {
      this._flags = h ? this._flags | 16 : this._flags & -17
    }
    SetFlag(h, k) {
      h <<= 16
      this._flags = k ? this._flags | h : this._flags & ~h
    }
    GetFlag(h) {
      return 0 !== (this._flags & (h << 16))
    }
    GetCurrentImageInfo() {
      return this._sdkInst.GetCurrentImageInfo()
    }
    GetCurrentSurfaceSize() {
      return this._sdkInst.GetCurrentSurfaceSize()
    }
    GetCurrentTexRect() {
      return this._sdkInst.GetCurrentTexRect()
    }
    GetImagePoint(h) {
      return this._sdkInst.GetImagePoint(h)
    }
    GetObjectClass() {
      return this._objectType
    }
    BelongsToObjectClass(h) {
      return h.IsFamily() ? h.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === h
    }
    VerifySupportsSceneGraph() {
      if (!this.GetPlugin().SupportsSceneGraph()) throw Error('object does not support scene graph')
    }
    HasParent() {
      return null !== this.GetParent()
    }
    GetParent() {
      var h = this.GetWorldInfo()
      return h ? ((h = h.GetParent()) ? h.GetInstance() : null) : null
    }
    GetTopParent() {
      var h = this.GetWorldInfo()
      return h ? ((h = h.GetTopParent()) ? h.GetInstance() : null) : null
    }
    *parents() {
      const h = this.GetWorldInfo()
      if (h) for (const k of h.parents()) yield k.GetInstance()
    }
    HasChildren() {
      const h = this.GetWorldInfo()
      return h ? h.HasChildren() : !1
    }
    GetChildren() {
      const h = this.GetWorldInfo()
      return h ? h.GetChildren().map(k => k.GetInstance()) : []
    }
    *children() {
      const h = this.GetWorldInfo()
      if (h) for (const k of h.children()) yield k.GetInstance()
    }
    *allChildren() {
      const h = this.GetWorldInfo()
      if (h) for (const k of h.allChildren()) yield k.GetInstance()
    }
    GetChildCount() {
      const h = this.GetWorldInfo()
      return h ? h.GetChildCount() : 0
    }
    GetChildAt(h) {
      const k = this.GetWorldInfo()
      return k ? ((h = k.GetChildAt(h)) ? h.GetInstance() : null) : null
    }
    AddChild(h, k) {
      this.VerifySupportsSceneGraph()
      h.VerifySupportsSceneGraph()
      this.GetWorldInfo().AddChild(h.GetWorldInfo(), k || {})
    }
    RemoveChild(h) {
      const k = this.GetWorldInfo()
      k && k.RemoveChild(h.GetWorldInfo())
    }
    GetDestroyWithParent() {
      const h = this.GetWorldInfo()
      return h ? h.GetDestroyWithParent() : !1
    }
    SetupInitialSceneGraphConnections() {
      var h = this.GetWorldInfo()
      if (h && (h = h.GetSceneGraphChildrenExportData()))
        for (const k of h)
          if ((h = this._runtime.GetInstanceByUID(k[2]))) {
            const m = k[3]
            this.AddChild(h, {
              transformX: !!((m >> 0) & 1),
              transformY: !!((m >> 1) & 1),
              transformWidth: !!((m >> 2) & 1),
              transformHeight: !!((m >> 3) & 1),
              transformAngle: !!((m >> 4) & 1),
              destroyWithParent: !!((m >> 5) & 1),
              transformZElevation: !!((m >> 6) & 1)
            })
          }
    }
    IsInContainer() {
      return null !== this._siblings
    }
    _AddSibling(h) {
      this._siblings.push(h)
    }
    GetSiblings() {
      return this._siblings
    }
    HasSibling(h) {
      return !!this.GetSibling(h)
    }
    GetSibling(h) {
      const k = this.siblings()
      if (null === k || 0 === k.length) return !1
      for (const m of k) if (m.GetObjectClass() === h) return m
      return null
    }
    siblings() {
      return this._siblings
    }
    SetSiblingsSinglePicked() {
      for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol().SetSinglePicked(h)
    }
    _PushSiblingsToSolInstances() {
      for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushInstance(h)
    }
    _SetSiblingsToSolInstancesIndex(h) {
      for (const k of this.siblings()) k.GetObjectClass().GetCurrentSol()._GetOwnInstances()[h] = k
    }
    _PushSiblingsToSolElseInstances() {
      for (const h of this.siblings()) h.GetObjectClass().GetCurrentSol()._PushElseInstance(h)
    }
    _SetSiblingsToSolElseInstancesIndex(h) {
      for (const k of this.siblings()) k.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[h] = k
    }
    GetPlugin() {
      return this._objectType.GetPlugin()
    }
    _SetIID(h) {
      this._iid = h
    }
    GetIID() {
      this._objectType._UpdateIIDs()
      return this._iid
    }
    GetUID() {
      return this._uid
    }
    GetPUID() {
      return this._puid
    }
    GetBehaviorInstances() {
      return this._behaviorInstances
    }
    GetBehaviorInstanceFromCtor(h) {
      if (!h) return null
      for (const k of this._behaviorInstances) if (k.GetBehavior() instanceof h) return k
      return null
    }
    GetBehaviorSdkInstanceFromCtor(h) {
      return h ? ((h = this.GetBehaviorInstanceFromCtor(h)) ? h.GetSdkInstance() : null) : null
    }
    GetBehaviorIndexBySID(h) {
      const k = this._behaviorInstances
      for (let m = 0, r = k.length; m < r; ++m) if (k[m].GetBehaviorType().GetSID() === h) return m
      return -1
    }
    GetAllInstanceVariableValues() {
      return this._instVarValues
    }
    _GetAllInstanceVariableNames() {
      return this._objectType._GetAllInstanceVariableNames()
    }
    GetInstanceVariableCount() {
      return this._instVarValues.length
    }
    GetInstanceVariableValue(h) {
      h |= 0
      const k = this._instVarValues
      if (0 > h || h >= k.length) throw new RangeError('invalid instance variable')
      return k[h]
    }
    _GetInstanceVariableValueUnchecked(h) {
      return this._instVarValues[h]
    }
    _GetInstanceVariableTypedValue(h) {
      const k = this._instVarValues[h]
      return 0 === this._objectType.GetInstanceVariableType(h) ? !!k : k
    }
    SetInstanceVariableValue(h, k) {
      h |= 0
      const m = this._instVarValues
      if (0 > h || h >= m.length) throw new RangeError('invalid instance variable')
      switch (this._objectType.GetInstanceVariableType(h)) {
        case 0:
          m[h] = k ? 1 : 0
          break
        case 1:
          m[h] = 'number' === typeof k ? k : parseFloat(k)
          break
        case 2:
          m[h] = 'string' === typeof k ? k : k.toString()
          break
        default:
          throw Error('unknown instance variable type')
      }
    }
    SetInstanceVariableOffset(h, k) {
      if (0 !== k) {
        h |= 0
        var m = this._instVarValues
        if (0 > h || h >= m.length) throw new RangeError('invalid instance variable')
        var r = m[h]
        if ('number' === typeof r) m[h] = 'number' === typeof k ? m[h] + k : m[h] + parseFloat(k)
        else {
          if ('boolean' === typeof r) throw Error('can not set offset of boolean variable')
          if ('string' === typeof r) throw Error('can not set offset of string variable')
          throw Error('unknown instance variable type')
        }
      }
    }
    GetSavedDataMap() {
      let h = f.get(this)
      if (h) return h
      h = new Map()
      f.set(this, h)
      return h
    }
    GetUnsavedDataMap() {
      let h = g.get(this)
      if (h) return h
      h = new Map()
      g.set(this, h)
      return h
    }
    _HasAnyCreateDestroyHandler(h) {
      const k = this.GetObjectClass()
      if (k.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0
      for (const m of k.GetFamilies()) if (m.UserScriptDispatcher().HasAnyHandlerFor(h)) return !0
      return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(h) ? !0 : !1
    }
    _TriggerOnCreatedOnSelfAndRelated() {
      const h = new Set()
      h.add(this)
      const k = this.GetWorldInfo()
      if (k && k.HasChildren()) for (const m of this.allChildren()) if ((h.add(m), m.IsInContainer())) for (const r of m.siblings()) h.add(r)
      if (this.IsInContainer()) for (const m of this.siblings()) h.add(m)
      for (const m of h.values()) m._TriggerOnCreated()
    }
    _TriggerOnCreated() {
      if (this._HasAnyCreateDestroyHandler('instancecreate')) {
        const h = this.GetObjectClass(),
          k = new e.Event('instancecreate')
        k.instance = this.GetInterfaceClass()
        h.DispatchUserScriptEvent(k)
        for (const m of h.GetFamilies()) m.DispatchUserScriptEvent(k)
        this._runtime.DispatchUserScriptEvent(k)
      }
      this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnCreated, this, null)
    }
    _TriggerOnDestroyed() {
      this._runtime.Trigger(this.GetPlugin().constructor.Cnds.OnDestroyed, this, null)
    }
    _FireDestroyedScriptEvents(h) {
      if (this._iScriptInterface) {
        var k = new e.Event('destroy')
        k.isEndingLayout = h
        this.DispatchUserScriptEvent(k)
      }
      if (this._HasAnyCreateDestroyHandler('instancedestroy')) {
        k = this.GetObjectClass()
        var m = new e.Event('instancedestroy')
        m.instance = this.GetInterfaceClass()
        m.isEndingLayout = h
        k.DispatchUserScriptEvent(m)
        for (const r of k.GetFamilies()) r.DispatchUserScriptEvent(m)
        this._runtime.DispatchUserScriptEvent(m)
      }
    }
    _GetDebuggerProperties() {
      return this._sdkInst.GetDebuggerProperties()
    }
    SaveToJson(h = 'full') {
      const k = {}
      'full' === h ? (k.uid = this.GetUID()) : (k.c3 = !0)
      if ('visual-state' !== h) {
        var m = f.get(this)
        m && m.size && (k.ex = e.ToSuperJSON(m))
        ;-1 !== this.GetTimeScale() && (k.mts = this.GetTimeScale())
        if (0 < this._objectType.GetInstanceVariablesCount()) {
          m = {}
          var r = this._objectType.GetInstanceVariableSIDs()
          for (let w = 0, p = this._instVarValues.length; w < p; ++w) m[r[w].toString()] = this._instVarValues[w]
          k.ivs = m
        }
        if (this._behaviorInstances.length) {
          m = {}
          for (const w of this._behaviorInstances) (r = w.SaveToJson()) && (m[w.GetBehaviorType().GetSID().toString()] = r)
          k.behs = m
        }
      }
      this._worldInfo && (k.w = this._worldInfo._SaveToJson(h))
      ;(h = this._sdkInst.SaveToJson()) && (k.data = h)
      return k
    }
    _OnBeforeLoad(h = 'full') {
      this._worldInfo && this._worldInfo._OnBeforeLoad(h)
    }
    LoadFromJson(h, k = 'full') {
      if ('full' === k) this._uid = h.uid
      else if (!h.c3) return
      if ('visual-state' !== k) {
        var m = f.get(this)
        m && (m.clear(), f.delete(this))
        if ((m = h.ex)) (m = e.FromSuperJSON(m)), f.set(this, m)
        this._timeScale = h.hasOwnProperty('mts') ? h.mts : -1
        if ((m = h.ivs))
          for (const [p, q] of Object.entries(m))
            if (((m = parseInt(p, 10)), (m = this._objectType.GetInstanceVariableIndexBySID(m)), !(0 > m || m >= this._instVarValues.length))) {
              var r = q
              null === r && (r = NaN)
              this._instVarValues[m] = r
            }
      }
      if (this.GetPlugin().IsWorldType()) {
        m = h.w
        var w = m.l
        this._worldInfo.GetLayer().GetSID() !== w &&
          ((r = this._worldInfo.GetLayer()), (w = r.GetLayout().GetLayerBySID(w)) ? (this._worldInfo._SetLayer(w), r._RemoveInstance(this, !0), w._AddInstance(this, !0), w.SetZIndicesChanged(), this._worldInfo.SetBboxChanged()) : 'full' === k && this._runtime.DestroyInstance(this))
        this._worldInfo._LoadFromJson(m, k)
      }
      if ('visual-state' !== k && (k = h.behs)) for (const [p, q] of Object.entries(k)) (k = parseInt(p, 10)), (k = this.GetBehaviorIndexBySID(k)), 0 > k || k >= this._behaviorInstances.length || this._behaviorInstances[k].LoadFromJson(q)
      ;(h = h.data) && this._sdkInst.LoadFromJson(h)
    }
    GetInterfaceClass() {
      return this._iScriptInterface || this._InitUserScriptInterface()
    }
    _InitUserScriptInterface() {
      var h = this._worldInfo ? self.IWorldInstance : a
      const k = this._sdkInst.GetScriptInterfaceClass(),
        m = this._objectType._GetUserScriptInstanceClass(),
        r = m || k || h
      a._Init(this)
      this._iScriptInterface = new r()
      a._Init(null)
      if (k && !(this._iScriptInterface instanceof h)) throw new TypeError(`script interface class '${k.name}' does not extend the right base class '${h.name}'`)
      if (m && ((h = k || h), !(this._iScriptInterface instanceof h))) throw new TypeError(`setInstanceClass(): class '${m.name}' does not extend the right base class '${h.name}'`)
      return this._iScriptInterface
    }
    _GetInstVarsScriptDescriptor(h) {
      if (0 !== this._instVarValues.length) {
        var k = {},
          m = this._objectType._GetAllInstanceVariableJsPropNames()
        for (let r = 0, w = m.length; r < w; ++r)
          k[m[r]] = {
            configurable: !1,
            enumerable: !0,
            get: e.Instance.prototype._GetInstanceVariableTypedValue.bind(this, r),
            set: e.Instance.prototype.SetInstanceVariableValue.bind(this, r)
          }
        k = Object.create(Object.prototype, k)
        h.instVars = {
          value: k,
          writable: !1
        }
      }
    }
    _GetBehaviorsScriptDescriptor(h) {
      var k = this._behaviorInstances
      if (0 !== k.length) {
        var m = {}
        for (const r of k)
          m[r.GetBehaviorType().GetJsPropName()] = {
            value: r.GetScriptInterface(),
            writable: !1
          }
        k = Object.create(Object.prototype, m)
        h.behaviors = {
          value: k,
          writable: !1
        }
      }
    }
    DispatchUserScriptEvent(h) {
      h.instance = this.GetInterfaceClass()
      var k = this._runtime
      ;(k = k.IsDebug() && !k.GetEventSheetManager().IsInEventEngine()) && b.StartMeasuringScriptTime()
      this.GetInterfaceClass().dispatchEvent(h)
      k && b.AddScriptTime()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SceneGraphInfo = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._owner = b
      this._parent = null
      this._children = []
      this._startWidth = b.GetWidth()
      this._startHeight = b.GetHeight()
      this._startScaleY = this._startScaleX = 1
      this._parentStartAngle = 0
    }
    Release() {
      this._parent = null
      e.clearArray(this._children)
    }
    SetParent(b) {
      this._parentStartAngle = (this._parent = b) ? b.GetAngle() : 0
    }
    GetParent() {
      return this._parent
    }
    HasChildren() {
      return 0 < this._children.length
    }
    GetChildren() {
      return this._children
    }
    GetStartScaleX() {
      return this._startScaleX
    }
    SetStartScaleX(b) {
      this._startScaleX = b
    }
    GetStartScaleY() {
      return this._startScaleY
    }
    SetStartScaleY(b) {
      this._startScaleY = b
    }
    _GetStartWidth() {
      return this._startWidth
    }
    _GetStartHeight() {
      return this._startHeight
    }
    GetParentScaleX() {
      return this._owner.GetTransformWithParentWidth() ? this._parent.GetWidth() / this._parent._GetSceneGraphInfo()._GetStartWidth() : 1
    }
    GetParentScaleY() {
      return this._owner.GetTransformWithParentHeight() ? this._parent.GetHeight() / this._parent._GetSceneGraphInfo()._GetStartHeight() : 1
    }
    GetParentStartAngle() {
      return this._parentStartAngle
    }
    _SaveToJson() {
      return {
        sw: this._startWidth,
        sh: this._startHeight,
        sx: this._startScaleX,
        sy: this._startScaleY,
        psa: this._parentStartAngle,
        c: this._children.map(b => {
          let a = ''
          b.GetTransformWithParentX() && (a += 'x')
          b.GetTransformWithParentY() && (a += 'y')
          b.GetTransformWithParentWidth() && (a += 'w')
          b.GetTransformWithParentHeight() && (a += 'h')
          b.GetTransformWithParentAngle() && (a += 'a')
          b.GetTransformWithParentZElevation() && (a += 'z')
          b.GetDestroyWithParent() && (a += 'd')
          return {
            uid: b.GetInstance().GetUID(),
            f: a
          }
        })
      }
    }
    _LoadFromJson(b) {
      this._startWidth = b.sw
      this._startHeight = b.sh
      this._startScaleX = b.sx
      this._startScaleY = b.sy
      this._parentStartAngle = b.psa
    }
    _OnAfterLoad(b) {
      const a = this._owner,
        c = a.GetRuntime()
      for (const d of b.c) {
        b = c.GetInstanceByUID(d.uid).GetWorldInfo()
        const f = d.f,
          g = {}
        g.transformX = f.includes('x')
        g.transformY = f.includes('y')
        g.transformWidth = f.includes('w')
        g.transformHeight = f.includes('h')
        g.transformAngle = f.includes('a')
        g.transformZElevation = f.includes('z')
        g.destroyWithParent = f.includes('d')
        a.AddChild(b, g)
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.glMatrix,
    a = b.vec3,
    c = b.vec4,
    d = e.New(e.Rect),
    f = e.New(e.Quad),
    g = e.New(e.Event, 'bboxchange', !1),
    h = e.New(e.Color, 0, 0, 0, 0),
    k = e.New(e.CollisionPoly),
    m = e.New(e.Color, 1, 1, 1, 1),
    r = e.New(e.Rect, 0, 0, -1, -1),
    w = e.New(e.Rect, 0, 0, -1, -1),
    p = new Set(['absolute', 'relative']),
    q = [],
    t = a.create(),
    x = c.create()
  let v = !0
  e.WorldInfo = class extends e.DefendedBase {
    constructor(u, A) {
      super()
      this._inst = u
      this._objectClass = u.GetObjectClass()
      this._runtime = u.GetRuntime()
      this._layer = A
      this._zIndex = -1
      this._flags = 196635
      this._objectClass.GetPlugin().IsRotatable() && (this._flags |= 128)
      this._oy = this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN
      this._boundingBox = e.New(e.Rect)
      this._boundingQuad = e.New(e.Quad)
      this._collisionCells = w
      this._renderCells = r
      this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null
      this._colorPremultiplied = this._color = m
      this._instanceEffectList = this._stateGroup = null
      this._inst.GetObjectClass().UsesEffects() && (this._instanceEffectList = e.New(e.InstanceEffectList, this._inst, this))
      this._sceneGraphInfo = null
      this._sceneGraphFlagsExportData = NaN
      this._sceneGraphChildrenExportData = null
      this._sceneGraphZIndex = this._sceneGraphZIndexExportData = NaN
      this._meshInfo = null
    }
    _MarkDestroyed() {
      this._flags |= 256
    }
    Release() {
      this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), (this._stateGroup = null))
      this._sourceCollisionPoly = null
      this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), (this._transformedPolyInfo = null))
      this._solidFilterTags && (this._solidFilterTags.clear(), (this._solidFilterTags = null))
      this.ReleaseMesh()
      this.HasParent() && this.GetParent().RemoveChild(this)
      if (this.HasChildren()) {
        const u = [...this.GetChildren()]
        for (const A of u) this.RemoveChild(A)
      }
      this._ReleaseSceneGraphInfo()
      this._layer = this._runtime = this._objectClass = this._inst = null
    }
    Init(u) {
      v = !1
      this.SetXY(u[0], u[1])
      this.SetZElevation(u[2])
      this.SetSize(u[3], u[4])
      this._depth = 0
      this.IsRotatable() ? this.SetAngle(u[6]) : (this._a = 0)
      h.setFromJSON(u[7])
      this._SetColor(h)
      this.SetOriginX(u[8])
      this.SetOriginY(u[9])
      this.SetBlendMode(u[10])
      this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(u[12])
      u[14] && ((this._sceneGraphFlagsExportData = u[14][0]), (this._sceneGraphChildrenExportData = u[14][1]), (this._sceneGraphZIndexExportData = u[14][2]))
      if (u[15]) {
        var A = u[15]
        this.CreateMesh(A[0], A[1])
        u = this.GetSourceMesh()
        A = A[2]
        for (let z = 0, C = A.length; z < C; ++z) {
          const E = A[z]
          for (let J = 0, F = E.length; J < F; ++J) {
            const I = E[J],
              L = u.GetMeshPointAt(J, z)
            L.SetX(I[0])
            L.SetY(I[1])
            L.SetZElevation(I[2])
            L.SetU(I[3])
            L.SetV(I[4])
          }
        }
      }
      v = !0
      this._UpdateRendererStateGroup()
    }
    InitNoData() {
      this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0
      this._cosA = 1
      this._oy = this._ox = 0
      this._UpdateRendererStateGroup()
    }
    GetRuntime() {
      return this._runtime
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetInstance() {
      return this._inst
    }
    _GetParentOffsetAngle() {
      return this.GetTransformWithParentAngle() ? this.GetParent().GetAngle() - this._sceneGraphInfo.GetParentStartAngle() : 0
    }
    SetX(u) {
      u = +u
      if (this.GetTransformWithParentX()) {
        const A = this._sceneGraphInfo
        u -= this.GetX()
        const z = -this._GetParentOffsetAngle()
        0 === z ? (this._x += u / A.GetParentScaleX()) : ((this._x += (Math.cos(z) * u) / A.GetParentScaleX()), this.GetTransformWithParentY() && (this._y += (Math.sin(z) * u) / A.GetParentScaleY()))
      } else this._x = u
    }
    OffsetX(u) {
      u = +u
      this.GetTransformWithParentX() ? this.SetX(this.GetX() + u) : (this._x += u)
    }
    GetX() {
      if (this.GetTransformWithParentX()) {
        let u = this._x
        const A = this._sceneGraphInfo,
          z = this.GetParent(),
          C = this._GetParentOffsetAngle()
        0 === C ? (u *= A.GetParentScaleX()) : ((u = u * A.GetParentScaleX() * Math.cos(C)), this.GetTransformWithParentY() && (u -= this._y * A.GetParentScaleY() * Math.sin(C)))
        return z.GetX() + u
      }
      return this._x
    }
    SetY(u) {
      u = +u
      if (this.GetTransformWithParentY()) {
        const A = this._sceneGraphInfo
        u -= this.GetY()
        const z = -this._GetParentOffsetAngle()
        0 === z ? (this._y += u / A.GetParentScaleY()) : (this.GetTransformWithParentX() && (this._x -= (Math.sin(z) * u) / A.GetParentScaleX()), (this._y += (Math.cos(z) * u) / A.GetParentScaleY()))
      } else this._y = u
    }
    OffsetY(u) {
      u = +u
      this.GetTransformWithParentY() ? this.SetY(this.GetY() + u) : (this._y += u)
    }
    GetY() {
      if (this.GetTransformWithParentY()) {
        let u = this._y
        const A = this._sceneGraphInfo,
          z = this.GetParent(),
          C = this._GetParentOffsetAngle()
        0 === C ? (u *= A.GetParentScaleY()) : ((u = u * A.GetParentScaleY() * Math.cos(C)), this.GetTransformWithParentX() && (u += this._x * A.GetParentScaleX() * Math.sin(C)))
        return z.GetY() + u
      }
      return this._y
    }
    SetXY(u, A) {
      u = +u
      A = +A
      if (this.GetTransformWithParentXOrY()) {
        const C = this.GetTransformWithParentX(),
          E = this.GetTransformWithParentY(),
          J = this._sceneGraphInfo,
          F = u - this.GetX(),
          I = A - this.GetY()
        var z = -this._GetParentOffsetAngle()
        if (0 === z) (this._x = C ? this._x + F / J.GetParentScaleX() : u), (this._y = E ? this._y + I / J.GetParentScaleY() : A)
        else {
          const L = Math.sin(z)
          z = Math.cos(z)
          this._x = C ? (E ? this._x + (z * F - L * I) / J.GetParentScaleX() : this._x + (z * F) / J.GetParentScaleX()) : u
          this._y = E ? (C ? this._y + (L * F + z * I) / J.GetParentScaleY() : this._y + (z * I) / J.GetParentScaleY()) : A
        }
      } else (this._x = u), (this._y = A)
    }
    OffsetXY(u, A) {
      u = +u
      A = +A
      this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + u, this.GetY() + A) : ((this._x += u), (this._y += A))
    }
    EqualsXY(u, A) {
      return this.GetX() === u && this.GetY() === A
    }
    SetZElevation(u) {
      u = +u
      this.GetTransformWithParentZElevation() && (u -= this.GetParent().GetZElevation())
      this._zElevation !== u && ((this._zElevation = u), this._UpdateZElevation(), (u = this.GetLayer()), 0 !== this._zElevation && u._SetAnyInstanceZElevated(), u.SetZIndicesChanged())
    }
    _UpdateZElevation() {
      this._UpdateRendererStateGroup()
      if (this.HasChildren()) {
        const u = this.GetChildren()
        for (let A = 0, z = u.length; A < z; A++) {
          const C = u[A]
          C.GetTransformWithParentZElevation() && C._UpdateZElevation()
        }
      }
    }
    OffsetZElevation(u) {
      this.SetZElevation(this.GetZElevation() + u)
    }
    GetZElevation() {
      return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
    }
    GetTotalZElevation() {
      return this.GetLayer().GetZElevation() + this.GetZElevation()
    }
    SetWidth(u) {
      u = +u
      this.GetTransformWithParentWidth() ? (this._w *= u / this.GetWidth()) : (this._w = u)
    }
    OffsetWidth(u) {
      u = +u
      this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + u) : (this._w += u)
    }
    GetWidth() {
      return this.GetTransformWithParentWidth() ? this.GetParent().GetWidth() * this._w : this._w
    }
    SetHeight(u) {
      u = +u
      this.GetTransformWithParentHeight() ? (this._h *= u / this.GetHeight()) : (this._h = u)
    }
    OffsetHeight(u) {
      u = +u
      this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + u) : (this._h += u)
    }
    GetHeight() {
      return this.GetTransformWithParentHeight() ? this.GetParent().GetHeight() * this._h : this._h
    }
    SetSize(u, A) {
      u = +u
      A = +A
      this.GetTransformWithParentWidth() ? (this._w *= u / this.GetWidth()) : (this._w = u)
      this.GetTransformWithParentHeight() ? (this._h *= A / this.GetHeight()) : (this._h = A)
    }
    GetDepth() {
      return this._depth
    }
    SetDepth(u) {
      if (0 > u) throw new RangeError('invalid depth')
      this._depth = u
    }
    GetSceneGraphScale() {
      if (this.HasParent()) {
        const u = this._sceneGraphInfo
        return Math.min(u.GetParentScaleX(), u.GetParentScaleY())
      }
      return 1
    }
    IsRotatable() {
      return 0 !== (this._flags & 128)
    }
    SetAngle(u) {
      u = +u
      this.IsRotatable() && (this.GetTransformWithParentAngle() && (u -= this.GetParent().GetAngle()), (u = e.clampAngle(u)), this._a !== u && ((this._a = u), this._MarkSinCosAngleChanged()))
    }
    OffsetAngle(u) {
      u = +u
      0 !== u && this.IsRotatable() && ((this._a = e.clampAngle(this._a + u)), this._MarkSinCosAngleChanged())
    }
    _MarkSinCosAngleChanged() {
      this._flags |= 262144
      if (this.HasChildren()) {
        const u = this.GetChildren()
        for (let A = 0, z = u.length; A < z; A++) u[A]._MarkSinCosAngleChanged()
      }
    }
    GetAngle() {
      return this.GetTransformWithParentAngle() ? e.clampAngle(this.GetParent().GetAngle() + this._a) : this._a
    }
    _MaybeUpdateSinCosAngle() {
      const u = this._flags
      if (0 !== (u & 262144)) {
        var A = this.GetAngle()
        this._sinA = Math.sin(A)
        this._cosA = Math.cos(A)
        this._flags = u & -262145
      }
    }
    GetSinAngle() {
      this._MaybeUpdateSinCosAngle()
      return this._sinA
    }
    GetCosAngle() {
      this._MaybeUpdateSinCosAngle()
      return this._cosA
    }
    SetOriginX(u) {
      this._ox = +u
    }
    OffsetOriginX(u) {
      this._ox += +u
    }
    GetOriginX() {
      return this._ox
    }
    SetOriginY(u) {
      this._oy = +u
    }
    OffsetOriginY(u) {
      this._oy += +u
    }
    GetOriginY() {
      return this._oy
    }
    _SetColor(u) {
      this._color.equals(u) ||
        (this._color === m
          ? ((this._color = e.New(e.Color, u)), (this._colorPremultiplied = e.New(e.Color, u)), this._colorPremultiplied.premultiply())
          : u.equalsRgba(1, 1, 1, 1)
          ? (this._colorPremultiplied = this._color = m)
          : (this._color.set(u), this._colorPremultiplied.set(u), this._colorPremultiplied.premultiply()),
        this._UpdateRendererStateGroup())
    }
    SetOpacity(u) {
      u = e.clamp(+u, 0, 1)
      this._color.a !== u && (h.copyRgb(this._color), (h.a = u), this._SetColor(h))
    }
    OffsetOpacity(u) {
      this.SetOpacity(this.GetOpacity() + u)
    }
    GetOpacity() {
      return this._color.a
    }
    SetUnpremultipliedColor(u) {
      this._color.equalsIgnoringAlpha(u) || (h.copyRgb(u), (h.a = this._color.a), this._SetColor(h))
    }
    SetUnpremultipliedColorRGB(u, A, z) {
      h.setRgb(u, A, z)
      this.SetUnpremultipliedColor(h)
    }
    OffsetUnpremultipliedColorRGB(u, A, z) {
      if (0 !== u || 0 !== A || 0 !== z) h.copyRgb(this._color), (h.r += u), (h.g += A), (h.b += z), this.SetUnpremultipliedColor(h)
    }
    GetUnpremultipliedColor() {
      return this._color
    }
    GetPremultipliedColor() {
      return this._colorPremultiplied
    }
    GetDestroyWithParent() {
      return 0 !== (this._flags & 512)
    }
    SetDestroyWithParent(u) {
      this._SetFlag(512, u)
    }
    GetTransformWithParentX() {
      return 0 !== (this._flags & 1024)
    }
    SetTransformWithParentX(u) {
      this._SetFlag(1024, u)
    }
    GetTransformWithParentY() {
      return 0 !== (this._flags & 2048)
    }
    GetTransformWithParentXOrY() {
      return 0 !== (this._flags & 3072)
    }
    SetTransformWithParentY(u) {
      this._SetFlag(2048, u)
    }
    GetTransformWithParentWidth() {
      return 0 !== (this._flags & 4096)
    }
    SetTransformWithParentWidth(u) {
      this._SetFlag(4096, u)
    }
    GetTransformWithParentHeight() {
      return 0 !== (this._flags & 8192)
    }
    SetTransformWithParentHeight(u) {
      this._SetFlag(8192, u)
    }
    GetTransformWithParentAngle() {
      return 0 !== (this._flags & 16384)
    }
    SetTransformWithParentAngle(u) {
      this._SetFlag(16384, u)
    }
    GetTransformWithParentZElevation() {
      return 0 !== (this._flags & 32768)
    }
    SetTransformWithParentZElevation(u) {
      this._SetFlag(32768, u)
    }
    _ClearAllSceneGraphFlags() {
      this._flags &= -65025
    }
    AddChild(u, A) {
      if (u !== this && !u.HasParent() && !this._HasChildRecursive(u) && !this._HasAnyParent(u)) {
        var z = u.GetX(),
          C = u.GetY(),
          E = u.GetWidth(),
          J = u.GetHeight(),
          F = u.GetAngle(),
          I = u.GetZElevation()
        u._SetParent(this)
        u.SetTransformWithParentX(A.transformX)
        u.SetTransformWithParentY(A.transformY)
        u.SetTransformWithParentWidth(A.transformWidth)
        u.SetTransformWithParentHeight(A.transformHeight)
        u.SetTransformWithParentAngle(A.transformAngle)
        u.SetTransformWithParentZElevation(A.transformZElevation)
        u.SetDestroyWithParent(A.destroyWithParent)
        A.transformX && ((u._x = z - this.GetX()), A.transformWidth && (u._x /= this.GetWidth() / this._sceneGraphInfo._GetStartWidth()))
        A.transformY && ((u._y = C - this.GetY()), A.transformHeight && (u._y /= this.GetHeight() / this._sceneGraphInfo._GetStartHeight()))
        A.transformWidth && ((u._w = E / this.GetWidth()), u._sceneGraphInfo.SetStartScaleX(u._w))
        A.transformHeight && ((u._h = J / this.GetHeight()), u._sceneGraphInfo.SetStartScaleY(u._h))
        A.transformAngle && (u._a = F - this.GetAngle())
        A.transformZElevation && (u._zElevation = I - this.GetZElevation())
        this._AddChildToSceneGraphInfo(u)
        this.SetBboxChanged()
      }
    }
    RemoveChild(u) {
      if (u.GetParent() === this) {
        var A = u.GetX(),
          z = u.GetY(),
          C = u.GetWidth(),
          E = u.GetHeight(),
          J = u.GetAngle(),
          F = u.GetZElevation()
        u._SetParent(null)
        u._ClearAllSceneGraphFlags()
        u.SetXY(A, z)
        u.SetSize(C, E)
        u.SetAngle(J)
        u.SetZElevation(F)
        this._RemoveChildFromSceneGraphInfo(u)
        this.SetBboxChanged()
      }
    }
    _ResetAllSceneGraphState() {
      for (var u of this.children()) this.RemoveChild(u)
      ;(u = this.GetParent()) && u.RemoveChild(this)
      this._ClearAllSceneGraphFlags()
    }
    HasParent() {
      return null !== this.GetParent()
    }
    GetParent() {
      const u = this._sceneGraphInfo
      return null !== u ? u.GetParent() : null
    }
    GetTopParent() {
      let u = this
      for (; u.HasParent(); ) u = u.GetParent()
      return u
    }
    *parents() {
      let u = this.GetParent()
      for (; u; ) yield u, (u = u.GetParent())
    }
    HasChild(u) {
      return this.GetChildren().includes(u)
    }
    HasChildren() {
      const u = this._sceneGraphInfo
      return null !== u ? u.HasChildren() : !1
    }
    GetChildren() {
      const u = this._sceneGraphInfo
      return null !== u ? u.GetChildren() : q
    }
    children() {
      return this.GetChildren()
    }
    *allChildren() {
      for (const u of this.children()) yield u, yield* u.allChildren()
    }
    GetChildCount() {
      return this.GetChildren().length
    }
    GetChildAt(u) {
      const A = this.GetChildren()
      u = Math.floor(+u)
      return 0 > u || u >= A.length ? null : A[u]
    }
    _CreateSceneGraphInfo(u) {
      this._sceneGraphInfo || (this._sceneGraphInfo = e.New(e.SceneGraphInfo, this))
      u && this._sceneGraphInfo.SetParent(u)
    }
    _GetSceneGraphInfo() {
      return this._sceneGraphInfo
    }
    _ReleaseSceneGraphInfo() {
      this._sceneGraphInfo && (this._sceneGraphInfo.Release(), (this._sceneGraphInfo = null))
    }
    _SetParent(u) {
      u ? (u._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(u)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
    }
    _HasAnyParent(u) {
      if (!this.HasParent()) return !1
      const A = this.GetParent()
      return A === u ? !0 : A._HasAnyParent(u)
    }
    _HasChildRecursive(u) {
      if (this.HasChild(u)) return !0
      for (const A of this.GetChildren()) if (A._HasChildRecursive(u)) return !0
      return !1
    }
    _AddChildToSceneGraphInfo(u) {
      this._sceneGraphInfo.GetChildren().push(u)
    }
    _RemoveChildFromSceneGraphInfo(u) {
      const A = this._sceneGraphInfo.GetChildren(),
        z = A.indexOf(u)
      ;-1 !== z && A.splice(z, 1)
      0 !== A.length || this.HasParent() || this._ReleaseSceneGraphInfo()
      u.HasChildren() || u._ReleaseSceneGraphInfo()
    }
    GetSceneGraphChildrenExportData() {
      return this._sceneGraphChildrenExportData
    }
    GetSceneGraphZIndexExportData() {
      return this._sceneGraphZIndexExportData
    }
    GetSceneGraphZIndex() {
      return this._sceneGraphZIndex
    }
    SetSceneGraphZIndex(u) {
      this._sceneGraphZIndex = u
    }
    SetUsePointsShaderProgram() {
      this._SetFlag(524288, !0)
      this._UpdateRendererStateGroup()
    }
    _UpdateRendererStateGroup() {
      if (v) {
        var u = this._runtime.GetRenderer()
        this._stateGroup && u.ReleaseStateGroup(this._stateGroup)
        var A = 0 !== (this._flags & 524288) ? u.GetPointsRenderingProgram() || '<point>' : u.GetTextureFillShaderProgram() || '<default>'
        this._stateGroup = u.AcquireStateGroup(A, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
      }
    }
    GetRendererStateGroup() {
      return this._stateGroup
    }
    HasDefaultColor() {
      return this._color === m
    }
    SetBlendMode(u) {
      u |= 0
      if (0 > u || 31 < u) throw new RangeError('invalid blend mode')
      this.GetBlendMode() !== u && ((this._flags = (this._flags & -2080374785) | (u << 26)), this._UpdateRendererStateGroup())
    }
    GetBlendMode() {
      return (this._flags & 2080374784) >> 26
    }
    _SetLayer(u) {
      this._layer = u
      0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
    }
    GetLayer() {
      return this._layer
    }
    GetLayout() {
      return this.GetLayer().GetLayout()
    }
    _SetZIndex(u) {
      this._zIndex = u | 0
    }
    GetZIndex() {
      this._layer._UpdateZIndices()
      return this._zIndex
    }
    _GetLastCachedZIndex() {
      return this._zIndex
    }
    _SetFlag(u, A) {
      this._flags = A ? this._flags | u : this._flags & ~u
    }
    IsVisible() {
      return 0 !== (this._flags & 1)
    }
    SetVisible(u) {
      this._SetFlag(1, u)
    }
    IsCollisionEnabled() {
      return 0 !== (this._flags & 8)
    }
    SetCollisionEnabled(u) {
      u = !!u
      this.IsCollisionEnabled() !== u && (this._SetFlag(8, u), u ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
    }
    SetSolidCollisionFilter(u, A) {
      this._SetFlag(32, u)
      this._solidFilterTags && this._solidFilterTags.clear()
      if (A.trim()) {
        this._solidFilterTags || (this._solidFilterTags = new Set())
        for (const z of A.split(' ')) z && this._solidFilterTags.add(z.toLowerCase())
      } else this._solidFilterTags = null
    }
    IsSolidCollisionAllowed(u) {
      const A = 0 !== (this._flags & 32),
        z = this._solidFilterTags
      if (!u || !z) return !A
      for (const C of z) if (u.has(C)) return A
      return !A
    }
    SetBboxChanged() {
      this._flags |= 65554
      this._objectClass._SetAnyCollisionCellChanged(!0)
      this._runtime.UpdateRender()
      this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), (this._flags &= -3), this._UpdateRenderCell())
      0 !== (this._flags & 4) && this._inst.Dispatcher().dispatchEvent(g)
      if (null !== this._sceneGraphInfo) {
        const u = this._sceneGraphInfo.GetChildren()
        for (let A = 0, z = u.length; A < z; ++A) u[A].SetBboxChanged()
      }
    }
    CalculateBbox(u, A, z) {
      const C = this.GetX(),
        E = this.GetY(),
        J = this.GetWidth(),
        F = this.GetHeight(),
        I = this.GetAngle()
      u.setWH(C - this._ox * J, E - this._oy * F, J, F)
      z && this.HasMesh() && this._ExpandBboxForMesh(u)
      0 === I ? A.setFromRect(u) : (u.offset(-C, -E), A.setFromRotatedRectPrecalc(u, this.GetSinAngle(), this.GetCosAngle()), A.offset(C, E), A.getBoundingBox(u))
      u.normalize()
    }
    _UpdateBbox() {
      const u = this._flags
      0 !== (u & 2) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), (this._flags = u & -3))
    }
    GetBoundingBox() {
      this._UpdateBbox()
      return this._boundingBox
    }
    GetBoundingQuad() {
      this._UpdateBbox()
      return this._boundingQuad
    }
    PixelRoundQuad(u) {
      var A = this.GetX(),
        z = this.GetY()
      A = Math.round(A) - A
      z = Math.round(z) - z
      if (0 === A && 0 === z) return u
      f.copy(u)
      f.offset(A, z)
      return f
    }
    OverwriteBoundingBox(u) {
      this._boundingBox.copy(u)
      this._boundingQuad.setFromRect(this._boundingBox)
      this._flags &= -3
      this._UpdateCollisionCell()
      this._UpdateRenderCell()
    }
    SetBboxChangeEventEnabled(u) {
      this._SetFlag(4, u)
    }
    IsBboxChangeEventEnabled() {
      return 0 !== (this._flags & 4)
    }
    IsInViewport(u, A) {
      return A && 0 !== this.GetDepth() ? this._IsInViewport_3D() : 0 === this.GetZElevation() ? u.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
    }
    _IsInViewport_ZElevated() {
      const u = this.GetLayer(),
        A = this.GetTotalZElevation()
      if (A >= u.GetCameraZ()) return !1
      u.GetViewportForZ(A, d)
      return d.intersectsRect(this.GetBoundingBox())
    }
    _IsInViewport_3D() {
      var u = this.GetBoundingBox()
      const A = u.getLeft(),
        z = u.getRight(),
        C = u.getTop()
      u = u.getBottom()
      const E = this.GetTotalZElevation(),
        J = E + this.GetDepth()
      return this.GetLayer()._GetViewFrustum().ContainsAABB(A, C, E, z, u, J)
    }
    _ProjectToUnitViewport(u, A, z, C, E) {
      t[0] = NaN
      t[1] = NaN
      e.Gfx.Project(z, C, E, A, u, x, t)
      return [t[0], t[1]]
    }
    SetSourceCollisionPoly(u) {
      this._sourceCollisionPoly = u
      this._DiscardTransformedCollisionPoly()
      this.HasMesh() && (this._meshInfo.meshPoly = null)
    }
    GetSourceCollisionPoly() {
      return this._sourceCollisionPoly
    }
    HasOwnCollisionPoly() {
      return null !== this._sourceCollisionPoly || this.HasMesh()
    }
    GetTransformedCollisionPoly() {
      return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
    }
    GetCustomTransformedCollisionPoly(u, A, z) {
      let C = 0,
        E = 1
      0 !== z && ((C = Math.sin(z)), (E = Math.cos(z)))
      return this._GetCustomTransformedCollisionPolyPrecalc(u, A, z, C, E)
    }
    _GetCustomTransformedCollisionPolyPrecalc(u, A, z, C, E) {
      let J = this._transformedPolyInfo
      null === J &&
        (this._transformedPolyInfo = J =
          {
            poly: e.New(e.CollisionPoly),
            width: NaN,
            height: NaN,
            angle: NaN
          })
      const F = J.poly
      if (J.width === u && J.height === A && J.angle === z) return F
      const I = this._sourceCollisionPoly
      if (this.HasMesh()) {
        const L = this.GetOriginX(),
          N = this.GetOriginY(),
          S = this.GetSourceMesh()
        let V = this._meshInfo.meshPoly
        V || (I ? (k.copy(I), k.offset(L, N)) : k.setDefaultPoints(), (V = S.InsertPolyMeshVertices(k)), (this._meshInfo.meshPoly = V))
        S.TransformCollisionPoly(V, F)
        F.offset(-L, -N)
        F.transformPrecalc(u, A, C, E)
      } else I ? (F.copy(I), F.transformPrecalc(u, A, C, E)) : F.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY())
      J.width = u
      J.height = A
      J.angle = z
      return F
    }
    _DiscardTransformedCollisionPoly() {
      this.SetPhysicsBodyChanged(!0)
      const u = this._transformedPolyInfo
      null !== u && (u.width = NaN)
    }
    CreateMesh(u, A) {
      u = Math.floor(u)
      A = Math.floor(A)
      if (!this.GetInstance().GetPlugin().SupportsMesh()) throw Error('object does not support mesh')
      this.ReleaseMesh()
      this._meshInfo = {
        sourceMesh: e.New(e.Gfx.Mesh, u, A),
        transformedMesh: e.New(e.Gfx.Mesh, u, A),
        meshPoly: null
      }
    }
    HasMesh() {
      return null !== this._meshInfo
    }
    GetSourceMesh() {
      if (!this.HasMesh()) throw Error('no mesh')
      return this._meshInfo.sourceMesh
    }
    GetTransformedMesh() {
      if (!this.HasMesh()) throw Error('no mesh')
      return this._meshInfo.transformedMesh
    }
    SetMeshChanged(u) {
      this._SetFlag(65536, u)
    }
    IsMeshChanged() {
      return 0 !== (this._flags & 65536)
    }
    SetPhysicsBodyChanged(u) {
      this._SetFlag(131072, u)
    }
    IsPhysicsBodyChanged() {
      return 0 !== (this._flags & 131072)
    }
    _ExpandBboxForMesh(u) {
      var A = this._meshInfo.sourceMesh
      const z = Math.min(A.GetMinX(), 0),
        C = Math.min(A.GetMinY(), 0),
        E = Math.max(A.GetMaxX(), 1)
      A = Math.max(A.GetMaxY(), 1)
      const J = u.width(),
        F = u.height()
      u.offsetLeft(z * J)
      u.offsetTop(C * F)
      u.offsetRight((E - 1) * J)
      u.offsetBottom((A - 1) * F)
    }
    ReleaseMesh() {
      this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), (this._meshInfo = null), this._DiscardTransformedCollisionPoly())
    }
    SetMeshPoint(u, A, z) {
      u = Math.floor(u)
      A = Math.floor(A)
      var C = z.mode || 'absolute'
      if (!p.has(C)) throw Error('invalid mode')
      C = 'relative' === C
      let E = z.x,
        J = z.y
      const F = z.zElevation
      let I = 'number' === typeof z.u ? z.u : C ? 0 : -1
      z = 'number' === typeof z.v ? z.v : C ? 0 : -1
      if (!this.HasMesh()) return !1
      const L = this.GetSourceMesh(),
        N = L.GetMeshPointAt(u, A)
      if (null === N) return !1
      let S = !1
      'number' === typeof F && N.GetZElevation() !== F && (N.SetZElevation(F), (S = !0))
      C && ((E += u / (L.GetHSize() - 1)), (J += A / (L.GetVSize() - 1)))
      ;-1 !== I || C ? (C && (I += u / (L.GetHSize() - 1)), (I = e.clamp(I, 0, 1))) : (I = N.GetU())
      ;-1 !== z || C ? (C && (z += A / (L.GetVSize() - 1)), (z = e.clamp(z, 0, 1))) : (z = N.GetV())
      if (N.GetX() === E && N.GetY() === J && N.GetU() === I && N.GetV() === z) return S
      N.SetX(E)
      N.SetY(J)
      N.SetU(I)
      N.SetV(z)
      this._DiscardTransformedCollisionPoly()
      return !0
    }
    HasTilemap() {
      return this._inst.HasTilemap()
    }
    ContainsPoint(u, A) {
      return this.GetBoundingBox().containsPoint(u, A) && this.GetBoundingQuad().containsPoint(u, A)
        ? this.HasTilemap()
          ? this._inst.GetSdkInstance().TestPointOverlapTile(u, A)
          : this.HasOwnCollisionPoly()
          ? this.GetTransformedCollisionPoly().containsPoint(u - this.GetX(), A - this.GetY())
          : !0
        : !1
    }
    _IsCollisionCellChanged() {
      return 0 !== (this._flags & 16)
    }
    _UpdateCollisionCell() {
      if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & 256)) {
        var u = this.GetBoundingBox(),
          A = this._objectClass._GetCollisionCellGrid(),
          z = this._collisionCells
        d.set(A.XToCell(u.getLeft()), A.YToCell(u.getTop()), A.XToCell(u.getRight()), A.YToCell(u.getBottom()))
        z.equals(d) || ((u = this._inst), z === w ? (A.Update(u, null, d), (this._collisionCells = e.New(e.Rect, d))) : (A.Update(u, z, d), z.copy(d)), (this._flags &= -17))
      }
    }
    _RemoveFromCollisionCells() {
      const u = this._collisionCells
      u !== w && (this._objectClass._GetCollisionCellGrid().Update(this._inst, u, null), (this._collisionCells = w))
    }
    _UpdateRenderCell() {
      const u = this.GetLayer()
      if (u.UsesRenderCells() && 0 === (this._flags & 256)) {
        var A = u.GetRenderGrid(),
          z = this.GetBoundingBox(),
          C = this._renderCells
        d.set(A.XToCell(z.getLeft()), A.YToCell(z.getTop()), A.XToCell(z.getRight()), A.YToCell(z.getBottom()))
        C.equals(d) || ((z = this._inst), C === r ? (A.Update(z, null, d), (this._renderCells = e.New(e.Rect, d))) : (A.Update(z, C, d), C.copy(d)), u.SetRenderListStale())
      }
    }
    _RemoveFromRenderCells() {
      const u = this._renderCells
      u !== r && (this.GetLayer().GetRenderGrid().Update(this._inst, u, null), (this._renderCells = r))
    }
    GetRenderCellRange() {
      return this._renderCells
    }
    ZOrderMoveToTop() {
      const u = this._inst,
        A = this._layer,
        z = A._GetInstances()
      ;(z.length && z[z.length - 1] === u) || (A._RemoveInstance(u, !1), A._AddInstance(u, !1), this._runtime.UpdateRender())
    }
    ZOrderMoveToBottom() {
      const u = this._inst,
        A = this._layer,
        z = A._GetInstances()
      ;(z.length && z[0] === u) || (A._RemoveInstance(u, !1), A._PrependInstance(u, !1), this._runtime.UpdateRender())
    }
    ZOrderMoveToLayer(u) {
      const A = this._inst,
        z = this._layer
      if (z.GetLayout() !== u.GetLayout()) throw Error('layer from different layout')
      u !== z && (z._RemoveInstance(A, !0), this._SetLayer(u), u._AddInstance(A, !0), this._runtime.UpdateRender())
    }
    ZOrderMoveAdjacentToInstance(u, A) {
      const z = this._inst
      let C = !1
      const E = this._layer
      if (u.GetUID() !== z.GetUID()) {
        var J = u.GetWorldInfo()
        if (!J) throw Error('expected world instance')
        J = J.GetLayer()
        E.GetIndex() !== J.GetIndex() && (E._RemoveInstance(z, !0), this._SetLayer(J), J._AddInstance(z, !0), (C = !0))
        u = J.MoveInstanceAdjacent(z, u, !!A)
        ;(C || u) && this._runtime.UpdateRender()
      }
    }
    GetInstanceEffectList() {
      return this._instanceEffectList
    }
    _SetHasAnyActiveEffect(u) {
      this._SetFlag(64, u)
    }
    HasAnyActiveEffect() {
      return 0 !== (this._flags & 64)
    }
    _SaveToJson(u) {
      const A = {
        x: this.GetX(),
        y: this.GetY(),
        w: this.GetWidth(),
        h: this.GetHeight(),
        l: this.GetLayer().GetSID(),
        zi: this.GetZIndex()
      }
      0 !== this.GetZElevation() && (A.ze = this.GetZElevation())
      0 !== this.GetAngle() && (A.a = this.GetAngle())
      this.HasDefaultColor() || (A.c = this._color.toJSON())
      0.5 !== this.GetOriginX() && (A.oX = this.GetOriginX())
      0.5 !== this.GetOriginY() && (A.oY = this.GetOriginY())
      0 !== this.GetBlendMode() && (A.bm = this.GetBlendMode())
      this.IsVisible() || (A.v = this.IsVisible())
      this.IsCollisionEnabled() || (A.ce = this.IsCollisionEnabled())
      this.IsBboxChangeEventEnabled() && (A.be = this.IsBboxChangeEventEnabled())
      this._instanceEffectList && (A.fx = this._instanceEffectList._SaveToJson())
      const z = 0 !== (this._flags & 32)
      z && (A.sfi = z)
      this._solidFilterTags && (A.sft = [...this._solidFilterTags].join(' '))
      this._sceneGraphInfo && 'visual-state' !== u && (A.sgi = this._sceneGraphInfo._SaveToJson())
      this.HasMesh() && (A.mesh = this.GetSourceMesh().SaveToJson())
      return A
    }
    _OnBeforeLoad(u) {
      'visual-state' !== u && this._ResetAllSceneGraphState()
    }
    _LoadFromJson(u, A) {
      v = !1
      this.SetX(u.x)
      this.SetY(u.y)
      this.SetWidth(u.w)
      this.SetHeight(u.h)
      this._SetZIndex(u.zi)
      this.SetZElevation(u.hasOwnProperty('ze') ? u.ze : 0)
      this.SetAngle(u.hasOwnProperty('a') ? u.a : 0)
      u.hasOwnProperty('c') ? h.setFromJSON(u.c) : u.hasOwnProperty('o') ? (h.copyRgb(this._color), (h.a = u.o)) : h.setRgba(1, 1, 1, 1)
      this._SetColor(h)
      this.SetOriginX(u.hasOwnProperty('oX') ? u.oX : 0.5)
      this.SetOriginY(u.hasOwnProperty('oY') ? u.oY : 0.5)
      this.SetBlendMode(u.hasOwnProperty('bm') ? u.bm : 0)
      this.SetVisible(u.hasOwnProperty('v') ? u.v : !0)
      this.SetCollisionEnabled(u.hasOwnProperty('ce') ? u.ce : !0)
      this.SetBboxChangeEventEnabled(u.hasOwnProperty('be') ? u.be : !1)
      this.SetSolidCollisionFilter(u.hasOwnProperty('sfi') ? u.sfi : !1, u.hasOwnProperty('sft') ? u.sft : '')
      this._instanceEffectList && u.hasOwnProperty('fx') && this._instanceEffectList._LoadFromJson(u.fx)
      if (u.hasOwnProperty('sgi') && 'visual-state' !== A) {
        this._CreateSceneGraphInfo(null)
        const z = this._sceneGraphInfo,
          C = u.sgi
        z._LoadFromJson(C)
        const E = this.GetRuntime().Dispatcher(),
          J = () => {
            E.removeEventListener('afterload', J)
            0 === (this._flags & 256) && z._OnAfterLoad(C)
          }
        E.addEventListener('afterload', J)
      }
      u.hasOwnProperty('mesh') ? ((u = u.mesh), this.CreateMesh(u.cols, u.rows), this.GetSourceMesh().LoadFromJson(u)) : this.ReleaseMesh()
      this.SetBboxChanged()
      v = !0
      this._UpdateRendererStateGroup()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.BehaviorType = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      const c = b.GetRuntime(),
        d = c.GetPluginManager(),
        f = c.GetObjectReference(a[1])
      d.HasBehaviorByConstructorFunction(f) || d.CreateBehavior(a)
      this._runtime = c
      this._objectClass = b
      this._behavior = d.GetBehaviorByConstructorFunction(f)
      this._sdkType = null
      this._instSdkCtor = f.Instance
      this._sid = a[2]
      this._name = a[0]
      this._jsPropName = this._runtime.GetJsPropName(a[3])
      this._sdkType = e.New(f.Type, this)
      this.OnCreate()
    }
    static Create(b, a) {
      return e.New(e.BehaviorType, b, a)
    }
    Release() {
      this._behavior = this._runtime = null
      this._sdkType.Release()
      this._instSdkCtor = this._sdkType = null
    }
    GetSdkType() {
      return this._sdkType
    }
    OnCreate() {
      this._sdkType.OnCreate()
    }
    GetRuntime() {
      return this._runtime
    }
    GetObjectClass() {
      return this._objectClass
    }
    GetBehavior() {
      return this._behavior
    }
    GetInstanceSdkCtor() {
      return this._instSdkCtor
    }
    GetName() {
      return this._name
    }
    GetSID() {
      return this._sid
    }
    GetJsPropName() {
      return this._jsPropName
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.IBehaviorInstance
  e.BehaviorInstance = class extends e.DefendedBase {
    constructor(a) {
      super()
      this._runtime = a.runtime
      this._behaviorType = a.behaviorType
      this._behavior = this._behaviorType.GetBehavior()
      this._inst = a.instance
      this._index = a.index
      this._iScriptInterface = this._sdkInst = null
      this._behavior._AddInstance(this._inst)
    }
    Release() {
      this._iScriptInterface && (this._iScriptInterface._Release(), (this._iScriptInterface = null))
      this._behavior._RemoveInstance(this._inst)
      this._sdkInst.Release()
      this._inst = this._behavior = this._behaviorType = this._runtime = this._iScriptInterface = this._sdkInst = null
    }
    _CreateSdkInstance(a) {
      if (this._sdkInst) throw Error('already got sdk instance')
      this._sdkInst = e.New(this._behaviorType.GetInstanceSdkCtor(), this, a)
      this._InitScriptInterface()
    }
    GetSdkInstance() {
      return this._sdkInst
    }
    GetObjectInstance() {
      return this._inst
    }
    GetRuntime() {
      return this._runtime
    }
    GetBehaviorType() {
      return this._behaviorType
    }
    GetBehavior() {
      return this._behavior
    }
    _GetIndex() {
      return this._index
    }
    PostCreate() {
      this._sdkInst.PostCreate()
    }
    OnSpriteFrameChanged(a, c) {
      this._sdkInst.OnSpriteFrameChanged(a, c)
    }
    _GetDebuggerProperties() {
      return this._sdkInst.GetDebuggerProperties()
    }
    SaveToJson() {
      return this._sdkInst.SaveToJson()
    }
    LoadFromJson(a) {
      return this._sdkInst.LoadFromJson(a)
    }
    static SortByTickSequence(a, c) {
      var d = a.GetObjectInstance(),
        f = c.GetObjectInstance()
      const g = d.GetObjectClass().GetIndex(),
        h = f.GetObjectClass().GetIndex()
      if (g !== h) return g - h
      d = d.GetPUID()
      f = f.GetPUID()
      return d !== f ? d - f : a.GetBehaviorInstance()._GetIndex() - c.GetBehaviorInstance()._GetIndex()
    }
    _InitScriptInterface() {
      const a = this._sdkInst.GetScriptInterfaceClass(),
        c = a || b
      b._Init(this)
      this._iScriptInterface = new c()
      b._Init(null)
      if (a && !(this._iScriptInterface instanceof b)) throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${b.name}'`)
    }
    GetScriptInterface() {
      return this._iScriptInterface
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.EffectList = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._owner = b
      this._allEffectTypes = []
      this._activeEffectTypes = []
      this._effectTypesByName = new Map()
      this._effectParams = []
      this._preservesOpaqueness = !0
      for (const c of a) (b = e.New(e.EffectType, this, c, this._allEffectTypes.length)), this._allEffectTypes.push(b), this._effectTypesByName.set(b.GetName().toLowerCase(), b), 3 <= c.length && this._effectParams.push(this._LoadSingleEffectParameters(c[2]))
      this.GetRuntime()._AddEffectList(this)
    }
    Release() {
      e.clearArray(this._allEffectTypes)
      e.clearArray(this._activeEffectTypes)
      this._effectTypesByName.clear()
      e.clearArray(this._effectParams)
      this._owner = null
    }
    PrependEffectTypes(b) {
      if (b.length) {
        this._allEffectTypes = b.concat(this._allEffectTypes)
        for (const a of b) this._effectTypesByName.set(a.GetName().toLowerCase(), a)
        for (let a = 0, c = this._allEffectTypes.length; a < c; ++a) this._allEffectTypes[a]._SetIndex(a)
      }
    }
    _LoadSingleEffectParameters(b) {
      b = b.slice(0)
      for (let a = 0, c = b.length; a < c; ++a) {
        const d = b[a]
        if (Array.isArray(d)) {
          const f = e.New(e.Color)
          f.setFromJSON(d)
          b[a] = f
        }
      }
      return b
    }
    GetOwner() {
      return this._owner
    }
    GetRuntime() {
      return this._owner.GetRuntime()
    }
    UpdateActiveEffects() {
      e.clearArray(this._activeEffectTypes)
      let b = !0
      for (const a of this._allEffectTypes) a.IsActive() && (this._activeEffectTypes.push(a), a.GetShaderProgram().PreservesOpaqueness() || (b = !1))
      this._preservesOpaqueness = b
    }
    GetAllEffectTypes() {
      return this._allEffectTypes
    }
    HasAnyEffectType() {
      return 0 < this._allEffectTypes.length
    }
    GetEffectTypeByName(b) {
      return this._effectTypesByName.get(b.toLowerCase()) || null
    }
    GetEffectTypeByIndex(b) {
      b = Math.floor(+b)
      if (0 > b || b >= this._allEffectTypes.length) throw new RangeError('invalid effect type index')
      return this._allEffectTypes[b]
    }
    IsEffectIndexActive(b) {
      return this.GetEffectTypeByIndex(b).IsActive()
    }
    SetEffectIndexActive(b, a) {
      this.GetEffectTypeByIndex(b).SetActive(a)
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes
    }
    HasAnyActiveEffect() {
      return 0 < this._activeEffectTypes.length
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness
    }
    GetEffectParametersForIndex(b) {
      return this._effectParams[b]
    }
    static SaveFxParamToJson(b) {
      return b && b instanceof e.Color
        ? {
            t: 'color',
            v: b.toJSON()
          }
        : b
    }
    static LoadFxParamFromJson(b) {
      if ('object' === typeof b) {
        if ('color' === b.t) {
          const a = e.New(e.Color)
          a.setFromJSON(b.v)
          return a
        }
        throw Error('invalid effect parameter type')
      }
      return b
    }
    static SaveFxParamsToJson(b) {
      return b.map(e.EffectList.SaveFxParamToJson)
    }
    static LoadFxParamsFromJson(b) {
      return b.map(e.EffectList.LoadFxParamFromJson)
    }
    SaveToJson() {
      return this._allEffectTypes.map(b => ({
        name: b.GetName(),
        active: b.IsActive(),
        params: e.EffectList.SaveFxParamsToJson(this._effectParams[b.GetIndex()])
      }))
    }
    LoadFromJson(b) {
      for (const a of b) if ((b = this.GetEffectTypeByName(a.name))) b.SetActive(a.active), (this._effectParams[b.GetIndex()] = e.EffectList.LoadFxParamsFromJson(a.params))
      this.UpdateActiveEffects()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.EffectType = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      this._effectList = b
      this._id = a[0]
      this._name = a[1]
      this._index = c
      this._shaderProgram = null
      this._isActive = !0
    }
    Release() {
      this._shaderProgram = this._effectList = null
    }
    Clone(b) {
      b = e.New(e.EffectType, b, [this._id, this._name], -1)
      b._shaderProgram = this._shaderProgram
      b._isActive = this._isActive
      return b
    }
    _InitRenderer(b) {
      b = b.GetShaderProgramByName(this._id)
      if (!b) throw Error("failed to find shader program '" + this._id + "'")
      this._shaderProgram = b
    }
    GetEffectList() {
      return this._effectList
    }
    GetName() {
      return this._name
    }
    _SetIndex(b) {
      this._index = b
    }
    GetIndex() {
      return this._index
    }
    GetOwner() {
      return this._effectList.GetOwner()
    }
    GetRuntime() {
      return this._effectList.GetRuntime()
    }
    SetActive(b) {
      this._isActive = !!b
    }
    IsActive() {
      return this._isActive
    }
    GetShaderProgram() {
      return this._shaderProgram
    }
    GetDefaultParameterValues() {
      const b = []
      for (let a = 0, c = this._shaderProgram.GetParameterCount(); a < c; ++a) {
        const d = this._shaderProgram.GetParameterType(a)
        if ('float' === d || 'percent' === d) b.push(0)
        else if ('color' === d) b.push(e.New(e.Color, 1, 1, 1, 1))
        else throw new TypeError('unknown effect parameter type')
      }
      return b
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.InstanceEffectList = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      this._inst = b
      this._wi = a
      this._effectList = b.GetObjectClass().GetEffectList()
      this._activeEffectFlags = []
      this._activeEffectTypes = []
      this._preservesOpaqueness = !0
      this._effectParams = []
      for (const d of this._effectList.GetAllEffectTypes()) this._activeEffectFlags.push(!0)
      this.UpdateActiveEffects()
    }
    Release() {
      e.clearArray(this._activeEffectFlags)
      e.clearArray(this._activeEffectTypes)
      e.clearArray(this._effectParams)
      this._effectList = this._inst = null
    }
    _LoadEffectParameters(b) {
      for (const a of b) this._effectParams.push(this._LoadSingleEffectParameters(a))
    }
    _LoadSingleEffectParameters(b) {
      b = b.slice(0)
      for (let a = 0, c = b.length; a < c; ++a) {
        const d = b[a]
        if (Array.isArray(d)) {
          const f = e.New(e.Color)
          f.setFromJSON(d)
          b[a] = f
        }
      }
      return b
    }
    LoadDefaultEffectParameters() {
      for (const b of this._effectList.GetAllEffectTypes()) this._effectParams.push(b.GetDefaultParameterValues())
    }
    GetOwner() {
      return this._owner
    }
    GetEffectList() {
      return this._effectList
    }
    GetRuntime() {
      return this._inst.GetRuntime()
    }
    UpdateActiveEffects() {
      e.clearArray(this._activeEffectTypes)
      const b = this._effectList.GetAllEffectTypes(),
        a = this._activeEffectTypes,
        c = this._activeEffectFlags
      let d = !0
      for (let f = 0, g = b.length; f < g; ++f)
        if (c[f]) {
          const h = b[f]
          a.push(h)
          h.GetShaderProgram().PreservesOpaqueness() || (d = !1)
        }
      this._preservesOpaqueness = d
      this._wi._SetHasAnyActiveEffect(!!a.length)
    }
    GetActiveEffectTypes() {
      return this._activeEffectTypes
    }
    GetEffectParametersForIndex(b) {
      return this._effectParams[b]
    }
    PreservesOpaqueness() {
      return this._preservesOpaqueness
    }
    HasAnyActiveBackgroundBlendingEffect() {
      return this._activeEffectTypes.some(b => b.GetShaderProgram().UsesDest())
    }
    IsEffectIndexActive(b) {
      return this._activeEffectFlags[b]
    }
    SetEffectIndexActive(b, a) {
      this._activeEffectFlags[b] = !!a
    }
    GetAllEffectTypes() {
      return this._effectList.GetAllEffectTypes()
    }
    _SaveToJson() {
      return this._effectList.GetAllEffectTypes().map(b => ({
        name: b.GetName(),
        active: this._activeEffectFlags[b.GetIndex()],
        params: e.EffectList.SaveFxParamsToJson(this._effectParams[b.GetIndex()])
      }))
    }
    _LoadFromJson(b) {
      for (const a of b) if ((b = this._effectList.GetEffectTypeByName(a.name))) (this._activeEffectFlags[b.GetIndex()] = a.active), (this._effectParams[b.GetIndex()] = e.EffectList.LoadFxParamsFromJson(a.params))
      this.UpdateActiveEffects()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = [],
    a = [],
    c = [],
    d = e.New(e.CollisionPoly),
    f = e.New(e.CollisionPoly),
    g = e.New(e.Quad),
    h = e.New(e.Rect),
    k = e.New(e.Rect)
  let m = null,
    r = null,
    w = null
  e.CollisionEngine = class extends e.DefendedBase {
    constructor(p) {
      super()
      this._runtime = p
      this._registeredCollisions = []
      this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0
    }
    Release() {
      this._runtime = null
    }
    _Update1sStats() {
      this._collisionCheckSec = this._collisionCheckCount
      this._collisionCheckCount = 0
      this._polyCheckSec = this._polyCheckCount
      this._polyCheckCount = 0
    }
    Get1secCollisionChecks() {
      return this._collisionCheckSec
    }
    Get1secPolyChecks() {
      return this._polyCheckSec
    }
    RegisterCollision(p, q) {
      const t = p.GetWorldInfo(),
        x = q.GetWorldInfo()
      t && x && t.IsCollisionEnabled() && x.IsCollisionEnabled() && this._registeredCollisions.push([p, q])
    }
    AddRegisteredCollisionCandidates(p, q, t) {
      for (const [x, v] of this._registeredCollisions) {
        let u
        if (p === x) u = v
        else if (p === v) u = x
        else continue
        u.BelongsToObjectClass(q) && (t.includes(u) || t.push(u))
      }
    }
    CheckRegisteredCollision(p, q) {
      if (!this._registeredCollisions.length) return !1
      for (const [t, x] of this._registeredCollisions) if ((p === t && q === x) || (p === x && q === t)) return !0
      return !1
    }
    ClearRegisteredCollisions() {
      e.clearArray(this._registeredCollisions)
    }
    TestOverlap(p, q) {
      if (!p || !q || p === q) return !1
      p = p.GetWorldInfo()
      q = q.GetWorldInfo()
      if (!p.IsCollisionEnabled() || !q.IsCollisionEnabled()) return !1
      this._collisionCheckCount++
      const t = p.GetLayer(),
        x = q.GetLayer()
      return t.IsTransformCompatibleWith(x) ? this._TestOverlap_SameLayers(p, q) : this._TestOverlap_DifferentLayers(p, q)
    }
    _TestOverlap_SameLayers(p, q) {
      if (!p.GetBoundingBox().intersectsRect(q.GetBoundingBox())) return !1
      this._polyCheckCount++
      if (!p.GetBoundingQuad().intersectsQuad(q.GetBoundingQuad()) || (p.HasTilemap() && q.HasTilemap())) return !1
      if (p.HasTilemap()) return this.TestTilemapOverlap(p, q)
      if (q.HasTilemap()) return this.TestTilemapOverlap(q, p)
      if (!p.HasOwnCollisionPoly() && !q.HasOwnCollisionPoly()) return !0
      const t = p.GetTransformedCollisionPoly(),
        x = q.GetTransformedCollisionPoly()
      return t.intersectsPoly(x, q.GetX() - p.GetX(), q.GetY() - p.GetY())
    }
    _TestOverlap_DifferentLayers(p, q) {
      var t = p.HasTilemap(),
        x = q.HasTilemap()
      if (t && !x) return this.TestTilemapOverlapDifferentLayers(p, q)
      if (x && !t) return this.TestTilemapOverlapDifferentLayers(q, p)
      if (x || t) return !1
      x = p.GetLayer()
      t = q.GetLayer()
      d.copy(p.GetTransformedCollisionPoly())
      f.copy(q.GetTransformedCollisionPoly())
      var v = d.pointsArr()
      for (let u = 0, A = v.length; u < A; u += 2) {
        const z = u + 1,
          C = v[z],
          [E, J] = x.LayerToCanvasCss(v[u] + p.GetX(), C + p.GetY())
        v[u] = E
        v[z] = J
      }
      p = f.pointsArr()
      for (let u = 0, A = p.length; u < A; u += 2) {
        x = u + 1
        v = p[x]
        const [z, C] = t.LayerToCanvasCss(p[u] + q.GetX(), v + q.GetY())
        p[u] = z
        p[x] = C
      }
      d.setBboxChanged()
      f.setBboxChanged()
      this._polyCheckCount++
      return d.intersectsPoly(f, 0, 0)
    }
    TestTilemapOverlapDifferentLayers(p, q) {
      var t = p.GetLayer(),
        x = q.GetLayer()
      m || (m = e.New(e.CollisionPoly))
      r || (r = e.New(e.Rect))
      w || (w = e.New(e.Quad))
      var v = q.GetX(),
        u = q.GetY()
      const [A, z] = x.LayerToCanvasCss(v, u),
        [C, E] = t.CanvasCssToLayer(A, z)
      t = v - C
      u -= E
      r.copy(q.GetBoundingBox())
      r.offset(t, u)
      if (!p.GetBoundingBox().intersectsRect(r)) return !1
      w.copy(q.GetBoundingQuad())
      w.offset(t, u)
      this._polyCheckCount++
      if (!p.GetBoundingQuad().intersectsQuad(w)) return !1
      m.copy(q.GetTransformedCollisionPoly())
      x = m.pointsArr()
      for (let J = 0, F = x.length; J < F; J += 2) (v = J + 1), (x[J] += t), (x[v] += u)
      return this.TestTilemapOverlap(p, q, C, E, m, r, w)
    }
    TestTilemapOverlap(p, q, t, x, v, u, A) {
      u = void 0 !== u ? u : q.GetBoundingBox()
      const z = p.GetX(),
        C = p.GetY()
      var E = p.GetInstance().GetSdkInstance()
      t = void 0 !== t ? t : q.GetX()
      x = void 0 !== x ? x : q.GetY()
      p = q.HasOwnCollisionPoly()
      A = void 0 !== A ? A : q.GetBoundingQuad()
      E.GetCollisionRectCandidates(u, a)
      for (let I = 0, L = a.length; I < L; ++I) {
        var J = a[I]
        E = J.GetRect()
        this._collisionCheckCount++
        if (u.intersectsRectOffset(E, z, C) && (g.setFromRect(E), g.offset(z, C), g.intersectsQuad(A)))
          if (p) {
            var F = void 0 !== v ? v : q.GetTransformedCollisionPoly()
            if ((J = J.GetPoly())) {
              if ((this._polyCheckCount++, J.intersectsPoly(F, t - (z + E.getLeft()), x - (C + E.getTop())))) return e.clearArray(a), !0
            } else if ((d.setFromQuad(g, 0, 0), d.intersectsPoly(F, t, x))) return e.clearArray(a), !0
          } else if ((F = J.GetPoly())) {
            if ((d.setFromQuad(A, 0, 0), F.intersectsPoly(d, -(z + E.getLeft()), -(C + E.getTop())))) return e.clearArray(a), !0
          } else return e.clearArray(a), !0
      }
      e.clearArray(a)
      return !1
    }
    TestAndSelectCanvasPointOverlap(p, q, t, x) {
      const v = p.GetCurrentSol()
      var u = this._runtime.GetCurrentEvent()
      if (!u) throw Error('cannot call outside event')
      u = u.IsOrBlock()
      if (v.IsSelectAll()) {
        x || (v._SetSelectAll(!1), e.clearArray(v._GetOwnInstances()))
        for (var A of p.GetInstances()) {
          var z = A.GetWorldInfo(),
            C = z.GetLayer()
          const [E, J] = C.CanvasCssToLayer(q, t, z.GetTotalZElevation())
          if (z.ContainsPoint(E, J)) {
            if (x) return !1
            v._PushInstance(A)
          } else u && v._PushElseInstance(A)
        }
      } else {
        A = u ? v._GetOwnElseInstances() : v._GetOwnInstances()
        z = 0
        for (let E = 0, J = A.length; E < J; ++E) {
          C = A[E]
          const F = C.GetWorldInfo(),
            I = F.GetLayer(),
            [L, N] = I.CanvasCssToLayer(q, t, F.GetTotalZElevation())
          if (F.ContainsPoint(L, N)) {
            if (x) return !1
            u ? v._PushInstance(C) : (A[z++] = C)
          } else u && (A[z++] = C)
        }
        x || (A.length = z)
      }
      p.ApplySolToContainer()
      return x ? !0 : v.HasAnyInstances()
    }
    GetCollisionCandidates(p, q, t, x) {
      p = p ? 1 !== p.GetParallaxX() || 1 !== p.GetParallaxY() : !1
      if (q.IsFamily()) for (const v of q.GetFamilyMembers()) p || v.IsAnyInstanceParallaxed() ? e.appendArray(x, v.GetInstances()) : (v._UpdateAllCollisionCells(), v._GetCollisionCellGrid().QueryRange(t, x))
      else p || q.IsAnyInstanceParallaxed() ? e.appendArray(x, q.GetInstances()) : (q._UpdateAllCollisionCells(), q._GetCollisionCellGrid().QueryRange(t, x))
    }
    GetObjectClassesCollisionCandidates(p, q, t, x) {
      for (const v of q) this.GetCollisionCandidates(p, v, t, x)
    }
    GetSolidCollisionCandidates(p, q, t) {
      const x = this._runtime.GetSolidBehavior()
      x && this.GetObjectClassesCollisionCandidates(p, x.GetObjectClasses(), q, t)
    }
    GetJumpthruCollisionCandidates(p, q, t) {
      const x = this._runtime.GetJumpthruBehavior()
      x && this.GetObjectClassesCollisionCandidates(p, x.GetObjectClasses(), q, t)
    }
    IsSolidCollisionAllowed(p, q) {
      return p._IsSolidEnabled() && (!q || q.GetWorldInfo().IsSolidCollisionAllowed(p.GetSavedDataMap().get('solidTags')))
    }
    TestOverlapSolid(p) {
      const q = p.GetWorldInfo()
      this.GetSolidCollisionCandidates(q.GetLayer(), q.GetBoundingBox(), b)
      for (const t of b) if (this.IsSolidCollisionAllowed(t, p) && this.TestOverlap(p, t)) return e.clearArray(b), t
      e.clearArray(b)
      return null
    }
    TestRectOverlapSolid(p, q) {
      this.GetSolidCollisionCandidates(null, p, b)
      for (const t of b) if (this.IsSolidCollisionAllowed(t, q) && this.TestRectOverlap(p, t)) return e.clearArray(b), t
      e.clearArray(b)
      return null
    }
    TestOverlapJumpthru(p, q) {
      let t = null
      q && ((t = c), e.clearArray(t))
      const x = p.GetWorldInfo()
      this.GetJumpthruCollisionCandidates(x.GetLayer(), x.GetBoundingBox(), b)
      for (const v of b)
        if (v._IsJumpthruEnabled() && this.TestOverlap(p, v))
          if (q) t.push(v)
          else return e.clearArray(b), v
      e.clearArray(b)
      return t
    }
    PushOut(p, q, t, x, v) {
      x = x || 50
      const u = p.GetWorldInfo(),
        A = u.GetX(),
        z = u.GetY()
      for (let C = 0; C < x; ++C) if ((u.SetXY(A + q * C, z + t * C), u.SetBboxChanged(), !this.TestOverlap(p, v))) return !0
      u.SetXY(A, z)
      u.SetBboxChanged()
      return !1
    }
    PushOutSolid(p, q, t, x, v, u) {
      x = x || 50
      const A = p.GetWorldInfo(),
        z = A.GetX(),
        C = A.GetY()
      let E = null,
        J = null
      for (let F = 0; F < x; ++F)
        if ((A.SetXY(z + q * F, C + t * F), A.SetBboxChanged(), !this.TestOverlap(p, E)))
          if ((E = this.TestOverlapSolid(p))) J = E
          else if ((v && (E = u ? (this.TestOverlap(p, u) ? u : null) : this.TestOverlapJumpthru(p)) && (J = E), !E)) return J && this.PushInFractional(p, q, t, J, 16, !0), !0
      A.SetXY(z, C)
      A.SetBboxChanged()
      return !1
    }
    PushOutSolidAxis(p, q, t, x) {
      x = x || 50
      const v = p.GetWorldInfo(),
        u = v.GetX(),
        A = v.GetY()
      let z = null,
        C = null
      for (let E = 0; E < x; ++E)
        for (let J = 0; 2 > J; ++J) {
          const F = 2 * J - 1
          v.SetXY(u + q * E * F, A + t * E * F)
          v.SetBboxChanged()
          if (!this.TestOverlap(p, z))
            if ((z = this.TestOverlapSolid(p))) C = z
            else return C && this.PushInFractional(p, q * F, t * F, C, 16, !0), !0
        }
      v.SetXY(u, A)
      v.SetBboxChanged()
      return !1
    }
    PushInFractional(p, q, t, x, v, u) {
      let A = 2,
        z = !1
      var C = !1
      const E = p.GetWorldInfo()
      let J = E.GetX(),
        F = E.GetY()
      for (; A <= v; ) (C = 1 / A), (A *= 2), E.OffsetXY(q * C * (z ? 1 : -1), t * C * (z ? 1 : -1)), E.SetBboxChanged(), this.TestOverlap(p, x) || (u && this.TestOverlapSolid(p)) ? (C = z = !0) : ((C = z = !1), (J = E.GetX()), (F = E.GetY()))
      C && (E.SetXY(J, F), E.SetBboxChanged())
    }
    PushOutSolidNearest(p, q = 100) {
      let t = 0
      const x = p.GetWorldInfo(),
        v = x.GetX(),
        u = x.GetY()
      let A = 0,
        z = this.TestOverlapSolid(p)
      if (!z) return !0
      for (; t <= q; ) {
        let C = 0,
          E = 0
        switch (A) {
          case 0:
            C = 0
            E = -1
            t++
            break
          case 1:
            C = 1
            E = -1
            break
          case 2:
            C = 1
            E = 0
            break
          case 3:
            E = C = 1
            break
          case 4:
            C = 0
            E = 1
            break
          case 5:
            C = -1
            E = 1
            break
          case 6:
            C = -1
            E = 0
            break
          case 7:
            E = C = -1
        }
        A = (A + 1) % 8
        x.SetXY(Math.floor(v + C * t), Math.floor(u + E * t))
        x.SetBboxChanged()
        if (!this.TestOverlap(p, z) && ((z = this.TestOverlapSolid(p)), !z)) return !0
      }
      x.SetXY(v, u)
      x.SetBboxChanged()
      return !1
    }
    CalculateBounceAngle(p, q, t, x) {
      const v = p.GetWorldInfo(),
        u = v.GetX(),
        A = v.GetY(),
        z = Math.max(10, e.distanceTo(q, t, u, A))
      var C = e.angleTo(q, t, u, A),
        E = x || this.TestOverlapSolid(p)
      if (!E) return e.clampAngle(C + Math.PI)
      let J = E
      var F = 0,
        I = 0
      const L = e.toRadians(5)
      let N
      for (N = 1; 36 > N; ++N) {
        const S = C - N * L
        v.SetXY(q + Math.cos(S) * z, t + Math.sin(S) * z)
        v.SetBboxChanged()
        if (!this.TestOverlap(p, J) && ((J = x ? null : this.TestOverlapSolid(p)), !J)) {
          F = S
          break
        }
      }
      36 === N && (F = e.clampAngle(C + Math.PI))
      J = E
      for (N = 1; 36 > N; ++N)
        if (((E = C + N * L), v.SetXY(q + Math.cos(E) * z, t + Math.sin(E) * z), v.SetBboxChanged(), !this.TestOverlap(p, J) && ((J = x ? null : this.TestOverlapSolid(p)), !J))) {
          I = E
          break
        }
      36 === N && (I = e.clampAngle(C + Math.PI))
      v.SetXY(u, A)
      v.SetBboxChanged()
      if (I === F) return I
      p = e.angleDiff(I, F) / 2
      p = e.angleClockwise(I, F) ? e.clampAngle(F + p + Math.PI) : e.clampAngle(I + p)
      F = Math.cos(C)
      C = Math.sin(C)
      I = Math.cos(p)
      p = Math.sin(p)
      q = F * I + C * p
      return e.angleTo(0, 0, F - 2 * q * I, C - 2 * q * p)
    }
    TestSegmentOverlap(p, q, t, x, v) {
      if (!v) return !1
      const u = v.GetWorldInfo()
      if (!u.IsCollisionEnabled()) return !1
      this._collisionCheckCount++
      h.set(Math.min(p, t), Math.min(q, x), Math.max(p, t), Math.max(q, x))
      if (!u.GetBoundingBox().intersectsRect(h)) return !1
      if (v.HasTilemap()) return this._TestSegmentOverlapTilemap(p, q, t, x, v, u)
      this._polyCheckCount++
      return u.GetBoundingQuad().intersectsSegment(p, q, t, x) ? (u.HasOwnCollisionPoly() ? u.GetTransformedCollisionPoly().intersectsSegment(u.GetX(), u.GetY(), p, q, t, x) : !0) : !1
    }
    _TestSegmentOverlapTilemap(p, q, t, x, v, u) {
      const A = u.GetX()
      u = u.GetY()
      v = v.GetSdkInstance()
      k.set(p, q, t, x)
      k.normalize()
      v.GetCollisionRectCandidates(k, a)
      for (let C = 0, E = a.length; C < E; ++C) {
        var z = a[C]
        v = z.GetRect()
        this._collisionCheckCount++
        if (h.intersectsRectOffset(v, A, u) && (g.setFromRect(v), g.offset(A, u), g.intersectsSegment(p, q, t, x)))
          if ((z = z.GetPoly())) {
            if ((this._polyCheckCount++, z.intersectsSegment(A + v.getLeft(), u + v.getTop(), p, q, t, x))) return e.clearArray(a), !0
          } else return e.clearArray(a), !0
      }
      e.clearArray(a)
      return !1
    }
    TestRectOverlap(p, q) {
      if (!q) return !1
      const t = q.GetWorldInfo()
      if (!t.IsCollisionEnabled()) return !1
      this._collisionCheckCount++
      if (!t.GetBoundingBox().intersectsRect(p)) return !1
      if (q.HasTilemap()) return this._TestRectOverlapTilemap(p, q, t)
      this._polyCheckCount++
      g.setFromRect(p)
      if (!t.GetBoundingQuad().intersectsQuad(g)) return !1
      if (!t.HasOwnCollisionPoly()) return !0
      d.setFromRect(p, t.GetX(), t.GetY())
      p = t.GetTransformedCollisionPoly()
      return d.intersectsPoly(p, 0, 0)
    }
    _TestRectOverlapTilemap(p, q, t) {
      const x = t.GetX()
      t = t.GetY()
      q.GetSdkInstance().GetCollisionRectCandidates(p, a)
      for (let u = 0, A = a.length; u < A; ++u) {
        var v = a[u]
        q = v.GetRect()
        this._collisionCheckCount++
        if (p.intersectsRectOffset(q, x, t))
          if ((v = v.GetPoly())) {
            if ((this._polyCheckCount++, d.setFromRect(p, 0, 0), v.intersectsPoly(d, -(x + q.getLeft()), -(t + q.getTop())))) return e.clearArray(a), !0
          } else return e.clearArray(a), !0
      }
      e.clearArray(a)
      return !1
    }
    TestRayIntersectsInstance(p, q) {
      if (p) {
        var t = p.GetWorldInfo()
        t.IsCollisionEnabled() &&
          (this._collisionCheckCount++,
          t.GetBoundingBox().intersectsRect(q.rect) && (p.HasTilemap() ? this._TestRayIntersectsTilemap(p, t, q) : (this._polyCheckCount++, t.HasOwnCollisionPoly() ? q.TestInstancePoly(p, t.GetX(), t.GetY(), t.GetTransformedCollisionPoly()) : q.TestInstanceQuad(p, t.GetBoundingQuad()))))
      }
    }
    _TestRayIntersectsTilemap(p, q, t) {
      const x = q.GetX(),
        v = q.GetY()
      p.GetSdkInstance().GetCollisionRectCandidates(t.rect, a)
      for (let A = 0, z = a.length; A < z; A++) {
        var u = a[A]
        const C = u.GetRect()
        this._collisionCheckCount++
        t.rect.intersectsRectOffset(C, x, v) && ((u = u.GetPoly()), this._polyCheckCount++, u ? t.TestInstancePoly(p, x + C.getLeft(), v + C.getTop(), u) : t.TestInstanceRect(p, q.GetX(), q.GetY(), C))
      }
      e.clearArray(a)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.SparseGrid = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._cellWidth = b
      this._cellHeight = a
      this._cells = e.New(e.PairMap)
    }
    Release() {
      this._cells.Release()
      this._cells = null
    }
    GetCell(b, a, c) {
      let d = this._cells.Get(b, a)
      return d ? d : c ? ((d = e.New(e.GridCell, this, b, a)), this._cells.Set(b, a, d), d) : null
    }
    XToCell(b) {
      b = Math.floor(b / this._cellWidth)
      return isFinite(b) ? b : 0
    }
    YToCell(b) {
      b = Math.floor(b / this._cellHeight)
      return isFinite(b) ? b : 0
    }
    Update(b, a, c) {
      if (a)
        for (let d = a.getLeft(), f = a.getRight(); d <= f; ++d)
          for (let g = a.getTop(), h = a.getBottom(); g <= h; ++g) {
            if (c && c.containsPoint(d, g)) continue
            const k = this.GetCell(d, g, !1)
            k && (k.Remove(b), k.IsEmpty() && this._cells.Delete(d, g))
          }
      if (c) for (let d = c.getLeft(), f = c.getRight(); d <= f; ++d) for (let g = c.getTop(), h = c.getBottom(); g <= h; ++g) (a && a.containsPoint(d, g)) || this.GetCell(d, g, !0).Insert(b)
    }
    QueryRange(b, a) {
      let c = this.XToCell(b.getLeft())
      const d = this.YToCell(b.getTop()),
        f = this.XToCell(b.getRight())
      b = this.YToCell(b.getBottom())
      if (isFinite(f) && isFinite(b))
        for (; c <= f; ++c)
          for (let g = d; g <= b; ++g) {
            const h = this.GetCell(c, g, !1)
            h && h.Dump(a)
          }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.GridCell = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      this._grid = b
      this._x = a
      this._y = c
      this._instances = e.New(e.ArraySet)
    }
    Release() {
      this._instances.Release()
      this._grid = this._instances = null
    }
    IsEmpty() {
      return this._instances.IsEmpty()
    }
    Insert(b) {
      this._instances.Add(b)
    }
    Remove(b) {
      this._instances.Delete(b)
    }
    Dump(b) {
      e.appendArray(b, this._instances.GetArray())
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Ray = class {
    constructor() {
      this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0
      this.rect = new e.Rect()
      this.hitFraction = 2
      this.hitUid = null
      this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0
      this.normalX = 1
      this.normalY = 0
      this.reflectionX = 1
      this.reflectionY = 0
    }
    DidCollide() {
      return 1.000001 > this.hitFraction
    }
    Set(b, a, c, d) {
      this.x1 = b
      this.y1 = a
      this.x2 = c
      this.y2 = d
      this.dx = c - b
      this.dy = d - a
      this.rect.set(b, a, c, d)
      this.rect.normalize()
      this.hitFraction = 2
      this.hitUid = null
      this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0
      this.normalX = 1
      this.normalY = 0
      this.reflectionX = 1
      this.reflectionY = 0
      return this
    }
    Complete() {
      if (!1 !== this.DidCollide()) {
        var b = this.dx * this.hitFraction,
          a = this.dy * this.hitFraction,
          c = Math.sqrt(b * b + a * a)
        b /= c
        a /= c
        this.distance = c - 1e-6
        this.hitX = this.x1 + b * this.distance
        this.hitY = this.y1 + a * this.distance
        this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2
        this.normalX = Math.cos(this.hitNormal)
        this.normalY = Math.sin(this.hitNormal)
        c = b * this.normalX + a * this.normalY
        this.reflectionX = b - 2 * this.normalX * c
        this.reflectionY = a - 2 * this.normalY * c
        0 < c && ((this.hitNormal = e.clampAngle(this.hitNormal + Math.PI)), (this.normalX = -this.normalX), (this.normalY = -this.normalY))
      }
    }
    TestInstanceSegment(b, a, c, d, f) {
      const g = e.rayIntersect(this.x1, this.y1, this.x2, this.y2, a, c, d, f)
      0 <= g && g < this.hitFraction && ((this.hitFraction = g), (this.hitUid = b.GetUID()), (this.hitNormalDx = a - d), (this.hitNormalDy = c - f))
    }
    TestInstanceRect(b, a, c, d) {
      const f = a + d.getLeft()
      a += d.getRight()
      const g = c + d.getTop()
      c += d.getBottom()
      this.TestInstanceSegment(b, f, g, a, g)
      this.TestInstanceSegment(b, a, g, a, c)
      this.TestInstanceSegment(b, a, c, f, c)
      this.TestInstanceSegment(b, f, c, f, g)
    }
    TestInstanceQuad(b, a) {
      const c = a.getTlx(),
        d = a.getTly(),
        f = a.getTrx(),
        g = a.getTry(),
        h = a.getBrx(),
        k = a.getBry(),
        m = a.getBlx()
      a = a.getBly()
      this.TestInstanceSegment(b, c, d, f, g)
      this.TestInstanceSegment(b, f, g, h, k)
      this.TestInstanceSegment(b, h, k, m, a)
      this.TestInstanceSegment(b, m, a, c, d)
    }
    TestInstancePoly(b, a, c, d) {
      d = d.pointsArr()
      for (let f = 0, g = d.length; f < g; f += 2) {
        const h = (f + 2) % g
        this.TestInstanceSegment(b, d[f] + a, d[f + 1] + c, d[h] + a, d[h + 1] + c)
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set('off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale'.split(' ')),
    a = new Set(['high', 'low']),
    c = e.New(e.Quad),
    d = e.New(e.Rect)
  e.CanvasManager = class extends e.DefendedBase {
    constructor(f) {
      super()
      this._runtime = f
      this._canvas = null
      this._isWebGPUEnabled = !1
      this._webgpuRenderer = this._webglRenderer = null
      this._gpuPreference = 'high-performance'
      this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight = this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = this._windowInnerHeight = this._windowInnerWidth = 0
      this._enableMipmaps = !0
      this._drawHeight = this._drawWidth = this._textureAnisotropy = 0
      this._documentFullscreenMode = this._fullscreenMode = 'letterbox-scale'
      this._deviceTransformOffY = this._deviceTransformOffX = 0
      this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = 'high'
      this._isDocumentFullscreen = !1
      this._availableAdditionalRenderTargets = []
      this._usedAdditionalRenderTargets = new Set()
      this._shaderData = null
      this._gpuLastUtilisation = this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0
      this._gpuFrameTimingsBuffer = null
      this._layersGpuProfile = new Map()
      this._gpuCurUtilisation = NaN
      this._webgpuFrameTimings = new Map()
      this._snapshotFormat = ''
      this._snapshotQuality = 1
      this._snapshotArea = e.New(e.Rect)
      this._snapshotUrl = ''
      this._snapshotResolve = this._snapshotPromise = null
      this._loaderStartTime = this._isPastingToDrawingCanvas = 0
      this._rafId = -1
      this._loadingProgress = 0
      this._loadingprogress_handler = g => (this._loadingProgress = g.progress)
      this._percentText = null
      this._splashTextures = {
        logo: null,
        powered: null,
        website: null
      }
      this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0
      this._splashState = 'fade-in'
      this._splashDoneResolve = null
      this._splashDonePromise = new Promise(g => (this._splashDoneResolve = g))
    }
    _SetGPUPowerPreference(f) {
      this._gpuPreference = f
    }
    _SetWebGPUEnabled(f) {
      this._isWebGPUEnabled = !!f
    }
    async CreateCanvas(f) {
      this._canvas = f.canvas
      this._runtime.AddDOMComponentMessageHandler('runtime', 'window-resize', g => this._OnWindowResize(g))
      this._runtime.AddDOMComponentMessageHandler('runtime', 'fullscreenchange', g => this._OnFullscreenChange(g))
      this._runtime.AddDOMComponentMessageHandler('runtime', 'fullscreenerror', g => this._OnFullscreenError(g))
      this._isDocumentFullscreen = !!f.isFullscreen
      if (this._isWebGPUEnabled)
        if (navigator.gpu)
          try {
            await this._InitWebGPU(f)
          } catch (g) {
            ;(this._webgpuRenderer = null), console.error('Failed to initialise WebGPU, switching to WebGL: ', g)
          }
        else console.warn('WebGPU was enabled but is not supported, falling back to WebGL')
      this._webgpuRenderer || (await this._InitWebGL(f))
    }
    async _InitWebGPU(f) {
      const g = {
        powerPreference: this._gpuPreference,
        depth: this._runtime.Uses3DFeatures()
      }
      this._webgpuRenderer = e.New(e.Gfx.WebGPURenderer)
      await this._webgpuRenderer.Create(this._canvas, g)
      this._webgpuRenderer.SupportsGPUProfiling() || (this._gpuLastUtilisation = NaN)
      this.SetSize(f.windowInnerWidth, f.windowInnerHeight, !0)
    }
    async _InitWebGL(f) {
      this._canvas.addEventListener('webglcontextlost', h => this._OnWebGLContextLost(h))
      this._canvas.addEventListener('webglcontextrestored', h => this._OnWebGLContextRestored(h))
      const g = {
        powerPreference: this._gpuPreference,
        enableGpuProfiling: !0,
        depth: this._runtime.Uses3DFeatures()
      }
      'Android' === e.Platform.OS && 'Chromium' === e.Platform.BrowserEngine && 75 > e.Platform.BrowserVersionNumber && (console.warn('[Construct 3] Disabling WebGL 2 because this device appears to be affected by crbug.com/934823. Install software updates to avoid this.'), (g.maxWebGLVersion = 1))
      'standard' === this._runtime.GetCompositingMode() ? (g.alpha = !0) : ((g.alpha = !1), (g.lowLatency = !0))
      this._webglRenderer = e.New(e.Gfx.WebGLRenderer, this._canvas, g)
      await this._webglRenderer.InitState()
      this._webglRenderer.SupportsGPUProfiling() || (this._gpuLastUtilisation = NaN)
      this.SetSize(f.windowInnerWidth, f.windowInnerHeight, !0)
      this._shaderData = self.C3_Shaders
      await this._LoadShaderPrograms()
      f = !1
      for (const h of this._runtime._GetAllEffectLists()) {
        for (const k of h.GetAllEffectTypes()) k._InitRenderer(this._webglRenderer), k.GetShaderProgram().UsesDest() && (f = !0)
        h.UpdateActiveEffects()
      }
      this._runtime._SetUsesAnyBackgroundBlending(f)
      this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
      this._webglRenderer.SetMipmapsEnabled(this._enableMipmaps)
    }
    async _LoadShaderPrograms() {
      if (this._shaderData) {
        var f = []
        for (const [g, h] of Object.entries(this._shaderData)) {
          const k = e.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource()
          f.push(this._webglRenderer.CreateShaderProgram(h, k, g))
        }
        await Promise.all(f)
        this._webglRenderer.ResetLastProgram()
        this._webglRenderer.SetTextureFillMode()
      }
    }
    Release() {
      this._canvas = this._webglRenderer = this._runtime = null
    }
    _OnWindowResize(f) {
      const g = this._runtime,
        h = f.devicePixelRatio
      g.IsInWorker() && (self.devicePixelRatio = h)
      g._SetDevicePixelRatio(h)
      this._isDocumentFullscreen = !!f.isFullscreen
      this.SetSize(f.innerWidth, f.innerHeight)
      g.UpdateRender()
      g.IsDebug() && (g.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && g.Render()
    }
    _OnFullscreenChange(f) {
      this._isDocumentFullscreen = !!f.isFullscreen
      this.SetSize(f.innerWidth, f.innerHeight, !0)
      this._runtime.UpdateRender()
    }
    _OnFullscreenError(f) {
      this._isDocumentFullscreen = !!f.isFullscreen
      this.SetSize(f.innerWidth, f.innerHeight, !0)
      this._runtime.UpdateRender()
    }
    SetSize(f, g, h = !1) {
      f = Math.floor(f)
      g = Math.floor(g)
      if (0 >= f || 0 >= g) throw Error('invalid size')
      if (this._windowInnerWidth !== f || this._windowInnerHeight !== g || h) {
        this._windowInnerWidth = f
        this._windowInnerHeight = g
        h = this.GetCurrentFullscreenMode()
        'letterbox-scale' === h ? this._CalculateLetterboxScale(f, g) : 'letterbox-integer-scale' === h ? this._CalculateLetterboxIntegerScale(f, g) : 'off' === h ? this._CalculateFixedSizeCanvas(f, g) : this._CalculateFullsizeCanvas(f, g)
        this._UpdateFullscreenScalingQuality(h)
        this._canvas.width = this._canvasDeviceWidth
        this._canvas.height = this._canvasDeviceHeight
        this._runtime.PostComponentMessageToDOM('canvas', 'update-size', {
          marginLeft: this._canvasCssOffsetX,
          marginTop: this._canvasCssOffsetY,
          styleWidth: this._canvasCssWidth,
          styleHeight: this._canvasCssHeight
        })
        f = this.GetRenderer()
        f.SetSize(this._canvasDeviceWidth, this._canvasDeviceHeight, !0)
        for (var k of this._availableAdditionalRenderTargets) f.DeleteRenderTarget(k)
        e.clearArray(this._availableAdditionalRenderTargets)
        k = this._runtime.GetLayoutManager()
        k.SetAllLayerProjectionChanged()
        k.SetAllLayerMVChanged()
      }
    }
    _CalculateLetterboxScale(f, g) {
      const h = this._runtime.GetDevicePixelRatio(),
        k = this._runtime.GetOriginalViewportWidth(),
        m = this._runtime.GetOriginalViewportHeight(),
        r = k / m
      f / g > r
        ? ((this._canvasCssWidth = Math.round(g * r)), (this._canvasCssHeight = g), (this._canvasCssOffsetX = Math.floor((f - this._canvasCssWidth) / 2)), (this._canvasCssOffsetY = 0))
        : ((this._canvasCssWidth = f), (this._canvasCssHeight = Math.round(f / r)), (this._canvasCssOffsetX = 0), (this._canvasCssOffsetY = Math.floor((g - this._canvasCssHeight) / 2)))
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h)
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * h)
      this._runtime.SetViewportSize(k, m)
    }
    _CalculateLetterboxIntegerScale(f, g) {
      const h = this._runtime.GetDevicePixelRatio()
      1 !== h && ((f += 1), (g += 1))
      const k = this._runtime.GetOriginalViewportWidth(),
        m = this._runtime.GetOriginalViewportHeight()
      var r = k / m
      r = f / g > r ? (g * r * h) / k : ((f / r) * h) / m
      1 < r ? (r = Math.floor(r)) : 1 > r && (r = 1 / Math.ceil(1 / r))
      this._canvasDeviceWidth = Math.round(k * r)
      this._canvasDeviceHeight = Math.round(m * r)
      this._canvasCssWidth = this._canvasDeviceWidth / h
      this._canvasCssHeight = this._canvasDeviceHeight / h
      this._canvasCssOffsetX = Math.max(Math.floor((f - this._canvasCssWidth) / 2), 0)
      this._canvasCssOffsetY = Math.max(Math.floor((g - this._canvasCssHeight) / 2), 0)
      this._runtime.SetViewportSize(k, m)
    }
    _CalculateFullsizeCanvas(f, g) {
      const h = this._runtime.GetDevicePixelRatio()
      this._canvasCssWidth = f
      this._canvasCssHeight = g
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h)
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * h)
      this._canvasCssOffsetY = this._canvasCssOffsetX = 0
      f = this.GetDisplayScale()
      this._runtime.SetViewportSize(this._canvasCssWidth / f, this._canvasCssHeight / f)
    }
    _CalculateFixedSizeCanvas(f, g) {
      const h = this._runtime.GetDevicePixelRatio()
      this._canvasCssWidth = this._runtime.GetViewportWidth()
      this._canvasCssHeight = this._runtime.GetViewportHeight()
      this._canvasDeviceWidth = Math.round(this._canvasCssWidth * h)
      this._canvasDeviceHeight = Math.round(this._canvasCssHeight * h)
      this.IsDocumentFullscreen() ? ((this._canvasCssOffsetX = Math.floor((f - this._canvasCssWidth) / 2)), (this._canvasCssOffsetY = Math.floor((g - this._canvasCssHeight) / 2))) : (this._canvasCssOffsetY = this._canvasCssOffsetX = 0)
      this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
    }
    _UpdateFullscreenScalingQuality(f) {
      if ('high' === this._wantFullscreenScalingQuality) (this._drawWidth = this._canvasDeviceWidth), (this._drawHeight = this._canvasDeviceHeight), (this._fullscreenScalingQuality = 'high')
      else {
        let h
        if ('off' === this.GetCurrentFullscreenMode()) {
          var g = this._runtime.GetViewportWidth()
          h = this._runtime.GetViewportHeight()
        } else (g = this._runtime.GetOriginalViewportWidth()), (h = this._runtime.GetOriginalViewportHeight())
        this._canvasDeviceWidth < g && this._canvasDeviceHeight < h
          ? ((this._drawWidth = this._canvasDeviceWidth), (this._drawHeight = this._canvasDeviceHeight), (this._fullscreenScalingQuality = 'high'))
          : ((this._drawWidth = g),
            (this._drawHeight = h),
            (this._fullscreenScalingQuality = 'low'),
            'scale-inner' === f
              ? ((f = g / h), (g = this._windowInnerWidth / this._windowInnerHeight), g < f ? (this._drawWidth = this._drawHeight * g) : g > f && (this._drawHeight = this._drawWidth / g))
              : 'scale-outer' === f && ((f = g / h), (g = this._windowInnerWidth / this._windowInnerHeight), g > f ? (this._drawWidth = this._drawHeight * g) : g < f && (this._drawHeight = this._drawWidth / g)))
      }
    }
    IsDocumentFullscreen() {
      return this._isDocumentFullscreen
    }
    SetFullscreenMode(f) {
      if (!b.has(f)) throw Error('invalid fullscreen mode')
      this._fullscreenMode = f
      f = this._runtime.GetLayoutManager()
      f.SetAllLayerProjectionChanged()
      f.SetAllLayerMVChanged()
    }
    GetFullscreenMode() {
      return this._fullscreenMode
    }
    SetDocumentFullscreenMode(f) {
      if (!b.has(f)) throw Error('invalid fullscreen mode')
      this._documentFullscreenMode = f
      f = this._runtime.GetLayoutManager()
      f.SetAllLayerProjectionChanged()
      f.SetAllLayerMVChanged()
    }
    GetDocumentFullscreenMode() {
      return this._documentFullscreenMode
    }
    GetCurrentFullscreenMode() {
      return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() : this.GetFullscreenMode()
    }
    SetFullscreenScalingQuality(f) {
      if (!a.has(f)) throw Error('invalid fullscreen scaling quality')
      this._wantFullscreenScalingQuality = f
      this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
    }
    GetSetFullscreenScalingQuality() {
      return this._wantFullscreenScalingQuality
    }
    GetCurrentFullscreenScalingQuality() {
      return this._fullscreenScalingQuality
    }
    static _FullscreenModeNumberToString(f) {
      switch (f) {
        case 0:
          return 'off'
        case 1:
          return 'crop'
        case 2:
          return 'scale-inner'
        case 3:
          return 'scale-outer'
        case 4:
          return 'letterbox-scale'
        case 5:
          return 'letterbox-integer-scale'
        default:
          throw Error('invalid fullscreen mode')
      }
    }
    GetLastWidth() {
      return this._windowInnerWidth
    }
    GetLastHeight() {
      return this._windowInnerHeight
    }
    GetDrawWidth() {
      return this._drawWidth
    }
    GetDrawHeight() {
      return this._drawHeight
    }
    SetMipmapsEnabled(f) {
      this._enableMipmaps = !!f
    }
    _SetTextureAnisotropy(f) {
      this._textureAnisotropy = f
    }
    GetTextureAnisotropy() {
      return this._textureAnisotropy
    }
    IsRendererContextLost() {
      return this.GetRenderer().IsContextLost()
    }
    _OnWebGLContextLost(f) {
      console.log('[Construct 3] WebGL context lost')
      f.preventDefault()
      this._availableAdditionalRenderTargets = []
      this._usedAdditionalRenderTargets.clear()
      this._webglRenderer.OnContextLost()
      this._runtime._OnWebGLContextLost()
    }
    async _OnWebGLContextRestored(f) {
      await this._webglRenderer.OnContextRestored()
      await this._LoadShaderPrograms()
      for (const g of this._runtime._GetAllEffectLists()) for (const h of g.GetAllEffectTypes()) h._InitRenderer(this._webglRenderer)
      await this._runtime._OnWebGLContextRestored()
      console.log('[Construct 3] WebGL context restored')
    }
    GetWebGLRenderer() {
      return this._webglRenderer
    }
    GetWebGPURenderer() {
      return this._webgpuRenderer
    }
    GetRenderer() {
      return this._webgpuRenderer || this._webglRenderer
    }
    GetRenderScale() {
      return 'low' === this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
    }
    GetDisplayScale() {
      const f = this.GetCurrentFullscreenMode()
      if ('off' === f || 'crop' === f) return 1
      const g = this._runtime.GetOriginalViewportWidth(),
        h = this._runtime.GetOriginalViewportHeight(),
        k = g / h,
        m = this._canvasDeviceWidth / this._canvasDeviceHeight
      return ('scale-inner' !== f && m > k) || ('scale-inner' === f && m < k) ? this._canvasCssHeight / h : this._canvasCssWidth / g
    }
    SetDeviceTransformOffset(f, g) {
      this._deviceTransformOffX = f
      this._deviceTransformOffY = g
    }
    SetDeviceTransform(f, g, h) {
      g = (g || this._drawWidth) / 2 + this._deviceTransformOffX
      const k = (h || this._drawHeight) / 2 + this._deviceTransformOffY
      h = f.CalculateLookAtModelView2(g, k, f.GetDefaultCameraZ() * this._runtime.GetDevicePixelRatio(), g, k, 0, h || this._drawHeight)
      f.SetModelViewMatrix(h)
    }
    SetCssTransform(f) {
      var g = this._canvasCssWidth / 2
      const h = this._canvasCssHeight / 2
      g = f.CalculateLookAtModelView2(g, h, f.GetDefaultCameraZ(), g, h, 0)
      f.SetModelViewMatrix(g)
    }
    GetDeviceWidth() {
      return this._canvasDeviceWidth
    }
    GetDeviceHeight() {
      return this._canvasDeviceHeight
    }
    GetCssWidth() {
      return this._canvasCssWidth
    }
    GetCssHeight() {
      return this._canvasCssHeight
    }
    GetCanvasClientX() {
      return this._canvasCssOffsetX
    }
    GetCanvasClientY() {
      return this._canvasCssOffsetY
    }
    GetAdditionalRenderTarget(f) {
      f.depth = this._runtime.Uses3DFeatures()
      const g = this._availableAdditionalRenderTargets,
        h = g.findIndex(m => m.IsCompatibleWithOptions(f))
      let k
      ;-1 !== h ? ((k = g[h]), g.splice(h, 1)) : (k = this.GetRenderer().CreateRenderTarget(f))
      this._usedAdditionalRenderTargets.add(k)
      return k
    }
    ReleaseAdditionalRenderTarget(f) {
      if (!this._usedAdditionalRenderTargets.has(f)) throw Error('render target not in use')
      this._usedAdditionalRenderTargets.delete(f)
      this._availableAdditionalRenderTargets.push(f)
    }
    *activeLayersGpuProfiles() {
      for (const f of this._runtime.GetLayoutManager().runningLayouts())
        for (const g of f.GetLayers()) {
          const h = this._layersGpuProfile.get(g)
          h && (yield h)
        }
    }
    GetLayerTimingsBuffer(f) {
      if (!this.GetRenderer().SupportsGPUProfiling()) return null
      let g = this._layersGpuProfile.get(f)
      g ||
        ((g = {
          name: f.GetName(),
          timingsBuffer: e.New(e.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
          curUtilisation: 0,
          lastUtilisation: 0
        }),
        this._layersGpuProfile.set(f, g))
      return g.timingsBuffer
    }
    _Update1sFrameRange() {
      const f = this.GetRenderer()
      if (f.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
        this._gpuTimeEndFrame = f.GetFrameNumber()
        this._gpuCurUtilisation = NaN
        for (const g of this.activeLayersGpuProfiles()) g.curUtilisation = NaN
      }
    }
    _UpdateTick() {
      this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL()
      this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
    }
    _UpdateTick_WebGL() {
      if (isNaN(this._gpuCurUtilisation) && ((this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame)), !isNaN(this._gpuCurUtilisation))) {
        if (this._runtime.IsDebug()) for (const f of this.activeLayersGpuProfiles()) if (((f.curUtilisation = f.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame)), isNaN(f.curUtilisation))) return
        this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame)
        this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1)
        if (this._runtime.IsDebug()) {
          for (const f of this.activeLayersGpuProfiles()) f.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame), (f.lastUtilisation = Math.min(f.curUtilisation, 1))
          self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
        }
        this._gpuTimeStartFrame = this._gpuTimeEndFrame
        this._gpuTimeEndFrame = 0
      }
    }
    GetGPUFrameTimingsBuffer() {
      return this._gpuFrameTimingsBuffer
    }
    _UpdateTick_WebGPU() {
      if (0 !== this._gpuTimeEndFrame) {
        for (var f = this._gpuTimeStartFrame; f < this._gpuTimeEndFrame; ++f) {
          var g = this._webgpuFrameTimings.get(f)
          if (g && !g.HasResult()) return
        }
        g = this._runtime.GetMainRunningLayout()
        f = e.MakeFilledArray(g.GetLayerCount() + 1, 0)
        for (var h = this._gpuTimeStartFrame; h < this._gpuTimeEndFrame; ++h) {
          var k = this._webgpuFrameTimings.get(h)
          if (k) {
            k = k.GetResult()
            for (let m = 0, r = Math.min(f.length, k.length / 2); m < r; ++m) {
              const w = k[2 * m],
                p = k[2 * m + 1]
              f[m] = 0 === Number(w) || 0 === Number(p) ? NaN : f[m] + Number(p - w) / 1e9
            }
          }
        }
        this._gpuLastUtilisation = e.clamp(f[0], 0, 1)
        if (this._runtime.IsDebug()) {
          h = []
          g = g.GetLayers()
          for (let m = 0, r = Math.min(g.length, f.length - 1); m < r; ++m)
            h.push({
              name: g[m].GetName(),
              lastUtilisation: e.clamp(f[m + 1], 0, 1)
            })
          self.C3Debugger.UpdateGPUProfile(this._gpuLastUtilisation, h)
        }
        for (f = this._gpuTimeStartFrame; f < this._gpuTimeEndFrame; ++f) this._webgpuFrameTimings.delete(f)
        this._gpuTimeStartFrame = this._gpuTimeEndFrame
        this._gpuTimeEndFrame = 0
      }
    }
    _AddWebGPUFrameTiming(f) {
      this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), f)
    }
    GetGPUUtilisation() {
      return this._gpuLastUtilisation
    }
    SnapshotCanvas(f, g, h, k, m, r) {
      this._snapshotFormat = f
      this._snapshotQuality = g
      this._snapshotArea.setWH(h, k, m, r)
      return this._snapshotPromise
        ? this._snapshotPromise
        : (this._snapshotPromise = new Promise(w => {
            this._snapshotResolve = w
          }))
    }
    _MaybeTakeSnapshot() {
      if (this._snapshotFormat) {
        var f = this._canvas,
          g = this._snapshotArea,
          h = e.clamp(Math.floor(g.getLeft()), 0, f.width),
          k = e.clamp(Math.floor(g.getTop()), 0, f.height),
          m = g.width()
        m = 0 === m ? f.width - h : e.clamp(Math.floor(m), 0, f.width - h)
        g = g.height()
        g = 0 === g ? f.height - k : e.clamp(Math.floor(g), 0, f.height - k)
        ;(0 !== h || 0 !== k || m !== f.width || g !== f.height) && 0 < m && 0 < g && ((f = e.CreateCanvas(m, g)), f.getContext('2d').drawImage(this._canvas, h, k, m, g, 0, 0, m, g))
        e.CanvasToBlob(f, this._snapshotFormat, this._snapshotQuality).then(r => {
          this._snapshotUrl = URL.createObjectURL(r)
          this._snapshotPromise = null
          this._snapshotResolve(this._snapshotUrl)
        })
        this._snapshotFormat = ''
        this._snapshotQuality = 1
      }
    }
    GetCanvasSnapshotUrl() {
      return this._snapshotUrl
    }
    SetIsPastingToDrawingCanvas(f) {
      f ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
    }
    IsPastingToDrawingCanvas() {
      return 0 < this._isPastingToDrawingCanvas
    }
    InitLoadingScreen(f) {
      this._webglRenderer &&
        (2 === f
          ? ((this._percentText = e.New(e.Gfx.RendererText, this.GetRenderer())),
            this._percentText.SetIsAsync(!1),
            this._percentText.SetFontName('Arial'),
            this._percentText.SetFontSize(16),
            this._percentText.SetHorizontalAlignment('center'),
            this._percentText.SetVerticalAlignment('center'),
            this._percentText.SetSize(300, 200))
          : 0 === f
          ? (f = this._runtime.GetLoadingLogoAsset()) && f.LoadStaticTexture(this._webglRenderer).catch(g => console.warn('[C3 runtime] Failed to create texture for loading logo: ', g))
          : 4 === f &&
            (this._LoadSvgSplashImage('splash-images/splash-logo.svg')
              .then(g => {
                'done' === this._splashState ? this._webglRenderer.DeleteTexture(g) : (this._splashTextures.logo = g)
              })
              .catch(g => console.warn('Failed to load splash image: ', g)),
            this._LoadBitmapSplashImage('splash-images/splash-poweredby-512.png')
              .then(g => {
                'done' === this._splashState ? this._webglRenderer.DeleteTexture(g) : (this._splashTextures.powered = g)
              })
              .catch(g => console.warn('Failed to load splash image: ', g)),
            this._LoadBitmapSplashImage('splash-images/splash-website-512.png')
              .then(g => {
                'done' === this._splashState ? this._webglRenderer.DeleteTexture(g) : (this._splashTextures.website = g)
              })
              .catch(g => console.warn('Failed to load splash image: ', g))))
    }
    async _LoadSvgSplashImage(f) {
      f = new URL(f, this._runtime.GetBaseURL()).toString()
      f = await e.FetchBlob(f)
      f = await this._runtime.RasterSvgImage(f, 2048, 2048)
      return await this._webglRenderer.CreateStaticTextureAsync(f, {
        mipMapQuality: 'high'
      })
    }
    async _LoadBitmapSplashImage(f) {
      f = new URL(f, this._runtime.GetBaseURL()).toString()
      f = await e.FetchBlob(f)
      return await this._webglRenderer.CreateStaticTextureAsync(f, {
        mipMapQuality: 'high'
      })
    }
    HideCordovaSplashScreen() {
      this._runtime.PostComponentMessageToDOM('runtime', 'hide-cordova-splash')
    }
    StartLoadingScreen() {
      this._loaderStartTime = Date.now()
      this._runtime.Dispatcher().addEventListener('loadingprogress', this._loadingprogress_handler)
      this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
      3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
    }
    async EndLoadingScreen() {
      if (this._webglRenderer) {
        this._loadingProgress = 1
        var f = this._runtime.GetLoaderStyle()
        4 === f && (await this._splashDonePromise)
        this._splashDonePromise = this._splashDoneResolve = null
        ;-1 !== this._rafId && (cancelAnimationFrame(this._rafId), (this._rafId = -1))
        this._runtime.Dispatcher().removeEventListener('loadingprogress', this._loadingprogress_handler)
        this._loadingprogress_handler = null
        this._percentText && (this._percentText.Release(), (this._percentText = null))
        this._runtime.ReleaseLoadingLogoAsset()
        this._webglRenderer.Start()
        this._splashTextures.logo && (this._webglRenderer.DeleteTexture(this._splashTextures.logo), (this._splashTextures.logo = null))
        this._splashTextures.powered && (this._webglRenderer.DeleteTexture(this._splashTextures.powered), (this._splashTextures.powered = null))
        this._splashTextures.website && (this._webglRenderer.DeleteTexture(this._splashTextures.website), (this._splashTextures.website = null))
        this._webglRenderer.ClearRgba(0, 0, 0, 0)
        this._webglRenderer.Finish()
        this._splashState = 'done'
        this._gpuTimeStartFrame = this._webglRenderer.GetFrameNumber()
        3 === f && this.HideCordovaSplashScreen()
      }
    }
    _DrawLoadingScreen() {
      if (-1 !== this._rafId) {
        var f = this._webglRenderer
        if (f) {
          f.Start()
          this._rafId = -1
          var g = this._runtime.GetAssetManager().HasHadErrorLoading(),
            h = this._runtime.GetLoaderStyle()
          3 !== h && (this.SetCssTransform(f), f.ClearRgba(0, 0, 0, 0), f.ResetColor(), f.SetTextureFillMode(), f.SetTexture(null))
          if (0 === h) this._DrawProgressBarAndLogoLoadingScreen(g)
          else if (1 === h) this._DrawProgressBarLoadingScreen(g, 120, 0)
          else if (2 === h) this._DrawPercentTextLoadingScreen(g)
          else if (3 === h) e.noop()
          else if (4 === h) this._DrawSplashLoadingScreen(g)
          else throw Error('invalid loader style')
          f.Finish()
          this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
        }
      }
    }
    _DrawPercentTextLoadingScreen(f) {
      f ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(0.6, 0.6, 0.6)
      this._percentText.SetText(Math.round(100 * this._loadingProgress) + '%')
      f = this._canvasCssWidth / 2
      const g = this._canvasCssHeight / 2
      c.setRect(f - 150, g - 100, f + 150, g + 100)
      this._webglRenderer.SetTexture(this._percentText.GetTexture())
      this._webglRenderer.Quad3(c, this._percentText.GetTexRect())
    }
    _DrawProgressBarLoadingScreen(f, g, h) {
      const k = this._webglRenderer
      k.SetColorFillMode()
      f ? k.SetColorRgba(1, 0, 0, 1) : k.SetColorRgba(0.118, 0.565, 1, 1)
      f = this._canvasCssWidth / 2
      const m = this._canvasCssHeight / 2,
        r = g / 2
      d.setWH(f - r, m - 4 + h, Math.floor(g * this._loadingProgress), 8)
      k.Rect(d)
      d.setWH(f - r, m - 4 + h, g, 8)
      d.offset(-0.5, -0.5)
      d.inflate(0.5, 0.5)
      k.SetColorRgba(0, 0, 0, 1)
      k.LineRect2(d)
      d.inflate(1, 1)
      k.SetColorRgba(1, 1, 1, 1)
      k.LineRect2(d)
    }
    _DrawProgressBarAndLogoLoadingScreen(f) {
      var g = this._runtime.GetLoadingLogoAsset()
      if (g)
        if ((g = g.GetTexture())) {
          var h = g.GetWidth(),
            k = g.GetHeight(),
            m = this._canvasCssWidth / 2,
            r = this._canvasCssHeight / 2,
            w = h / 2
          k /= 2
          c.setRect(m - w, r - k, m + w, r + k)
          this._webglRenderer.SetTexture(g)
          this._webglRenderer.Quad(c)
          this._DrawProgressBarLoadingScreen(f, h, k + 16)
        } else this._DrawProgressBarLoadingScreen(f, 120, 0)
      else this._DrawProgressBarLoadingScreen(f, 120, 0)
    }
    _DrawSplashLoadingScreen(f) {
      const g = this._webglRenderer,
        h = this._splashTextures.logo,
        k = this._splashTextures.powered,
        m = this._splashTextures.website,
        r = Date.now()
      0 === this._splashFrameNumber && (this._loaderStartTime = r)
      const w = this._runtime.IsPreview() || (this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova()),
        p = w ? 0 : 200,
        q = w ? 0 : 3e3
      let t = 1
      'fade-in' === this._splashState ? (t = Math.min((r - this._loaderStartTime) / 300, 1)) : 'fade-out' === this._splashState && (t = Math.max(1 - (r - this._splashFadeOutStartTime) / 300, 0))
      g.SetColorFillMode()
      g.SetColorRgba(0.231 * t, 0.251 * t, 0.271 * t, t)
      d.set(0, 0, this._canvasCssWidth, this._canvasCssHeight)
      g.Rect(d)
      const x = Math.ceil(this._canvasCssWidth),
        v = Math.ceil(this._canvasCssHeight)
      let u
      256 < this._canvasCssHeight
        ? (g.SetColorRgba(0.302 * t, 0.334 * t, 0.365 * t, t),
          (u = Math.max(0.005 * v, 2)),
          d.setWH(0, 0.8 * v - u / 2, x, u),
          g.Rect(d),
          f ? g.SetColorRgba(t, 0, 0, t) : g.SetColorRgba(0.161 * t, 0.953 * t, 0.816 * t, t),
          (f = x * this._loadingProgress),
          d.setWH(0.5 * x - f / 2, 0.8 * v - u / 2, f, u),
          g.Rect(d),
          g.SetColorRgba(t, t, t, t),
          g.SetTextureFillMode(),
          k && ((f = 1.5 * e.clamp(0.22 * v, 105, 0.6 * x)), (u = f / 8), d.setWH(0.5 * x - f / 2, 0.2 * v - u / 2, f, u), g.SetTexture(k), g.Rect(d)),
          h && ((u = f = Math.min(0.395 * v, 0.95 * x)), d.setWH(0.5 * x - f / 2, 0.485 * v - u / 2, f, u), g.SetTexture(h), g.Rect(d)),
          m && ((f = 1.5 * e.clamp(0.22 * v, 105, 0.6 * x)), (u = f / 8), d.setWH(0.5 * x - f / 2, 0.868 * v - u / 2, f, u), g.SetTexture(m), g.Rect(d)))
        : (g.SetColorRgba(0.302 * t, 0.334 * t, 0.365 * t, t),
          (u = Math.max(0.005 * v, 2)),
          d.setWH(0, 0.85 * v - u / 2, x, u),
          g.Rect(d),
          f ? g.SetColorRgba(t, 0, 0, t) : g.SetColorRgba(0.161 * t, 0.953 * t, 0.816 * t, t),
          (f = x * this._loadingProgress),
          d.setWH(0.5 * x - f / 2, 0.85 * v - u / 2, f, u),
          g.Rect(d),
          g.SetColorRgba(t, t, t, t),
          g.SetTextureFillMode(),
          h && ((u = f = 0.55 * v), d.setWH(0.5 * x - f / 2, 0.45 * v - u / 2, f, u), g.SetTexture(h), g.Rect(d)))
      this._splashFrameNumber++
      'fade-in' === this._splashState && 300 <= r - this._loaderStartTime && 2 <= this._splashFrameNumber && ((this._splashState = 'wait'), (this._splashFadeInFinishTime = r))
      'wait' === this._splashState && r - this._splashFadeInFinishTime >= q && 1 <= this._loadingProgress && ((this._splashState = 'fade-out'), (this._splashFadeOutStartTime = r))
      ;(('fade-out' === this._splashState && r - this._splashFadeOutStartTime >= 300 + p) || (w && 1 <= this._loadingProgress && 500 > r - this._loaderStartTime)) && this._splashDoneResolve()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3Debugger,
    a = {
      messagePort: null,
      baseUrl: '',
      headless: !1,
      hasDom: !0,
      isInWorker: !1,
      useAudio: !0,
      projectData: '',
      exportType: ''
    }
  let c = !0
  e.Runtime = class extends e.DefendedBase {
    constructor(d) {
      d = Object.assign({}, a, d)
      super()
      this._messagePort = d.messagePort
      this._baseUrl = d.baseUrl
      this._isHeadless = !!d.headless
      this._hasDom = !!d.hasDom
      this._isInWorker = !!d.isInWorker
      c = d.ife
      this._useAudio = !!d.useAudio
      this._exportType = d.exportType
      this._isiOSCordova = !!d.isiOSCordova
      this._isiOSWebView = !!d.isiOSWebView
      this._isFBInstantAvailable = !!d.isFBInstantAvailable
      this._opusWasmScriptUrl = d.opusWasmScriptUrl
      this._opusWasmBinaryUrl = d.opusWasmBinaryUrl
      this._isDebugging = this._breakpointsEnabled = this._isDebug = !('preview' !== this._exportType || !d.isDebug)
      this._debuggingDisabled = 0
      this._additionalLoadPromises = []
      this._additionalCreatePromises = []
      this._isUsingCreatePromises = !1
      this._appId = this._projectUniqueId = this._projectVersion = this._projectName = ''
      this._originalViewportHeight = this._originalViewportWidth = 0
      this._devicePixelRatio = self.devicePixelRatio
      this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0
      this._usesLoaderLayout = !1
      this._isLoading = !0
      this._usesAnyBackgroundBlending = !1
      this._loadingLogoAsset = null
      this._assetManager = e.New(e.AssetManager, this, d)
      this._layoutManager = e.New(e.LayoutManager, this)
      this._eventSheetManager = e.New(e.EventSheetManager, this)
      this._pluginManager = e.New(e.PluginManager, this)
      this._collisionEngine = e.New(e.CollisionEngine, this)
      this._timelineManager = e.New(e.TimelineManager, this)
      this._transitionManager = e.New(e.TransitionManager, this)
      this._allObjectClasses = []
      this._objectClassesByName = new Map()
      this._objectClassesBySid = new Map()
      this._familyCount = 0
      this._allContainers = []
      this._allEffectLists = []
      this._currentLayoutStack = []
      this._instancesPendingCreate = []
      this._instancesPendingDestroy = new Map()
      this._isFlushingPendingInstances = this._hasPendingInstances = !1
      this._nextUid = this._objectCount = 0
      this._instancesByUid = new Map()
      this._instancesToReleaseAtEndOfTick = new Set()
      this._instancesToReleaseAffectedObjectClasses = new Set()
      this._objectReferenceTable = []
      this._jsPropNameTable = []
      this._canvasManager = null
      this._uses3dFeatures = !1
      this._framerateMode = 'vsync'
      this._compositingMode = 'standard'
      this._sampling = 'trilinear'
      this._isPixelRoundingEnabled = !1
      this._needRender = !0
      this._isPausedOnBlur = this._pauseOnBlur = !1
      this._tickCallbacks = {
        normal: f => {
          this._ruafId = this._rafId = -1
          this.Tick(f)
        },
        tickOnly: f => {
          this._ruafId = -1
          this.Tick(f, !1, 'skip-render')
        },
        renderOnly: () => {
          this._rafId = -1
          this.Render()
        }
      }
      this._ruafId = this._rafId = -1
      this._execCount = this._tickCountNoSave = this._tickCount = 0
      this._hasStartedTicking = this._isInTick = this._hasStarted = !1
      this._isLayoutFirstTick = !0
      this._suspendCount = 0
      this._scheduleTriggersThrottle = new e.PromiseThrottle(1)
      this._randomNumberCallback = () => Math.random()
      this._dt = this._dt1 = this._lastTickTime = this._startTime = 0
      this._timeScale = 1
      this._minimumFramerate = 30
      this._gameTime = e.New(e.KahanSum)
      this._gameTimeRaw = e.New(e.KahanSum)
      this._wallTime = e.New(e.KahanSum)
      this._fpsFrameCount = -1
      this._mainThreadTime = this._mainThreadTimeCounter = this._fps = this._fpsLastTime = 0
      this._isLoadingState = !1
      this._loadFromSlotName = this._saveToSlotName = ''
      this._loadFromJson = null
      this._lastSaveJson = ''
      this._savegamesStorage = this._projectStorage = null
      this._dispatcher = e.New(e.Event.Dispatcher)
      this._domEventHandlers = new Map()
      this._pendingResponsePromises = new Map()
      this._nextDomResponseId = 0
      this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1
      this._waitingToHandleEvents = []
      this._eventObjects = {
        pretick: e.New(e.Event, 'pretick', !1),
        tick: e.New(e.Event, 'tick', !1),
        tick2: e.New(e.Event, 'tick2', !1),
        instancedestroy: e.New(e.Event, 'instancedestroy', !1),
        beforelayoutchange: e.New(e.Event, 'beforelayoutchange', !1),
        layoutchange: e.New(e.Event, 'layoutchange', !1)
      }
      this._eventObjects.instancedestroy.instance = null
      this._userScriptDispatcher = e.New(e.Event.Dispatcher)
      this._userScriptEventObjects = null
      this._behInstsToTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence)
      this._behInstsToPostTick = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence)
      this._behInstsToTick2 = e.New(e.RedBlackSet, e.BehaviorInstance.SortByTickSequence)
      this._jobScheduler = e.New(e.JobSchedulerRuntime, this, d.jobScheduler)
      d.canvas && (this._canvasManager = e.New(e.CanvasManager, this))
      this._messagePort.onmessage = f => this._OnMessageFromDOM(f.data)
      this.AddDOMComponentMessageHandler('runtime', 'visibilitychange', f => this._OnVisibilityChange(f))
      this.AddDOMComponentMessageHandler('runtime', 'opus-decode', f => this._WasmDecodeWebMOpus(f.arrayBuffer))
      this.AddDOMComponentMessageHandler('runtime', 'get-remote-preview-status-info', () => this._GetRemotePreviewStatusInfo())
      this.AddDOMComponentMessageHandler('runtime', 'js-invoke-function', f => this._InvokeFunctionFromJS(f))
      this.AddDOMComponentMessageHandler('runtime', 'go-to-last-error-script', self.goToLastErrorScript)
      this._dispatcher.addEventListener('window-blur', f => this._OnWindowBlur(f))
      this._dispatcher.addEventListener('window-focus', () => this._OnWindowFocus())
      this._timelineManager.AddRuntimeListeners()
      this._iRuntime = null
      this._interfaceMap = new WeakMap()
      this._commonScriptInterfaces = {
        keyboard: null,
        mouse: null,
        touch: null
      }
    }
    static Create(d) {
      return e.New(e.Runtime, d)
    }
    Release() {
      e.clearArray(this._allObjectClasses)
      this._objectClassesByName.clear()
      this._objectClassesBySid.clear()
      this._layoutManager.Release()
      this._layoutManager = null
      this._eventSheetManager.Release()
      this._eventSheetManager = null
      this._pluginManager.Release()
      this._pluginManager = null
      this._assetManager.Release()
      this._assetManager = null
      this._collisionEngine.Release()
      this._collisionEngine = null
      this._timelineManager.Release()
      this._timelineManager = null
      this._transitionManager.Release()
      this._transitionManager = null
      this._canvasManager && (this._canvasManager.Release(), (this._canvasManager = null))
      this._dispatcher.Release()
      this._tickEvent = this._dispatcher = null
    }
    ['_OnMessageFromDOM'](d) {
      const f = d.type
      if ('event' === f) this._OnEventFromDOM(d)
      else if ('result' === f) this._OnResultFromDOM(d)
      else throw Error(`unknown message '${f}'`)
    }
    _OnEventFromDOM(d) {
      if (this._isReadyToHandleEvents) {
        var f = d.component,
          g = d.handler,
          h = d.data,
          k = d.dispatchOpts,
          m = !(!k || !k.dispatchRuntimeEvent)
        k = !(!k || !k.dispatchUserScriptEvent)
        var r = d.responseId
        if ('runtime' === f && (m && ((d = new e.Event(g)), (d.data = h), this._dispatcher.dispatchEventAndWaitAsyncSequential(d)), k)) {
          d = new e.Event(g, !0)
          for (const [w, p] of Object.entries(h)) d[w] = p
          this.DispatchUserScriptEvent(d)
        }
        if ((d = this._domEventHandlers.get(f)))
          if ((d = d.get(g))) {
            m = null
            try {
              m = d(h)
            } catch (w) {
              console.error(`Exception in '${f}' handler '${g}':`, w)
              null !== r && this._PostResultToDOM(r, !1, '' + w)
              return
            }
            null !== r &&
              (m && m.then
                ? m
                    .then(w => this._PostResultToDOM(r, !0, w))
                    .catch(w => {
                      console.error(`Rejection from '${f}' handler '${g}':`, w)
                      this._PostResultToDOM(r, !1, '' + w)
                    })
                : this._PostResultToDOM(r, !0, m))
          } else m || k || console.warn(`[Runtime] No DOM handler '${g}' for component '${f}'`)
        else m || k || console.warn(`[Runtime] No DOM event handlers for component '${f}'`)
      } else this._waitingToHandleEvents.push(d)
    }
    _PostResultToDOM(d, f, g) {
      this._messagePort.postMessage({
        type: 'result',
        responseId: d,
        isOk: f,
        result: g
      })
    }
    _OnResultFromDOM(d) {
      const f = d.responseId,
        g = d.isOk
      d = d.result
      const h = this._pendingResponsePromises.get(f)
      g ? h.resolve(d) : h.reject(d)
      this._pendingResponsePromises.delete(f)
    }
    AddDOMComponentMessageHandler(d, f, g) {
      let h = this._domEventHandlers.get(d)
      h || ((h = new Map()), this._domEventHandlers.set(d, h))
      if (h.has(f)) throw Error(`[Runtime] Component '${d}' already has handler '${f}'`)
      h.set(f, g)
    }
    PostComponentMessageToDOM(d, f, g) {
      this._messagePort.postMessage({
        type: 'event',
        component: d,
        handler: f,
        data: g,
        responseId: null
      })
    }
    PostComponentMessageToDOMAsync(d, f, g) {
      const h = this._nextDomResponseId++,
        k = new Promise((m, r) => {
          this._pendingResponsePromises.set(h, {
            resolve: m,
            reject: r
          })
        })
      this._messagePort.postMessage({
        type: 'event',
        component: d,
        handler: f,
        data: g,
        responseId: h
      })
      return k
    }
    PostToDebugger(d) {
      if (!this.IsDebug()) throw Error('not in debug mode')
      this.PostComponentMessageToDOM('runtime', 'post-to-debugger', d)
    }
    async Init(d) {
      this.IsDebug() ? await b.Init(this) : self.C3Debugger && self.C3Debugger.InitPreview(this)
      var [f] = await Promise.all([this._assetManager.FetchJson('data.json'), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()])
      this._LoadDataJson(f)
      await this._InitialiseCanvas(d)
      this.IsPreview() || console.info('Made with Construct 3, the game and app creator :: https://www.construct.net')
      this.GetWebGLRenderer()
        ? ((f = this.GetWebGLRenderer()),
          console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? 'worker' : 'DOM'}, rendering with WebGL ${f.GetWebGLVersionNumber()} [${f.GetUnmaskedRenderer()}] (${f.IsDesynchronized() ? 'desynchronized' : 'standard'} compositing)`),
          f.HasMajorPerformanceCaveat() && console.warn('[C3 runtime] WebGL indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.'))
        : this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? 'worker' : 'DOM'}, rendering with experimental WebGPU`)
      this._isReadyToHandleEvents = !0
      for (const g of this._waitingToHandleEvents) this._OnEventFromDOM(g)
      e.clearArray(this._waitingToHandleEvents)
      this._canvasManager && this._canvasManager.StartLoadingScreen()
      for (const g of d.runOnStartupFunctions) this._additionalLoadPromises.push(this._RunOnStartupFunction(g))
      await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises])
      e.clearArray(this._additionalLoadPromises)
      if (this._assetManager.HasHadErrorLoading()) this._canvasManager && this._canvasManager.HideCordovaSplashScreen()
      else
        return (
          this._canvasManager && (await this._canvasManager.EndLoadingScreen()),
          await this._dispatcher.dispatchEventAndWaitAsync(new e.Event('beforeruntimestart')),
          await this.Start(),
          this._messagePort.postMessage({
            type: 'runtime-ready'
          }),
          this
        )
    }
    async _RunOnStartupFunction(d) {
      try {
        await d(this._iRuntime)
      } catch (f) {
        console.error('[C3 runtime] Error in runOnStartup function: ', f)
      }
    }
    _LoadDataJson(d) {
      d = d.project
      this._projectName = d[0]
      this._projectVersion = d[16]
      this._projectUniqueId = d[31]
      this._appId = d[38]
      const f = d[39] || 'loading-logo.png'
      this._isPixelRoundingEnabled = !!d[9]
      this._originalViewportWidth = this._viewportWidth = d[10]
      this._originalViewportHeight = this._viewportHeight = d[11]
      this._parallaxXorigin = this._originalViewportWidth / 2
      this._parallaxYorigin = this._originalViewportHeight / 2
      this._compositingMode = d[36]
      this._framerateMode = d[37]
      'low-latency' === this._compositingMode &&
        this.IsAndroidWebView() &&
        77 >= e.Platform.BrowserVersionNumber &&
        (console.warn('[C3 runtime] Desynchronized (low-latency) compositing is enabled, but is disabled in the Android WebView <=77 due to crbug.com/1008842. Reverting to synchronized (standard) compositing.'), (this._compositingMode = 'standard'))
      this._uses3dFeatures = !!d[40]
      this._sampling = d[14]
      this._usesLoaderLayout = !!d[18]
      this._loaderStyle = d[19]
      this._nextUid = d[21]
      this._pauseOnBlur = d[22]
      const g = this._assetManager
      g._SetAudioFiles(d[7], d[25])
      g._SetMediaSubfolder(d[8])
      g._SetFontsSubfolder(d[32])
      g._SetIconsSubfolder(d[28])
      g._SetWebFonts(d[29])
      if (0 === this._loaderStyle) {
        let w = ''
        this.IsPreview() ? g._HasLocalUrlBlob(f) && (w = g.GetLocalUrlAsBlobUrl(f)) : (w = g.GetIconsSubfolder() + f)
        w &&
          (this._loadingLogoAsset = g.LoadImage({
            url: w
          }))
      }
      this._canvasManager &&
        (this._canvasManager.SetFullscreenMode(e.CanvasManager._FullscreenModeNumberToString(d[12])),
        this._canvasManager.SetFullscreenScalingQuality(d[23] ? 'high' : 'low'),
        this._canvasManager.SetMipmapsEnabled(0 !== d[24]),
        this._canvasManager._SetGPUPowerPreference(d[34]),
        this._canvasManager._SetTextureAnisotropy(d[41]),
        this._canvasManager._SetWebGPUEnabled(d[13]))
      this._pluginManager.CreateSystemPlugin()
      this._objectReferenceTable = self.C3_GetObjectRefTable()
      for (var h of d[2]) this._pluginManager.CreatePlugin(h)
      this._objectReferenceTable = self.C3_GetObjectRefTable()
      this._LoadJsPropNameTable()
      for (var k of d[3]) (h = e.ObjectClass.Create(this, this._allObjectClasses.length, k)), this._allObjectClasses.push(h), this._objectClassesByName.set(h.GetName().toLowerCase(), h), this._objectClassesBySid.set(h.GetSID(), h)
      for (const w of d[4]) this._allObjectClasses[w[0]]._LoadFamily(w)
      for (var m of d[27]) (k = m.map(w => this._allObjectClasses[w])), this._allContainers.push(e.New(e.Container, this, k))
      for (const w of this._allObjectClasses) w._OnAfterCreate()
      for (const w of d[5]) this._layoutManager.Create(w)
      ;(m = d[1]) && (m = this._layoutManager.GetLayoutByName(m)) && this._layoutManager.SetFirstLayout(m)
      for (var r of d[33]) this._timelineManager.Create(r)
      for (const w of d[35]) this._transitionManager.Create(w)
      this._InitScriptInterfaces()
      for (const w of d[6]) this._eventSheetManager.Create(w)
      this._eventSheetManager._PostInit()
      this._InitGlobalVariableScriptInterface()
      e.clearArray(this._objectReferenceTable)
      this.FlushPendingInstances()
      r = 'any'
      d = d[20]
      1 === d ? (r = 'portrait') : 2 === d && (r = 'landscape')
      this.PostComponentMessageToDOM('runtime', 'set-target-orientation', {
        targetOrientation: r
      })
    }
    GetLoaderStyle() {
      return this._loaderStyle
    }
    IsFBInstantAvailable() {
      return this._isFBInstantAvailable
    }
    IsLoading() {
      return this._isLoading
    }
    AddLoadPromise(d) {
      this._additionalLoadPromises.push(d)
    }
    SetUsingCreatePromises(d) {
      this._isUsingCreatePromises = !!d
    }
    AddCreatePromise(d) {
      this._isUsingCreatePromises && this._additionalCreatePromises.push(d)
    }
    GetCreatePromises() {
      return this._additionalCreatePromises
    }
    _GetNextFamilyIndex() {
      return this._familyCount++
    }
    GetFamilyCount() {
      return this._familyCount
    }
    _AddEffectList(d) {
      this._allEffectLists.push(d)
    }
    _GetAllEffectLists() {
      return this._allEffectLists
    }
    async _InitialiseCanvas(d) {
      this._canvasManager && (await this._canvasManager.CreateCanvas(d), this._canvasManager.InitLoadingScreen(this._loaderStyle))
    }
    async _MaybeLoadOpusDecoder() {
      if (!this._assetManager.IsAudioFormatSupported('audio/webm; codecs=opus')) {
        var d = null
        try {
          d = this.IsiOSCordova() && this._assetManager.IsFileProtocol() ? await this._assetManager.CordovaFetchLocalFileAsArrayBuffer(this._opusWasmBinaryUrl) : await this._assetManager.FetchArrayBuffer(this._opusWasmBinaryUrl)
        } catch (f) {
          console.info('Failed to fetch Opus decoder WASM; assuming project has no Opus audio.', f)
          return
        }
        d ? this.AddJobWorkerBuffer(d, 'opus-decoder-wasm') : this.AddJobWorkerBlob(null, 'opus-decoder-wasm')
        await this.AddJobWorkerScripts([this._opusWasmScriptUrl])
      }
    }
    async _WasmDecodeWebMOpus(d) {
      return await this.AddJob(
        'OpusDecode',
        {
          arrayBuffer: d
        },
        [d]
      )
    }
    async Start() {
      this._hasStarted = !0
      this._startTime = Date.now()
      if (this._usesLoaderLayout) {
        for (var d of this._allObjectClasses) d.IsFamily() || d.IsOnLoaderLayout() || !d.IsWorldType() || d.OnCreate()
        this._assetManager.WaitForAllToLoad().then(() => {
          this._isLoading = !1
          this._OnLoadFinished()
        })
      } else this._isLoading = !1
      this._assetManager.SetInitialLoadFinished()
      this.IsDebug() && b.RuntimeInit(c)
      for (const f of this._layoutManager.GetAllLayouts()) f._CreateGlobalNonWorlds()
      d = this._layoutManager.GetFirstLayout()
      await d._Load(null, this.GetRenderer())
      await d._StartRunning(!0)
      this._fpsLastTime = performance.now()
      this._usesLoaderLayout || this._OnLoadFinished()
      ;(await this.PostComponentMessageToDOMAsync('runtime', 'before-start-ticking')).isSuspended ? this._suspendCount++ : this.Tick()
    }
    _OnLoadFinished() {
      this.Trigger(e.Plugins.System.Cnds.OnLoadFinished, null, null)
      this.PostComponentMessageToDOM('runtime', 'register-sw')
    }
    GetObjectReference(d) {
      d = Math.floor(d)
      const f = this._objectReferenceTable
      if (0 > d || d >= f.length) throw Error('invalid object reference')
      return f[d]
    }
    _LoadJsPropNameTable() {
      for (const d of self.C3_JsPropNameTable) {
        const f = e.first(Object.keys(d))
        this._jsPropNameTable.push(f)
      }
    }
    GetJsPropName(d) {
      d = Math.floor(d)
      const f = this._jsPropNameTable
      if (0 > d || d >= f.length) throw Error('invalid prop reference')
      return f[d]
    }
    HasDOM() {
      return this._hasDom
    }
    IsHeadless() {
      return this._isHeadless
    }
    IsInWorker() {
      return this._isInWorker
    }
    GetBaseURL() {
      return this._baseUrl
    }
    GetEventSheetManager() {
      return this._eventSheetManager
    }
    GetEventStack() {
      return this._eventSheetManager.GetEventStack()
    }
    GetCurrentEventStackFrame() {
      return this._eventSheetManager.GetCurrentEventStackFrame()
    }
    GetCurrentEvent() {
      return this._eventSheetManager.GetCurrentEvent()
    }
    GetCurrentCondition() {
      return this._eventSheetManager.GetCurrentCondition()
    }
    IsCurrentConditionFirst() {
      return 0 === this.GetCurrentEventStackFrame().GetConditionIndex()
    }
    GetCurrentAction() {
      return this._eventSheetManager.GetCurrentAction()
    }
    GetPluginManager() {
      return this._pluginManager
    }
    GetSystemPlugin() {
      return this._pluginManager.GetSystemPlugin()
    }
    GetObjectClassByIndex(d) {
      d = Math.floor(d)
      if (0 > d || d >= this._allObjectClasses.length) throw new RangeError('invalid index')
      return this._allObjectClasses[d]
    }
    GetObjectClassByName(d) {
      return this._objectClassesByName.get(d.toLowerCase()) || null
    }
    GetObjectClassBySID(d) {
      return this._objectClassesBySid.get(d) || null
    }
    GetSingleGlobalObjectClassByCtor(d) {
      return (d = this._pluginManager.GetPluginByConstructorFunction(d)) ? d.GetSingleGlobalObjectClass() : null
    }
    GetAllObjectClasses() {
      return this._allObjectClasses
    }
    *allInstances() {
      for (const d of this._allObjectClasses) d.IsFamily() || (yield* d.instances())
    }
    Dispatcher() {
      return this._dispatcher
    }
    UserScriptDispatcher() {
      return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(d) {
      d.runtime = this.GetIRuntime()
      const f = this.IsDebug() && !this._eventSheetManager.IsInEventEngine()
      f && b.StartMeasuringScriptTime()
      this._userScriptDispatcher.dispatchEvent(d)
      f && b.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(d) {
      d.runtime = this.GetIRuntime()
      return this._userScriptDispatcher.dispatchEventAndWaitAsync(d)
    }
    GetOriginalViewportWidth() {
      return this._originalViewportWidth
    }
    GetOriginalViewportHeight() {
      return this._originalViewportHeight
    }
    SetOriginalViewportSize(d, f) {
      if (this._originalViewportWidth !== d || this._originalViewportHeight !== f) (this._originalViewportWidth = d), (this._originalViewportHeight = f), (d = this.GetLayoutManager()), d.SetAllLayerProjectionChanged(), d.SetAllLayerMVChanged()
    }
    GetViewportWidth() {
      return this._viewportWidth
    }
    GetViewportHeight() {
      return this._viewportHeight
    }
    SetViewportSize(d, f) {
      if (this._viewportWidth !== d || this._viewportHeight !== f) (this._viewportWidth = d), (this._viewportHeight = f), (d = this.GetLayoutManager()), d.SetAllLayerProjectionChanged(), d.SetAllLayerMVChanged()
    }
    _SetDevicePixelRatio(d) {
      this._devicePixelRatio = d
    }
    GetDevicePixelRatio() {
      return this._devicePixelRatio
    }
    GetParallaxXOrigin() {
      return this._parallaxXorigin
    }
    GetParallaxYOrigin() {
      return this._parallaxYorigin
    }
    GetCanvasManager() {
      return this._canvasManager
    }
    GetDrawWidth() {
      return this._canvasManager ? this._canvasManager.GetDrawWidth() : this._viewportWidth
    }
    GetDrawHeight() {
      return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
    }
    GetRenderScale() {
      return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
    }
    GetDisplayScale() {
      return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
    }
    GetCanvasClientX() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
    }
    GetCanvasClientY() {
      return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
    }
    GetCanvasCssWidth() {
      return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
    }
    GetCanvasCssHeight() {
      return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
    }
    GetFullscreenMode() {
      return this._canvasManager ? this._canvasManager.GetFullscreenMode() : 'off'
    }
    GetAdditionalRenderTarget(d) {
      return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(d) : null
    }
    ReleaseAdditionalRenderTarget(d) {
      this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(d)
    }
    _SetUsesAnyBackgroundBlending(d) {
      this._usesAnyBackgroundBlending = !!d
    }
    UsesAnyBackgroundBlending() {
      return this._usesAnyBackgroundBlending
    }
    GetGPUUtilisation() {
      return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
    }
    IsLinearSampling() {
      return 'nearest' !== this.GetSampling()
    }
    GetFramerateMode() {
      return this._framerateMode
    }
    GetCompositingMode() {
      return this._compositingMode
    }
    GetSampling() {
      return this._sampling
    }
    UsesLoaderLayout() {
      return this._usesLoaderLayout
    }
    GetLoadingLogoAsset() {
      return this._loadingLogoAsset
    }
    ReleaseLoadingLogoAsset() {
      this._loadingLogoAsset && (this._loadingLogoAsset.Release(), (this._loadingLogoAsset = null))
    }
    GetLayoutManager() {
      return this._layoutManager
    }
    GetMainRunningLayout() {
      return this._layoutManager.GetMainRunningLayout()
    }
    GetTimelineManager() {
      return this._timelineManager
    }
    GetTransitionManager() {
      return this._transitionManager
    }
    GetAssetManager() {
      return this._assetManager
    }
    LoadImage(d) {
      return this._assetManager.LoadImage(d)
    }
    CreateInstance(d, f, g, h, k) {
      return this.CreateInstanceFromData(d, f, !1, g, h, !1, k)
    }
    CreateInstanceFromData(d, f, g, h, k, m, r) {
      var w = null
      let p = null
      if (d instanceof e.ObjectClass) {
        p = d
        if (p.IsFamily()) {
          d = p.GetFamilyMembers()
          var q = Math.floor(this.Random() * d.length)
          p = d[q]
        }
        w = p.GetDefaultInstanceData()
      } else (w = d), (p = this.GetObjectClassByIndex(w[1]))
      var t = p.GetPlugin().IsWorldType()
      if (this._isLoading && t && !p.IsOnLoaderLayout()) return null
      const x = f
      t || (f = null)
      var v = g && !m && w && !this._instancesByUid.has(w[2]) ? w[2] : this._nextUid++
      q = w ? w[0] : null
      d = e.New(e.Instance, {
        runtime: this,
        objectType: p,
        layer: f,
        worldData: q,
        instVarData: w ? w[3] : null,
        uid: v
      })
      this._instancesByUid.set(v, d)
      v = null
      t && ((v = d.GetWorldInfo()), 'undefined' !== typeof h && 'undefined' !== typeof k && (v.SetX(h), v.SetY(k)), p._SetAnyCollisionCellChanged(!0))
      f && (r || f._AddInstance(d, !0), (1 === f.GetParallaxX() && 1 === f.GetParallaxY()) || p._SetAnyInstanceParallaxed(!0), f.GetLayout().MaybeLoadTexturesFor(p))
      this._objectCount++
      if (p.IsInContainer() && !g && !m) {
        for (var u of p.GetContainer().objectTypes()) {
          if (u === p) continue
          const C = this.CreateInstanceFromData(u, x, !1, v ? v.GetX() : h, v ? v.GetY() : k, !0, !1)
          d._AddSibling(C)
        }
        for (var A of d.siblings()) {
          A._AddSibling(d)
          for (var z of d.siblings()) A !== z && A._AddSibling(z)
        }
      }
      t && !g && r && this._CreateChildInstancesFromData(d, q, v, f, h, k)
      if (p.IsInContainer() && !g && !m && r)
        for (const C of d.siblings()) if ((u = C.GetWorldInfo())) (A = C.GetPlugin()), (z = C.GetObjectClass().GetDefaultInstanceData()[0]), A.IsWorldType() ? this._CreateChildInstancesFromData(C, z, u, f, u.GetX(), u.GetY()) : this._CreateChildInstancesFromData(C, z, u, f)
      if (r && !m && !g && d.IsInContainer()) for (const C of d.siblings()) for (const E of C.siblings()) d === E && x._RemoveInstance(C, !0)
      !m && r && ('undefined' === typeof h && (h = q[0]), 'undefined' === typeof k && (k = q[1]), (f = v.GetTopParent()), (h = h - v.GetX() + f.GetX()), (k = k - v.GetY() + f.GetY()), f.SetXY(h, k))
      p._SetIIDsStale()
      k = w ? e.cloneArray(w[5]) : null
      w = w ? w[4].map(C => e.cloneArray(C)) : null
      ;(t = t && q && q[13]) && d._SetHasTilemap()
      d._CreateSdkInstance(k, w)
      t && ((q = q[13]), d.GetSdkInstance().LoadTilemapData(q[2], q[0], q[1]))
      this._instancesPendingCreate.push(d)
      this._hasPendingInstances = !0
      this.IsDebug() && b.InstanceCreated(d)
      return d
    }
    _CreateChildInstancesFromData(d, f, g, h, k, m) {
      var r = g.GetSceneGraphZIndexExportData(),
        w = g.GetSceneGraphChildrenExportData()
      d.GetWorldInfo().SetSceneGraphZIndex(r)
      if (w) {
        'undefined' === typeof k && (k = f[0])
        'undefined' === typeof m && (m = f[1])
        r = new Set()
        g = f[0]
        f = f[1]
        for (const v of w) {
          var p = v[1],
            q = v[2]
          w = v[3]
          var t = !!v[4]
          const u = v[5]
          q = this._layoutManager.GetLayoutBySID(v[0]).GetLayer(p).GetInitialInstanceData(q)
          p = this.GetObjectClassByIndex(q[1])
          var x = d.HasSibling(p)
          const A = r.has(p)
          x && !A && t
            ? ((t = d.GetSibling(p)),
              (x = k + q[0][0] - g),
              (q = m + q[0][1] - f),
              t.GetWorldInfo().SetXY(x, q),
              t.GetWorldInfo().SetSceneGraphZIndex(u),
              d.AddChild(t, {
                transformX: !!((w >> 0) & 1),
                transformY: !!((w >> 1) & 1),
                transformWidth: !!((w >> 2) & 1),
                transformHeight: !!((w >> 3) & 1),
                transformAngle: !!((w >> 4) & 1),
                destroyWithParent: !!((w >> 5) & 1),
                transformZElevation: !!((w >> 6) & 1)
              }),
              r.add(p))
            : ((p = this.CreateInstanceFromData(q, h, !1, k + q[0][0] - g, m + q[0][1] - f, !1, !0)),
              p.GetWorldInfo().SetSceneGraphZIndex(u),
              d.AddChild(p, {
                transformX: !!((w >> 0) & 1),
                transformY: !!((w >> 1) & 1),
                transformWidth: !!((w >> 2) & 1),
                transformHeight: !!((w >> 3) & 1),
                transformAngle: !!((w >> 4) & 1),
                destroyWithParent: !!((w >> 5) & 1),
                transformZElevation: !!((w >> 6) & 1)
              }))
        }
      }
    }
    DestroyInstance(d) {
      if (!this._instancesToReleaseAtEndOfTick.has(d)) {
        var f = d.GetObjectClass(),
          g = this._instancesPendingDestroy.get(f)
        if (g) {
          if (g.has(d)) return
          g.add(d)
        } else (g = new Set()), g.add(d), this._instancesPendingDestroy.set(f, g)
        this.IsDebug() && b.InstanceDestroyed(d)
        d._MarkDestroyed()
        this._hasPendingInstances = !0
        if (d.IsInContainer()) for (const h of d.siblings()) this.DestroyInstance(h)
        for (const h of d.children()) h.GetDestroyWithParent() && this.DestroyInstance(h)
        this._layoutManager.IsEndingLayout() || this._isLoadingState || ((f = this.GetEventSheetManager()), f.BlockFlushingInstances(!0), d._TriggerOnDestroyed(), f.BlockFlushingInstances(!1))
        d._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
      }
    }
    FlushPendingInstances() {
      this._hasPendingInstances && ((this._isFlushingPendingInstances = !0), this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), (this._hasPendingInstances = this._isFlushingPendingInstances = !1), this.UpdateRender())
    }
    _FlushInstancesPendingCreate() {
      for (const d of this._instancesPendingCreate) {
        const f = d.GetObjectClass()
        f._AddInstance(d)
        for (const g of f.GetFamilies()) g._AddInstance(d), g._SetIIDsStale()
      }
      e.clearArray(this._instancesPendingCreate)
    }
    _FlushInstancesPendingDestroy() {
      this._dispatcher.SetDelayRemoveEventsEnabled(!0)
      for (const [d, f] of this._instancesPendingDestroy.entries()) this._FlushInstancesPendingDestroyForObjectClass(d, f), f.clear()
      this._instancesPendingDestroy.clear()
      this._dispatcher.SetDelayRemoveEventsEnabled(!1)
    }
    _FlushInstancesPendingDestroyForObjectClass(d, f) {
      for (const h of f) {
        var g = this._eventObjects.instancedestroy
        g.instance = h
        this._dispatcher.dispatchEvent(g)
        this._instancesByUid.delete(h.GetUID())
        if ((g = h.GetWorldInfo())) g._RemoveFromCollisionCells(), g._RemoveFromRenderCells(), g._MarkDestroyed()
        this._instancesToReleaseAtEndOfTick.add(h)
        this._objectCount--
      }
      e.arrayRemoveAllInSet(d.GetInstances(), f)
      d._SetIIDsStale()
      this._instancesToReleaseAffectedObjectClasses.add(d)
      0 === d.GetInstances().length && d._SetAnyInstanceParallaxed(!1)
      for (const h of d.GetFamilies()) e.arrayRemoveAllInSet(h.GetInstances(), f), h._SetIIDsStale(), this._instancesToReleaseAffectedObjectClasses.add(h)
      if (d.GetPlugin().IsWorldType()) {
        d = new Set([...f].map(h => h.GetWorldInfo().GetLayer()))
        for (const h of d) h._RemoveAllInstancesInSet(f)
      }
    }
    _GetInstancesPendingCreate() {
      return this._instancesPendingCreate
    }
    *instancesPendingCreateForObjectClass(d) {
      for (const f of this._GetInstancesPendingCreate()) d.IsFamily() ? f.GetObjectClass().BelongsToFamily(d) && (yield f) : f.GetObjectClass() === d && (yield f)
    }
    _GetNewUID() {
      return this._nextUid++
    }
    _MapInstanceByUID(d, f) {
      this._instancesByUid.set(d, f)
    }
    _OnWebGLContextLost() {
      this._dispatcher.dispatchEvent(e.New(e.Event, 'webglcontextlost'))
      this.SetSuspended(!0)
      for (var d of this._allObjectClasses) !d.IsFamily() && d.HasLoadedTextures() && d.ReleaseTextures()
      ;(d = this.GetMainRunningLayout()) && d._OnWebGLContextLost()
      e.ImageInfo.OnWebGLContextLost()
      e.ImageAsset.OnWebGLContextLost()
    }
    async _OnWebGLContextRestored() {
      await this.GetMainRunningLayout()._Load(null, this.GetWebGLRenderer())
      this._dispatcher.dispatchEvent(e.New(e.Event, 'webglcontextrestored'))
      this.SetSuspended(!1)
      this.UpdateRender()
    }
    _OnVisibilityChange(d) {
      this.SetSuspended(d.hidden)
    }
    _OnWindowBlur(d) {
      this.IsPreview() && this._pauseOnBlur && !e.Platform.IsMobile && !d.data.parentHasFocus && (this.SetSuspended(!0), (this._isPausedOnBlur = !0))
    }
    _OnWindowFocus() {
      this._isPausedOnBlur && (this.SetSuspended(!1), (this._isPausedOnBlur = !1))
    }
    _RequestAnimationFrame() {
      const d = this._tickCallbacks
      'vsync' === this._framerateMode
        ? -1 === this._rafId && (this._rafId = self.requestAnimationFrame(d.normal))
        : 'unlimited-tick' === this._framerateMode
        ? (-1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(d.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(d.renderOnly)))
        : -1 === this._ruafId && (this._ruafId = e.RequestUnlimitedAnimationFrame(d.normal))
    }
    _CancelAnimationFrame() {
      ;-1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), (this._rafId = -1))
      ;-1 !== this._ruafId && (e.CancelUnlimitedAnimationFrame(this._ruafId), (this._ruafId = -1))
    }
    IsSuspended() {
      return 0 < this._suspendCount
    }
    SetSuspended(d) {
      var f = this.IsSuspended()
      this._suspendCount += d ? 1 : -1
      0 > this._suspendCount && (this._suspendCount = 0)
      d = this.IsSuspended()
      !f && d
        ? (console.log('[Construct 3] Suspending'), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(e.New(e.Event, 'suspend')), this.Trigger(e.Plugins.System.Cnds.OnSuspend, null, null))
        : f &&
          !d &&
          (console.log('[Construct 3] Resuming'),
          (this._fpsLastTime = this._lastTickTime = f = performance.now()),
          (this._mainThreadTimeCounter = this._mainThreadTime = this._fps = this._fpsFrameCount = 0),
          this._dispatcher.dispatchEvent(e.New(e.Event, 'resume')),
          this.Trigger(e.Plugins.System.Cnds.OnResume, null, null),
          this.HitBreakpoint() || this.Tick(f))
    }
    _AddBehInstToTick(d) {
      this._behInstsToTick.Add(d)
    }
    _AddBehInstToPostTick(d) {
      this._behInstsToPostTick.Add(d)
    }
    _AddBehInstToTick2(d) {
      this._behInstsToTick2.Add(d)
    }
    _RemoveBehInstToTick(d) {
      this._behInstsToTick.Remove(d)
    }
    _RemoveBehInstToPostTick(d) {
      this._behInstsToPostTick.Remove(d)
    }
    _RemoveBehInstToTick2(d) {
      this._behInstsToTick2.Remove(d)
    }
    _BehaviorTick() {
      this._behInstsToTick.SetQueueingEnabled(!0)
      for (const d of this._behInstsToTick) d.Tick()
      this._behInstsToTick.SetQueueingEnabled(!1)
    }
    _BehaviorPostTick() {
      this._behInstsToPostTick.SetQueueingEnabled(!0)
      for (const d of this._behInstsToPostTick) d.PostTick()
      this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    _BehaviorTick2() {
      this._behInstsToTick2.SetQueueingEnabled(!0)
      for (const d of this._behInstsToTick2) d.Tick2()
      this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick() {
      this._behInstsToTick.SetQueueingEnabled(!0)
      for (const d of this._behInstsToTick) {
        const f = d.Tick()
        e.IsIterator(f) && (yield* f)
      }
      this._behInstsToTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorPostTick() {
      this._behInstsToPostTick.SetQueueingEnabled(!0)
      for (const d of this._behInstsToPostTick) {
        const f = d.PostTick()
        e.IsIterator(f) && (yield* f)
      }
      this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick2() {
      this._behInstsToTick2.SetQueueingEnabled(!0)
      for (const d of this._behInstsToTick2) {
        const f = d.Tick2()
        e.IsIterator(f) && (yield* f)
      }
      this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    async Tick(d, f, g) {
      this._hasStartedTicking = !0
      const h = 'background-wake' === g
      g = 'background-wake' !== g && 'skip-render' !== g
      this._hasStarted &&
        (!this.IsSuspended() || f || h) &&
        ((f = performance.now()),
        (this._isInTick = !0),
        this._MeasureDt(d || 0),
        (d = this.Step_BeforePreTick()),
        this.IsDebugging() && (await d),
        (d = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick)),
        d instanceof Promise && (await d),
        (d = this.Step_AfterPreTick()),
        this.IsDebugging() && (await d),
        this._NeedsHandleSaveOrLoad() && (await this._HandleSaveOrLoad()),
        this.GetLayoutManager().IsPendingChangeMainLayout() && (await this._MaybeChangeLayout()),
        (d = this.Step_RunEventsEtc()),
        this.IsDebugging() && (await d),
        g && this.Render(),
        this.IsSuspended() || h || this._RequestAnimationFrame(),
        this._tickCount++,
        this._tickCountNoSave++,
        this._execCount++,
        (this._isInTick = !1),
        (this._mainThreadTimeCounter += performance.now() - f))
    }
    async Step_BeforePreTick() {
      const d = this._eventSheetManager,
        f = this.IsDebug()
      this.FlushPendingInstances()
      d.BlockFlushingInstances(!0)
      this.PushCurrentLayout(this.GetMainRunningLayout())
      f && b.StartMeasuringTime()
      this.IsDebugging() ? await d.DebugRunScheduledWaits() : d.RunScheduledWaits()
      f && b.AddEventsTime()
      this.PopCurrentLayout()
      d.BlockFlushingInstances(!1)
      this.FlushPendingInstances()
      d.BlockFlushingInstances(!0)
    }
    async Step_AfterPreTick() {
      const d = this.IsDebug(),
        f = this.IsDebugging(),
        g = this._dispatcher,
        h = this._eventObjects,
        k = this._userScriptEventObjects
      d && b.StartMeasuringTime()
      f ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick()
      f ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) : this._BehaviorPostTick()
      d && b.AddBehaviorTickTime()
      d && b.StartMeasuringTime()
      f ? await this.DebugFireGeneratorEventAndBreak(h.tick) : g.dispatchEvent(h.tick)
      d && b.AddPluginTickTime()
      this._eventSheetManager.BlockFlushingInstances(!1)
      this.DispatchUserScriptEvent(k.tick)
    }
    async Step_RunEventsEtc() {
      const d = this._eventSheetManager,
        f = this._dispatcher,
        g = this._eventObjects,
        h = this.IsDebug(),
        k = this.IsDebugging()
      h && b.StartMeasuringTime()
      k ? await d.DebugRunEvents(this._layoutManager) : d.RunEvents(this._layoutManager)
      h && b.AddEventsTime()
      this._collisionEngine.ClearRegisteredCollisions()
      this._ReleaseInstancesAtEndOfTick()
      this._isLayoutFirstTick = !1
      d.BlockFlushingInstances(!0)
      h && b.StartMeasuringTime()
      k ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2()
      h && b.AddBehaviorTickTime()
      h && b.StartMeasuringTime()
      k ? await this.DebugFireGeneratorEventAndBreak(g.tick2) : f.dispatchEvent(g.tick2)
      h && b.AddPluginTickTime()
      d.BlockFlushingInstances(!1)
      k && (await d.RunQueuedDebugTriggersAsync())
    }
    _ReleaseInstancesAtEndOfTick() {
      if (0 !== this._instancesToReleaseAtEndOfTick.size) {
        var d = this._dispatcher
        d.SetDelayRemoveEventsEnabled(!0)
        for (const f of this._instancesToReleaseAffectedObjectClasses) f.GetSolStack().RemoveInstances(this._instancesToReleaseAtEndOfTick)
        this._instancesToReleaseAffectedObjectClasses.clear()
        this._eventSheetManager.RemoveInstancesFromScheduledWaits(this._instancesToReleaseAtEndOfTick)
        for (const f of this._instancesToReleaseAtEndOfTick) f.Release()
        this._instancesToReleaseAtEndOfTick.clear()
        d.SetDelayRemoveEventsEnabled(!1)
      }
    }
    async _MaybeChangeLayout() {
      const d = this.GetLayoutManager()
      let f = 0
      for (; d.IsPendingChangeMainLayout() && 10 > f++; ) await this._DoChangeLayout(d.GetPendingChangeMainLayout())
    }
    _MeasureDt(d) {
      let f = 0
      0 !== this._lastTickTime && ((f = Math.max(d - this._lastTickTime, 0) / 1e3), 0.5 < f && (f = 0), (this._dt1 = Math.min(f, 1 / this._minimumFramerate)))
      this._lastTickTime = d
      this._dt = this._dt1 * this._timeScale
      this._gameTime.Add(this._dt)
      this._gameTimeRaw.Add(f * this._timeScale)
      this._wallTime.Add(this._dt1)
      this._canvasManager && this._canvasManager._UpdateTick()
      1e3 <= d - this._fpsLastTime &&
        ((this._fpsLastTime += 1e3),
        1e3 <= d - this._fpsLastTime && (this._fpsLastTime = d),
        (this._fps = this._fpsFrameCount),
        (this._fpsFrameCount = 0),
        (this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1e3, 1)),
        (this._mainThreadTimeCounter = 0),
        this._canvasManager && this._canvasManager._Update1sFrameRange(),
        this._collisionEngine._Update1sStats(),
        this.IsDebug() && b.Update1sPerfStats())
      this._fpsFrameCount++
    }
    async _DoChangeLayout(d) {
      const f = this._dispatcher,
        g = this.GetLayoutManager().GetMainRunningLayout()
      await g._StopRunning()
      g._Unload(d, this.GetRenderer())
      g === d && this._eventSheetManager.ClearAllScheduledWaits()
      this._collisionEngine.ClearRegisteredCollisions()
      this._ReleaseInstancesAtEndOfTick()
      f.dispatchEvent(this._eventObjects.beforelayoutchange)
      e.Asyncify.SetHighThroughputMode(!0)
      await d._Load(g, this.GetRenderer())
      e.Asyncify.SetHighThroughputMode(!1)
      await d._StartRunning(!1)
      f.dispatchEvent(this._eventObjects.layoutchange)
      this.UpdateRender()
      this._isLayoutFirstTick = !0
      this.FlushPendingInstances()
    }
    UpdateRender() {
      this._needRender = !0
    }
    GetWebGLRenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
    }
    GetWebGPURenderer() {
      return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
    }
    GetRenderer() {
      return this._canvasManager ? this._canvasManager.GetRenderer() : null
    }
    Render() {
      const d = this._canvasManager
      if (d && !d.IsRendererContextLost()) {
        var f = this.GetRenderer(),
          g = f.SupportsGPUProfiling(),
          h = g && f.IsWebGL()
        g = g && f.IsWebGPU()
        h && f.CheckForQueryResults()
        if (this._needRender) {
          var k = this._layoutManager.GetMainRunningLayout()
          f.Start()
          var m = this.IsDebug()
          m && b.StartMeasuringTime()
          this._needRender = !1
          var r = null
          h && ((r = d.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery()), f.StartQuery(r))
          h = null
          g && ((h = f.StartFrameTiming(2 * (1 + k.GetLayerCount()))), f.WriteTimestamp(0))
          this.Uses3DFeatures() && 'low' === d.GetCurrentFullscreenScalingQuality() ? f.SetFixedSizeDepthBuffer(d.GetDrawWidth(), d.GetDrawHeight()) : f.SetAutoSizeDepthBuffer()
          this._Render(this.GetRenderer(), k)
          r && f.EndQuery(r)
          g && (f.WriteTimestamp(1), this._canvasManager._AddWebGPUFrameTiming(h))
          f.Finish()
          m && (b.AddDrawCallsTime(), b.UpdateInspectHighlight())
          d && d._MaybeTakeSnapshot()
        } else f.IncrementFrameNumber()
      }
    }
    _Render(d, f) {
      d.SetTextureFillMode()
      d.SetAlphaBlend()
      d.SetColorRgba(1, 1, 1, 1)
      d.SetRenderTarget(null)
      d.SetTexture(null)
      d.SetDepthEnabled(this.Uses3DFeatures())
      f.Draw(d)
    }
    Trigger(d, f, g) {
      if (!this._hasStarted) return !1
      var h = !this._isInTick && !this._eventSheetManager.IsInTrigger()
      let k = 0
      h && (k = performance.now())
      const m = this.IsDebug()
      m && this.SetDebuggingEnabled(!1)
      d = this._eventSheetManager._Trigger(this._layoutManager, d, f, g)
      h && ((h = performance.now() - k), (this._mainThreadTimeCounter += h), m && b.AddTriggersTime(h))
      m && this.SetDebuggingEnabled(!0)
      return d
    }
    DebugTrigger(d, f, g) {
      if (!this.IsDebug()) return this.Trigger(d, f, g)
      if (this.HitBreakpoint()) throw Error('called DebugTrigger() while stopped on breakpoint')
      if (!this._isInTick && !this._eventSheetManager.IsInTrigger()) throw Error('called DebugTrigger() outside of event code - use TriggerAsync() instead')
      return this._eventSheetManager._DebugTrigger(this._layoutManager, d, f, g)
    }
    async TriggerAsync(d, f, g) {
      if (!this.IsDebugging()) return this.Trigger(d, f, g)
      if (!this._hasStarted) return !1
      if (this.HitBreakpoint()) return this._eventSheetManager.QueueDebugTrigger(d, f, g)
      if (!this.GetMainRunningLayout()) return this._eventSheetManager.QueueTrigger(d, f, g)
      const h = performance.now()
      d = this._eventSheetManager._DebugTrigger(this._layoutManager, d, f, g)
      for (f = d.next(); !f.done; ) await this.DebugBreak(f.value), (f = d.next())
      this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame())
      this._mainThreadTimeCounter += performance.now() - h
      return f.value
    }
    FastTrigger(d, f, g) {
      const h = this.IsDebug()
      h && this.SetDebuggingEnabled(!1)
      d = this._eventSheetManager._FastTrigger(this._layoutManager, d, f, g)
      h && this.SetDebuggingEnabled(!0)
      return d
    }
    DebugFastTrigger(d, f, g) {
      return this._eventSheetManager._DebugFastTrigger(this._layoutManager, d, f, g)
    }
    ScheduleTriggers(d) {
      return this._scheduleTriggersThrottle.Add(d)
    }
    PushCurrentLayout(d) {
      this._currentLayoutStack.push(d)
    }
    PopCurrentLayout() {
      if (!this._currentLayoutStack.length) throw Error('layout stack empty')
      this._currentLayoutStack.pop()
    }
    GetCurrentLayout() {
      return this._currentLayoutStack.length ? this._currentLayoutStack[this._currentLayoutStack.length - 1] : this.GetMainRunningLayout()
    }
    GetDt(d) {
      return d && -1 !== d.GetTimeScale() ? this._dt1 * d.GetTimeScale() : this._dt
    }
    _GetDtFast() {
      return this._dt
    }
    GetDt1() {
      return this._dt1
    }
    GetTimeScale() {
      return this._timeScale
    }
    SetTimeScale(d) {
      if (isNaN(d) || 0 > d) d = 0
      this._timeScale = d
    }
    SetMinimumFramerate(d) {
      this._minimumFramerate = e.clamp(d, 1, 120)
    }
    GetMinimumFramerate() {
      return this._minimumFramerate
    }
    GetFPS() {
      return this._fps
    }
    GetMainThreadTime() {
      return this._mainThreadTime
    }
    GetStartTime() {
      return this._startTime
    }
    GetGameTime() {
      return this._gameTime.Get()
    }
    GetGameTimeRaw() {
      return this._gameTimeRaw.Get()
    }
    GetWallTime() {
      return this._wallTime.Get()
    }
    GetTickCount() {
      return this._tickCount
    }
    GetTickCountNoSave() {
      return this._tickCountNoSave
    }
    IncrementExecCount() {
      ++this._execCount
    }
    GetExecCount() {
      return this._execCount
    }
    GetObjectCount() {
      return this._objectCount
    }
    GetProjectName() {
      return this._projectName
    }
    GetProjectVersion() {
      return this._projectVersion
    }
    GetProjectUniqueId() {
      return this._projectUniqueId
    }
    GetAppId() {
      return this._appId
    }
    GetInstanceByUID(d) {
      if (this._isLoadingState) throw Error('cannot call while loading state - wait until afterload event')
      return this._instancesByUid.get(d) || null
    }
    _RefreshUidMap() {
      this._instancesByUid.clear()
      for (const d of this._allObjectClasses) if (!d.IsFamily()) for (const f of d.GetInstances()) this._instancesByUid.set(f.GetUID(), f)
    }
    IsPreview() {
      return 'preview' === this._exportType
    }
    IsDebug() {
      return this._isDebug
    }
    GetExportType() {
      return this._exportType
    }
    IsCordova() {
      return 'cordova' === this._exportType
    }
    IsAndroidWebView() {
      return 'Android' === e.Platform.OS && ('cordova' === this._exportType || 'playable-ad' === this._exportType || 'instant-games' === this._exportType)
    }
    IsiOSCordova() {
      return this._isiOSCordova
    }
    IsiOSWebView() {
      return this._isiOSWebView
    }
    GetCollisionEngine() {
      return this._collisionEngine
    }
    GetSolidBehavior() {
      return this._pluginManager.GetSolidBehavior()
    }
    GetJumpthruBehavior() {
      return this._pluginManager.GetJumpthruBehavior()
    }
    Uses3DFeatures() {
      return this._uses3dFeatures
    }
    IsLayoutFirstTick() {
      return this._isLayoutFirstTick
    }
    SetPixelRoundingEnabled(d) {
      d = !!d
      this._isPixelRoundingEnabled !== d && ((this._isPixelRoundingEnabled = d), this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender())
    }
    IsPixelRoundingEnabled() {
      return this._isPixelRoundingEnabled
    }
    SaveToSlot(d) {
      this._saveToSlotName = d
    }
    LoadFromSlot(d) {
      this._loadFromSlotName = d
    }
    LoadFromJsonString(d) {
      this._loadFromJson = d
    }
    GetLastSaveJsonString() {
      return this._lastSaveJson
    }
    _NeedsHandleSaveOrLoad() {
      return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
    }
    async _HandleSaveOrLoad() {
      this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad())
      this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() && b.StepIfPausedInDebugger())
      if (null !== this._loadFromJson) {
        this.FlushPendingInstances()
        try {
          await this._DoLoadFromJsonString(this._loadFromJson), (this._lastSaveJson = this._loadFromJson), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null), (this._lastSaveJson = '')
        } catch (d) {
          console.error('[Construct 3] Failed to load state from JSON string: ', d), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
        }
        this._ClearSaveOrLoad()
      }
    }
    _ClearSaveOrLoad() {
      this._loadFromSlotName = this._saveToSlotName = ''
      this._loadFromJson = null
    }
    _GetProjectStorage() {
      this._projectStorage ||
        (this._projectStorage = localforage.createInstance({
          name: 'c3-localstorage-' + this.GetProjectUniqueId(),
          description: this.GetProjectName()
        }))
      return this._projectStorage
    }
    _GetSavegamesStorage() {
      this._savegamesStorage ||
        (this._savegamesStorage = localforage.createInstance({
          name: 'c3-savegames-' + this.GetProjectUniqueId(),
          description: this.GetProjectName()
        }))
      return this._savegamesStorage
    }
    async _DoSaveToSlot(d) {
      const f = await this._SaveToJsonString()
      try {
        await this._GetSavegamesStorage().setItem(d, f), console.log('[Construct 3] Saved state to storage (' + f.length + ' chars)'), (this._lastSaveJson = f), await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveComplete, null), (this._lastSaveJson = '')
      } catch (g) {
        console.error('[Construct 3] Failed to save state to storage: ', g), await this.TriggerAsync(e.Plugins.System.Cnds.OnSaveFailed, null)
      }
    }
    async _DoLoadFromSlot(d) {
      try {
        const f = await this._GetSavegamesStorage().getItem(d)
        if (!f) throw Error('empty slot')
        console.log('[Construct 3] Loaded state from storage (' + f.length + ' chars)')
        await this._DoLoadFromJsonString(f)
        this._lastSaveJson = f
        await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadComplete, null)
        this._lastSaveJson = ''
      } catch (f) {
        console.error('[Construct 3] Failed to load state from storage: ', f), await this.TriggerAsync(e.Plugins.System.Cnds.OnLoadFailed, null)
      }
    }
    async _SaveToJsonString() {
      const d = {
        c3save: !0,
        version: 1,
        rt: {
          time: this.GetGameTime(),
          timeRaw: this.GetGameTimeRaw(),
          walltime: this.GetWallTime(),
          timescale: this.GetTimeScale(),
          tickcount: this.GetTickCount(),
          execcount: this.GetExecCount(),
          next_uid: this._nextUid,
          running_layout: this.GetMainRunningLayout().GetSID(),
          start_time_offset: Date.now() - this._startTime
        },
        types: {},
        layouts: {},
        events: this._eventSheetManager._SaveToJson(),
        timelines: this._timelineManager._SaveToJson(),
        user_script_data: null
      }
      for (var f of this._allObjectClasses) f.IsFamily() || f.HasNoSaveBehavior() || (d.types[f.GetSID().toString()] = f._SaveToJson())
      for (const g of this._layoutManager.GetAllLayouts()) d.layouts[g.GetSID().toString()] = g._SaveToJson()
      f = this._CreateUserScriptEvent('save')
      f.saveData = null
      await this.DispatchUserScriptEventAsyncWait(f)
      d.user_script_data = f.saveData
      return JSON.stringify(d)
    }
    IsLoadingState() {
      return this._isLoadingState
    }
    async _DoLoadFromJsonString(d) {
      var f = this.GetLayoutManager()
      d = JSON.parse(d)
      if (d.c2save) throw Error('C2 saves are incompatible with C3 runtime')
      if (!d.c3save) throw Error('not valid C3 save data')
      if (1 < d.version) throw Error('C3 save data from future version')
      this._dispatcher.dispatchEvent(e.New(e.Event, 'beforeload'))
      for (var g of this.allInstances()) g._OnBeforeLoad()
      this._isLoadingState = !0
      g = d.rt
      this._gameTime.Set(g.time)
      g.hasOwnProperty('timeRaw') && this._gameTimeRaw.Set(g.timeRaw)
      this._wallTime.Set(g.walltime)
      this._timeScale = g.timescale
      this._tickCount = g.tickcount
      this._execCount = g.execcount
      this._startTime = Date.now() - g.start_time_offset
      var h = g.running_layout
      if (h !== this.GetMainRunningLayout().GetSID())
        if ((h = f.GetLayoutBySID(h))) await this._DoChangeLayout(h)
        else return
      for (const [k, m] of Object.entries(d.types)) (h = parseInt(k, 10)), (h = this.GetObjectClassBySID(h)), !h || h.IsFamily() || h.HasNoSaveBehavior() || h._LoadFromJson(m)
      this.FlushPendingInstances()
      this._RefreshUidMap()
      this._isLoadingState = !1
      this._nextUid = g.next_uid
      for (const [k, m] of Object.entries(d.layouts)) (g = parseInt(k, 10)), (g = f.GetLayoutBySID(g)) && g._LoadFromJson(m)
      this._eventSheetManager._LoadFromJson(d.events)
      for (const k of this._allObjectClasses)
        if (!k.IsFamily() && k.IsInContainer())
          for (const m of k.GetInstances()) {
            g = m.GetIID()
            for (const r of k.GetContainer().objectTypes())
              if (r !== k) {
                h = r.GetInstances()
                if (0 > g || g >= h.length) throw Error('missing sibling instance')
                m._AddSibling(h[g])
              }
          }
      this._timelineManager._LoadFromJson(d.timelines)
      f.SetAllLayerProjectionChanged()
      f.SetAllLayerMVChanged()
      this._dispatcher.dispatchEvent(e.New(e.Event, 'afterload'))
      f = this._CreateUserScriptEvent('load')
      f.saveData = d.user_script_data
      await this.DispatchUserScriptEventAsyncWait(f)
      this.UpdateRender()
    }
    async AddJobWorkerScripts(d) {
      d = (await Promise.all(d.map(f => this._assetManager.FetchBlob(f)))).map(f => URL.createObjectURL(f))
      this._jobScheduler.ImportScriptsToJobWorkers(d)
    }
    AddJobWorkerBlob(d, f) {
      this._jobScheduler.SendBlobToJobWorkers(d, f)
    }
    AddJobWorkerBuffer(d, f) {
      this._jobScheduler.SendBufferToJobWorkers(d, f)
    }
    AddJob(d, f, g) {
      return this._jobScheduler.AddJob(d, f, g)
    }
    BroadcastJob(d, f, g) {
      return this._jobScheduler.BroadcastJob(d, f, g)
    }
    InvokeDownload(d, f) {
      this.PostComponentMessageToDOM('runtime', 'invoke-download', {
        url: d,
        filename: f
      })
    }
    async RasterSvgImage(d, f, g, h, k, m) {
      h = h || f
      k = k || g
      if (this.IsInWorker())
        return (
          await this.PostComponentMessageToDOMAsync('runtime', 'raster-svg-image', {
            blob: d,
            imageWidth: f,
            imageHeight: g,
            surfaceWidth: h,
            surfaceHeight: k,
            imageBitmapOpts: m
          })
        ).imageBitmap
      d = await self.C3_RasterSvgImageBlob(d, f, g, h, k)
      return m ? await self.createImageBitmap(d, m) : d
    }
    async GetSvgImageSize(d) {
      return this.IsInWorker()
        ? await this.PostComponentMessageToDOMAsync('runtime', 'get-svg-image-size', {
            blob: d
          })
        : await self.C3_GetSvgImageSize(d)
    }
    RequestDeviceOrientationEvent() {
      this._didRequestDeviceOrientationEvent || ((this._didRequestDeviceOrientationEvent = !0), this.PostComponentMessageToDOM('runtime', 'enable-device-orientation'))
    }
    RequestDeviceMotionEvent() {
      this._didRequestDeviceMotionEvent || ((this._didRequestDeviceMotionEvent = !0), this.PostComponentMessageToDOM('runtime', 'enable-device-motion'))
    }
    Random() {
      return this._randomNumberCallback()
    }
    SetRandomNumberGeneratorCallback(d) {
      this._randomNumberCallback = d
    }
    _GetRemotePreviewStatusInfo() {
      const d = this.GetWebGLRenderer()
      return {
        fps: this.GetFPS(),
        cpu: this.GetMainThreadTime(),
        gpu: this.GetGPUUtilisation(),
        layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : '',
        renderer: d ? d.GetUnmaskedRenderer() : '<unavailable>'
      }
    }
    HitBreakpoint() {
      return this.IsDebug() ? b.HitBreakpoint() : !1
    }
    DebugBreak(d) {
      return this.IsDebugging() ? b.DebugBreak(d) : Promise.resolve()
    }
    DebugBreakNext() {
      return this.IsDebugging() ? b.BreakNext() : !1
    }
    SetDebugBreakpointsEnabled(d) {
      this._breakpointsEnabled = !!d
      this._UpdateDebuggingFlag()
    }
    AreDebugBreakpointsEnabled() {
      return this._breakpointsEnabled
    }
    IsDebugging() {
      return this._isDebugging
    }
    SetDebuggingEnabled(d) {
      d ? this._debuggingDisabled-- : this._debuggingDisabled++
      this._UpdateDebuggingFlag()
    }
    _UpdateDebuggingFlag() {
      this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
    }
    IsCPUProfiling() {
      return this.IsDebug() && b.IsCPUProfiling()
    }
    IsGPUProfiling() {
      return this.IsDebug() && this.GetRenderer().SupportsGPUProfiling() && b.IsGPUProfiling()
    }
    async DebugIterateAndBreak(d) {
      if (d) for (const f of d) await this.DebugBreak(f)
    }
    DebugFireGeneratorEventAndBreak(d) {
      return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(d))
    }
    _InvokeFunctionFromJS(d) {
      return this._eventSheetManager._InvokeFunctionFromJS(d.name, d.params)
    }
    GetIRuntime() {
      return this._iRuntime
    }
    _CreateUserScriptEvent(d) {
      d = e.New(e.Event, d, !1)
      d.runtime = this._iRuntime
      return d
    }
    _InitScriptInterfaces() {
      var d = {}
      for (const f of this._allObjectClasses)
        d[f.GetJsPropName()] = {
          value: f.GetIObjectClass(),
          enumerable: !0,
          writable: !1
        }
      d = Object.create(Object.prototype, d)
      this._iRuntime = new self.IRuntime(this, d)
      this._userScriptEventObjects = {
        tick: this._CreateUserScriptEvent('tick')
      }
    }
    _InitGlobalVariableScriptInterface() {
      const d = {}
      for (const f of this.GetEventSheetManager().GetAllGlobalVariables()) d[f.GetJsPropName()] = f._GetScriptInterfaceDescriptor()
      this._iRuntime._InitGlobalVars(d)
    }
    _GetCommonScriptInterfaces() {
      return this._commonScriptInterfaces
    }
    _MapScriptInterface(d, f) {
      this._interfaceMap.set(d, f)
    }
    _UnwrapScriptInterface(d) {
      return this._interfaceMap.get(d)
    }
    _UnwrapIObjectClass(d) {
      if (!(d instanceof self.IObjectClass)) throw new TypeError('expected IObjectClass')
      d = this._UnwrapScriptInterface(d)
      if (!(d && d instanceof e.ObjectClass)) throw Error('invalid IObjectClass')
      return d
    }
    _UnwrapIWorldInstance(d) {
      if (!(d instanceof self.IWorldInstance)) throw new TypeError('expected IWorldInstance')
      d = this._UnwrapScriptInterface(d)
      if (!(d && d instanceof e.Instance)) throw Error('invalid IInstance')
      return d
    }
  }
  self.C3_CreateRuntime = e.Runtime.Create
  self.C3_InitRuntime = (d, f) => d.Init(f)
}
{
  ;('use strict')
  const e = self.C3
  e.JobSchedulerRuntime = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._runtime = b
      this._jobPromises = new Map()
      this._nextJobId = 0
      this._inputPort = a.inputPort
      a.outputPort.onmessage = c => this._OnJobWorkerMessage(c)
      this._maxNumWorkers = a.maxNumWorkers
      this._jobWorkerCount = 1
      this._hadErrorCreatingWorker = this._isCreatingWorker = !1
    }
    async Init() {}
    ImportScriptsToJobWorkers(b) {
      this._inputPort.postMessage({
        type: '_import_scripts',
        scripts: b
      })
    }
    SendBlobToJobWorkers(b, a) {
      this._inputPort.postMessage({
        type: '_send_blob',
        blob: b,
        id: a
      })
    }
    SendBufferToJobWorkers(b, a) {
      this._inputPort.postMessage(
        {
          type: '_send_buffer',
          buffer: b,
          id: a
        },
        [b]
      )
    }
    AddJob(b, a, c, d, f) {
      c || (c = [])
      const g = this._nextJobId++
      b = {
        type: b,
        isBroadcast: !1,
        jobId: g,
        params: a,
        transferables: c
      }
      a = new Promise((h, k) => {
        this._jobPromises.set(g, {
          resolve: h,
          progress: d,
          reject: k,
          cancelled: !1
        })
      })
      f && f.SetAction(() => this._CancelJob(g))
      this._inputPort.postMessage(b, c)
      this._MaybeCreateExtraWorker()
      return a
    }
    BroadcastJob(b, a, c) {
      c || (c = [])
      const d = this._nextJobId++
      this._inputPort.postMessage(
        {
          type: b,
          isBroadcast: !0,
          jobId: d,
          params: a,
          transferables: c
        },
        c
      )
    }
    _CancelJob(b) {
      const a = this._jobPromises.get(b)
      a &&
        ((a.cancelled = !0),
        (a.resolve = null),
        (a.progress = null),
        (a.reject = null),
        this._inputPort.postMessage({
          type: '_cancel',
          jobId: b
        }))
    }
    _OnJobWorkerMessage(b) {
      b = b.data
      const a = b.type,
        c = b.jobId
      switch (a) {
        case 'result':
          this._OnJobResult(c, b.result)
          break
        case 'progress':
          this._OnJobProgress(c, b.progress)
          break
        case 'error':
          this._OnJobError(c, b.error)
          break
        case 'ready':
          this._OnJobWorkerReady()
          break
        default:
          throw Error(`unknown message from worker '${a}'`)
      }
    }
    _OnJobResult(b, a) {
      const c = this._jobPromises.get(b)
      if (!c) throw Error('invalid job ID')
      c.cancelled || c.resolve(a)
      this._jobPromises.delete(b)
    }
    _OnJobProgress(b, a) {
      b = this._jobPromises.get(b)
      if (!b) throw Error('invalid job ID')
      !b.cancelled && b.progress && b.progress(a)
    }
    _OnJobError(b, a) {
      const c = this._jobPromises.get(b)
      if (!c) throw Error('invalid job ID')
      c.cancelled || c.reject(a)
      this._jobPromises.delete(b)
    }
    _OnJobWorkerReady() {
      this._isCreatingWorker &&
        ((this._isCreatingWorker = !1),
        this._jobWorkerCount++,
        this._jobWorkerCount < this._maxNumWorkers
          ? this._MaybeCreateExtraWorker()
          : this._inputPort.postMessage({
              type: '_no_more_workers'
            }))
    }
    async _MaybeCreateExtraWorker() {
      if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._jobPromises.size <= this._jobWorkerCount))
        try {
          ;(this._isCreatingWorker = !0), ((await this._runtime.PostComponentMessageToDOMAsync('runtime', 'create-job-worker')).outputPort.onmessage = b => this._OnJobWorkerMessage(b))
        } catch (b) {
          ;(this._hadErrorCreatingWorker = !0), (this._isCreatingWorker = !1), console.error(`[Construct 3] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, b)
        }
    }
  }
}
self.C3_Shaders = {}
self.C3_Shaders.darken = {
  src: 'varying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform lowp sampler2D samplerBack;\nuniform mediump vec2 destStart;\nuniform mediump vec2 destEnd;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nfront.rgb /= front.a;\nmediump vec2 tex = (vTex - srcStart) / (srcEnd - srcStart);\nlowp vec4 back = texture2D(samplerBack, mix(destStart, destEnd, tex));\nback.rgb /= back.a;\nfront.rgb = min(front.rgb, back.rgb) * front.a;\ngl_FragColor = front * back.a;\n}',
  extendBoxHorizontal: 0,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: []
}
self.C3_Shaders.warpobject = {
  src: '#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcStart;\nuniform mediump vec2 srcEnd;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float layerScale;\nuniform mediump float freqX;\nuniform mediump float freqY;\nuniform mediump float ampX;\nuniform mediump float ampY;\nuniform mediump float speedX;\nuniform mediump float speedY;\nvoid main(void)\n{\nmediump float _2pi = 2.0 * 3.14159265359;\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 n = ((vTex - srcOriginStart) / srcOriginSize);\nmediump vec2 p = vTex;\np.x += cos(n.y * _2pi * freqY + seconds * speedY * _2pi) * ampY * pixelSize.x * layerScale;\np.y += sin(n.x * _2pi * freqX + seconds * speedX * _2pi) * ampX * pixelSize.y * layerScale;\np = clamp(p, min(srcStart, srcEnd), max(srcStart, srcEnd));\ngl_FragColor = texture2D(samplerFront, p);\n}',
  extendBoxHorizontal: 30,
  extendBoxVertical: 30,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !0,
  parameters: [
    ['freqX', 0, 'float'],
    ['freqY', 0, 'float'],
    ['ampX', 0, 'float'],
    ['ampY', 0, 'float'],
    ['speedX', 0, 'float'],
    ['speedY', 0, 'float']
  ]
}
self.C3_Shaders.alphaclamp = {
  src: 'precision mediump float;\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform lowp float alphathreshold;\nuniform lowp float lowerclamp;\nuniform lowp float upperclamp;\nvoid main(void)\n{\nlowp vec4 front = texture2D(samplerFront, vTex);\nlowp float a = front.a;\nlowp vec4 unpremultiplied = front / a;\na = (a < alphathreshold ? lowerclamp : upperclamp);\nfront *= a;\nfront.a = a;\ngl_FragColor = front;\n}',
  extendBoxHorizontal: 0,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !0,
  animated: !1,
  parameters: [
    ['alphathreshold', 0, 'percent'],
    ['lowerclamp', 0, 'percent'],
    ['upperclamp', 0, 'percent']
  ]
}
self.C3_Shaders.glowhorizontal = {
  src: 'varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelWidth = pixelSize.x;\nmediump float halfPixelWidth = pixelWidth / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 1.0 + halfPixelWidth, 0.0)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 3.0 + halfPixelWidth, 0.0)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 5.0 + halfPixelWidth, 0.0)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(pixelWidth * 7.0 + halfPixelWidth, 0.0)) * 0.06;\ngl_FragColor = mix(front, max(front, sum), intensity);\n}',
  extendBoxHorizontal: 8,
  extendBoxVertical: 0,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: [['intensity', 0, 'percent']]
}
self.C3_Shaders.glowvertical = {
  src: 'varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelHeight = pixelSize.y;\nmediump float halfPixelHeight = pixelHeight / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\ngl_FragColor = mix(front, max(front, sum), intensity);\n}',
  extendBoxHorizontal: 0,
  extendBoxVertical: 8,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: [['intensity', 0, 'percent']]
}
self.C3_Shaders.warpripple = {
  src: '#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying mediump vec2 vTex;\nuniform lowp sampler2D samplerFront;\nuniform mediump vec2 srcOriginStart;\nuniform mediump vec2 srcOriginEnd;\nuniform highmedp float seconds;\nuniform mediump vec2 pixelSize;\nuniform mediump float freq;\nuniform mediump float amp;\nuniform mediump float speed;\nconst mediump float PI = 3.1415926;\nvoid main(void)\n{\nmediump vec2 srcOriginSize = srcOriginEnd - srcOriginStart;\nmediump vec2 tex = (vTex - srcOriginStart) / srcOriginSize;\ntex = tex * 2.0 - 1.0;\nmediump float d = length(tex);\nmediump float a = atan(tex.y, tex.x);\nd += sin((d * 2.0 * PI) * freq / (pixelSize.x * 750.0) + (seconds * speed)) * amp * (pixelSize.x * 750.0);\ntex.x = cos(a) * d;\ntex.y = sin(a) * d;\ntex = (tex + 1.0) / 2.0;\ntex = clamp(tex, 0.0, 1.0);\ntex = tex * srcOriginSize + srcOriginStart;\ngl_FragColor = texture2D(samplerFront, tex);\n}',
  extendBoxHorizontal: 50,
  extendBoxVertical: 50,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !0,
  parameters: [
    ['freq', 0, 'float'],
    ['amp', 0, 'percent'],
    ['speed', 0, 'float']
  ]
}
self.C3_Shaders.blurvertical = {
  src: 'varying mediump vec2 vTex;\nuniform mediump sampler2D samplerFront;\nuniform mediump vec2 pixelSize;\nuniform mediump float intensity;\nvoid main(void)\n{\nmediump vec4 sum = vec4(0.0);\nmediump float pixelHeight = pixelSize.y;\nmediump float halfPixelHeight = pixelHeight / 2.0;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex - vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nmediump vec4 front = texture2D(samplerFront, vTex);\nsum += front * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 1.0 + halfPixelHeight)) * 0.16;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 3.0 + halfPixelHeight)) * 0.13;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 5.0 + halfPixelHeight)) * 0.10;\nsum += texture2D(samplerFront, vTex + vec2(0.0, pixelHeight * 7.0 + halfPixelHeight)) * 0.06;\ngl_FragColor = mix(front, sum, intensity);\n}',
  extendBoxHorizontal: 0,
  extendBoxVertical: 8,
  crossSampling: !1,
  mustPreDraw: !1,
  preservesOpaqueness: !1,
  animated: !1,
  parameters: [['intensity', 0, 'percent']]
}
{
  ;('use strict')
  const e = self.C3
  let b = null,
    a = '',
    c = '',
    d = [],
    f = '',
    g = '',
    h = ''
  const k = e.New(e.ArrayStack)

  function m(r, w) {
    r = r[1]
    w = w[1]
    if ('number' === typeof r && 'number' === typeof w) return r - w
    r = '' + r
    w = '' + w
    return r < w ? -1 : r > w ? 1 : 0
  }
  e.Plugins.System = class extends e.SDKPluginBase {
    constructor(r) {
      super(r)
      this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack()
      this._eventStack = this._runtime.GetEventSheetManager().GetEventStack()
      this._imagesLoadingComplete = this._imagesLoadingTotal = 0
      this._functionMaps = new Map()
    }
    Release() {
      super.Release()
    }
    UpdateRender() {
      this._runtime.UpdateRender()
    }
    Trigger(r) {
      this._runtime.Trigger(r, null, null)
    }
    GetRegex(r, w) {
      ;(b && r === a && w === c) || ((b = new RegExp(r, w)), (a = r), (c = w))
      b.lastIndex = 0
      return b
    }
    GetRegexMatches(r, w, p) {
      if (r === f && w === g && p === h) return d
      const q = this.GetRegex(w, p)
      d = r.match(q)
      f = r
      g = w
      h = p
      return d
    }
    async _LoadTexturesForObjectClasses(r, w) {
      if (w.length) {
        this._imagesLoadingTotal += w.length
        var p = []
        for (const q of w) p.push(r.MaybeLoadTexturesFor(q))
        await e.PromiseAllWithProgress(p, () => {
          this._imagesLoadingComplete++
        })
        this._imagesLoadingComplete++
        this._imagesLoadingComplete === this._imagesLoadingTotal && (this._runtime.Trigger(e.Plugins.System.Cnds.OnImageLoadingComplete, null, null), (this._imagesLoadingTotal = this._imagesLoadingComplete = 0))
      }
    }
    _UnloadTexturesForObjectClasses(r, w) {
      for (const p of w) 0 === p.GetInstanceCount() && r.MaybeUnloadTexturesFor(p)
    }
    _GetForEachStack() {
      return k
    }
    _Repeat(r) {
      var w = this._runtime.GetEventSheetManager()
      const p = w.GetEventStack(),
        q = p.GetCurrentStackFrame(),
        t = q.GetCurrentEvent(),
        x = t.GetSolModifiers()
      var v = q.IsSolModifierAfterCnds()
      const u = p.Push(t),
        A = w.GetLoopStack(),
        z = A.Push()
      z.SetEnd(r)
      if (v) for (v = 0; v < r && !z.IsStopped(); ++v) w.PushCopySol(x), z.SetIndex(v), t.Retrigger(q, u), w.PopSol(x)
      else for (w = 0; w < r && !z.IsStopped(); ++w) z.SetIndex(w), t.Retrigger(q, u)
      p.Pop()
      A.Pop()
      return !1
    }
    *_DebugRepeat(r) {
      var w = this._runtime.GetEventSheetManager()
      const p = w.GetEventStack(),
        q = p.GetCurrentStackFrame(),
        t = q.GetCurrentEvent(),
        x = t.GetSolModifiers()
      var v = q.IsSolModifierAfterCnds()
      const u = p.Push(t),
        A = w.GetLoopStack(),
        z = A.Push()
      z.SetEnd(r)
      if (v) for (v = 0; v < r && !z.IsStopped(); ++v) w.PushCopySol(x), z.SetIndex(v), yield* t.DebugRetrigger(q, u), w.PopSol(x)
      else for (w = 0; w < r && !z.IsStopped(); ++w) z.SetIndex(w), yield* t.DebugRetrigger(q, u)
      p.Pop()
      A.Pop()
      return !1
    }
    _While() {
      var r = this._runtime.GetEventSheetManager()
      const w = r.GetEventStack(),
        p = w.GetCurrentStackFrame(),
        q = p.GetCurrentEvent(),
        t = q.GetSolModifiers()
      var x = p.IsSolModifierAfterCnds()
      const v = w.Push(q),
        u = r.GetLoopStack(),
        A = u.Push()
      if (x) for (x = 0; !A.IsStopped(); ++x) r.PushCopySol(t), A.SetIndex(x), q.Retrigger(p, v) || A.Stop(), r.PopSol(t)
      else for (r = 0; !A.IsStopped(); ++r) A.SetIndex(r), q.Retrigger(p, v) || A.Stop()
      w.Pop()
      u.Pop()
      return !1
    }
    *_DebugWhile() {
      var r = this._runtime.GetEventSheetManager()
      const w = r.GetEventStack(),
        p = w.GetCurrentStackFrame(),
        q = p.GetCurrentEvent(),
        t = q.GetSolModifiers()
      var x = p.IsSolModifierAfterCnds()
      const v = w.Push(q),
        u = r.GetLoopStack(),
        A = u.Push()
      if (x) for (x = 0; !A.IsStopped(); ++x) r.PushCopySol(t), A.SetIndex(x), (yield* q.DebugRetrigger(p, v)) || A.Stop(), r.PopSol(t)
      else for (r = 0; !A.IsStopped(); ++r) A.SetIndex(r), (yield* q.DebugRetrigger(p, v)) || A.Stop()
      w.Pop()
      u.Pop()
      return !1
    }
    _For(r, w, p) {
      var q = this._runtime.GetEventSheetManager()
      const t = q.GetEventStack(),
        x = t.GetCurrentStackFrame(),
        v = x.GetCurrentEvent(),
        u = v.GetSolModifiers(),
        A = x.IsSolModifierAfterCnds(),
        z = t.Push(v),
        C = q.GetLoopStack(),
        E = C.Push()
      E.SetName(r)
      E.SetEnd(p)
      if (p < w)
        if (A) for (r = w; r >= p && !E.IsStopped(); --r) q.PushCopySol(u), E.SetIndex(r), v.Retrigger(x, z), q.PopSol(u)
        else for (q = w; q >= p && !E.IsStopped(); --q) E.SetIndex(q), v.Retrigger(x, z)
      else if (A) for (r = w; r <= p && !E.IsStopped(); ++r) q.PushCopySol(u), E.SetIndex(r), v.Retrigger(x, z), q.PopSol(u)
      else for (q = w; q <= p && !E.IsStopped(); ++q) E.SetIndex(q), v.Retrigger(x, z)
      t.Pop()
      C.Pop()
      return !1
    }
    *_DebugFor(r, w, p) {
      var q = this._runtime.GetEventSheetManager()
      const t = q.GetEventStack(),
        x = t.GetCurrentStackFrame(),
        v = x.GetCurrentEvent(),
        u = v.GetSolModifiers(),
        A = x.IsSolModifierAfterCnds(),
        z = t.Push(v),
        C = q.GetLoopStack(),
        E = C.Push()
      E.SetName(r)
      E.SetEnd(p)
      if (p < w)
        if (A) for (r = w; r >= p && !E.IsStopped(); --r) q.PushCopySol(u), E.SetIndex(r), yield* v.DebugRetrigger(x, z), q.PopSol(u)
        else for (q = w; q >= p && !E.IsStopped(); --q) E.SetIndex(q), yield* v.DebugRetrigger(x, z)
      else if (A) for (r = w; r <= p && !E.IsStopped(); ++r) q.PushCopySol(u), E.SetIndex(r), yield* v.DebugRetrigger(x, z), q.PopSol(u)
      else for (q = w; q <= p && !E.IsStopped(); ++q) E.SetIndex(q), yield* v.DebugRetrigger(x, z)
      t.Pop()
      C.Pop()
      return !1
    }
    _ForEach(r) {
      var w = this._runtime.GetEventSheetManager()
      const p = w.GetEventStack(),
        q = p.GetCurrentStackFrame(),
        t = q.GetCurrentEvent(),
        x = t.GetSolModifiers()
      var v = q.IsSolModifierAfterCnds()
      const u = p.Push(t),
        A = w.GetLoopStack(),
        z = A.Push(),
        C = r.IsInContainer(),
        E = r.GetCurrentSol(),
        J = k.Push()
      e.shallowAssignArray(J, E.GetInstances())
      z.SetEnd(J.length)
      if (v) for (let F = 0, I = J.length; F < I && !z.IsStopped(); ++F) w.PushCopySol(x), (v = J[F]), r.GetCurrentSol().SetSinglePicked(v), C && v.SetSiblingsSinglePicked(), z.SetIndex(F), t.Retrigger(q, u), w.PopSol(x)
      else {
        E._SetSelectAll(!1)
        r = E._GetOwnInstances()
        e.clearArray(r)
        r.push(null)
        for (let F = 0, I = J.length; F < I && !z.IsStopped(); ++F) (w = J[F]), (r[0] = w), C && w.SetSiblingsSinglePicked(), z.SetIndex(F), t.Retrigger(q, u)
      }
      p.Pop()
      A.Pop()
      e.clearArray(J)
      k.Pop()
      return !1
    }
    *_DebugForEach(r) {
      var w = this._runtime.GetEventSheetManager()
      const p = w.GetEventStack(),
        q = p.GetCurrentStackFrame(),
        t = q.GetCurrentEvent(),
        x = t.GetSolModifiers()
      var v = q.IsSolModifierAfterCnds()
      const u = p.Push(t),
        A = w.GetLoopStack(),
        z = A.Push(),
        C = r.IsInContainer(),
        E = r.GetCurrentSol(),
        J = k.Push()
      e.shallowAssignArray(J, E.GetInstances())
      z.SetEnd(J.length)
      if (v) for (let F = 0, I = J.length; F < I && !z.IsStopped(); ++F) w.PushCopySol(x), (v = J[F]), r.GetCurrentSol().SetSinglePicked(v), C && v.SetSiblingsSinglePicked(), z.SetIndex(F), yield* t.DebugRetrigger(q, u), w.PopSol(x)
      else {
        E._SetSelectAll(!1)
        r = E._GetOwnInstances()
        e.clearArray(r)
        r.push(null)
        for (let F = 0, I = J.length; F < I && !z.IsStopped(); ++F) (w = J[F]), (r[0] = w), C && w.SetSiblingsSinglePicked(), z.SetIndex(F), yield* t.DebugRetrigger(q, u)
      }
      p.Pop()
      A.Pop()
      e.clearArray(J)
      k.Pop()
      return !1
    }
    _ForEachOrdered(r, w) {
      var p = this._runtime.GetEventSheetManager()
      const q = p.GetEventStack(),
        t = p.GetCurrentCondition(),
        x = q.GetCurrentStackFrame(),
        v = x.GetCurrentEvent(),
        u = v.GetSolModifiers(),
        A = x.IsSolModifierAfterCnds(),
        z = q.Push(v),
        C = p.GetLoopStack(),
        E = C.Push(),
        J = r.IsInContainer(),
        F = r.GetCurrentSol(),
        I = k.Push()
      e.clearArray(I)
      const L = F.GetInstances()
      E.SetEnd(L.length)
      for (let N = 0, S = L.length; N < S; ++N) I.push([L[N], t.ReevaluateParameter(1, N)])
      I.sort(m)
      1 === w && I.reverse()
      if (A) for (let N = 0, S = I.length; N < S && !E.IsStopped(); ++N) p.PushCopySol(u), (w = I[N][0]), r.GetCurrentSol().SetSinglePicked(w), J && w.SetSiblingsSinglePicked(), E.SetIndex(N), v.Retrigger(x, z), p.PopSol(u)
      else {
        F._SetSelectAll(!1)
        r = F._GetOwnInstances()
        e.clearArray(r)
        r.push(null)
        for (let N = 0, S = I.length; N < S && !E.IsStopped(); ++N) (p = I[N][0]), (r[0] = p), J && p.SetSiblingsSinglePicked(), E.SetIndex(N), v.Retrigger(x, z)
      }
      q.Pop()
      C.Pop()
      e.clearArray(I)
      k.Pop()
      return !1
    }
    *_DebugForEachOrdered(r, w) {
      var p = this._runtime.GetEventSheetManager()
      const q = p.GetEventStack(),
        t = p.GetCurrentCondition(),
        x = q.GetCurrentStackFrame(),
        v = x.GetCurrentEvent(),
        u = v.GetSolModifiers(),
        A = x.IsSolModifierAfterCnds(),
        z = q.Push(v),
        C = p.GetLoopStack(),
        E = C.Push(),
        J = r.IsInContainer(),
        F = r.GetCurrentSol(),
        I = k.Push()
      e.clearArray(I)
      const L = F.GetInstances()
      E.SetEnd(L.length)
      for (let N = 0, S = L.length; N < S; ++N) I.push([L[N], t.ReevaluateParameter(1, N)])
      I.sort(m)
      1 === w && I.reverse()
      if (A) for (let N = 0, S = I.length; N < S && !E.IsStopped(); ++N) p.PushCopySol(u), (w = I[N][0]), r.GetCurrentSol().SetSinglePicked(w), J && w.SetSiblingsSinglePicked(), E.SetIndex(N), yield* v.DebugRetrigger(x, z), p.PopSol(u)
      else {
        F._SetSelectAll(!1)
        r = F._GetOwnInstances()
        e.clearArray(r)
        r.push(null)
        for (let N = 0, S = I.length; N < S && !E.IsStopped(); ++N) (p = I[N][0]), (r[0] = p), J && p.SetSiblingsSinglePicked(), E.SetIndex(N), yield* v.DebugRetrigger(x, z)
      }
      q.Pop()
      C.Pop()
      e.clearArray(I)
      k.Pop()
      return !1
    }
    _GetFunctionMap(r, w) {
      let p = this._functionMaps.get(r)
      if (p) return p
      if (!w) return null
      p = {
        defaultFunc: null,
        strMap: new Map()
      }
      this._functionMaps.set(r, p)
      return p
    }
    _DoCallMappedFunction(r, w, p, q, t) {
      w.GetEventBlock().RunAsMappedFunctionCall(p)
      q && r.PopSol(t)
    }
    *_DebugDoCallMappedFunction(r, w, p, q, t) {
      yield* w.GetEventBlock().DebugRunAsMappedFunctionCall(p)
      q && r.PopSol(t)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.System.Type = class extends e.DefendedBase {
    constructor(b) {
      super()
      this._objectClass = b
      this._runtime = b.GetRuntime()
      this._plugin = b.GetPlugin()
    }
    OnCreate() {}
    Release() {
      this._plugin = this._runtime = this._objectClass = null
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.System.Instance = class extends e.DefendedBase {
    constructor(b, a) {
      super()
      this._inst = b
      this._objectClass = this._inst.GetObjectClass()
      this._sdkType = this._objectClass.GetSdkType()
      this._runtime = this._inst.GetRuntime()
    }
    Release() {
      this._runtime = this._sdkType = this._objectClass = this._inst = null
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []
  e.Plugins.System.Cnds = {
    EveryTick() {
      return !0
    },
    OnLayoutStart() {
      return !0
    },
    OnLayoutEnd() {
      return !0
    },
    OnSuspend() {
      return !0
    },
    OnResume() {
      return !0
    },
    IsSuspended() {
      return this._runtime.IsSuspended()
    },
    Else() {
      const a = this._runtime.GetCurrentEventStackFrame()
      return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
    },
    TriggerOnce() {
      const a = this._runtime.GetCurrentCondition().GetSavedDataMap()
      let c = a.get('TriggerOnce_lastTick')
      'undefined' === typeof c && ((c = -1), a.set('TriggerOnce_lastTick', -1))
      const d = this._runtime.GetTickCount()
      a.set('TriggerOnce_lastTick', d)
      return this._runtime.IsLayoutFirstTick() || c !== d - 1
    },
    Every(a) {
      const c = this._runtime.GetCurrentCondition().GetSavedDataMap(),
        d = c.get('Every_lastTime') || 0,
        f = this._runtime.GetGameTime()
      c.has('Every_seconds') || c.set('Every_seconds', a)
      const g = c.get('Every_seconds')
      if (f >= d + g) return c.set('Every_lastTime', d + g), f >= c.get('Every_lastTime') + 0.04 && c.set('Every_lastTime', f), c.set('Every_seconds', a), !0
      f < d - 0.1 && c.set('Every_lastTime', f)
      return !1
    },
    IsGroupActive(a) {
      return (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) && a.IsGroupActive()
    },
    IsPreview() {
      return this._runtime.IsPreview()
    },
    IsMobile() {
      return e.Platform.IsMobile
    },
    OnLoadFinished() {
      return !0
    },
    OnCanvasSnapshot() {
      return !0
    },
    EffectsSupported() {
      return !0
    },
    OnSaveComplete() {
      return !0
    },
    OnSaveFailed() {
      return !0
    },
    OnLoadComplete() {
      return !0
    },
    OnLoadFailed() {
      return !0
    },
    ObjectUIDExists(a) {
      return !!this._runtime.GetInstanceByUID(a)
    },
    IsOnPlatform(a) {
      switch (a) {
        case 0:
          return 'browser' === e.Platform.Context
        case 1:
          return 'iOS' === e.Platform.OS
        case 2:
          return 'Android' === e.Platform.OS
        case 8:
          return 'cordova' === e.Platform.Context
        case 9:
          return 'scirra-arcade' === this._runtime.GetExportType()
        case 10:
          return 'nwjs' === e.Platform.Context
        case 13:
          return 'windows-uwp' === this._runtime.GetExportType()
        default:
          return !1
      }
    },
    RegexTest(a, c, d) {
      return this.GetRegex(c, d).test(a)
    },
    Compare(a, c, d) {
      return e.compare(a, c, d)
    },
    CompareBetween(a, c, d) {
      return a >= c && a <= d
    },
    CompareVar(a, c, d) {
      return e.compare(a.GetValue(), c, d)
    },
    CompareBoolVar(a) {
      return !!a.GetValue()
    },
    CompareTime(a, c) {
      const d = this._runtime.GetGameTime()
      return 0 === a ? ((a = this._runtime.GetCurrentCondition().GetSavedDataMap()), !a.get('CompareTime_executed') && d >= c ? (a.set('CompareTime_executed', !0), !0) : !1) : e.compare(d, a, c)
    },
    IsNaN(a) {
      return isNaN(a)
    },
    AngleWithin(a, c, d) {
      return e.angleDiff(e.toRadians(a), e.toRadians(d)) <= e.toRadians(c)
    },
    IsClockwiseFrom(a, c) {
      return e.angleClockwise(e.toRadians(a), e.toRadians(c))
    },
    IsBetweenAngles(a, c, d) {
      a = e.toRadians(a)
      c = e.toRadians(c)
      d = e.toRadians(d)
      return e.angleClockwise(d, c) ? e.angleClockwise(a, c) && !e.angleClockwise(a, d) : !(!e.angleClockwise(a, c) && e.angleClockwise(a, d))
    },
    IsValueType(a, c) {
      return 'number' === typeof a ? 0 === c : 1 === c
    },
    EvaluateExpression(a) {
      return !!a
    },
    PickByComparison(a, c, d, f) {
      if (!a) return !1
      const g = this._GetForEachStack(),
        h = g.Push(),
        k = a.GetCurrentSol()
      e.shallowAssignArray(h, k.GetInstances())
      k.IsSelectAll() && e.clearArray(k._GetOwnElseInstances())
      const m = this._runtime.GetCurrentCondition()
      let r = 0
      for (let w = 0, p = h.length; w < p; ++w) {
        const q = h[w]
        h[r] = q
        c = m.ReevaluateParameter(1, w)
        f = m.ReevaluateParameter(3, w)
        e.compare(c, d, f) ? ++r : k._PushElseInstance(q)
      }
      e.truncateArray(h, r)
      k.SetArrayPicked(h)
      c = !!h.length
      e.clearArray(h)
      g.Pop()
      a.ApplySolToContainer()
      return c
    },
    PickByEvaluate(a, c) {
      if (!a) return !1
      const d = this._GetForEachStack(),
        f = d.Push(),
        g = a.GetCurrentSol()
      e.shallowAssignArray(f, g.GetInstances())
      g.IsSelectAll() && e.clearArray(g._GetOwnElseInstances())
      const h = this._runtime.GetCurrentCondition()
      let k = 0
      for (let m = 0, r = f.length; m < r; ++m) {
        const w = f[m]
        f[k] = w
        ;(c = h.ReevaluateParameter(1, m)) ? ++k : g._PushElseInstance(w)
      }
      e.truncateArray(f, k)
      g.SetArrayPicked(f)
      c = !!f.length
      e.clearArray(f)
      d.Pop()
      a.ApplySolToContainer()
      return c
    },
    PickNth(a, c) {
      if (!a) return !1
      const d = a.GetCurrentSol(),
        f = d.GetInstances()
      c = Math.floor(c)
      if (c >= f.length) return !1
      d.PickOne(f[c])
      a.ApplySolToContainer()
      return !0
    },
    PickRandom(a) {
      if (!a) return !1
      const c = a.GetCurrentSol(),
        d = c.GetInstances(),
        f = Math.floor(this._runtime.Random() * d.length)
      if (f >= d.length) return !1
      c.PickOne(d[f])
      a.ApplySolToContainer()
      return !0
    },
    PickAll(a) {
      if (!a || !a.GetInstanceCount()) return !1
      a.GetCurrentSol()._SetSelectAll(!0)
      a.ApplySolToContainer()
      return !0
    },
    PickOverlappingPoint(a, c, d) {
      if (!a) return !1
      const f = a.GetCurrentSol()
      var g = f.GetInstances()
      const h = this._runtime.GetCurrentEvent().IsOrBlock(),
        k = this._runtime.GetCurrentCondition().IsInverted()
      f.IsSelectAll() ? (e.shallowAssignArray(b, g), f.ClearArrays(), f._SetSelectAll(!1)) : h ? (e.shallowAssignArray(b, f._GetOwnElseInstances()), e.clearArray(f._GetOwnElseInstances())) : (e.shallowAssignArray(b, f._GetOwnInstances()), e.clearArray(f._GetOwnInstances()))
      for (let m = 0, r = b.length; m < r; ++m) (g = b[m]), e.xor(g.GetWorldInfo().ContainsPoint(c, d), k) ? f._PushInstance(g) : f._PushElseInstance(g)
      a.ApplySolToContainer()
      return e.xor(!!f._GetOwnInstances().length, k)
    },
    PickLastCreated(a) {
      if (!a) return !1
      var c = a.IsFamily()
      let d = null
      const f = this._runtime._GetInstancesPendingCreate()
      for (let g = f.length - 1; 0 <= g; --g) {
        const h = f[g]
        if (c) {
          if (h.GetObjectClass().BelongsToFamily(a)) {
            d = h
            break
          }
        } else if (h.GetObjectClass() === a) {
          d = h
          break
        }
      }
      d || ((c = a.GetInstances()), c.length && (d = c[c.length - 1]))
      if (!d) return !1
      a.GetCurrentSol().PickOne(d)
      a.ApplySolToContainer()
      return !0
    },
    Repeat(a) {
      return this._runtime.IsDebugging() ? this._DebugRepeat(a) : this._Repeat(a)
    },
    While() {
      return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
    },
    For(a, c, d) {
      return this._runtime.IsDebugging() ? this._DebugFor(a, c, d) : this._For(a, c, d)
    },
    ForEach(a) {
      return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
    },
    ForEachOrdered(a, c, d) {
      return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a, d) : this._ForEachOrdered(a, d)
    },
    LayerVisible(a) {
      return a ? a.IsVisible() : !1
    },
    LayerEmpty(a) {
      return a ? !a.GetInstanceCount() : !1
    },
    LayerCmpOpacity(a, c, d) {
      return a ? e.compare(100 * a.GetOpacity(), c, d) : !1
    },
    OnImageLoadingComplete() {
      return !0
    },
    IsLoadingImages() {
      return 0 < this._imagesLoadingTotal
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(h, k) {
    const m = h[0] - k[0]
    return 0 !== m ? m : h[1] - k[1]
  }

  function a(h, k) {
    return h[1] - k[1]
  }
  const c = [],
    d = [],
    f = e.New(e.Rect),
    g = e.New(e.Color)
  e.Plugins.System.Acts = {
    SetVar(h, k) {
      h.SetValue(k)
    },
    AddVar(h, k) {
      h.IsNumber() && 'number' !== typeof k && (k = parseFloat(k))
      h.SetValue(h.GetValue() + k)
    },
    SubVar(h, k) {
      h.IsNumber() && h.SetValue(h.GetValue() - k)
    },
    SetBoolVar(h, k) {
      h.SetValue(!!k)
    },
    ToggleBoolVar(h) {
      h.SetValue(!h.GetValue())
    },
    ResetGlobals() {
      this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue()
    },
    CreateObject(h, k, m, r, w) {
      h &&
        k &&
        (m = this._runtime.CreateInstance(h, k, m, r, w)) &&
        (w && k.SortAndAddSceneGraphInstancesByZIndex(m), (k = this._runtime.GetEventSheetManager()), k.BlockFlushingInstances(!0), m._TriggerOnCreatedOnSelfAndRelated(), k.BlockFlushingInstances(!1), h.GetCurrentSol().SetSinglePicked(m), m.IsInContainer() && m.SetSiblingsSinglePicked())
    },
    CreateObjectByName(h, k, m, r, w) {
      h && k && (h = this._runtime.GetObjectClassByName(h)) && e.Plugins.System.Acts.CreateObject.call(this, h, k, m, r, w)
    },
    RecreateInitialObjects(h, k, m, r, w, p, q, t, x, v) {
      if (h) {
        var u = this._runtime.GetCurrentLayout()
        if (p && ((u = this._runtime.GetLayoutManager().GetLayoutByName(p)), !u)) return
        p = null
        if ('number' !== typeof q || 0 <= q) if (((p = u.GetLayer(q)), !p)) return
        f.set(k, m, r, w)
        k = u.RecreateInitialObjects(h, f, p, t, x, v)
        h.GetCurrentSol().SetArrayPicked(k)
        h.ApplySolToContainer()
      }
    },
    StopLoop() {
      const h = this._loopStack
      h.IsInLoop() && h.GetCurrent().Stop()
    },
    SetGroupActive(h, k) {
      ;(h = this._runtime.GetEventSheetManager().GetEventGroupByName(h)) && (0 === k ? h.SetGroupActive(!1) : 1 === k ? h.SetGroupActive(!0) : h.SetGroupActive(!h.IsGroupActive()))
    },
    SetTimescale(h) {
      this._runtime.SetTimeScale(h)
    },
    SetObjectTimescale(h, k) {
      0 > k && (k = 0)
      if (h) {
        h = h.GetCurrentSol().GetInstances()
        for (const m of h) m.SetTimeScale(k)
      }
    },
    RestoreObjectTimescale(h) {
      if (h) {
        h = h.GetCurrentSol().GetInstances()
        for (const k of h) k.RestoreTimeScale()
      }
    },
    Wait(h) {
      if (!(0 > h)) return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(h), !0
    },
    WaitForSignal(h) {
      this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(h)
      return !0
    },
    WaitForPreviousActions() {
      const h = this._runtime.GetEventSheetManager()
      h.AddScheduledWait().InitPromise(h.GetPromiseForAllAsyncActions())
      return !0
    },
    Signal(h) {
      h = h.toLowerCase()
      for (const k of this._runtime.GetEventSheetManager().scheduledWaits()) k.IsSignal() && k.GetSignalTag() === h && k.SetSignalled()
    },
    async SnapshotCanvas(h, k, m, r, w, p) {
      const q = this._runtime.GetCanvasManager()
      q && (this.UpdateRender(), await q.SnapshotCanvas(0 === h ? 'image/png' : 'image/jpeg', k / 100, m, r, w, p), await this._runtime.TriggerAsync(e.Plugins.System.Cnds.OnCanvasSnapshot, null))
    },
    SetCanvasSize(h, k) {
      if (!(0 >= h || 0 >= k)) {
        this._runtime.SetViewportSize(h, k)
        var m = this._runtime.GetCurrentLayout()
        m.BoundScrolling()
        for (const r of m.GetLayers()) r.UpdateViewport()
        if ((m = this._runtime.GetCanvasManager())) 'off' !== m.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(h, k), m.SetSize(m.GetLastWidth(), m.GetLastHeight(), !0), this._runtime.UpdateRender()
      }
    },
    SetFullscreenQuality(h) {
      const k = this._runtime.GetCanvasManager()
      k && 'off' !== k.GetCurrentFullscreenMode() && (k.SetFullscreenScalingQuality(0 !== h ? 'high' : 'low'), k.SetSize(k.GetLastWidth(), k.GetLastHeight(), !0))
    },
    SaveState(h) {
      this._runtime.SaveToSlot(h)
    },
    LoadState(h) {
      this._runtime.LoadFromSlot(h)
    },
    LoadStateJSON(h) {
      this._runtime.LoadFromJsonString(h)
    },
    SetHalfFramerateMode(h) {},
    ResetPersisted() {
      for (const h of this._runtime.GetLayoutManager().GetAllLayouts()) h.ResetPersistData()
    },
    SetPixelRounding(h) {
      this._runtime.SetPixelRoundingEnabled(0 !== h)
    },
    SetMinimumFramerate(h) {
      this._runtime.SetMinimumFramerate(h)
    },
    SortZOrderByInstVar(h, k) {
      if (h) {
        var m = h.GetCurrentSol().GetInstances(),
          r = this._runtime.GetCurrentLayout(),
          w = h.IsFamily()
        h = h.GetFamilyIndex()
        for (let q = 0, t = m.length; q < t; ++q) {
          var p = m[q]
          const x = p.GetWorldInfo()
          if (!x) continue
          let v
          v = w ? p.GetInstanceVariableValue(k + p.GetObjectClass().GetFamilyInstanceVariableOffset(h)) : p.GetInstanceVariableValue(k)
          c.push([x.GetLayer().GetIndex(), x.GetZIndex()])
          d.push([p, v])
        }
        if (c.length) {
          c.sort(b)
          d.sort(a)
          k = !1
          for (let q = 0, t = c.length; q < t; ++q) (m = d[q][0]), (w = r.GetLayerByIndex(c[q][0])), (h = c[q][1]), (p = w._GetInstances()), p[h] !== m && ((p[h] = m), m.GetWorldInfo()._SetLayer(w), w.SetZIndicesChanged(), (k = !0))
          k && this._runtime.UpdateRender()
          e.clearArray(c)
          e.clearArray(d)
        }
      }
    },
    GoToLayout(h) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager()
        k.IsPendingChangeMainLayout() || k.ChangeMainLayout(h)
      }
    },
    GoToLayoutByName(h) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager()
        k.IsPendingChangeMainLayout() || ((h = k.GetLayoutByName(h)) && k.ChangeMainLayout(h))
      }
    },
    NextPrevLayout(h) {
      if (!this._runtime.IsLoading()) {
        var k = this._runtime.GetLayoutManager()
        if (!k.IsPendingChangeMainLayout()) {
          var m = k.GetAllLayouts(),
            r = m.indexOf(k.GetMainRunningLayout())
          ;(h && 0 === r) || ((h || r !== m.length - 1) && k.ChangeMainLayout(m[r + (h ? -1 : 1)]))
        }
      }
    },
    RestartLayout() {
      if (!this._runtime.IsLoading()) {
        var h = this._runtime.GetLayoutManager()
        h.IsPendingChangeMainLayout() || (h.ChangeMainLayout(h.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
      }
    },
    SetLayerVisible(h, k) {
      h && h.SetVisible(k)
    },
    SetLayerOpacity(h, k) {
      h && h.SetOpacity(k / 100)
    },
    SetLayerScale(h, k) {
      h && h.SetOwnScale(k)
    },
    SetLayerScaleRate(h, k) {
      h && h.SetScaleRate(k)
    },
    SetLayerAngle(h, k) {
      h && h.SetAngle(e.toRadians(+k))
    },
    SetLayerScroll(h, k, m) {
      h && (h.SetOwnScrollPositionEnabled(!0), h.SetScrollX(k), h.SetScrollY(m))
    },
    RestoreLayerScroll(h) {
      h && h.SetOwnScrollPositionEnabled(!1)
    },
    SetLayerParallax(h, k, m) {
      h && h.SetParallax(k / 100, m / 100)
    },
    SetLayerZElevation(h, k) {
      h && h.SetZElevation(+k)
    },
    SetLayerBackground(h, k) {
      h && (g.setFromRgbValue(k), g.clamp(), (h = h.GetBackgroundColor()), h.equalsIgnoringAlpha(g) || (h.copyRgb(g), this.UpdateRender()))
    },
    SetLayerTransparent(h, k) {
      h && h.SetTransparent(k)
    },
    SetLayerBlendMode(h, k) {
      h && h.SetBlendMode(k)
    },
    SetLayerEffectEnabled(h, k, m) {
      h && ((h = h.GetEffectList()), (m = h.GetEffectTypeByName(m))) && ((k = 1 === k), m.IsActive() !== k && (m.SetActive(k), h.UpdateActiveEffects(), this._runtime.UpdateRender()))
    },
    SetLayerEffectParam(h, k, m, r) {
      if (h && ((h = h.GetEffectList()), (k = h.GetEffectTypeByName(k)))) {
        var w = k.GetIndex()
        h = h.GetEffectParametersForIndex(w)
        m = Math.floor(m)
        if (!(0 > m || m >= h.length)) {
          w = k.GetShaderProgram().GetParameterType(m)
          if ('color' === w) {
            g.setFromRgbValue(r)
            m = h[m]
            if (g.equalsIgnoringAlpha(m)) return
            m.copyRgb(g)
          } else {
            'percent' === w && (r /= 100)
            if (h[m] === r) return
            h[m] = r
          }
          k.IsActive() && this._runtime.UpdateRender()
        }
      }
    },
    SetLayerForceOwnTexture(h, k) {
      h && h.SetForceOwnTexture(k)
    },
    SetLayoutScale(h) {
      this._runtime.GetCurrentLayout().SetScale(+h)
    },
    SetLayoutAngle(h) {
      this._runtime.GetCurrentLayout().SetAngle(e.toRadians(+h))
    },
    SetLayoutEffectEnabled(h, k) {
      const m = this._runtime.GetCurrentLayout().GetEffectList()
      if ((k = m.GetEffectTypeByName(k))) (h = 1 === h), k.IsActive() !== h && (k.SetActive(h), m.UpdateActiveEffects(), this._runtime.UpdateRender())
    },
    SetLayoutEffectParam(h, k, m) {
      var r = this._runtime.GetCurrentLayout().GetEffectList()
      if ((h = r.GetEffectTypeByName(h))) {
        var w = h.GetIndex()
        r = r.GetEffectParametersForIndex(w)
        k = Math.floor(k)
        if (!(0 > k || k >= r.length)) {
          w = h.GetShaderProgram().GetParameterType(k)
          if ('color' === w) {
            g.setFromRgbValue(m)
            k = r[k]
            if (g.equalsIgnoringAlpha(k)) return
            k.copyRgb(g)
          } else {
            'percent' === w && (m /= 100)
            if (r[k] === m) return
            r[k] = m
          }
          h.IsActive() && this._runtime.UpdateRender()
        }
      }
    },
    SetLayoutVanishingPoint(h, k) {
      this._runtime.GetCurrentLayout().SetVanishingPointXY(h / 100, k / 100)
    },
    ScrollX(h) {
      this._runtime.GetCurrentLayout().SetScrollX(h)
    },
    ScrollY(h) {
      this._runtime.GetCurrentLayout().SetScrollY(h)
    },
    Scroll(h, k) {
      const m = this._runtime.GetCurrentLayout()
      m.SetScrollX(h)
      m.SetScrollY(k)
    },
    ScrollToObject(h) {
      if (h && (h = h.GetFirstPicked()) && (h = h.GetWorldInfo())) {
        var k = this._runtime.GetCurrentLayout()
        k.SetScrollX(h.GetX())
        k.SetScrollY(h.GetY())
      }
    },
    async LoadObjectTextures(h) {
      const k = this._runtime.GetMainRunningLayout()
      k && h && !this._runtime.IsLoading() && ((h = h.IsFamily() ? h.GetFamilyMembers() : [h]), await this._LoadTexturesForObjectClasses(k, h))
    },
    async LoadObjectTexturesByName(h) {
      await e.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(h))
    },
    UnloadObjectTextures(h) {
      const k = this._runtime.GetMainRunningLayout()
      k && h && ((h = h.IsFamily() ? h.GetFamilyMembers() : [h]), this._UnloadTexturesForObjectClasses(k, h))
    },
    UnloadObjectTexturesByName(h) {
      e.Plugins.System.Acts.UnloadObjectTexturesByName.call(this, this._runtime.GetObjectClassByName(h))
    },
    UnloadUnusedTextures() {
      const h = this._runtime.GetMainRunningLayout()
      if (h) {
        var k = h._GetTextureLoadedObjectTypes()
        this._UnloadTexturesForObjectClasses(h, k)
      }
    },
    async LoadLayoutTextures(h) {
      const k = this._runtime.GetMainRunningLayout()
      h && k && !this._runtime.IsLoading() && (await this._LoadTexturesForObjectClasses(k, h._GetInitialObjectClasses()))
    },
    async LoadLayoutTexturesByName(h) {
      const k = this._runtime.GetMainRunningLayout()
      ;(h = this._runtime.GetLayoutManager().GetLayoutByName(h)) && k && !this._runtime.IsLoading() && (await this._LoadTexturesForObjectClasses(k, h._GetInitialObjectClasses()))
    },
    SetFunctionReturnValue(h) {
      const k = this._eventStack.GetCurrentExpFuncStackFrame()
      if (k)
        switch (k.GetFunctionReturnType()) {
          case 1:
            'number' === typeof h && k.SetFunctionReturnValue(h)
            break
          case 2:
            'string' === typeof h && k.SetFunctionReturnValue(h)
            break
          case 3:
            k.SetFunctionReturnValue(h)
        }
    },
    MapFunction(h, k, m) {
      var r = this._GetFunctionMap(h.toLowerCase(), !0)
      const w = r.strMap,
        p = k.toLowerCase()
      w.has(p) && console.warn(`[Construct 3] Function map '${h}' string '${k}' already in map; overwriting entry`)
      if ((r = e.first(w.values()) || r.defaultFunc)) {
        r = 0 !== r.GetReturnType()
        const q = 0 !== m.GetReturnType()
        if (r !== q) {
          console.error(`[Construct 3] Function map '${h}' string '${k}' function return type not compatible with other functions in the map; entry ignored`)
          return
        }
      }
      w.set(p, m)
    },
    MapFunctionDefault(h, k) {
      const m = this._GetFunctionMap(h.toLowerCase(), !0)
      m.defaultFunc && console.warn(`[Construct 3] Function map '${h}' already has a default; overwriting entry`)
      var r = e.first(m.strMap.values()) || m.defaultFunc
      if (r) {
        r = 0 !== r.GetReturnType()
        const w = 0 !== k.GetReturnType()
        if (r !== w) {
          console.error(`[Construct 3] Function map '${h}' default: function return type not compatible with other functions in the map; entry ignored`)
          return
        }
      }
      m.defaultFunc = k
    },
    CallMappedFunction(h, k, m) {
      m = Math.floor(m)
      var r = this._GetFunctionMap(h.toLowerCase(), !1)
      if (r) {
        var w = r.strMap.get(k.toLowerCase())
        if (!w)
          if (r.defaultFunc) (w = r.defaultFunc), (m = 0)
          else {
            console.warn(`[Construct 3] Call mapped function: no function associated with map '${h}' string '${k}'; call ignored (consider setting a default)`)
            return
          }
        if (w.IsEnabled())
          if (0 !== w.GetReturnType()) console.warn(`[Construct 3] Call mapped function: map '${h}' string '${k}' has a return type so cannot be called`)
          else {
            h = this._runtime
            k = h.GetEventSheetManager()
            var p = k.GetCurrentEvent()
            r = p.GetSolModifiersIncludingParents()
            var q = 0 < r.length
            q && k.PushCleanSol(r)
            var t = []
            if ((p = k.FindFirstFunctionBlockParent(p))) {
              p = p.GetFunctionParameters()
              for (let x = m, v = p.length; x < v; ++x) t.push(p[x].GetValue())
            }
            m = w.GetFunctionParameters()
            for (let x = t.length, v = m.length; x < v; ++x) t.push(m[x].GetInitialValue())
            return h.IsDebugging() ? this._DebugDoCallMappedFunction(k, w, t, q, r) : this._DoCallMappedFunction(k, w, t, q, r)
          }
      } else console.warn(`[Construct 3] Call mapped function: map name '${h}' not found; call ignored`)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.System.Exps = {
    int: function (b) {
      'string' === typeof b && ((b = parseInt(b, 10)), isNaN(b) && (b = 0))
      return Math.floor(b)
    },
    float: function (b) {
      'string' === typeof b && ((b = parseFloat(b)), isNaN(b) && (b = 0))
      return b
    },
    str(b) {
      return b.toString()
    },
    len(b) {
      return 'string' === typeof b ? b.length : 0
    },
    random(b, a) {
      return 'undefined' === typeof a ? this._runtime.Random() * b : this._runtime.Random() * (a - b) + b
    },
    choose(...b) {
      const a = Math.floor(this._runtime.Random() * b.length)
      return b[a]
    },
    pi() {
      return Math.PI
    },
    infinity() {
      return Infinity
    },
    sqrt(b) {
      return Math.sqrt(b)
    },
    abs(b) {
      return Math.abs(b)
    },
    round(b) {
      return Math.round(b)
    },
    roundtodp(b, a) {
      a = Math.max(Math.floor(a), 0)
      a = Math.pow(10, a)
      return Math.round((b + Number.EPSILON) * a) / a
    },
    floor(b) {
      return Math.floor(b)
    },
    ceil(b) {
      return Math.ceil(b)
    },
    sign(b) {
      return Math.sign(b)
    },
    sin(b) {
      return Math.sin(e.toRadians(b))
    },
    cos(b) {
      return Math.cos(e.toRadians(b))
    },
    tan(b) {
      return Math.tan(e.toRadians(b))
    },
    asin(b) {
      return e.toDegrees(Math.asin(b))
    },
    acos(b) {
      return e.toDegrees(Math.acos(b))
    },
    atan(b) {
      return e.toDegrees(Math.atan(b))
    },
    exp(b) {
      return Math.exp(b)
    },
    ln(b) {
      return Math.log(b)
    },
    log10(b) {
      return Math.log(b) / Math.LN10
    },
    max(...b) {
      let a = b[0]
      'number' !== typeof a && (a = 0)
      for (let c = 1, d = b.length; c < d; ++c) {
        let f = b[c]
        'number' === typeof f && a < f && (a = f)
      }
      return a
    },
    min(...b) {
      let a = b[0]
      'number' !== typeof a && (a = 0)
      for (let c = 1, d = b.length; c < d; ++c) {
        let f = b[c]
        'number' === typeof f && a > f && (a = f)
      }
      return a
    },
    clamp(b, a, c) {
      return e.clamp(b, a, c)
    },
    distance(b, a, c, d) {
      return e.distanceTo(b, a, c, d)
    },
    angle(b, a, c, d) {
      return e.toDegrees(e.angleTo(b, a, c, d))
    },
    lerp(b, a, c) {
      return e.lerp(b, a, c)
    },
    unlerp(b, a, c) {
      return e.unlerp(b, a, c)
    },
    qarp(b, a, c, d) {
      return e.qarp(b, a, c, d)
    },
    cubic(b, a, c, d, f) {
      return e.cubic(b, a, c, d, f)
    },
    cosp(b, a, c) {
      return e.cosp(b, a, c)
    },
    anglediff(b, a) {
      return e.toDegrees(e.angleDiff(e.toRadians(b), e.toRadians(a)))
    },
    anglelerp(b, a, c) {
      return e.toDegrees(e.angleLerp(e.toRadians(b), e.toRadians(a), c))
    },
    anglerotate(b, a, c) {
      return e.toDegrees(e.angleRotate(e.toRadians(b), e.toRadians(a), e.toRadians(c)))
    },
    setbit(b, a, c) {
      a |= 0
      return ((b | 0) & ~(1 << a)) | ((0 !== c ? 1 : 0) << a)
    },
    togglebit(b, a) {
      return (b | 0) ^ (1 << (a | 0))
    },
    getbit(b, a) {
      return (b | 0) & (1 << (a | 0)) ? 1 : 0
    },
    newline() {
      return '\n'
    },
    uppercase(b) {
      return 'string' === typeof b ? b.toUpperCase() : ''
    },
    lowercase(b) {
      return 'string' === typeof b ? b.toLowerCase() : ''
    },
    left(b, a) {
      return 'string' === typeof b ? b.substr(0, a) : ''
    },
    mid(b, a, c) {
      return 'string' !== typeof b ? '' : 0 > c ? b.substr(a) : b.substr(a, c)
    },
    right(b, a) {
      return 'string' === typeof b ? b.substr(b.length - a) : ''
    },
    trim(b) {
      return 'string' === typeof b ? b.trim() : ''
    },
    tokenat(b, a, c) {
      if ('string' !== typeof b || 'string' !== typeof c) return ''
      b = b.split(c)
      a = Math.floor(a)
      return 0 > a || a >= b.length ? '' : b[a]
    },
    tokencount(b, a) {
      return 'string' === typeof b && 'string' === typeof a && b.length ? b.split(a).length : 0
    },
    find(b, a) {
      return 'string' === typeof b && 'string' === typeof a ? b.search(new RegExp(e.EscapeRegex(a), 'i')) : -1
    },
    findcase(b, a) {
      return 'string' === typeof b && 'string' === typeof a ? b.search(new RegExp(e.EscapeRegex(a), '')) : -1
    },
    replace(b, a, c) {
      return 'string' === typeof b && 'string' === typeof a && 'string' === typeof c ? b.replace(new RegExp(e.EscapeRegex(a), 'gi'), c) : 'string' === typeof b ? b : ''
    },
    regexsearch(b, a, c) {
      a = this.GetRegex(a, c)
      return b ? b.search(a) : -1
    },
    regexreplace(b, a, c, d) {
      a = this.GetRegex(a, c)
      return b ? b.replace(a, d) : ''
    },
    regexmatchcount(b, a, c) {
      return (b = this.GetRegexMatches(b.toString(), a, c)) ? b.length : 0
    },
    regexmatchat(b, a, c, d) {
      d = Math.floor(d)
      b = this.GetRegexMatches(b.toString(), a, c)
      return !b || 0 > d || d >= b.length ? '' : b[d]
    },
    zeropad(b, a) {
      let c = 0 > b ? '-' : ''
      0 > b && (b = -b)
      c += '0'.repeat(Math.max(a - b.toString().length, 0))
      return c + b.toString()
    },
    urlencode(b) {
      return encodeURIComponent(b)
    },
    urldecode(b) {
      return decodeURIComponent(b)
    },
    dt() {
      return this._runtime._GetDtFast()
    },
    timescale() {
      return this._runtime.GetTimeScale()
    },
    wallclocktime() {
      return (Date.now() - this._runtime.GetStartTime()) / 1e3
    },
    unixtime() {
      return Date.now()
    },
    time() {
      return this._runtime.GetGameTime()
    },
    tickcount() {
      return this._runtime.GetTickCount()
    },
    objectcount() {
      return this._runtime.GetObjectCount()
    },
    fps() {
      return this._runtime.GetFPS()
    },
    cpuutilisation() {
      return this._runtime.GetMainThreadTime()
    },
    gpuutilisation() {
      return this._runtime.GetGPUUtilisation()
    },
    windowwidth() {
      return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    windowheight() {
      return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    originalwindowwidth() {
      return this._runtime.GetOriginalViewportWidth()
    },
    originalwindowheight() {
      return this._runtime.GetOriginalViewportHeight()
    },
    originalviewportwidth() {
      return this._runtime.GetOriginalViewportWidth()
    },
    originalviewportheight() {
      return this._runtime.GetOriginalViewportHeight()
    },
    scrollx() {
      return this._runtime.GetCurrentLayout().GetScrollX()
    },
    scrolly() {
      return this._runtime.GetCurrentLayout().GetScrollY()
    },
    layoutname() {
      return this._runtime.GetCurrentLayout().GetName()
    },
    layoutscale() {
      return this._runtime.GetCurrentLayout().GetScale()
    },
    layoutangle() {
      return e.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
    },
    layoutwidth() {
      return this._runtime.GetCurrentLayout().GetWidth()
    },
    layoutheight() {
      return this._runtime.GetCurrentLayout().GetHeight()
    },
    viewportleft(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getLeft() : 0
    },
    viewporttop(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getTop() : 0
    },
    viewportright(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getRight() : 0
    },
    viewportbottom(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().getBottom() : 0
    },
    viewportwidth(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().width() : 0
    },
    viewportheight(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetViewport().height() : 0
    },
    canvastolayerx(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.CanvasCssToLayer(a, c)[0] : 0
    },
    canvastolayery(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.CanvasCssToLayer(a, c)[1] : 0
    },
    layertocanvasx(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.LayerToCanvasCss(a, c)[0] : 0
    },
    layertocanvasy(b, a, c) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.LayerToCanvasCss(a, c)[1] : 0
    },
    layerscale(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetOwnScale() : 0
    },
    layerangle(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? e.toDegrees(b.GetOwnAngle()) : 0
    },
    layeropacity(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetOpacity() : 0
    },
    layerscalerate(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetScaleRate() : 0
    },
    layerscrollx(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetScrollX() : 0
    },
    layerscrolly(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetScrollY() : 0
    },
    layerparallaxx(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetParallaxX() : 0
    },
    layerparallaxy(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? 100 * b.GetParallaxY() : 0
    },
    layerzelevation(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetZElevation() : 0
    },
    layerindex(b) {
      return (b = this._runtime.GetCurrentLayout().GetLayer(b)) ? b.GetIndex() : -1
    },
    canvassnapshot() {
      const b = this._runtime.GetCanvasManager()
      return b ? b.GetCanvasSnapshotUrl() : ''
    },
    loopindex(b) {
      const a = this._loopStack
      return a.IsInLoop() ? (b ? ((b = a.FindByName(b)) ? b.GetIndex() : 0) : a.GetCurrent().GetIndex()) : 0
    },
    savestatejson() {
      return this._runtime.GetLastSaveJsonString()
    },
    callmapped(b, a, ...c) {
      var d = this._GetFunctionMap(b.toLowerCase(), !1)
      if (!d) return console.warn(`[Construct 3] Call mapped function: map name '${b}' not found; returning 0`), 0
      var f = d.strMap.get(a.toLowerCase())
      if (!f)
        if (d.defaultFunc) f = d.defaultFunc
        else return console.warn(`[Construct 3] Call mapped function: no function associated with map '${b}' string '${a}'; returning 0 (consider setting a default)`), 0
      d = f.GetReturnType()
      const g = f.GetDefaultReturnValue()
      if (0 === d) return console.warn(`[Construct 3] Call mapped function: map '${b}' string '${a}' has no return type so cannot be called from an expression; returning 0`), 0
      if (!f.IsEnabled()) return g
      b = this._runtime.GetEventSheetManager()
      a = b.GetCurrentEvent().GetSolModifiersIncludingParents()
      const h = 0 < a.length
      h && b.PushCleanSol(a)
      const k = f.GetFunctionParameters()
      for (let m = c.length, r = k.length; m < r; ++m) c.push(k[m].GetInitialValue())
      f = f.GetEventBlock()
      c = f.RunAsExpressionFunctionCall(f.GetSolModifiersIncludingParents(), d, g, ...c)
      h && b.PopSol(a)
      return c
    },
    loadingprogress() {
      return this._runtime.GetAssetManager().GetLoadProgress()
    },
    imageloadingprogress() {
      return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
    },
    renderer() {
      return this._runtime.GetWebGPURenderer() ? 'webgpu' : 'webgl'
    },
    rendererdetail() {
      return this._runtime.GetWebGPURenderer() ? '<unavailable>' : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    imagememoryusage() {
      let b = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage()
      return Math.round((100 * b) / 1048576) / 100
    },
    rgb(b, a, c) {
      return e.PackRGB(b, a, c)
    },
    rgbex(b, a, c) {
      return e.PackRGBEx(b / 100, a / 100, c / 100)
    },
    rgba(b, a, c, d) {
      return e.PackRGBAEx(b / 100, a / 100, c / 100, d / 100)
    },
    rgbex255(b, a, c) {
      return e.PackRGBEx(b / 255, a / 255, c / 255)
    },
    rgba255(b, a, c, d) {
      return e.PackRGBAEx(b / 255, a / 255, c / 255, d / 255)
    },
    projectname() {
      return this._runtime.GetProjectName()
    },
    projectversion() {
      return this._runtime.GetProjectVersion()
    },
    currenteventsheetname() {
      return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
    },
    currenteventnumber() {
      return this._runtime.GetCurrentEvent().GetDisplayNumber()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Text = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Text.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
    LoadTextures(b) {}
    ReleaseTextures() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = [0, 0, 0],
    c = ['left', 'center', 'right'],
    d = ['top', 'center', 'bottom'],
    f = new e.Rect(),
    g = new e.Quad(),
    h = new e.Color()
  e.Plugins.Text.Instance = class extends e.SDKWorldInstanceBase {
    constructor(p, q) {
      super(p)
      this._text = ''
      this._enableBBcode = !0
      this._faceName = 'Arial'
      this._ptSize = 12
      this._lineHeightOffset = 0
      this._isItalic = this._isBold = !1
      this._color = e.New(e.Color)
      this._verticalAlign = this._horizontalAlign = 0
      this._wrapByWord = !0
      this._typewriterEndTime = this._typewriterStartTime = -1
      this._typewriterLength = 0
      this._rendererText = e.New(e.Gfx.RendererText, this._runtime.GetRenderer(), {
        timeout: 5
      })
      this._rendererText.ontextureupdate = () => this._runtime.UpdateRender()
      this._rendererText.SetIsAsync(!1)
      q &&
        ((this._text = q[0]),
        (this._enableBBcode = !!q[1]),
        (this._faceName = q[2]),
        (this._ptSize = q[3]),
        (this._lineHeightOffset = q[4]),
        (this._isBold = !!q[5]),
        (this._isItalic = !!q[6]),
        (this._horizontalAlign = q[8]),
        (this._verticalAlign = q[9]),
        (this._wrapByWord = 0 === q[10]),
        (p = q[7]),
        this._color.setRgb(p[0], p[1], p[2]),
        this.GetWorldInfo().SetVisible(q[11]))
      this._UpdateTextSettings()
    }
    Release() {
      this._CancelTypewriter()
      this._rendererText.Release()
      this._rendererText = null
      super.Release()
    }
    _UpdateTextSettings() {
      const p = this._rendererText
      p.SetText(this._text)
      p.SetBBCodeEnabled(this._enableBBcode)
      p.SetFontName(this._faceName)
      p.SetLineHeight(this._lineHeightOffset)
      p.SetBold(this._isBold)
      p.SetItalic(this._isItalic)
      p.SetColor(this._color)
      p.SetHorizontalAlignment(c[this._horizontalAlign])
      p.SetVerticalAlignment(d[this._verticalAlign])
      p.SetWordWrapMode(this._wrapByWord ? 'word' : 'character')
    }
    _UpdateTextSize() {
      const p = this.GetWorldInfo()
      this._rendererText.SetFontSize(this._ptSize)
      this._rendererText.SetFontSizeScale(p.GetSceneGraphScale())
      var q = p.GetLayer()
      q = q.GetRenderScale() * q.Get2DScaleFactorToZ(p.GetTotalZElevation())
      this._rendererText.SetSize(p.GetWidth(), p.GetHeight(), q)
    }
    Draw(p) {
      var q = this.GetWorldInfo()
      this._UpdateTextSize()
      const t = this._rendererText.GetTexture()
      if (t) {
        var x = q.GetLayer()
        if (0 === q.GetAngle() && 0 === x.GetAngle() && 0 === q.GetTotalZElevation() && !q.HasMesh() && x.RendersIn2DMode()) {
          q = q.GetBoundingQuad()
          const [v, u] = x.LayerToDrawSurface(q.getTlx(), q.getTly()),
            [A, z] = x.LayerToDrawSurface(q.getBrx(), q.getBry())
          q = v - Math.round(v)
          const C = u - Math.round(u)
          f.set(v, u, A, z)
          f.offset(-q, -C)
          g.setFromRect(f)
          const [E, J] = p.GetRenderTargetSize(p.GetRenderTarget())
          this._runtime.GetCanvasManager().SetDeviceTransform(p, E, J)
          p.SetTexture(t)
          p.Quad3(g, this._rendererText.GetTexRect())
          x._SetTransform(p)
        } else p.SetTexture(t), q.HasMesh() ? this._DrawMesh(q, p) : this._DrawStandard(q, p)
      }
    }
    _DrawStandard(p, q) {
      p = p.GetBoundingQuad()
      this._runtime.IsPixelRoundingEnabled() && (p = this._PixelRoundQuad(p))
      q.Quad3(p, this._rendererText.GetTexRect())
    }
    _DrawMesh(p, q) {
      const t = p.GetTransformedMesh()
      if (p.IsMeshChanged()) {
        p.CalculateBbox(f, g, !1)
        let x = g
        this._runtime.IsPixelRoundingEnabled() && (x = this._PixelRoundQuad(x))
        t.CalculateTransformedMesh(p.GetSourceMesh(), x, this._rendererText.GetTexRect())
        p.SetMeshChanged(!1)
      }
      t.Draw(q)
    }
    _PixelRoundQuad(p) {
      const q = p.getTlx() - Math.round(p.getTlx()),
        t = p.getTly() - Math.round(p.getTly())
      if (0 === q && 0 === t) return p
      g.copy(p)
      g.offset(-q, -t)
      return g
    }
    SaveToJson() {
      const p = {
        t: this._text,
        c: this._color.toJSON(),
        fn: this._faceName,
        ps: this._ptSize
      }
      this._enableBBcode && (p.bbc = this._enableBBcode)
      0 !== this._horizontalAlign && (p.ha = this._horizontalAlign)
      0 !== this._verticalAlign && (p.va = this._verticalAlign)
      this._wrapByWord || (p.wr = this._wrapByWord)
      0 !== this._lineHeightOffset && (p.lho = this._lineHeightOffset)
      this._isBold && (p.b = this._isBold)
      this._isItalic && (p.i = this._isItalic)
      ;-1 !== this._typewriterEndTime &&
        (p.tw = {
          st: this._typewriterStartTime,
          en: this._typewriterEndTime,
          l: this._typewriterLength
        })
      return p
    }
    LoadFromJson(p) {
      this._CancelTypewriter()
      this._text = p.t
      this._color.setFromJSON(p.c)
      this._faceName = p.fn
      this._ptSize = p.ps
      this._enableBBcode = p.hasOwnProperty('bbc') ? p.bbc : !1
      this._horizontalAlign = p.hasOwnProperty('ha') ? p.ha : 0
      this._verticalAlign = p.hasOwnProperty('va') ? p.va : 0
      this._wrapByWord = p.hasOwnProperty('wr') ? p.wr : !0
      this._lineHeightOffset = p.hasOwnProperty('lho') ? p.lho : 0
      this._isBold = p.hasOwnProperty('b') ? p.b : !1
      this._isItalic = p.hasOwnProperty('i') ? p.i : !1
      p.hasOwnProperty('tw') && ((p = p.tw), (this._typewriterStartTime = p.st), (this._typewriterEndTime = p.en), (this._typewriterLength = p.l))
      this._UpdateTextSettings()
      ;-1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(p) {
      switch (p) {
        case 0:
          return this._text
        case 1:
          return this._enableBBcode
        case 2:
          return this._faceName
        case 3:
          return this._ptSize
        case 4:
          return this._lineHeightOffset
        case 5:
          return this._isBold
        case 6:
          return this._isItalic
        case 7:
          return (a[0] = this._color.getR()), (a[1] = this._color.getG()), (a[2] = this._color.getB()), a
        case 8:
          return this._horizontalAlign
        case 9:
          return this._verticalAlign
        case 10:
          return this._wrapByWord ? 1 : 0
      }
    }
    SetPropertyValueByIndex(p, q) {
      switch (p) {
        case 0:
          if (this._text === q) break
          this._text = q
          this._UpdateTextSettings()
          break
        case 1:
          if (this._enableBBcode === !!q) break
          this._enableBBcode = !!q
          this._UpdateTextSettings()
          break
        case 2:
          if (this._faceName === q) break
          this._faceName = q
          this._UpdateTextSettings()
          break
        case 3:
          if (this._ptSize === q) break
          this._ptSize = q
          this._UpdateTextSettings()
          break
        case 4:
          if (this._lineHeightOffset === q) break
          this._lineHeightOffset = q
          this._UpdateTextSettings()
          break
        case 5:
          if (this._isBold === !!q) break
          this._isBold = !!q
          this._UpdateTextSettings()
          break
        case 6:
          if (this._isItalic === !!q) break
          this._isItalic = !!q
          this._UpdateTextSettings()
          break
        case 7:
          p = this._color
          if (p.getR() === q[0] && p.getG() === q[1] && p.getB() === q[2]) break
          this._color.setRgb(q[0], q[1], q[2])
          this._UpdateTextSettings()
          break
        case 8:
          if (this._horizontalAlign === q) break
          this._horizontalAlign = q
          this._UpdateTextSettings()
          break
        case 9:
          if (this._verticalAlign === q) break
          this._verticalAlign = q
          this._UpdateTextSettings()
          break
        case 10:
          this._wrapByWord !== (0 === q) && ((this._wrapByWord = 0 === q), this._UpdateTextSettings())
      }
    }
    SetPropertyColorOffsetValueByIndex(p, q, t, x) {
      if (0 !== q || 0 !== t || 0 !== x)
        switch (p) {
          case 7:
            this._color.addRgb(q, t, x), this._UpdateTextSettings()
        }
    }
    _SetText(p) {
      this._text !== p && ((this._text = p), this._rendererText.SetText(p), this._runtime.UpdateRender())
    }
    GetText() {
      return this._text
    }
    _StartTypewriter(p, q) {
      this._SetText(p)
      this._typewriterStartTime = this._runtime.GetWallTime()
      this._typewriterEndTime = this._typewriterStartTime + q / this.GetInstance().GetActiveTimeScale()
      this._typewriterLength = e.BBString.StripAnyTags(p).length
      this._rendererText.SetDrawMaxCharacterCount(0)
      this._StartTicking()
    }
    _CancelTypewriter() {
      this._typewriterEndTime = this._typewriterStartTime = -1
      this._typewriterLength = 0
      this._rendererText.SetDrawMaxCharacterCount(-1)
      this._StopTicking()
    }
    _FinishTypewriter() {
      ;-1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
    }
    _SetFontFace(p) {
      this._faceName !== p && ((this._faceName = p), this._rendererText.SetFontName(p), this._runtime.UpdateRender())
    }
    _GetFontFace() {
      return this._faceName
    }
    _SetBold(p) {
      p = !!p
      this._isBold !== p && ((this._isBold = p), this._rendererText.SetBold(p), this._runtime.UpdateRender())
    }
    _IsBold() {
      return this._isBold
    }
    _SetItalic(p) {
      p = !!p
      this._isItalic !== p && ((this._isItalic = p), this._rendererText.SetItalic(p), this._runtime.UpdateRender())
    }
    _IsItalic() {
      return this._isItalic
    }
    _SetFontSize(p) {
      this._ptSize !== p && ((this._ptSize = p), this._runtime.UpdateRender())
    }
    _GetFontSize() {
      return this._ptSize
    }
    _SetFontColor(p) {
      this._color.equalsIgnoringAlpha(p) || (this._color.copyRgb(p), this._rendererText.SetColor(this._color), this._runtime.UpdateRender())
    }
    _GetFontColor() {
      return this._color
    }
    _SetLineHeight(p) {
      this._lineHeightOffset !== p && ((this._lineHeightOffset = p), this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetLineHeight() {
      return this._lineHeightOffset
    }
    _SetHAlign(p) {
      this._horizontalAlign !== p && ((this._horizontalAlign = p), this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetHAlign() {
      return this._horizontalAlign
    }
    _SetVAlign(p) {
      this._verticalAlign !== p && ((this._verticalAlign = p), this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetVAlign() {
      return this._verticalAlign
    }
    _SetWrapByWord(p) {
      p = !!p
      this._wrapByWord !== p && ((this._wrapByWord = p), this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _IsWrapByWord() {
      return this._wrapByWord
    }
    Tick() {
      var p = this._runtime.GetWallTime()
      p >= this._typewriterEndTime
        ? (this._CancelTypewriter(), this.Trigger(e.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        : ((p = e.relerp(this._typewriterStartTime, this._typewriterEndTime, p, 0, this._typewriterLength)), (p = Math.floor(p)), p !== this._rendererText.GetDrawMaxCharacterCount() && (this._rendererText.SetDrawMaxCharacterCount(p), this._runtime.UpdateRender()))
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.text.name',
          properties: [
            {
              name: 'plugins.text.properties.text.name',
              value: this._text,
              onedit: p => this._SetText(p)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.ITextInstance
    }
  }
  const k = new WeakMap(),
    m = new Map([
      ['left', 0],
      ['center', 1],
      ['right', 2]
    ]),
    r = new Map([
      ['top', 0],
      ['center', 1],
      ['bottom', 2]
    ]),
    w = new Map([
      ['word', !0],
      ['character', !1]
    ])
  self.ITextInstance = class extends self.IWorldInstance {
    constructor() {
      super()
      k.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text() {
      return k.get(this).GetText()
    }
    set text(p) {
      b.RequireString(p)
      const q = k.get(this)
      q._CancelTypewriter()
      q._SetText(p)
    }
    typewriterText(p, q) {
      b.RequireString(p)
      b.RequireFiniteNumber(q)
      const t = k.get(this)
      t._CancelTypewriter()
      t._StartTypewriter(p, q)
    }
    typewriterFinish() {
      k.get(this)._FinishTypewriter()
    }
    set fontFace(p) {
      b.RequireString(p)
      k.get(this)._SetFontFace(p)
    }
    get fontFace() {
      return k.get(this)._GetFontFace()
    }
    set isBold(p) {
      k.get(this)._SetBold(p)
    }
    get isBold() {
      return k.get(this)._IsBold()
    }
    set isItalic(p) {
      k.get(this)._SetItalic(p)
    }
    get isItalic() {
      return k.get(this)._IsItalic()
    }
    set sizePt(p) {
      b.RequireFiniteNumber(p)
      k.get(this)._SetFontSize(p)
    }
    get sizePt() {
      return k.get(this)._GetFontSize()
    }
    set fontColor(p) {
      b.RequireArray(p)
      if (3 > p.length) throw Error('expected 3 elements')
      h.setRgb(p[0], p[1], p[2])
      k.get(this)._SetFontColor(h)
    }
    get fontColor() {
      const p = k.get(this)._GetFontColor()
      return [p.getR(), p.getG(), p.getB()]
    }
    set lineHeight(p) {
      b.RequireFiniteNumber(p)
      k.get(this)._SetLineHeight(p)
    }
    get lineHeight() {
      return k.get(this)._GetLineHeight()
    }
    set horizontalAlign(p) {
      b.RequireString(p)
      p = m.get(p)
      if ('undefined' === typeof p) throw Error('invalid mode')
      k.get(this)._SetHAlign(p)
    }
    get horizontalAlign() {
      return c[k.get(this)._GetHAlign()]
    }
    set verticalAlign(p) {
      b.RequireString(p)
      p = r.get(p)
      if ('undefined' === typeof p) throw Error('invalid mode')
      k.get(this)._SetVAlign(p)
    }
    get verticalAlign() {
      return d[k.get(this)._GetVAlign()]
    }
    set wordWrapMode(p) {
      b.RequireString(p)
      p = w.get(p)
      if ('undefined' === typeof p) throw Error('invalid mode')
      k.get(this)._SetWrapByWord(p)
    }
    get wordWrapMode() {
      return k.get(this)._IsWrapByWord() ? 'word' : 'character'
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Text.Cnds = {
    CompareText(b, a) {
      return a ? this._text === b : e.equalsNoCase(this._text, b)
    },
    IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
      return !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Color)
  e.Plugins.Text.Acts = {
    SetText(a) {
      this._CancelTypewriter()
      'number' === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10)
      this._SetText(a.toString())
    },
    AppendText(a) {
      this._CancelTypewriter()
      'number' === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10)
      ;(a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, c) {
      this._CancelTypewriter()
      'number' === typeof a && 1e9 > a && (a = Math.round(1e10 * a) / 1e10)
      this._StartTypewriter(a.toString(), c)
    },
    SetFontFace(a, c) {
      let d = !1,
        f = !1
      switch (c) {
        case 1:
          d = !0
          break
        case 2:
          f = !0
          break
        case 3:
          f = d = !0
      }
      if (a !== this._faceName || d !== this._isBold || f !== this._isItalic) this._SetFontFace(a), this._SetBold(d), this._SetItalic(f)
    },
    SetFontSize(a) {
      this._SetFontSize(a)
    },
    SetFontColor(a) {
      b.setFromRgbValue(a)
      b.clamp()
      this._SetFontColor(b)
    },
    SetWebFont(a, c) {
      console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
    },
    SetEffect(a) {
      this.GetWorldInfo().SetBlendMode(a)
      this._runtime.UpdateRender()
    },
    TypewriterFinish() {
      this._FinishTypewriter()
    },
    SetLineHeight(a) {
      this._SetLineHeight(a)
    },
    SetHAlign(a) {
      this._SetHAlign(a)
    },
    SetVAlign(a) {
      this._SetVAlign(a)
    },
    SetWrapping(a) {
      this._SetWrapByWord(0 === a)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Text.Exps = {
    Text() {
      return this._text
    },
    PlainText() {
      return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
    },
    FaceName() {
      return this._faceName
    },
    FaceSize() {
      return this._ptSize
    },
    TextWidth() {
      this._UpdateTextSize()
      return this._rendererText.GetTextWidth()
    },
    TextHeight() {
      this._UpdateTextSize()
      return this._rendererText.GetTextHeight()
    },
    LineHeight() {
      return this._lineHeightOffset
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Sprite = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Sprite.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
      this._animations = b.GetAnimations()
    }
    Release() {
      e.clearArray(this._animations)
      super.Release()
    }
    OnCreate() {
      for (const b of this._animations) b.LoadAllAssets(this._runtime)
    }
    LoadTextures(b) {
      const a = {
        sampling: this._runtime.GetSampling()
      }
      return Promise.all(this._animations.map(c => c.LoadAllTextures(b, a)))
    }
    ReleaseTextures() {
      for (const b of this._animations) b.ReleaseAllTextures()
    }
    OnDynamicTextureLoadComplete() {
      this._UpdateAllCurrentTexture()
    }
    _UpdateAllCurrentTexture() {
      for (const b of this._objectClass.instancesIncludingPendingCreate()) b.GetSdkInstance()._UpdateCurrentTexture()
    }
    FinishCondition(b) {
      e.Plugins.Sprite._FinishCondition(this, b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = e.New(e.Rect),
    c = e.New(e.Quad),
    d = e.New(e.Vector2)
  e.Plugins.Sprite.Instance = class extends e.SDKWorldInstanceBase {
    constructor(h, k) {
      super(h)
      let m = !0,
        r = '',
        w = 0,
        p = !0
      k && ((m = !!k[0]), (r = k[1]), (w = k[2]), (p = k[3]))
      this._currentAnimation = this._objectClass.GetAnimationByName(r) || this._objectClass.GetAnimations()[0]
      this._currentFrameIndex = e.clamp(w, 0, this._currentAnimation.GetFrameCount() - 1)
      this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex)
      k = this._currentAnimationFrame.GetImageInfo()
      this._currentTexture = k.GetTexture()
      this._currentRcTex = k.GetTexRect()
      this.HandleWebGLContextLoss()
      h.SetFlag(2, !0)
      h.SetFlag(1, 0 <= this._currentAnimation.GetSpeed())
      this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed())
      this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo()
      this._animationTimer = e.New(e.KahanSum)
      this._animationRepeats = this._frameStartTime = 0
      this._animTriggerName = ''
      this._changeAnimFrameIndex = -1
      this._changeAnimationName = ''
      this._changeAnimationFrom = 0
      h = this.GetWorldInfo()
      this._bquadRef = h.GetBoundingQuad()
      h.SetVisible(m)
      h.SetCollisionEnabled(p)
      h.SetOriginX(this._currentAnimationFrame.GetOriginX())
      h.SetOriginY(this._currentAnimationFrame.GetOriginY())
      h.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly())
      h.SetBboxChanged()
      ;(1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount()) || 0 === this._currentAnimationSpeed || this._StartTicking()
    }
    Release() {
      this._animationTimer = this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null
      super.Release()
    }
    GetCurrentImageInfo() {
      return this._currentAnimationFrame.GetImageInfo()
    }
    IsOriginalSizeKnown() {
      return !0
    }
    OnWebGLContextLost() {
      this._currentTexture = null
    }
    OnWebGLContextRestored() {
      this._UpdateCurrentTexture()
    }
    Draw(h) {
      var k = this._currentTexture
      null !== k && (h.SetTexture(k), (k = this.GetWorldInfo()), k.HasMesh() ? this._DrawMesh(k, h) : this._DrawStandard(k, h))
    }
    _DrawStandard(h, k) {
      let m = this._bquadRef
      this._runtime.IsPixelRoundingEnabled() && (m = h.PixelRoundQuad(m))
      k.Quad3(m, this._currentRcTex)
    }
    _DrawMesh(h, k) {
      const m = h.GetTransformedMesh()
      if (h.IsMeshChanged()) {
        h.CalculateBbox(a, c, !1)
        let r = c
        this._runtime.IsPixelRoundingEnabled() && (r = h.PixelRoundQuad(r))
        m.CalculateTransformedMesh(h.GetSourceMesh(), r, this._currentRcTex)
        h.SetMeshChanged(!1)
      }
      m.Draw(k)
    }
    GetAnimationTime() {
      return this._animationTimer.Get()
    }
    IsAnimationPlaying() {
      return this._inst.GetFlag(2)
    }
    SetAnimationPlaying(h) {
      this._inst.SetFlag(2, h)
    }
    IsPlayingForwards() {
      return this._inst.GetFlag(1)
    }
    SetPlayingForwards(h) {
      this._inst.SetFlag(1, h)
    }
    IsInAnimationTrigger() {
      return this._inst.GetFlag(4)
    }
    SetInAnimationTrigger(h) {
      this._inst.SetFlag(4, h)
    }
    Tick() {
      this._changeAnimationName && this._DoChangeAnimation()
      0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame()
      const h = this._currentAnimationSpeed
      if (this.IsAnimationPlaying() && 0 !== h) {
        var k = this._runtime.GetDt(this._inst)
        this._animationTimer.Add(k)
        k = this.GetAnimationTime()
        var m = this._currentAnimationFrame,
          r = m.GetDuration() / h
        if (!(k < this._frameStartTime + r)) {
          var w = this._currentAnimation,
            p = this._currentAnimationRepeatTo,
            q = w.GetFrameCount(),
            t = w.GetRepeatCount(),
            x = w.IsLooping(),
            v = w.IsPingPong()
          this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--
          this._frameStartTime += r
          this._currentFrameIndex >= q && (v ? (this.SetPlayingForwards(!1), (this._currentFrameIndex = q - 2)) : x ? (this._currentFrameIndex = p) : (this._animationRepeats++, this._animationRepeats >= t ? this._FinishAnimation(!1) : (this._currentFrameIndex = p)))
          0 > this._currentFrameIndex &&
            (v
              ? ((this._currentFrameIndex = 1), this.SetPlayingForwards(!0), x || (this._animationRepeats++, this._animationRepeats >= t && this._FinishAnimation(!0)))
              : x
              ? (this._currentFrameIndex = p)
              : (this._animationRepeats++, this._animationRepeats >= t ? this._FinishAnimation(!0) : (this._currentFrameIndex = p)))
          this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, q - 1)
          r = w.GetFrameAt(this._currentFrameIndex)
          k > this._frameStartTime + r.GetDuration() / h && (this._frameStartTime = k)
          this._OnFrameChanged(m, r)
        }
      } else this._StopTicking()
    }
    _FinishAnimation(h) {
      this._currentFrameIndex = h ? 0 : this._currentAnimation.GetFrameCount() - 1
      this.SetAnimationPlaying(!1)
      this._animTriggerName = this._currentAnimation.GetName()
      this.SetInAnimationTrigger(!0)
      this.Trigger(e.Plugins.Sprite.Cnds.OnAnyAnimFinished)
      this.Trigger(e.Plugins.Sprite.Cnds.OnAnimFinished)
      this.SetInAnimationTrigger(!1)
      this._animationRepeats = 0
    }
    _OnFrameChanged(h, k) {
      if (h !== k) {
        var m = this.GetWorldInfo(),
          r = h.GetImageInfo(),
          w = k.GetImageInfo(),
          p = r.GetWidth()
        r = r.GetHeight()
        var q = w.GetWidth(),
          t = w.GetHeight()
        p !== q && m.SetWidth(m.GetWidth() * (q / p))
        r !== t && m.SetHeight(m.GetHeight() * (t / r))
        m.SetOriginX(k.GetOriginX())
        m.SetOriginY(k.GetOriginY())
        m.SetSourceCollisionPoly(k.GetCollisionPoly())
        m.SetBboxChanged()
        this._currentAnimationFrame = k
        this._currentTexture = w.GetTexture()
        this._currentRcTex = w.GetTexRect()
        m = this.GetInstance().GetBehaviorInstances()
        for (let x = 0, v = m.length; x < v; ++x) m[x].OnSpriteFrameChanged(h, k)
        this.Trigger(e.Plugins.Sprite.Cnds.OnFrameChanged)
        this._runtime.UpdateRender()
      }
    }
    _StartAnim(h) {
      this.SetAnimationPlaying(!0)
      this._frameStartTime = this.GetAnimationTime()
      1 === h && 0 !== this._currentFrameIndex && ((this._changeAnimFrameIndex = 0), this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
      this._StartTicking()
    }
    _SetAnim(h, k) {
      this._changeAnimationName = h
      this._changeAnimationFrom = k
      this._StartTicking()
      this.IsInAnimationTrigger() || this._DoChangeAnimation()
    }
    _GetCurrentAnimationName() {
      return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
    }
    _SetAnimFrame(h) {
      isFinite(h) && ((this._changeAnimFrameIndex = h), this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
    }
    _GetAnimFrame() {
      return this._currentFrameIndex
    }
    _SetAnimSpeed(h) {
      this._currentAnimationSpeed = Math.abs(h)
      this.SetPlayingForwards(0 <= h)
      0 < this._currentAnimationSpeed && this._StartTicking()
    }
    _GetAnimSpeed() {
      return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
    }
    _SetAnimRepeatToFrame(h) {
      this._currentAnimationRepeatTo = h = e.clamp(Math.floor(h), 0, this._currentAnimation.GetFrameCount() - 1)
    }
    _GetAnimRepeatToFrame() {
      return this._currentAnimationRepeatTo
    }
    _DoChangeAnimation() {
      const h = this._currentAnimationFrame
      var k = this._objectClass.GetAnimationByName(this._changeAnimationName)
      this._changeAnimationName = ''
      !k ||
        (k === this._currentAnimation && this.IsAnimationPlaying()) ||
        ((this._currentAnimation = k),
        this.SetPlayingForwards(0 <= k.GetSpeed()),
        (this._currentAnimationSpeed = Math.abs(k.GetSpeed())),
        (this._currentAnimationRepeatTo = k.GetRepeatTo()),
        (this._currentFrameIndex = e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)),
        1 === this._changeAnimationFrom && (this._currentFrameIndex = 0),
        this.SetAnimationPlaying(!0),
        (this._frameStartTime = this.GetAnimationTime()),
        (k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)),
        this._OnFrameChanged(h, k))
    }
    _DoChangeAnimFrame() {
      const h = this._currentAnimationFrame
      var k = this._currentFrameIndex
      this._currentFrameIndex = e.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1)
      this._changeAnimFrameIndex = -1
      k !== this._currentFrameIndex && ((k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)), this._OnFrameChanged(h, k), (this._frameStartTime = this.GetAnimationTime()))
    }
    _UpdateCurrentTexture() {
      const h = this._currentAnimationFrame.GetImageInfo()
      this._currentTexture = h.GetTexture()
      this._currentRcTex = h.GetTexRect()
      this.GetWorldInfo().SetMeshChanged(!0)
    }
    GetTexture() {
      return this._currentTexture
    }
    GetTexRect() {
      return this._currentRcTex
    }
    GetImagePointCount() {
      return this._currentAnimationFrame.GetImagePointCount()
    }
    GetImagePoint(h) {
      const k = this._currentAnimationFrame,
        m = this.GetWorldInfo()
      if ('string' === typeof h) h = k.GetImagePointByName(h)
      else if ('number' === typeof h) h = k.GetImagePointByIndex(h - 1)
      else throw new TypeError('expected string or number')
      if (!h) return [m.GetX(), m.GetY()]
      d.copy(h.GetVec2())
      if (m.HasMesh()) {
        const [r, w] = m.GetSourceMesh().TransformPoint(d.getX(), d.getY())
        d.set(r, w)
      }
      d.offset(-k.GetOriginX(), -k.GetOriginY())
      d.scale(m.GetWidth(), m.GetHeight())
      d.rotate(m.GetAngle())
      d.offset(m.GetX(), m.GetY())
      return [d.getX(), d.getY()]
    }
    GetCollisionPolyPointCount() {
      return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
    }
    GetCollisionPolyPoint(h) {
      h = Math.floor(h)
      const k = this.GetWorldInfo()
      var m = k.GetTransformedCollisionPoly()
      const r = m.pointCount()
      h === r && (h = 0)
      if (0 > h || h >= r) return [0, 0]
      m = m.pointsArr()
      return [m[2 * h] + k.GetX(), m[2 * h + 1] + k.GetY()]
    }
    GetDebuggerProperties() {
      const h = e.Plugins.Sprite.Acts
      return [
        {
          title: 'plugins.sprite.debugger.animation-properties.title',
          properties: [
            {
              name: 'plugins.sprite.debugger.animation-properties.current-animation',
              value: this._currentAnimation.GetName(),
              onedit: k => this.CallAction(h.SetAnim, k, 0)
            },
            {
              name: 'plugins.sprite.debugger.animation-properties.current-frame',
              value: this._currentFrameIndex,
              onedit: k => this.CallAction(h.SetAnimFrame, k)
            },
            {
              name: 'plugins.sprite.debugger.animation-properties.is-playing',
              value: this.IsAnimationPlaying(),
              onedit: k => (k ? this.CallAction(h.StartAnim, 0) : this.CallAction(h.StopAnim))
            },
            {
              name: 'plugins.sprite.debugger.animation-properties.speed',
              value: this._currentAnimationSpeed,
              onedit: k => this.CallAction(h.SetAnimSpeed, k)
            },
            {
              name: 'plugins.sprite.debugger.animation-properties.repeats',
              value: this._animationRepeats,
              onedit: k => (this._animationRepeats = k)
            }
          ]
        }
      ]
    }
    SaveToJson() {
      const h = {
        a: this._currentAnimation.GetSID()
      }
      0 !== this._frameStartTime && (h.fs = this._frameStartTime)
      var k = this.GetAnimationTime()
      0 !== k && (h.at = k)
      0 !== this._currentFrameIndex && (h.f = this._currentFrameIndex)
      0 !== this._currentAnimationSpeed && (h.cas = this._currentAnimationSpeed)
      1 !== this._animationRepeats && (h.ar = this._animationRepeats)
      0 !== this._currentAnimationRepeatTo && (h.rt = this._currentAnimationRepeatTo)
      this.IsAnimationPlaying() || (h.ap = this.IsAnimationPlaying())
      this.IsPlayingForwards() || (h.af = this.IsPlayingForwards())
      k = this.GetWorldInfo()
      k.IsCollisionEnabled() && (h.ce = k.IsCollisionEnabled())
      return h
    }
    LoadFromJson(h) {
      var k = this.GetObjectClass().GetAnimationBySID(h.a)
      k && (this._currentAnimation = k)
      this._frameStartTime = h.hasOwnProperty('fs') ? h.fs : 0
      this._animationTimer.Set(h.hasOwnProperty('at') ? h.at : 0)
      k = h.hasOwnProperty('f') ? h.f : 0
      this._currentFrameIndex = e.clamp(k, 0, this._currentAnimation.GetFrameCount() - 1)
      this._currentAnimationSpeed = h.hasOwnProperty('cas') ? h.cas : 0
      this._animationRepeats = h.hasOwnProperty('ar') ? h.ar : 1
      k = h.hasOwnProperty('rt') ? h.rt : 0
      this._currentAnimationRepeatTo = e.clamp(k, 0, this._currentAnimation.GetFrameCount() - 1)
      this.SetAnimationPlaying(h.hasOwnProperty('ap') ? !!h.ap : !0)
      this.SetPlayingForwards(h.hasOwnProperty('af') ? !!h.af : !0)
      this._currentAnimationFrame = k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)
      this._UpdateCurrentTexture()
      const m = this.GetWorldInfo()
      m.SetOriginX(k.GetOriginX())
      m.SetOriginY(k.GetOriginY())
      m.SetSourceCollisionPoly(k.GetCollisionPoly())
      m.SetCollisionEnabled(!!h.ce)
    }
    GetPropertyValueByIndex(h) {
      const k = this.GetWorldInfo()
      switch (h) {
        case 3:
          return k.IsCollisionEnabled()
        case 2:
          return e.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1)
      }
    }
    SetPropertyValueByIndex(h, k) {
      var m = this.GetWorldInfo()
      switch (h) {
        case 3:
          m.SetCollisionEnabled(!!k)
          break
        case 2:
          this.SetAnimationPlaying(!1)
          h = this._currentAnimation.GetFrameCount() - 1
          m = k = e.clamp(k, 0, h)
          k = this._currentAnimation.GetFrameAt(this._currentFrameIndex)
          const r = this._currentAnimation.GetFrameAt(m)
          this._OnFrameChanged(k, r)
          this._currentFrameIndex = e.clamp(m, 0, h)
      }
    }
    GetScriptInterfaceClass() {
      return self.ISpriteInstance
    }
  }
  const f = new WeakMap(),
    g = new Map([
      ['current-frame', 0],
      ['beginning', 1]
    ])
  self.ISpriteInstance = class extends self.IWorldInstance {
    constructor() {
      super()
      f.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    getImagePointCount() {
      return f.get(this).GetImagePointCount()
    }
    getImagePointX(h) {
      if ('string' !== typeof h && 'number' !== typeof h) throw new TypeError('expected string or number')
      return f.get(this).GetImagePoint(h)[0]
    }
    getImagePointY(h) {
      if ('string' !== typeof h && 'number' !== typeof h) throw new TypeError('expected string or number')
      return f.get(this).GetImagePoint(h)[1]
    }
    getImagePoint(h) {
      if ('string' !== typeof h && 'number' !== typeof h) throw new TypeError('expected string or number')
      return f.get(this).GetImagePoint(h)
    }
    getPolyPointCount() {
      return f.get(this).GetCollisionPolyPointCount()
    }
    getPolyPointX(h) {
      b.RequireFiniteNumber(h)
      return f.get(this).GetCollisionPolyPoint(h)[0]
    }
    getPolyPointY(h) {
      b.RequireFiniteNumber(h)
      return f.get(this).GetCollisionPolyPoint(h)[1]
    }
    getPolyPoint(h) {
      b.RequireFiniteNumber(h)
      return f.get(this).GetCollisionPolyPoint(h)
    }
    stopAnimation() {
      f.get(this).SetAnimationPlaying(!1)
    }
    startAnimation(h = 'current-frame') {
      b.RequireString(h)
      h = g.get(h)
      if ('undefined' === typeof h) throw Error('invalid mode')
      f.get(this)._StartAnim(h)
    }
    setAnimation(h, k = 'beginning') {
      b.RequireString(h)
      b.RequireString(k)
      k = g.get(k)
      if ('undefined' === typeof k) throw Error('invalid mode')
      f.get(this)._SetAnim(h, k)
    }
    get animationName() {
      return f.get(this)._GetCurrentAnimationName()
    }
    set animationFrame(h) {
      b.RequireFiniteNumber(h)
      f.get(this)._SetAnimFrame(h)
    }
    get animationFrame() {
      return f.get(this)._GetAnimFrame()
    }
    set animationSpeed(h) {
      b.RequireFiniteNumber(h)
      f.get(this)._SetAnimSpeed(h)
    }
    get animationSpeed() {
      return f.get(this)._GetAnimSpeed()
    }
    set animationRepeatToFrame(h) {
      b.RequireFiniteNumber(h)
      f.get(this)._SetAnimRepeatToFrame(h)
    }
    get animationRepeatToFrame() {
      return f.get(this)._GetAnimRepeatToFrame()
    }
    get imageWidth() {
      return f.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
      return f.get(this).GetCurrentImageInfo().GetHeight()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Rect),
    a = [],
    c = []
  let d = !1,
    f = null,
    g = !1
  const h = new Set()

  function k(t, x, v, u) {
    const A = x.GetUID(),
      z = v.GetUID()
    A < z ? t.Set(x, v, u) : t.Set(v, x, u)
  }

  function m(t, x, v) {
    const u = x.GetUID(),
      A = v.GetUID()
    u < A ? t.Delete(x, v) : t.Delete(v, x)
  }

  function r(t, x) {
    t.DeleteEither(x)
  }

  function w(t, x, v) {
    const u = x.GetUID(),
      A = v.GetUID()
    return u < A ? t.Get(x, v) : t.Get(v, x)
  }

  function p(t, x, v, u) {
    if (!x) return !1
    t = t.GetInstance()
    const A = 0 !== v || 0 !== u,
      z = t.GetWorldInfo(),
      C = t.GetRuntime(),
      E = C.GetCollisionEngine()
    var J = C.GetCurrentCondition()
    const F = J.GetEventBlock().IsOrBlock()
    var I = J.GetObjectClass()
    J = J.IsInverted()
    const L = x.GetCurrentSol()
    I = I !== x
    f = x
    d = I && !J
    g = !1
    let N = 0,
      S = 0,
      V = !1
    L.IsSelectAll()
      ? (b.copy(z.GetBoundingBox()), b.offset(v, u), E.GetCollisionCandidates(z.GetLayer(), x, b, c), (x = c))
      : F
      ? C.IsCurrentConditionFirst() && !L._GetOwnElseInstances().length && L._GetOwnInstances().length
        ? (x = L._GetOwnInstances())
        : ((x = L._GetOwnElseInstances()), (g = !0))
      : (x = L._GetOwnInstances())
    A && ((N = z.GetX()), (S = z.GetY()), z.OffsetXY(v, u), z.SetBboxChanged())
    for (const U of x)
      if (E.TestOverlap(t, U)) {
        V = !0
        if (J) break
        I && h.add(U)
      }
    A && (z.SetXY(N, S), z.SetBboxChanged())
    e.clearArray(c)
    return V
  }

  function q(t) {
    t = t.GetRuntime().GetCurrentEvent().IsOrBlock()
    const x = f.GetCurrentSol(),
      v = x._GetOwnInstances(),
      u = x._GetOwnElseInstances()
    x.IsSelectAll() ? (x.SetSetPicked(h), t && (e.clearArray(u), x.AddElseInstances(h, f.GetInstances()))) : t ? (g ? x.TransferElseInstancesToOwn(h) : (x.AddElseInstances(h, v), x.SetSetPicked(h))) : x.SetSetPicked(h)
    f.ApplySolToContainer()
  }
  e.Plugins.Sprite._FinishCondition = function (t, x) {
    d && (x && q(t), h.clear(), (f = null), (d = !1))
  }
  e.Plugins.Sprite.Cnds = {
    OnCollision(t) {
      if (this._runtime.IsDebugging()) return e.Plugins.Sprite.Cnds.DebugOnCollision.call(this, t)
      if (!t) return !1
      var x = this._runtime
      const v = x.GetCollisionEngine(),
        u = x.GetEventSheetManager(),
        A = u.GetEventStack()
      var z = u.GetCurrentCondition()
      const C = z.GetObjectClass()
      var E = z.GetSavedDataMap(),
        J = z.GetUnsavedDataMap()
      z = A.GetCurrentStackFrame()
      const F = x.GetTickCount(),
        I = F - 1,
        L = z.GetCurrentEvent(),
        N = A.Push(L)
      let S = E.get('collmemory')
      S || ((S = e.New(e.PairMap)), E.set('collmemory', S))
      J.get('spriteCreatedDestroyCallback') || (J.set('spriteCreatedDestroyCallback', !0), x.Dispatcher().addEventListener('instancedestroy', ia => r(S, ia.instance)))
      E = C.GetCurrentSol()
      x = t.GetCurrentSol()
      E = E.GetInstances()
      J = null
      for (let ia = 0; ia < E.length; ++ia) {
        const ka = E[ia]
        x.IsSelectAll() ? (v.GetCollisionCandidates(ka.GetWorldInfo().GetLayer(), t, ka.GetWorldInfo().GetBoundingBox(), a), (J = a), v.AddRegisteredCollisionCandidates(ka, t, J)) : (J = x.GetInstances())
        for (let ya = 0; ya < J.length; ++ya) {
          const ta = J[ya]
          if (v.TestOverlap(ka, ta) || v.CheckRegisteredCollision(ka, ta)) {
            var V = w(S, ka, ta),
              U = !1,
              X = -2
            'number' === typeof V && ((U = !0), (X = V))
            V = !U || X < I
            k(S, ka, ta, F)
            V &&
              ((V = L.GetSolModifiers()),
              u.PushCopySol(V),
              (X = C.GetCurrentSol()),
              (U = t.GetCurrentSol()),
              X._SetSelectAll(!1),
              U._SetSelectAll(!1),
              C === t ? ((U = X._GetOwnInstances()), e.clearArray(U), U.push(ka), U.push(ta), C.ApplySolToContainer()) : ((X = X._GetOwnInstances()), (U = U._GetOwnInstances()), e.clearArray(X), e.clearArray(U), X.push(ka), U.push(ta), C.ApplySolToContainer(), t.ApplySolToContainer()),
              L.Retrigger(z, N),
              u.PopSol(V))
          } else m(S, ka, ta)
        }
        e.clearArray(a)
      }
      A.Pop()
      return !1
    },
    *DebugOnCollision(t) {
      if (!t) return !1
      var x = this._runtime
      const v = x.GetCollisionEngine(),
        u = x.GetEventSheetManager(),
        A = u.GetEventStack(),
        z = A.GetCurrentStackFrame(),
        C = x.GetTickCount(),
        E = C - 1,
        J = z.GetCurrentEvent(),
        F = A.Push(J)
      var I = u.GetCurrentCondition()
      const L = I.GetObjectClass()
      var N = I.GetSavedDataMap()
      I = I.GetUnsavedDataMap()
      let S = N.get('collmemory')
      S || ((S = e.New(e.PairMap)), N.set('collmemory', S))
      I.get('spriteCreatedDestroyCallback') || (I.set('spriteCreatedDestroyCallback', !0), x.Dispatcher().addEventListener('instancedestroy', ia => r(S, ia.instance)))
      N = L.GetCurrentSol()
      x = t.GetCurrentSol()
      N = N.GetInstances()
      I = null
      for (let ia = 0; ia < N.length; ++ia) {
        const ka = N[ia]
        x.IsSelectAll() ? (v.GetCollisionCandidates(ka.GetWorldInfo().GetLayer(), t, ka.GetWorldInfo().GetBoundingBox(), a), (I = a), v.AddRegisteredCollisionCandidates(ka, t, I)) : (I = x.GetInstances())
        for (let ya = 0; ya < I.length; ++ya) {
          const ta = I[ya]
          if (v.TestOverlap(ka, ta) || v.CheckRegisteredCollision(ka, ta)) {
            var V = w(S, ka, ta),
              U = !1,
              X = -2
            'number' === typeof V && ((U = !0), (X = V))
            V = !U || X < E
            k(S, ka, ta, C)
            V &&
              ((V = J.GetSolModifiers()),
              u.PushCopySol(V),
              (X = L.GetCurrentSol()),
              (U = t.GetCurrentSol()),
              X._SetSelectAll(!1),
              U._SetSelectAll(!1),
              L === t ? ((U = X._GetOwnInstances()), e.clearArray(U), U.push(ka), U.push(ta), L.ApplySolToContainer()) : ((X = X._GetOwnInstances()), (U = U._GetOwnInstances()), e.clearArray(X), e.clearArray(U), X.push(ka), U.push(ta), L.ApplySolToContainer(), t.ApplySolToContainer()),
              yield* J.DebugRetrigger(z, F),
              u.PopSol(V))
          } else m(S, ka, ta)
        }
        e.clearArray(a)
      }
      A.Pop()
      return !1
    },
    IsOverlapping(t) {
      return p(this, t, 0, 0)
    },
    IsOverlappingOffset(t, x, v) {
      return p(this, t, x, v)
    },
    IsAnimPlaying(t) {
      return e.equalsNoCase(this._GetCurrentAnimationName(), t)
    },
    CompareFrame(t, x) {
      return e.compare(this._currentFrameIndex, t, x)
    },
    CompareAnimSpeed(t, x) {
      return e.compare(this._GetAnimSpeed(), t, x)
    },
    OnAnimFinished(t) {
      return e.equalsNoCase(this._animTriggerName, t)
    },
    OnAnyAnimFinished() {
      return !0
    },
    OnFrameChanged() {
      return !0
    },
    IsMirrored() {
      return 0 > this.GetWorldInfo().GetWidth()
    },
    IsFlipped() {
      return 0 > this.GetWorldInfo().GetHeight()
    },
    OnURLLoaded() {
      return !0
    },
    OnURLFailed() {
      return !0
    },
    IsCollisionEnabled() {
      return this.GetWorldInfo().IsCollisionEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Sprite.Acts = {
    Spawn(b, a, c, d) {
      if (b && a) {
        var [f, g] = this.GetImagePoint(c)
        if ((c = this._runtime.CreateInstance(b, a, f, g, d))) {
          d && a.SortAndAddSceneGraphInstancesByZIndex(c)
          b.GetPlugin().IsRotatable() && ((a = c.GetWorldInfo()), a.SetAngle(this.GetWorldInfo().GetAngle()), a.SetBboxChanged())
          a = this._runtime.GetEventSheetManager()
          a.BlockFlushingInstances(!0)
          c._TriggerOnCreatedOnSelfAndRelated()
          a.BlockFlushingInstances(!1)
          d = this._runtime.GetCurrentAction().GetSavedDataMap()
          a = !1
          if (!d.has('Spawn_LastExec') || d.get('Spawn_LastExec') < this._runtime.GetExecCount()) (a = !0), d.set('Spawn_LastExec', this._runtime.GetExecCount())
          if (b !== this.GetObjectClass() && ((b = b.GetCurrentSol()), b._SetSelectAll(!1), (b = b._GetOwnInstances()), a && e.clearArray(b), b.push(c), c.IsInContainer()))
            for (const h of c.siblings()) (c = h.GetObjectClass().GetCurrentSol()), a ? c.SetSinglePicked(h) : (c._SetSelectAll(!1), c._PushInstance(h))
        }
      }
    },
    StopAnim() {
      this.SetAnimationPlaying(!1)
    },
    StartAnim(b) {
      this._StartAnim(b)
    },
    SetAnim(b, a) {
      this._SetAnim(b, a)
    },
    SetAnimFrame(b) {
      this._SetAnimFrame(b)
    },
    SetAnimSpeed(b) {
      this._SetAnimSpeed(b)
    },
    SetAnimRepeatToFrame(b) {
      this._SetAnimRepeatToFrame(b)
    },
    SetMirrored(b) {
      const a = this.GetWorldInfo(),
        c = a.GetWidth()
      b = Math.abs(c) * (0 === b ? -1 : 1)
      c !== b && (a.SetWidth(b), a.SetBboxChanged())
    },
    SetFlipped(b) {
      const a = this.GetWorldInfo(),
        c = a.GetHeight()
      b = Math.abs(c) * (0 === b ? -1 : 1)
      c !== b && (a.SetHeight(b), a.SetBboxChanged())
    },
    SetScale(b) {
      const a = this._currentAnimationFrame.GetImageInfo(),
        c = this.GetWorldInfo()
      var d = 0 > c.GetWidth() ? -1 : 1
      const f = 0 > c.GetHeight() ? -1 : 1
      d *= a.GetWidth() * b
      b = a.GetHeight() * b * f
      if (c.GetWidth() !== d || c.GetHeight() !== b) c.SetSize(d, b), c.SetBboxChanged()
    },
    async LoadURL(b, a, c) {
      c = this._currentAnimationFrame.GetImageInfo()
      const d = this.GetWorldInfo(),
        f = this._runtime
      if (c.GetURL() === b) 0 === a && (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged()), this.Trigger(e.Plugins.Sprite.Cnds.OnURLLoaded)
      else {
        var g = e.New(e.ImageInfo)
        try {
          await g.LoadDynamicAsset(f, b)
          if (!g.IsLoaded()) throw Error('image failed to load')
          await g.LoadStaticTexture(f.GetRenderer(), {
            sampling: this._runtime.GetSampling()
          })
        } catch (h) {
          console.error('Load image from URL failed: ', h)
          this.Trigger(e.Plugins.Sprite.Cnds.OnURLFailed)
          return
        }
        c.ReplaceWith(g)
        this._sdkType._UpdateAllCurrentTexture()
        this.WasReleased() || 0 !== a || (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged())
        f.UpdateRender()
        this.WasReleased() || (await this.TriggerAsync(e.Plugins.Sprite.Cnds.OnURLLoaded))
      }
    },
    SetCollisions(b) {
      this.GetWorldInfo().SetCollisionEnabled(b)
    },
    SetSolidCollisionFilter(b, a) {
      this.GetWorldInfo().SetSolidCollisionFilter(0 === b, a)
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b)
      this._runtime.UpdateRender()
    }
  }
}
;('use strict')
self.C3.Plugins.Sprite.Exps = {
  AnimationFrame() {
    return this._currentFrameIndex
  },
  AnimationFrameCount() {
    return this._currentAnimation.GetFrameCount()
  },
  AnimationName() {
    return this._currentAnimation.GetName()
  },
  AnimationSpeed() {
    return this._GetAnimSpeed()
  },
  OriginalAnimationSpeed() {
    return this._currentAnimation.GetSpeed()
  },
  ImagePointX(e) {
    return this.GetImagePoint(e)[0]
  },
  ImagePointY(e) {
    return this.GetImagePoint(e)[1]
  },
  ImagePointCount() {
    return this.GetImagePointCount()
  },
  ImageWidth() {
    return this.GetCurrentImageInfo().GetWidth()
  },
  ImageHeight() {
    return this.GetCurrentImageInfo().GetHeight()
  },
  PolyPointXAt(e) {
    return this.GetCollisionPolyPoint(e)[0]
  },
  PolyPointYAt(e) {
    return this.GetCollisionPolyPoint(e)[1]
  },
  PolyPointCount() {
    return this.GetCollisionPolyPointCount()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Spritefont2 = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Spritefont2.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
      this._spriteFont = e.New(self.SpriteFont)
    }
    Release() {
      super.Release()
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(b) {
      return this.GetImageInfo().LoadStaticTexture(b, {
        sampling: this._runtime.GetSampling()
      })
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture()
    }
    GetSpriteFont() {
      return this._spriteFont
    }
    UpdateSettings(b, a, c, d) {
      const f = this.GetImageInfo(),
        g = this._spriteFont
      g.SetWidth(f.GetWidth())
      g.SetHeight(f.GetHeight())
      g.SetCharacterWidth(b)
      g.SetCharacterHeight(a)
      g.SetCharacterSet(c)
      g.SetSpacingData(d)
      g.UpdateCharacterMap()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = ['left', 'center', 'right'],
    c = ['top', 'center', 'bottom']
  e.Plugins.Spritefont2.Instance = class extends e.SDKWorldInstanceBase {
    constructor(k, m) {
      super(k)
      this._text = ''
      this._enableBBcode = !0
      this._characterHeight = this._characterWidth = 16
      this._characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#"\'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>'
      k = ''
      this._characterScale = 1
      this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing = 0
      this._wrapByWord = !0
      this._spriteFontText = null
      this._typewriterEndTime = this._typewriterStartTime = -1
      this._typewriterLength = 0
      m &&
        ((this._text = m[0]),
        (this._enableBBcode = m[1]),
        (this._characterWidth = m[2]),
        (this._characterHeight = m[3]),
        (this._characterSet = m[4]),
        (k = m[5]),
        (this._characterScale = m[6]),
        (this._characterSpacing = m[7]),
        (this._lineHeight = m[8]),
        (this._horizontalAlign = m[9]),
        (this._verticalAlign = m[10]),
        (this._wrapByWord = 0 === m[11]),
        this.GetWorldInfo().SetVisible(m[12]))
      this._sdkType.UpdateSettings(this._characterWidth, this._characterHeight, this._characterSet, k)
      this._spriteFontText = e.New(self.SpriteFontText, this._sdkType.GetSpriteFont())
      m = this.GetWorldInfo()
      this._spriteFontText.SetSize(m.GetWidth(), m.GetHeight())
      this._UpdateSettings()
    }
    Release() {
      this._CancelTypewriter()
      this._spriteFontText.Release()
      this._spriteFontText = null
      super.Release()
    }
    _UpdateSettings() {
      const k = this._spriteFontText
      k && (k.SetBBCodeEnabled(this._enableBBcode), k.SetText(this._text), k.SetWordWrapMode(this._wrapByWord ? 'word' : 'character'), k.SetHorizontalAlign(a[this._horizontalAlign]), k.SetVerticalAlign(c[this._verticalAlign]), k.SetSpacing(this._characterSpacing), k.SetLineHeight(this._lineHeight))
    }
    Draw(k) {
      const m = this._objectClass.GetImageInfo()
      var r = m.GetTexture()
      if (r) {
        k.SetTexture(r)
        r = this.GetWorldInfo()
        var w = r.GetBoundingQuad(),
          p = this._spriteFontText
        p.SetScale(this._characterScale)
        p.SetSceneGraphScale(r.GetSceneGraphScale())
        this._runtime.IsPixelRoundingEnabled() && (w = r.PixelRoundQuad(w))
        p.SetSize(r.GetWidth(), r.GetHeight())
        p.GetSpriteFont().SetTexRect(m.GetTexRect())
        p.SetColor(r.GetUnpremultipliedColor())
        p.Draw(k, w.getTlx(), w.getTly(), r.GetAngle())
      }
    }
    SaveToJson() {
      const k = {
        t: this._text,
        ebbc: this._enableBBcode,
        csc: this._characterScale,
        csp: this._characterSpacing,
        lh: this._lineHeight,
        ha: this._horizontalAlign,
        va: this._verticalAlign,
        w: this._wrapByWord,
        cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
        ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
        cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
        sd: this._sdkType.GetSpriteFont().GetSpacingData()
      }
      ;-1 !== this._typewriterEndTime &&
        (k.tw = {
          st: this._typewriterStartTime,
          en: this._typewriterEndTime,
          l: this._typewriterLength
        })
      return k
    }
    LoadFromJson(k) {
      this._CancelTypewriter()
      this._text = k.t
      this._enableBBcode = k.ebbc
      this._characterScale = k.csc
      this._characterSpacing = k.csp
      this._lineHeight = k.lh
      this._horizontalAlign = k.ha
      this._verticalAlign = k.va
      this._wrapByWord = k.w
      if (k.hasOwnProperty('tw')) {
        var m = k.tw
        this._typewriterStartTime = m.st
        this._typewriterEndTime = m.en
        this._typewriterLength = k.l
      }
      m = this._sdkType.GetSpriteFont()
      m.SetCharacterWidth(k.cw)
      m.SetCharacterHeight(k.ch)
      m.SetCharacterSet(k.cs)
      m.SetSpacingData(k.sd)
      this._UpdateSettings()
      ;-1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(k) {
      switch (k) {
        case 0:
          return this._text
        case 1:
          return this._enableBBcode
        case 2:
          return this._sdkType.GetSpriteFont().GetCharacterWidth()
        case 3:
          return this._sdkType.GetSpriteFont().GetCharacterHeight()
        case 4:
          return this._sdkType.GetSpriteFont().GetCharacterSet()
        case 5:
          return this._sdkType.GetSpriteFont().GetSpacingData()
        case 6:
          return this._characterScale
        case 7:
          return this._characterSpacing
        case 8:
          return this._lineHeight
        case 9:
          return this._horizontalAlign
        case 10:
          return this._verticalAlign
        case 11:
          return this._wrapByWord ? 1 : 0
      }
    }
    SetPropertyValueByIndex(k, m) {
      switch (k) {
        case 0:
          if (this._text === m) break
          this._text = m
          this._UpdateSettings()
          break
        case 1:
          if (this._enableBBcode === !!m) break
          this._enableBBcode = !!m
          this._UpdateSettings()
          break
        case 2:
          this._sdkType.GetSpriteFont().SetCharacterWidth(m)
          break
        case 3:
          this._sdkType.GetSpriteFont().SetCharacterHeight(m)
          break
        case 4:
          this._sdkType.GetSpriteFont().SetCharacterSet(m)
          break
        case 5:
          this._sdkType.GetSpriteFont().SetSpacingData(m)
          break
        case 6:
          if (this._characterScale === m) break
          this._characterScale = m
          this._UpdateSettings()
          break
        case 7:
          if (this._characterSpacing === m) break
          this._characterSpacing = m
          this._UpdateSettings()
          break
        case 8:
          if (this._lineHeight === m) break
          this._lineHeight = m
          this._UpdateSettings()
          break
        case 9:
          if (this._horizontalAlign === m) break
          this._horizontalAlign = m
          this._UpdateSettings()
          break
        case 10:
          if (this._verticalAlign === m) break
          this._verticalAlign = m
          this._UpdateSettings()
          break
        case 11:
          this._wrapByWord !== (0 === m) && ((this._wrapByWord = 0 === m), this._UpdateSettings())
      }
    }
    _SetText(k) {
      this._text !== k && ((this._text = k), this._spriteFontText.SetText(k), this._runtime.UpdateRender())
    }
    GetText() {
      return this._text
    }
    _StartTypewriter(k, m) {
      this._SetText(k)
      this._typewriterStartTime = this._runtime.GetWallTime()
      this._typewriterEndTime = this._typewriterStartTime + m / this.GetInstance().GetActiveTimeScale()
      this._typewriterLength = e.BBString.StripAnyTags(k).length
      this._spriteFontText.SetDrawMaxCharacterCount(0)
      this._StartTicking()
    }
    _CancelTypewriter() {
      this._typewriterEndTime = this._typewriterStartTime = -1
      this._typewriterLength = 0
      this._spriteFontText.SetDrawMaxCharacterCount(-1)
      this._StopTicking()
    }
    _FinishTypewriter() {
      ;-1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
    }
    _SetScale(k) {
      this._characterScale !== k && ((this._characterScale = k), this._spriteFontText.SetScale(this._characterScale), this._runtime.UpdateRender())
    }
    _GetScale() {
      return this._characterScale
    }
    _SetCharacterSpacing(k) {
      this._characterSpacing !== k && ((this._characterSpacing = k), this._spriteFontText.SetSpacing(this._characterSpacing), this._runtime.UpdateRender())
    }
    _GetCharacterSpacing() {
      return this._characterSpacing
    }
    _SetLineHeight(k) {
      this._lineHeight !== k && ((this._lineHeight = k), this._spriteFontText.SetLineHeight(this._lineHeight), this._runtime.UpdateRender())
    }
    _GetLineHeight() {
      return this._lineHeight
    }
    _SetHAlign(k) {
      this._horizontalAlign !== k && ((this._horizontalAlign = k), this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _GetHAlign() {
      return this._horizontalAlign
    }
    _SetVAlign(k) {
      this._verticalAlign !== k && ((this._verticalAlign = k), this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _GetVAlign() {
      return this._verticalAlign
    }
    _SetWrapByWord(k) {
      k = !!k
      this._wrapByWord !== k && ((this._wrapByWord = k), this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _IsWrapByWord() {
      return this._wrapByWord
    }
    Tick() {
      var k = this._runtime.GetWallTime()
      k >= this._typewriterEndTime
        ? (this._CancelTypewriter(), this.Trigger(e.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
        : ((k = e.relerp(this._typewriterStartTime, this._typewriterEndTime, k, 0, this._typewriterLength)), (k = Math.floor(k)), k !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(k), this._runtime.UpdateRender()))
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.spritefont2.name',
          properties: [
            {
              name: 'plugins.spritefont2.properties.text.name',
              value: this._text,
              onedit: k => this._SetText(k)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.ISpriteFontInstance
    }
  }
  const d = new WeakMap(),
    f = new Map([
      ['left', 0],
      ['center', 1],
      ['right', 2]
    ]),
    g = new Map([
      ['top', 0],
      ['center', 1],
      ['bottom', 2]
    ]),
    h = new Map([
      ['word', !0],
      ['character', !1]
    ])
  self.ISpriteFontInstance = class extends self.IWorldInstance {
    constructor() {
      super()
      d.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text() {
      return d.get(this).GetText()
    }
    set text(k) {
      b.RequireString(k)
      const m = d.get(this)
      m._CancelTypewriter()
      m._SetText(k)
    }
    typewriterText(k, m) {
      b.RequireString(k)
      b.RequireFiniteNumber(m)
      const r = d.get(this)
      r._CancelTypewriter()
      r._StartTypewriter(k, m)
    }
    typewriterFinish() {
      d.get(this)._FinishTypewriter()
    }
    set characterScale(k) {
      b.RequireFiniteNumber(k)
      d.get(this)._SetScale(k)
    }
    get characterScale() {
      return d.get(this)._GetScale()
    }
    set characterSpacing(k) {
      b.RequireFiniteNumber(k)
      d.get(this)._SetCharacterSpacing(k)
    }
    get characterSpacing() {
      return d.get(this)._GetCharacterSpacing()
    }
    set lineHeight(k) {
      b.RequireFiniteNumber(k)
      d.get(this)._SetLineHeight(k)
    }
    get lineHeight() {
      return d.get(this)._GetLineHeight()
    }
    set horizontalAlign(k) {
      b.RequireString(k)
      k = f.get(k)
      if ('undefined' === typeof k) throw Error('invalid mode')
      d.get(this)._SetHAlign(k)
    }
    get horizontalAlign() {
      return a[d.get(this)._GetHAlign()]
    }
    set verticalAlign(k) {
      b.RequireString(k)
      k = g.get(k)
      if ('undefined' === typeof k) throw Error('invalid mode')
      d.get(this)._SetVAlign(k)
    }
    get verticalAlign() {
      return c[d.get(this)._GetVAlign()]
    }
    set wordWrapMode(k) {
      b.RequireString(k)
      k = h.get(k)
      if ('undefined' === typeof k) throw Error('invalid mode')
      d.get(this)._SetWrapByWord(k)
    }
    get wordWrapMode() {
      return d.get(this)._IsWrapByWord() ? 'word' : 'character'
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Spritefont2.Cnds = {
    CompareText(b, a) {
      return a ? this._text === b : e.equalsNoCase(this._text, b)
    },
    IsRunningTypewriterText() {
      return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
      return !0
    }
  }
}
;('use strict')
self.C3.Plugins.Spritefont2.Acts = {
  SetText(e) {
    this._CancelTypewriter()
    'number' === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10)
    this._SetText(e.toString())
  },
  AppendText(e) {
    this._CancelTypewriter()
    'number' === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10)
    ;(e = e.toString()) && this._SetText(this._text + e)
  },
  TypewriterText(e, b) {
    this._CancelTypewriter()
    'number' === typeof e && 1e9 > e && (e = Math.round(1e10 * e) / 1e10)
    this._StartTypewriter(e.toString(), b)
  },
  TypewriterFinish() {
    this._FinishTypewriter()
  },
  SetScale(e) {
    this._SetScale(e)
  },
  SetCharacterSpacing(e) {
    this._SetCharacterSpacing(e)
  },
  SetLineHeight(e) {
    this._SetLineHeight(e)
  },
  SetCharacterWidth(e, b) {
    let a = !1
    const c = this._sdkType.GetSpriteFont()
    for (const d of e)
      if (' ' === d) c.SetSpaceWidth(b), (a = !0)
      else if ((e = c.GetCharacter(d))) e.SetDisplayWidth(b), (a = !0)
    a && c.SetCharacterWidthsChanged()
    this._runtime.UpdateRender()
  },
  SetEffect(e) {
    this.GetWorldInfo().SetBlendMode(e)
    this._runtime.UpdateRender()
  },
  SetHAlign(e) {
    this._SetHAlign(e)
  },
  SetVAlign(e) {
    this._SetVAlign(e)
  },
  SetWrapping(e) {
    this._SetWrapByWord(0 === e)
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Spritefont2.Exps = {
    CharacterWidth(b) {
      return (b = this._sdkType.GetSpriteFont().GetCharacter(b)) ? b.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
    },
    CharacterHeight() {
      return this._characterHeight
    },
    CharacterScale() {
      return this._characterScale
    },
    CharacterSpacing() {
      return this._characterSpacing
    },
    LineHeight() {
      return this._lineHeight
    },
    Text() {
      return this._text
    },
    PlainText() {
      return this._enableBBcode ? e.BBString.StripAnyTags(this._text) : this._text
    },
    TextWidth() {
      const b = this.GetWorldInfo()
      this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight())
      return this._spriteFontText.GetTextWidth()
    },
    TextHeight() {
      const b = this.GetWorldInfo()
      this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight())
      return this._spriteFontText.GetTextHeight()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  self.SpriteFontCharacter = class {
    constructor(b, a, c, d) {
      let f = b.GetCharacterWidth(),
        g = b.GetCharacterHeight()
      this._spriteFont = b
      this._char = a
      this._pxRect = new e.Rect(c, d, c + f, d + g)
      this._texRect = new e.Rect()
      this._displayWidth = -1
      this._UpdateTexRect()
    }
    Release() {
      this._texRect = this._pxRect = this._spriteFont = null
    }
    _UpdateTexRect() {
      let b = this._spriteFont.GetWidth(),
        a = this._spriteFont.GetHeight()
      this._texRect.copy(this._pxRect)
      this._texRect.divide(b, a)
      this._texRect.lerpInto(this._spriteFont.GetTexRect())
    }
    GetSpriteFont() {
      return this._spriteFont
    }
    GetChar() {
      return this._char
    }
    GetTexRect() {
      return this._texRect
    }
    SetDisplayWidth(b) {
      this._displayWidth = b
    }
    GetDisplayWidth() {
      return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new e.Rect(),
    a = new e.Quad(),
    c = new e.Color(),
    d = new Set(['left', 'center', 'right']),
    f = new Set(['top', 'center', 'bottom']),
    g = new Set(['word', 'character'])
  self.SpriteFontText = class {
    constructor(h) {
      this._spriteFont = h
      this._cssHeight = this._cssWidth = 0
      this._text = ''
      this._isBBcodeEnabled = !1
      this._bbString = null
      this._wrappedText = e.New(e.WordWrap)
      this._wrapMode = 'word'
      this._wrapChanged = !1
      this._horizontalAlign = 'left'
      this._verticalAlign = 'top'
      this._sceneGraphScale = this._scale = 1
      this._lineHeight = this._spacing = 0
      this._color = e.New(e.Color)
      this._drawMaxCharCount = -1
      this._drawCharCount = 0
      this._measureTextCallback = (k, m) => this._MeasureText(k, m)
      this._spriteFont._AddSpriteFontText(this)
    }
    Release() {
      this._spriteFont._RemoveSpriteFontText(this)
      this._measureTextCallback = this._color = null
      this._wrappedText.Clear()
      this._bbString = this._spriteFont = this._wrappedText = null
    }
    _MeasureText(h, k) {
      var m = this._GetStyleTag(k, 'scale'),
        r = (m ? parseFloat(m.param) : this._scale) * this._sceneGraphScale
      m = this._GetStyleTag(k, 'scalex')
      m = (m ? parseFloat(m.param) : 1) * r
      k = this._GetStyleTag(k, 'scaley')
      k = (k ? parseFloat(k.param) : 1) * r
      k = this._spriteFont.GetCharacterHeight() * k + this._lineHeight
      const w = this.GetSpriteFont()
      r = w.GetCharacterWidth() * m
      const p = this.GetSpacing()
      if (w.HasAnyCustomWidths()) {
        let t = 0,
          x = 0
        for (var q of h) {
          h = r
          const v = w.GetCharacter(q)
          v ? (h = v.GetDisplayWidth() * m) : ' ' === q && (h = w.GetSpaceWidth() * m)
          x += h
          ++t
        }
        return {
          width: x + t * p,
          height: k
        }
      }
      q = [...h].length
      return {
        width: r * q + Math.max(q, 0) * p,
        height: k
      }
    }
    _SetWrapChanged() {
      this._wrapChanged = !0
      this._wrappedText.Clear()
    }
    SetSize(h, k) {
      0 >= h || 0 >= k || (this._cssWidth === h && this._cssHeight === k) || (this._cssWidth !== h && this._SetWrapChanged(), (this._cssWidth = h), (this._cssHeight = k))
    }
    SetDrawMaxCharacterCount(h) {
      this._drawMaxCharCount = Math.floor(h)
    }
    GetDrawMaxCharacterCount() {
      return this._drawMaxCharCount
    }
    _GetStyleTag(h, k) {
      for (let m = h.length - 1; 0 <= m; --m) {
        const r = h[m]
        if (r.tag === k) return r
      }
      return null
    }
    _HasStyleTag(h, k) {
      return !!this._GetStyleTag(h, k)
    }
    _MaybeWrapText() {
      if (this._wrapChanged) {
        !this._isBBcodeEnabled ||
          (this._bbString && this._bbString.toString() === this._text) ||
          (this._bbString = new e.BBString(this._text, {
            noEscape: !0
          }))
        var h = -this.GetSpacing()
        this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, h)
        this._wrapChanged = !1
      }
    }
    Draw(h, k, m, r) {
      this._MaybeWrapText()
      let w = (this._drawCharCount = 0)
      const p = this._lineHeight,
        q = e.cloneArray(this._wrappedText.GetLines()),
        t = Math.sin(r)
      r = Math.cos(r)
      var x = q.reduce((v, u) => v + u.height, 0) - p
      'center' === this._verticalAlign ? (w = Math.max(Math.floor(this._cssHeight / 2 - x / 2), 0)) : 'bottom' === this._verticalAlign && (w = Math.floor(this._cssHeight - x))
      for (let v = 0, u = q.length; v < u; ++v) {
        x = q[v]
        const A = x.height
        if (0 < v && w > this._cssHeight - (A - p)) break
        0 <= w && this._DrawLine(h, x, k, m, w, t, r)
        w += A
      }
    }
    _DrawLine(h, k, m, r, w, p, q) {
      const t = k.height
      let x = 0
      'center' === this._horizontalAlign ? (x = Math.max(Math.floor((this._cssWidth - k.width) / 2), 0)) : 'right' === this._horizontalAlign && (x = Math.max(Math.floor(this._cssWidth - k.width), 0))
      for (const v of k.fragments) this._DrawFragment(h, v, m, r, x, w, p, q, t), (x += v.width)
    }
    _DrawFragment(h, k, m, r, w, p, q, t, x) {
      var v = k.text,
        u = k.width,
        A = k.styles
      if (-1 !== this._drawMaxCharCount) {
        if (this._drawCharCount >= this._drawMaxCharCount) return
        this._drawCharCount + v.length > this._drawMaxCharCount && ((v = v.substr(0, this._drawMaxCharCount - this._drawCharCount)), (u = this._MeasureText(v, A).width))
        this._drawCharCount += v.length
      }
      var z = this._GetStyleTag(A, 'background')
      if (!((e.IsStringAllWhitespace(v) && !z) || this._HasStyleTag(A, 'hide'))) {
        k = this._GetStyleTag(A, 'scale')
        var C = (k ? parseFloat(k.param) : this._scale) * this._sceneGraphScale
        k = this._GetStyleTag(A, 'scalex')
        k = (k ? parseFloat(k.param) : 1) * C
        var E = this._GetStyleTag(A, 'scaley')
        C *= E ? parseFloat(E.param) : 1
        C *= this._spriteFont.GetCharacterHeight()
        p += x - this._lineHeight - C
        x = this._GetStyleTag(A, 'offsetx')
        w += x ? parseFloat(x.param) : 0
        x = this._GetStyleTag(A, 'offsety')
        p += x ? parseFloat(x.param) : 0
        z && (h.SetColorFillMode(), c.parseString(z.param), c.setA(1), h.SetColor(c), b.set(w, p, w + u, p + C), b.getRight() > this._cssWidth && b.setRight(this._cssWidth), a.setFromRotatedRectPrecalc(b, q, t), a.offset(m, r), h.Quad(a), h.SetTextureFillMode())
        ;(u = this._GetStyleTag(A, 'color')) ? (c.parseString(u.param), c.setA(this._color.getA())) : c.copy(this._color)
        ;(u = this._GetStyleTag(A, 'opacity')) && c.setA((c.getA() * parseFloat(u.param)) / 100)
        c.premultiply()
        h.SetColor(c)
        u = this._spriteFont.GetCharacterWidth() * k
        A = Math.abs(this.GetSpacing())
        for (const J of v)
          if ((v = this._spriteFont.GetCharacter(J))) {
            z = v.GetDisplayWidth() * k
            if (w + z > this._cssWidth + A + 1e-5) break
            b.set(w, p, w + u, p + C)
            a.setFromRotatedRectPrecalc(b, q, t)
            a.offset(m, r)
            h.Quad3(a, v.GetTexRect())
            w += z + this._spacing
          } else w += this._spriteFont.GetSpaceWidth() * k + this._spacing
      }
    }
    GetSpriteFont() {
      return this._spriteFont
    }
    SetBBCodeEnabled(h) {
      h = !!h
      this._isBBcodeEnabled !== h && ((this._isBBcodeEnabled = h), this._SetWrapChanged())
    }
    IsBBCodeEnabled() {
      return this._isBBcodeEnabled
    }
    SetText(h) {
      this._text !== h && ((this._text = h), this._SetWrapChanged())
    }
    SetWordWrapMode(h) {
      if (!g.has(h)) throw Error('invalid word wrap mode')
      this._wrapMode !== h && ((this._wrapMode = h), this._SetWrapChanged())
    }
    SetHorizontalAlign(h) {
      if (!d.has(h)) throw Error('invalid alignment')
      this._horizontalAlign = h
    }
    SetVerticalAlign(h) {
      if (!f.has(h)) throw Error('invalid alignment')
      this._verticalAlign = h
    }
    SetScale(h) {
      this._scale !== h && ((this._scale = h), this._SetWrapChanged())
    }
    GetScale() {
      return this._scale
    }
    SetSceneGraphScale(h) {
      this._sceneGraphScale !== h && ((this._sceneGraphScale = h), this._SetWrapChanged())
    }
    GetSceneGraphScale() {
      return this._sceneGraphScale
    }
    SetSpacing(h) {
      this._spacing !== h && ((this._spacing = h), this._SetWrapChanged())
    }
    GetSpacing() {
      return this._spacing
    }
    SetLineHeight(h) {
      this._lineHeight = h
      this._SetWrapChanged()
    }
    GetLineHeight() {
      return this._lineHeight
    }
    SetOpacity(h) {
      h = e.clamp(h, 0, 1)
      this._color.a = h
    }
    SetColor(h) {
      this._color.equals(h) || this._color.copy(h)
    }
    GetColor() {
      return this._color
    }
    GetTextWidth() {
      this._MaybeWrapText()
      return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight() {
      this._MaybeWrapText()
      var h = this._spriteFont.GetCharacterHeight() * this._scale
      const k = this._lineHeight
      h += k
      return this._wrappedText.GetLineCount() * h - k
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = {
      width: 256,
      height: 256,
      characterWidth: 16,
      characterHeight: 16,
      characterSet: ''
    }
  self.SpriteFont = class {
    constructor(a) {
      a = Object.assign({}, b, a)
      if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight) throw Error('invalid size')
      this._width = a.width
      this._height = a.height
      this._characterWidth = a.characterWidth
      this._characterHeight = a.characterHeight
      this._characterSet = a.characterSet
      this._spacingData = ''
      this._spacingParsed = null
      this._hasAnyCustomWidths = !1
      this._spaceWidth = -1
      this._texRect = new e.Rect(0, 0, 1, 1)
      this._characterMap = new Map()
      this._mapChanged = !0
      this._allTexts = new Set()
    }
    Release() {
      this._texRect = null
      this._ReleaseCharacters()
      this._characterMap = null
      this._allTexts && this._allTexts.clear()
      this._allTexts = null
    }
    _ReleaseCharacters() {
      for (let a of this._characterMap.values()) a.Release()
      this._characterMap.clear()
    }
    _AddSpriteFontText(a) {
      this._allTexts.add(a)
    }
    _RemoveSpriteFontText(a) {
      this._allTexts.delete(a)
    }
    UpdateCharacterMap() {
      if (this._mapChanged) {
        this._ReleaseCharacters()
        var a = [...this._characterSet],
          c = Math.floor(this._width / this._characterWidth),
          d = c * Math.floor(this._height / this._characterHeight)
        for (let f = 0, g = a.length; f < g && !(f >= d); ++f) {
          let h = a[f]
          this._characterMap.set(h, e.New(self.SpriteFontCharacter, this, h, (f % c) * this._characterWidth, Math.floor(f / c) * this._characterHeight))
        }
        this._hasAnyCustomWidths = !1
        this._spaceWidth = -1
        if (Array.isArray(this._spacingParsed))
          for (let f of this._spacingParsed)
            if (Array.isArray(f) && 2 === f.length && ((a = f[0]), (c = f[1]), 'number' === typeof a && isFinite(a) && 'string' === typeof c && a !== this._characterWidth))
              for (let g of c) (c = this._characterMap.get(g)) ? (c.SetDisplayWidth(a), (this._hasAnyCustomWidths = !0)) : ' ' === g && ((this._spaceWidth = a), (this._hasAnyCustomWidths = !0))
        this._mapChanged = !1
        for (let f of this._allTexts) f._SetWrapChanged()
      }
    }
    SetCharacterWidthsChanged() {
      this._hasAnyCustomWidths = !0
      for (const a of this._allTexts) a._SetWrapChanged()
    }
    GetCharacter(a) {
      this.UpdateCharacterMap()
      return this._characterMap.get(a) || null
    }
    HasAnyCustomWidths() {
      return this._hasAnyCustomWidths
    }
    SetWidth(a) {
      a = Math.floor(a)
      if (0 >= a) throw Error('invalid size')
      this._width !== a && ((this._width = a), (this._mapChanged = !0))
    }
    GetWidth() {
      return this._width
    }
    SetHeight(a) {
      a = Math.floor(a)
      if (0 >= a) throw Error('invalid size')
      this._height !== a && ((this._height = a), (this._mapChanged = !0))
    }
    GetHeight() {
      return this._height
    }
    SetTexRect(a) {
      if (!this._texRect.equals(a)) {
        this._texRect.copy(a)
        for (const c of this._characterMap.values()) c._UpdateTexRect()
      }
    }
    GetTexRect() {
      return this._texRect
    }
    SetCharacterWidth(a) {
      a = Math.floor(a)
      if (0 >= a) throw Error('invalid size')
      this._characterWidth !== a && ((this._characterWidth = a), (this._mapChanged = !0))
    }
    GetCharacterWidth() {
      return this._characterWidth
    }
    SetCharacterHeight(a) {
      a = Math.floor(a)
      if (0 >= a) throw Error('invalid size')
      this._characterHeight !== a && ((this._characterHeight = a), (this._mapChanged = !0))
    }
    GetCharacterHeight() {
      return this._characterHeight
    }
    SetCharacterSet(a) {
      this._characterSet !== a && ((this._characterSet = a), (this._mapChanged = !0))
    }
    GetCharacterSet() {
      return this._characterSet
    }
    SetSpacingData(a) {
      if (this._spacingData !== a && ((this._spacingData = a), (this._mapChanged = !0), (this._spacingParsed = null), this._spacingData.length))
        try {
          this._spacingParsed = JSON.parse(this._spacingData)
        } catch (c) {
          this._spacingParsed = null
        }
    }
    GetSpacingData() {
      return this._spacingData
    }
    SetSpaceWidth(a) {
      0 > a && (a = -1)
      this._spaceWidth !== a && ((this._spaceWidth = a), 0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
    }
    GetSpaceWidth() {
      return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Dictionary = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Dictionary.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.IInstance
  e.Plugins.Dictionary.Instance = class extends e.SDKInstanceBase {
    constructor(c, d) {
      super(c)
      this._data = new Map()
      this._curKey = ''
    }
    Release() {
      this._data.clear()
      super.Release()
    }
    GetAsJsonString() {
      return JSON.stringify({
        c2dictionary: !0,
        data: e.MapToObject(this._data)
      })
    }
    GetDataMap() {
      return this._data
    }
    SaveToJson() {
      return e.MapToObject(this._data)
    }
    LoadFromJson(c) {
      e.ObjectToMap(c, this._data)
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.dictionary.name',
          properties: [
            {
              name: 'plugins.dictionary.debugger.key-count',
              value: this._data.size
            },
            ...[...this._data].map(c => ({
              name: '$' + c[0],
              value: c[1],
              onedit: d => this._data.set(c[0], d)
            }))
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.IDictionaryInstance
    }
  }
  const a = new WeakMap()
  self.IDictionaryInstance = class extends b {
    constructor() {
      super()
      a.set(this, b._GetInitInst().GetSdkInstance())
    }
    getDataMap() {
      return a.get(this).GetDataMap()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Dictionary.Cnds = {
    CompareValue(b, a, c) {
      b = this._data.get(b)
      return 'undefined' === typeof b ? !1 : e.compare(b, a, c)
    },
    ForEachKey() {
      const b = this._runtime,
        a = b.GetEventSheetManager(),
        c = b.GetCurrentEvent(),
        d = c.GetSolModifiers(),
        f = b.GetEventStack(),
        g = f.GetCurrentStackFrame(),
        h = f.Push(c)
      b.SetDebuggingEnabled(!1)
      for (const k of this._data.keys()) (this._curKey = k), a.PushCopySol(d), c.Retrigger(g, h), a.PopSol(d)
      b.SetDebuggingEnabled(!0)
      this._curKey = ''
      f.Pop()
      return !1
    },
    CompareCurrentValue(b, a) {
      const c = this._data.get(this._curKey)
      return 'undefined' === typeof c ? !1 : e.compare(c, b, a)
    },
    HasKey(b) {
      return this._data.has(b)
    },
    IsEmpty() {
      return 0 === this._data.size
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Dictionary.Acts = {
    AddKey(b, a) {
      this._data.set(b, a)
    },
    SetKey(b, a) {
      this._data.has(b) && this._data.set(b, a)
    },
    DeleteKey(b) {
      this._data.delete(b)
    },
    Clear() {
      this._data.clear()
    },
    JSONLoad(b) {
      let a = null
      try {
        a = JSON.parse(b)
      } catch (c) {
        console.error('[Construct 3] Error parsing JSON: ', c)
        return
      }
      a.c2dictionary && e.ObjectToMap(a.data, this._data)
    },
    JSONDownload(b) {
      const a = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], {
          type: 'application/json'
        })
      )
      this._runtime.InvokeDownload(a, b)
    }
  }
}
;('use strict')
self.C3.Plugins.Dictionary.Exps = {
  Get(e) {
    e = this._data.get(e)
    return 'undefined' === typeof e ? 0 : e
  },
  GetDefault(e, b) {
    e = this._data.get(e)
    return 'undefined' === typeof e ? b : e
  },
  KeyCount() {
    return this._data.size
  },
  CurrentKey() {
    return this._curKey
  },
  CurrentValue() {
    return this._data.get(this._curKey) || 0
  },
  AsJSON() {
    return this.GetAsJsonString()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Audio = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Audio.Type = class extends e.SDKTypeBase {
    constructor(a) {
      super(a)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IAudioObjectType
    }
  }

  function b() {
    if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface
    throw Error('audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode')
  }
  self.IAudioObjectType = class extends self.IObjectClass {
    constructor(a) {
      super(a)
    }
    get audioContext() {
      return b().GetAudioContext()
    }
    get destinationNode() {
      return b().GetDestinationNode()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = ['interactive', 'balanced', 'playback']
  e.Plugins.Audio.Instance = class extends e.SDKInstanceBase {
    constructor(a, c) {
      super(a, 'audio')
      this._nextPlayTime = 0
      this._triggerTag = ''
      this._saveLoadMode = this._timeScaleMode = 0
      this._playInBackground = !1
      this._distanceModel = this._panningModel = 1
      this._listenerX = this._runtime.GetViewportWidth() / 2
      this._listenerY = this._runtime.GetViewportHeight() / 2
      this._listenerZ = -600
      this._referenceDistance = 600
      this._maxDistance = 1e4
      this._rolloffFactor = 1
      this._listenerInst = null
      this._loadListenerUid = -1
      this._masterVolume = 1
      this._isSilent = !1
      this._sampleRate = 0
      this._effectCount = new Map()
      this._preloadCount = this._preloadTotal = 0
      this._remoteUrls = new Map()
      a = 'interactive'
      c && ((this._timeScaleMode = c[0]), (this._saveLoadMode = c[1]), (this._playInBackground = c[2]), (a = b[c[3]]), (this._panningModel = c[4]), (this._distanceModel = c[5]), (this._listenerZ = -c[6]), (this._referenceDistance = c[7]), (this._maxDistance = c[8]), (this._rolloffFactor = c[9]))
      this._lastAIState = []
      this._lastFxState = []
      this._lastAnalysersData = []
      this.AddDOMMessageHandlers([
        ['state', d => this._OnUpdateState(d)],
        ['fxstate', d => this._OnUpdateFxState(d)],
        ['trigger', d => this._OnTrigger(d)]
      ])
      c = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(c, 'instancedestroy', d => this._OnInstanceDestroyed(d.instance)),
        e.Disposable.From(c, 'afterload', () => this._OnAfterLoad()),
        e.Disposable.From(c, 'suspend', () => this._OnSuspend()),
        e.Disposable.From(c, 'resume', () => this._OnResume())
      )
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync('create-audio-context', {
          preloadList: this._runtime
            .GetAssetManager()
            .GetAudioToPreload()
            .map(d => ({
              originalUrl: d.originalUrl,
              url: d.url,
              type: d.type,
              fileSize: d.fileSize
            })),
          isiOSCordova: this._runtime.IsiOSCordova(),
          timeScaleMode: this._timeScaleMode,
          latencyHint: a,
          panningModel: this._panningModel,
          distanceModel: this._distanceModel,
          refDistance: this._referenceDistance,
          maxDistance: this._maxDistance,
          rolloffFactor: this._rolloffFactor,
          listenerPos: [this._listenerX, this._listenerY, this._listenerZ]
        }).then(d => {
          this._sampleRate = d.sampleRate
        })
      )
      this._StartTicking()
    }
    Release() {
      this._listenerInst = null
      super.Release()
    }
    _OnInstanceDestroyed(a) {
      this._listenerInst === a && (this._listenerInst = null)
    }
    DbToLinearNoCap(a) {
      return Math.pow(10, a / 20)
    }
    DbToLinear(a) {
      a = this.DbToLinearNoCap(a)
      return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
    }
    LinearToDbNoCap(a) {
      return (Math.log(a) / Math.log(10)) * 20
    }
    LinearToDb(a) {
      return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
    }
    _OnSuspend() {
      this._playInBackground ||
        this.PostToDOM('set-suspended', {
          isSuspended: !0
        })
    }
    _OnResume() {
      this._playInBackground ||
        this.PostToDOM('set-suspended', {
          isSuspended: !1
        })
    }
    _OnUpdateState(a) {
      const c = a.tickCount,
        d = this._lastAIState.filter(f => f.hasOwnProperty('placeholder') && (f.placeholder > c || -1 === f.placeholder))
      this._lastAIState = a.audioInstances
      this._lastAnalysersData = a.analysers
      0 < d.length && e.appendArray(this._lastAIState, d)
    }
    _OnUpdateFxState(a) {
      this._lastFxState = a.fxstate
    }
    _GetFirstAudioStateByTag(a) {
      for (const c of this._lastAIState) if (e.equalsNoCase(c.tag, a)) return c
      return null
    }
    _IsTagPlaying(a) {
      return this._lastAIState.some(c => e.equalsNoCase(a, c.tag) && c.isPlaying)
    }
    _MaybeMarkAsPlaying(a, c, d, f) {
      if (this._IsTagPlaying(a)) return null
      a = {
        tag: a,
        duration: 0,
        volume: f,
        isPlaying: !0,
        playbackTime: 0,
        playbackRate: 1,
        uid: -1,
        bufferOriginalUrl: '',
        bufferUrl: '',
        bufferType: '',
        isMusic: c,
        isLooping: d,
        isMuted: !1,
        resumePosition: 0,
        pan: null,
        placeholder: -1
      }
      this._lastAIState.push(a)
      return a
    }
    async _OnTrigger(a) {
      const c = a.type
      this._triggerTag = a.tag
      a = a.aiid
      if ('ended' === c) {
        for (const d of this._lastAIState)
          if (d.aiid === a) {
            d.isPlaying = !1
            break
          }
        await this.TriggerAsync(e.Plugins.Audio.Cnds.OnEnded)
      } else 'fade-ended' === c && (await this.TriggerAsync(e.Plugins.Audio.Cnds.OnFadeEnded))
    }
    Tick() {
      const a = {
        timeScale: this._runtime.GetTimeScale(),
        gameTime: this._runtime.GetGameTimeRaw(),
        instPans: this.GetInstancePans(),
        tickCount: this._runtime.GetTickCountNoSave()
      }
      if (this._listenerInst) {
        const c = this._listenerInst.GetWorldInfo()
        this._listenerX = c.GetX()
        this._listenerY = c.GetY()
        a.listenerPos = [this._listenerX, this._listenerY, this._listenerZ]
      }
      this.PostToDOM('tick', a)
    }
    rotatePtAround(a, c, d, f, g) {
      if (0 === d) return [a, c]
      const h = Math.sin(d)
      d = Math.cos(d)
      a -= f
      c -= g
      const k = a * h
      a = a * d - c * h
      return [a + f, c * d + k + g]
    }
    GetInstancePans() {
      return this._lastAIState
        .filter(a => -1 !== a.uid)
        .map(a => this._runtime.GetInstanceByUID(a.uid))
        .filter(a => a)
        .map(a => {
          const c = a.GetWorldInfo(),
            d = c.GetLayer().GetAngle(),
            [f, g] = this.rotatePtAround(c.GetX(), c.GetY(), -d, this._listenerX, this._listenerY)
          return {
            uid: a.GetUID(),
            x: f,
            y: g,
            angle: c.GetAngle() - d
          }
        })
    }
    GetAnalyserData(a, c) {
      for (const d of this._lastAnalysersData) if (d.index === c && e.equalsNoCase(d.tag, a)) return d
      return null
    }
    _IncrementEffectCount(a) {
      this._effectCount.set(a, (this._effectCount.get(a) || 0) + 1)
    }
    _ShouldSave(a) {
      return a.hasOwnProperty('placeholder') || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
    }
    SaveToJson() {
      return {
        isSilent: this._isSilent,
        masterVolume: this._masterVolume,
        listenerZ: this._listenerZ,
        listenerUid: this._listenerInst ? this._listenerInst.GetUID() : -1,
        remoteUrls: [...this._remoteUrls.entries()],
        playing: this._lastAIState.filter(a => this._ShouldSave(a)),
        effects: this._lastFxState,
        analysers: this._lastAnalysersData
      }
    }
    LoadFromJson(a) {
      this._isSilent = a.isSilent
      this._masterVolume = a.masterVolume
      this._listenerZ = a.listenerZ
      this._listenerInst = null
      this._loadListenerUid = a.listenerUid
      this._remoteUrls.clear()
      if (a.remoteUrls) for (const [c, d] of a.remoteUrls) this._remoteUrls.set(c, d)
      this._lastAIState = a.playing
      this._lastFxState = a.effects
      this._lastAnalysersData = a.analysers
    }
    _OnAfterLoad() {
      if (-1 !== this._loadListenerUid && ((this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid)), (this._loadListenerUid = -1), this._listenerInst)) {
        var a = this._listenerInst.GetWorldInfo()
        this._listenerX = a.GetX()
        this._listenerY = a.GetY()
      }
      for (var c of this._lastAIState) (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c.bufferOriginalUrl)) ? ((c.bufferUrl = a.url), (c.bufferType = a.type)) : (c.bufferUrl = null)
      for (const d of Object.values(this._lastFxState)) for (const f of d) f.hasOwnProperty('bufferOriginalUrl') && (c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(f.bufferOriginalUrl)) && ((f.bufferUrl = c.url), (f.bufferType = c.type))
      this.PostToDOM('load-state', {
        saveLoadMode: this._saveLoadMode,
        timeScale: this._runtime.GetTimeScale(),
        gameTime: this._runtime.GetGameTimeRaw(),
        listenerPos: [this._listenerX, this._listenerY, this._listenerZ],
        isSilent: this._isSilent,
        masterVolume: this._masterVolume,
        playing: this._lastAIState.filter(d => null !== d.bufferUrl),
        effects: this._lastFxState
      })
    }
    GetDebuggerProperties() {
      const a = []
      for (const [c, d] of Object.entries(this._lastFxState))
        a.push({
          name: '$' + c,
          value: d.map(f => f.type).join(', ')
        })
      return [
        {
          title: 'plugins.audio.debugger.tag-effects',
          properties: a
        },
        {
          title: 'plugins.audio.debugger.currently-playing',
          properties: [
            {
              name: 'plugins.audio.debugger.currently-playing-count',
              value: this._lastAIState.length
            },
            ...this._lastAIState.map((c, d) => ({
              name: '$#' + d,
              value: `${c.bufferOriginalUrl} ("${c.tag}") ${Math.round(10 * c.playbackTime) / 10} / ${Math.round(10 * c.duration) / 10}`
            }))
          ]
        }
      ]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Audio.Cnds = {
    OnEnded(b) {
      return e.equalsNoCase(this._triggerTag, b)
    },
    OnFadeEnded(b) {
      return e.equalsNoCase(this._triggerTag, b)
    },
    PreloadsComplete() {
      return this._preloadCount === this._preloadTotal
    },
    AdvancedAudioSupported() {
      return !0
    },
    IsSilent() {
      return this._isSilent
    },
    IsAnyPlaying() {
      for (const b of this._lastAIState) if (b.isPlaying) return !0
      return !1
    },
    IsTagPlaying(b) {
      return this._IsTagPlaying(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = 'lowpass highpass bandpass lowshelf highshelf peaking notch allpass'.split(' ')
  e.Plugins.Audio.Acts = {
    async Play(a, c, d, f) {
      if (!this._isSilent) {
        var g = a[1],
          h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])
        if (h) {
          var k = this._nextPlayTime
          this._nextPlayTime = 0
          var m = this._MaybeMarkAsPlaying(f.toLowerCase(), g, 0 !== c, this.DbToLinear(d))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: a[0],
              url: h.url,
              type: h.type,
              isMusic: g,
              tag: f.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: 0,
              off: k,
              trueClock: !!self.C3_GetAudioContextCurrentTime
            })
          } finally {
            m && (m.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    async PlayAtPosition(a, c, d, f, g, h, k, m, r, w) {
      if (!this._isSilent) {
        var p = a[1],
          q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])
        if (q) {
          var t = this._nextPlayTime
          this._nextPlayTime = 0
          var x = this._MaybeMarkAsPlaying(w.toLowerCase(), p, 0 !== c, this.DbToLinear(d))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: a[0],
              url: q.url,
              type: q.type,
              isMusic: p,
              tag: w.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: 0,
              off: t,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: f,
                y: g,
                angle: e.toRadians(h),
                innerAngle: e.toRadians(k),
                outerAngle: e.toRadians(m),
                outerGain: this.DbToLinear(r)
              }
            })
          } finally {
            x && (x.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    async PlayAtObject(a, c, d, f, g, h, k, m) {
      if (!this._isSilent && f && (f = f.GetFirstPicked()) && f.GetWorldInfo()) {
        var r = f.GetWorldInfo(),
          w = r.GetLayer().GetAngle(),
          [p, q] = this.rotatePtAround(r.GetX(), r.GetY(), -w, this._listenerX, this._listenerY),
          t = a[1],
          x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])
        if (x) {
          var v = this._nextPlayTime
          this._nextPlayTime = 0
          var u = this._MaybeMarkAsPlaying(m.toLowerCase(), t, 0 !== c, this.DbToLinear(d))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: a[0],
              url: x.url,
              type: x.type,
              isMusic: t,
              tag: m.toLowerCase(),
              isLooping: 0 !== c,
              vol: this.DbToLinear(d),
              pos: 0,
              off: v,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: p,
                y: q,
                angle: r.GetAngle() - w,
                innerAngle: e.toRadians(g),
                outerAngle: e.toRadians(h),
                outerGain: this.DbToLinear(k),
                uid: f.GetUID()
              }
            })
          } finally {
            u && (u.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    async PlayByName(a, c, d, f, g) {
      if (!this._isSilent) {
        a = 1 === a
        var h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) || this._remoteUrls.get(c.toLowerCase())
        if (h) {
          var k = this._nextPlayTime
          this._nextPlayTime = 0
          var m = this._MaybeMarkAsPlaying(g.toLowerCase(), a, 0 !== d, this.DbToLinear(f))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: c,
              url: h.url,
              type: h.type,
              isMusic: a,
              tag: g.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: k,
              trueClock: !!self.C3_GetAudioContextCurrentTime
            })
          } finally {
            m && (m.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    async PlayAtPositionByName(a, c, d, f, g, h, k, m, r, w, p) {
      if (!this._isSilent) {
        a = 1 === a
        var q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) || this._remoteUrls.get(c.toLowerCase())
        if (q) {
          var t = this._nextPlayTime
          this._nextPlayTime = 0
          var x = this._MaybeMarkAsPlaying(p.toLowerCase(), a, 0 !== d, this.DbToLinear(f))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: c,
              url: q.url,
              type: q.type,
              isMusic: a,
              tag: p.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: t,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: g,
                y: h,
                angle: e.toRadians(k),
                innerAngle: e.toRadians(m),
                outerAngle: e.toRadians(r),
                outerGain: this.DbToLinear(w)
              }
            })
          } finally {
            x && (x.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    async PlayAtObjectByName(a, c, d, f, g, h, k, m, r) {
      if (!this._isSilent && !this._isSilent && g && (g = g.GetFirstPicked()) && g.GetWorldInfo()) {
        var w = g.GetWorldInfo(),
          p = w.GetLayer().GetAngle(),
          [q, t] = this.rotatePtAround(w.GetX(), w.GetY(), -p, this._listenerX, this._listenerY)
        a = 1 === a
        var x = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) || this._remoteUrls.get(c.toLowerCase())
        if (x) {
          var v = this._nextPlayTime
          this._nextPlayTime = 0
          var u = this._MaybeMarkAsPlaying(r.toLowerCase(), a, 0 !== d, this.DbToLinear(f))
          try {
            await this.PostToDOMAsync('play', {
              originalUrl: c,
              url: x.url,
              type: x.type,
              isMusic: a,
              tag: r.toLowerCase(),
              isLooping: 0 !== d,
              vol: this.DbToLinear(f),
              pos: 0,
              off: v,
              trueClock: !!self.C3_GetAudioContextCurrentTime,
              panning: {
                x: q,
                y: t,
                angle: w.GetAngle() - p,
                innerAngle: e.toRadians(h),
                outerAngle: e.toRadians(k),
                outerGain: this.DbToLinear(m),
                uid: g.GetUID()
              }
            })
          } finally {
            u && (u.placeholder = this._runtime.GetTickCountNoSave())
          }
        }
      }
    },
    SetLooping(a, c) {
      this.PostToDOM('set-looping', {
        tag: a.toLowerCase(),
        isLooping: 0 === c
      })
    },
    SetMuted(a, c) {
      this.PostToDOM('set-muted', {
        tag: a.toLowerCase(),
        isMuted: 0 === c
      })
    },
    SetVolume(a, c) {
      this.PostToDOM('set-volume', {
        tag: a.toLowerCase(),
        vol: this.DbToLinear(c)
      })
    },
    FadeVolume(a, c, d, f) {
      this.PostToDOM('fade-volume', {
        tag: a.toLowerCase(),
        vol: this.DbToLinear(c),
        duration: d,
        stopOnEnd: 0 === f
      })
    },
    async Preload(a) {
      const c = a[1],
        d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])
      d &&
        (this._preloadTotal++,
        await this.PostToDOMAsync('preload', {
          originalUrl: a[0],
          url: d.url,
          type: d.type,
          isMusic: c
        }),
        this._preloadCount++)
    },
    async PreloadByName(a, c) {
      a = 1 === a
      const d = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) || this._remoteUrls.get(c.toLowerCase())
      d &&
        (this._preloadTotal++,
        await this.PostToDOMAsync('preload', {
          originalUrl: c,
          url: d.url,
          type: d.type,
          isMusic: a
        }),
        this._preloadCount++)
    },
    SetPlaybackRate(a, c) {
      this.PostToDOM('set-playback-rate', {
        tag: a.toLowerCase(),
        rate: Math.max(c, 0)
      })
    },
    Stop(a) {
      this.PostToDOM('stop', {
        tag: a.toLowerCase()
      })
    },
    StopAll() {
      this.PostToDOM('stop-all')
    },
    SetPaused(a, c) {
      this.PostToDOM('set-paused', {
        tag: a.toLowerCase(),
        paused: 0 === c
      })
    },
    Seek(a, c) {
      this.PostToDOM('seek', {
        tag: a.toLowerCase(),
        pos: c
      })
    },
    SetSilent(a) {
      2 === a && (a = this._isSilent ? 1 : 0)
      a = 0 === a
      this._isSilent !== a &&
        ((this._isSilent = a),
        this.PostToDOM('set-silent', {
          isSilent: a
        }))
    },
    SetMasterVolume(a) {
      a = this.DbToLinear(a)
      this._masterVolume !== a &&
        ((this._masterVolume = a),
        this.PostToDOM('set-master-volume', {
          vol: a
        }))
    },
    AddFilterEffect(a, c, d, f, g, h, k) {
      a = a.toLowerCase()
      c = b[c]
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'filter',
        tag: a,
        params: [c, d, f, g, h, e.clamp(k / 100, 0, 1)]
      })
    },
    AddDelayEffect(a, c, d, f) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'delay',
        tag: a,
        params: [c, this.DbToLinear(d), e.clamp(f / 100, 0, 1)]
      })
    },
    AddFlangerEffect(a, c, d, f, g, h) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'flanger',
        tag: a,
        params: [c / 1e3, d / 1e3, f, g / 100, e.clamp(h / 100, 0, 1)]
      })
    },
    AddPhaserEffect(a, c, d, f, g, h, k) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'phaser',
        tag: a,
        params: [c, d, f, g, h, e.clamp(k / 100, 0, 1)]
      })
    },
    AddConvolutionEffect(a, c, d, f) {
      a = a.toLowerCase()
      const g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c[0])
      g &&
        (this._IncrementEffectCount(a),
        this.PostToDOM('add-effect', {
          type: 'convolution',
          tag: a,
          bufferOriginalUrl: c[0],
          bufferUrl: g.url,
          bufferType: g.type,
          params: [0 === d, e.clamp(f / 100, 0, 1)]
        }))
    },
    AddGainEffect(a, c) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'gain',
        tag: a,
        params: [this.DbToLinear(c)]
      })
    },
    AddMuteEffect(a) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'gain',
        tag: a,
        params: [0]
      })
    },
    AddTremoloEffect(a, c, d) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'tremolo',
        tag: a,
        params: [c, e.clamp(d / 100, 0, 1)]
      })
    },
    AddRingModEffect(a, c, d) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'ringmod',
        tag: a,
        params: [c, e.clamp(d / 100, 0, 1)]
      })
    },
    AddDistortionEffect(a, c, d, f, g, h) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'distortion',
        tag: a,
        params: [this.DbToLinearNoCap(c), this.DbToLinearNoCap(d), f, this.DbToLinearNoCap(g), e.clamp(h / 100, 0, 1)]
      })
    },
    AddCompressorEffect(a, c, d, f, g, h) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'compressor',
        tag: a,
        params: [c, d, f, g / 1e3, h / 1e3]
      })
    },
    AddAnalyserEffect(a, c, d) {
      a = a.toLowerCase()
      this._IncrementEffectCount(a)
      this.PostToDOM('add-effect', {
        type: 'analyser',
        tag: a,
        params: [c, d]
      })
    },
    RemoveEffects(a) {
      a = a.toLowerCase()
      this._effectCount.set(a, 0)
      this.PostToDOM('remove-effects', {
        tag: a
      })
      this._lastFxState = {}
    },
    SetEffectParameter(a, c, d, f, g, h) {
      this.PostToDOM('set-effect-param', {
        tag: a.toLowerCase(),
        index: Math.floor(c),
        param: d,
        value: f,
        ramp: g,
        time: h
      })
    },
    SetListenerObject(a) {
      a && (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
    },
    SetListenerZ(a) {
      this._listenerZ = a
    },
    ScheduleNextPlay(a) {
      this._nextPlayTime = Math.max(a, 0)
    },
    UnloadAudio(a) {
      const c = a[1]
      ;(a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) &&
        this.PostToDOM('unload', {
          url: a.url,
          type: a.type,
          isMusic: c
        })
    },
    UnloadAudioByName(a, c) {
      a = 1 === a
      ;(c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(c) || this._remoteUrls.get(c.toLowerCase())) &&
        this.PostToDOM('unload', {
          url: c.url,
          type: c.type,
          isMusic: a
        })
    },
    UnloadAll() {
      this.PostToDOM('unload-all')
    },
    AddRemoteURL(a, c, d) {
      this._remoteUrls.set(d.toLowerCase(), {
        url: a,
        type: c
      })
    }
  }
}
;('use strict')
self.C3.Plugins.Audio.Exps = {
  Duration(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.duration : 0
  },
  PlaybackTime(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackTime : 0
  },
  PlaybackRate(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? e.playbackRate : 0
  },
  Volume(e) {
    return (e = this._GetFirstAudioStateByTag(e)) ? this.LinearToDb(e.volume) : 0
  },
  MasterVolume() {
    return this.LinearToDb(this._masterVolume)
  },
  EffectCount(e) {
    return this._effectCount.get(e.toLowerCase()) || 0
  },
  AnalyserFreqBinCount(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.binCount : 0
  },
  AnalyserFreqBinAt(e, b, a) {
    e = this.GetAnalyserData(e, Math.floor(b))
    if (!e) return 0
    a = Math.floor(a)
    return 0 > a || a >= e.binCount ? 0 : e.freqBins[a]
  },
  AnalyserPeakLevel(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.peak : 0
  },
  AnalyserRMSLevel(e, b) {
    return (e = this.GetAnalyserData(e, Math.floor(b))) ? e.rms : 0
  },
  SampleRate() {
    return this._sampleRate
  },
  CurrentTime() {
    return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Browser = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Browser.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Browser.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, 'browser')
      this._initLocationStr = ''
      this._isOnline = !1
      this._docTitle = this._referrer = ''
      this._isCookieEnabled = !1
      this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0
      this._isScirraArcade = !1
      this.AddDOMMessageHandlers([
        ['online-state', c => this._OnOnlineStateChanged(c)],
        ['backbutton', () => this._OnBackButton()],
        ['sw-message', c => this._OnSWMessage(c)],
        ['hashchange', c => this._OnHashChange(c)]
      ])
      b = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'afterfirstlayoutstart', () => this._OnAfterFirstLayoutStart()),
        e.Disposable.From(b, 'window-resize', () => this._OnWindowResize()),
        e.Disposable.From(b, 'suspend', () => this._OnSuspend()),
        e.Disposable.From(b, 'resume', () => this._OnResume())
      )
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync('get-initial-state', {
          exportType: this._runtime.GetExportType()
        }).then(c => {
          this._initLocationStr = c.location
          this._isOnline = c.isOnline
          this._referrer = c.referrer
          this._docTitle = c.title
          this._isCookieEnabled = c.isCookieEnabled
          this._screenWidth = c.screenWidth
          this._screenHeight = c.screenHeight
          this._windowOuterWidth = c.windowOuterWidth
          this._windowOuterHeight = c.windowOuterHeight
          this._isScirraArcade = c.isScirraArcade
        })
      )
    }
    Release() {
      super.Release()
    }
    _OnAfterFirstLayoutStart() {
      this.PostToDOM('ready-for-sw-messages')
    }
    async _OnOnlineStateChanged(b) {
      b = !!b.isOnline
      this._isOnline !== b && ((this._isOnline = b) ? await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOnline) : await this.TriggerAsync(e.Plugins.Browser.Cnds.OnOffline))
    }
    async _OnWindowResize() {
      await this.TriggerAsync(e.Plugins.Browser.Cnds.OnResize)
    }
    _OnSuspend() {
      this.Trigger(e.Plugins.Browser.Cnds.OnPageHidden)
    }
    _OnResume() {
      this.Trigger(e.Plugins.Browser.Cnds.OnPageVisible)
    }
    async _OnBackButton() {
      await this.TriggerAsync(e.Plugins.Browser.Cnds.OnBackButton)
    }
    _OnSWMessage(b) {
      b = b.type
      'downloading-update' === b ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateFound) : 'update-ready' === b || 'update-pending' === b ? this.Trigger(e.Plugins.Browser.Cnds.OnUpdateReady) : 'offline-ready' === b && this.Trigger(e.Plugins.Browser.Cnds.OnOfflineReady)
    }
    _OnHashChange(b) {
      this._initLocationStr = b.location
      this.Trigger(e.Plugins.Browser.Cnds.OnHashChange)
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.browser.name',
          properties: [
            {
              name: 'plugins.browser.debugger.user-agent',
              value: navigator.userAgent
            },
            {
              name: 'plugins.browser.debugger.is-online',
              value: this._isOnline
            },
            {
              name: 'plugins.browser.debugger.is-fullscreen',
              value: this._runtime.GetCanvasManager().IsDocumentFullscreen()
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Plugins.Browser.Cnds = {
  IsOnline() {
    return this._isOnline
  },
  OnOnline() {
    return !0
  },
  OnOffline() {
    return !0
  },
  OnResize() {
    return !0
  },
  CookiesEnabled() {
    return this._isCookieEnabled
  },
  IsFullscreen() {
    return this._runtime.GetCanvasManager().IsDocumentFullscreen()
  },
  OnBackButton() {
    return !0
  },
  IsPortraitLandscape(e) {
    const b = this._runtime.GetCanvasManager().GetLastWidth(),
      a = this._runtime.GetCanvasManager().GetLastHeight()
    return (b <= a ? 0 : 1) === e
  },
  OnUpdateFound() {
    return !0
  },
  OnUpdateReady() {
    return !0
  },
  OnOfflineReady() {
    return !0
  },
  OnHashChange() {
    return !0
  },
  PageVisible() {
    return !this._runtime.IsSuspended()
  },
  OnPageHidden() {
    return !0
  },
  OnPageVisible() {
    return !0
  },
  HasJava() {
    return !1
  },
  IsDownloadingUpdate() {
    return !1
  },
  OnMenuButton() {
    return !1
  },
  OnSearchButton() {
    return !1
  },
  IsMetered() {
    return !1
  },
  IsCharging() {
    return !0
  },
  SupportsFullscreen() {
    return !0
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = 'portrait landscape portrait-primary portrait-secondary landscape-primary landscape-secondary'.split(' ')
  e.Plugins.Browser.Acts = {
    Alert(a) {
      this.PostToDOM('alert', {
        message: a.toString()
      })
    },
    Close() {
      this._isScirraArcade || (this._runtime.IsDebug() ? self.C3Debugger.CloseWindow() : this.PostToDOM('close'))
    },
    Focus() {
      this.PostToDOM('set-focus', {
        isFocus: !0
      })
    },
    Blur() {
      this.PostToDOM('set-focus', {
        isFocus: !1
      })
    },
    GoBack() {
      this._isScirraArcade ||
        this.PostToDOM('navigate', {
          type: 'back'
        })
    },
    GoForward() {
      this._isScirraArcade ||
        this.PostToDOM('navigate', {
          type: 'forward'
        })
    },
    GoHome() {},
    Reload() {
      this._isScirraArcade ||
        (this._runtime.IsDebug()
          ? this._runtime.PostToDebugger({
              type: 'reload'
            })
          : this.PostToDOM('navigate', {
              type: 'reload'
            }))
    },
    GoToURL(a, c) {
      this._PostToDOMMaybeSync('navigate', {
        type: 'url',
        url: a,
        target: c,
        exportType: this._runtime.GetExportType()
      })
    },
    GoToURLWindow(a, c) {
      this._PostToDOMMaybeSync('navigate', {
        type: 'new-window',
        url: a,
        tag: c,
        exportType: this._runtime.GetExportType()
      })
    },
    RequestFullScreen(a, c) {
      2 <= a && (a += 1)
      6 === a && (a = 2)
      1 === a && (a = 0)
      a = e.CanvasManager._FullscreenModeNumberToString(a)
      this._runtime.GetCanvasManager().SetDocumentFullscreenMode(a)
      this._PostToDOMMaybeSync('request-fullscreen', {
        navUI: c
      })
    },
    CancelFullScreen() {
      this._PostToDOMMaybeSync('exit-fullscreen')
    },
    Vibrate(a) {
      a = a.split(',')
      for (let c = 0, d = a.length; c < d; ++c) a[c] = parseInt(a[c], 10)
      this._PostToDOMMaybeSync('vibrate', {
        pattern: a
      })
    },
    async InvokeDownload(a, c) {
      a && c && ((a = await this._runtime.GetAssetManager().GetProjectFileUrl(a)), this._runtime.InvokeDownload(a, c))
    },
    InvokeDownloadString(a, c, d) {
      d && ((a = `data:${c},${encodeURIComponent(a)}`), this._runtime.InvokeDownload(a, d))
    },
    ConsoleLog(a, c) {
      c = c.toString()
      0 === a ? console.log(c) : 1 === a ? console.warn(c) : 2 === a && console.error(c)
    },
    ConsoleGroup(a) {
      console.group(a)
    },
    ConsoleGroupEnd() {
      console.groupEnd()
    },
    ExecJs(a) {
      try {
        eval(a)
      } catch (c) {
        console.error('Error executing JavaScript: ', c)
      }
    },
    LockOrientation(a) {
      a = Math.floor(a)
      0 > a ||
        a >= b.length ||
        this._PostToDOMMaybeSync('lock-orientation', {
          orientation: b[a]
        })
    },
    UnlockOrientation() {
      this._PostToDOMMaybeSync('unlock-orientation')
    },
    LoadStyleSheet(a) {
      this._runtime.GetAssetManager().LoadStyleSheet(a)
    },
    SetHash(a) {
      this.PostToDOM('set-hash', {
        hash: a
      })
    }
  }
}
;('use strict')
self.C3.Plugins.Browser.Exps = {
  URL() {
    return this._runtime.IsInWorker() ? this._initLocationStr : location.toString()
  },
  Protocol() {
    return this._runtime.IsInWorker() ? new URL(this._initLocationStr).protocol : location.protocol
  },
  Domain() {
    return this._runtime.IsInWorker() ? "www.greatmathgame.com" : "www.greatmathgame.com"
  },
  Port() {
    return this._runtime.IsInWorker() ? new URL(this._initLocationStr).port : location.port
  },
  PathName() {
    return this._runtime.IsInWorker() ? new URL(this._initLocationStr).pathname : location.pathname
  },
  Hash() {
    return this._runtime.IsInWorker() ? new URL(this._initLocationStr).hash : location.hash
  },
  QueryString() {
    return this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search
  },
  QueryParam(e) {
    const b = this._runtime.IsInWorker() ? new URL(this._initLocationStr).search : location.search
    return (e = RegExp('[?&]' + e + '=([^&]*)').exec(b)) ? decodeURIComponent(e[1].replace(/\+/g, ' ')) : ''
  },
  Referrer() {
    return this._referrer
  },
  Title() {
    return this._docTitle
  },
  Language() {
    return navigator.language
  },
  Platform() {
    return navigator.platform
  },
  UserAgent() {
    return navigator.userAgent
  },
  ExecJS(e) {
    let b = 0
    try {
      b = eval(e)
    } catch (a) {
      console.error('Error executing JavaScript: ', a)
    }
    return 'number' === typeof b || 'string' === typeof b ? b : 'boolean' === typeof b ? (b ? 1 : 0) : 0
  },
  Name() {
    return navigator.appName
  },
  Version() {
    return navigator.appVersion
  },
  Product() {
    return navigator.product
  },
  Vendor() {
    return navigator.vendor
  },
  BatteryLevel() {
    return 1
  },
  BatteryTimeLeft() {
    return Infinity
  },
  Bandwidth() {
    const e = navigator.connection
    return e ? e.downlink || e.downlinkMax || e.bandwidth || Infinity : Infinity
  },
  ConnectionType() {
    const e = navigator.connection
    return e ? e.type || 'unknown' : 'unknown'
  },
  DevicePixelRatio() {
    return self.devicePixelRatio
  },
  ScreenWidth() {
    return this._screenWidth
  },
  ScreenHeight() {
    return this._screenHeight
  },
  WindowInnerWidth() {
    return this._runtime.GetCanvasManager().GetLastWidth()
  },
  WindowInnerHeight() {
    return this._runtime.GetCanvasManager().GetLastHeight()
  },
  WindowOuterWidth() {
    return this._windowOuterWidth
  },
  WindowOuterHeight() {
    return this._windowOuterWidth
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.LocalStorage = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.LocalStorage.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.LocalStorage.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b)
      this._lastValue = this._currentKey = ''
      this._keyNamesList = []
      this._errorMessage = ''
      this._pendingSets = this._pendingGets = 0
      this._storage = this._runtime._GetProjectStorage()
      this._debugCache = new Map()
      this._isLoadingDebugCache = !1
    }
    Release() {
      super.Release()
    }
    async _TriggerStorageError(b) {
      this._errorMessage = this._GetErrorString(b)
      await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnError)
    }
    _GetErrorString(b) {
      return b ? ('string' === typeof b ? b : 'string' === typeof b.message ? b.message : 'string' === typeof b.name ? b.name : 'string' === typeof b.data ? b.data : 'unknown error') : 'unknown error'
    }
    GetDebuggerProperties() {
      this._isLoadingDebugCache || this._DebugCacheStorage()
      return [
        {
          title: 'plugins.localstorage.name',
          properties: [...this._debugCache.entries()].map(b => ({
            name: '$' + b[0],
            value: b[1],
            onedit: a => this._storage.setItem(b[0], a)
          }))
        }
      ]
    }
    async _DebugCacheStorage() {
      this._isLoadingDebugCache = !0
      try {
        const b = await this._storage.keys()
        b.sort((c, d) => {
          c = c.toLowerCase()
          d = d.toLowerCase()
          return c < d ? -1 : d < c ? 1 : 0
        })
        const a = await Promise.all(b.map(c => this._storage.getItem(c)))
        this._debugCache.clear()
        for (let c = 0, d = b.length; c < d; ++c) this._debugCache.set(b[c], a[c])
      } catch (b) {
        console.warn('[C3 debugger] Error displaying local storage: ', b)
      } finally {
        this._isLoadingDebugCache = !1
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.LocalStorage.Cnds = {
    OnItemSet(b) {
      return this._currentKey === b
    },
    OnAnyItemSet() {
      return !0
    },
    OnItemGet(b) {
      return this._currentKey === b
    },
    OnAnyItemGet() {
      return !0
    },
    OnItemRemoved(b) {
      return this._currentKey === b
    },
    OnAnyItemRemoved() {
      return !0
    },
    OnCleared() {
      return !0
    },
    OnAllKeyNamesLoaded() {
      return !0
    },
    OnError() {
      return !0
    },
    OnItemExists(b) {
      return this._currentKey === b
    },
    OnItemMissing(b) {
      return this._currentKey === b
    },
    CompareKey(b, a) {
      return e.compare(this._currentKey, b, a)
    },
    CompareValue(b, a) {
      return e.compare(this._lastValue, b, a)
    },
    IsProcessingSets() {
      return 0 < this._pendingSets
    },
    IsProcessingGets() {
      return 0 < this._pendingGets
    },
    OnAllSetsComplete() {
      return !0
    },
    OnAllGetsComplete() {
      return !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a) {
    return 'string' === typeof a || 'number' === typeof a
  }
  e.Plugins.LocalStorage.Acts = {
    async SetItem(a, c) {
      this._pendingSets++
      try {
        const d = await this._storage.setItem(a, c)
        await this.ScheduleTriggers(async () => {
          this._currentKey = a
          this._lastValue = d
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet)
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet)
        })
      } catch (d) {
        await this._TriggerStorageError(d)
      } finally {
        this._pendingSets--, 0 === this._pendingSets && (await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllSetsComplete))
      }
    },
    async SetBinaryItem(a, c) {
      if (c && (c = c.GetFirstPicked(this._inst)) && (c = c.GetSdkInstance())) {
        c = c.GetArrayBufferReadOnly()
        this._pendingSets++
        try {
          await this._storage.setItem(a, c),
            await this.ScheduleTriggers(async () => {
              this._currentKey = a
              this._lastValue = ''
              await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemSet)
              await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemSet)
            })
        } catch (d) {
          await this._TriggerStorageError(d)
        } finally {
          this._pendingSets--, 0 === this._pendingSets && (await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllSetsComplete))
        }
      }
    },
    async GetItem(a) {
      this._pendingGets++
      try {
        const c = await this._storage.getItem(a)
        await this.ScheduleTriggers(async () => {
          this._currentKey = a
          this._lastValue = b(c) ? c : ''
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet)
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet)
        })
      } catch (c) {
        await this._TriggerStorageError(c)
      } finally {
        this._pendingGets--, 0 === this._pendingGets && (await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllGetsComplete))
      }
    },
    async GetBinaryItem(a, c) {
      if (c && (c = c.GetFirstPicked(this._inst))) {
        var d = c.GetSdkInstance()
        this._pendingGets++
        try {
          let f = await this._storage.getItem(a)
          f = f instanceof ArrayBuffer ? f : new ArrayBuffer(0)
          await this.ScheduleTriggers(async () => {
            this._lastValue = ''
            this._currentKey = a
            d.SetArrayBufferTransfer(f)
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemGet)
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemGet)
          })
        } catch (f) {
          await this._TriggerStorageError(f)
        } finally {
          this._pendingGets--, 0 === this._pendingGets && (await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllGetsComplete))
        }
      }
    },
    async CheckItemExists(a) {
      try {
        const c = await this._storage.getItem(a)
        await this.ScheduleTriggers(async () => {
          this._currentKey = a
          'undefined' === typeof c || null === c ? ((this._lastValue = ''), await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemMissing)) : ((this._lastValue = b(c) ? c : ''), await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemExists))
        })
      } catch (c) {
        await this._TriggerStorageError(c)
      }
    },
    async RemoveItem(a) {
      try {
        await this._storage.removeItem(a),
          await this.ScheduleTriggers(async () => {
            this._currentKey = a
            this._lastValue = ''
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAnyItemRemoved)
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnItemRemoved)
          })
      } catch (c) {
        await this._TriggerStorageError(c)
      }
    },
    async ClearStorage() {
      try {
        await this._storage.clear(),
          await this.ScheduleTriggers(async () => {
            this._lastValue = this._currentKey = ''
            e.clearArray(this._keyNamesList)
            await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnCleared)
          })
      } catch (a) {
        await this._TriggerStorageError(a)
      }
    },
    async GetAllKeyNames() {
      try {
        const a = await this._storage.keys()
        await this.ScheduleTriggers(async () => {
          this._keyNamesList = a
          await this.TriggerAsync(e.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)
        })
      } catch (a) {
        await this._TriggerStorageError(a)
      }
    }
  }
}
;('use strict')
self.C3.Plugins.LocalStorage.Exps = {
  ItemValue() {
    return this._lastValue
  },
  Key() {
    return this._currentKey
  },
  KeyCount() {
    return this._keyNamesList.length
  },
  KeyAt(e) {
    e = Math.floor(e)
    return 0 > e || e >= this._keyNamesList.length ? '' : this._keyNamesList[e]
  },
  ErrorMessage() {
    return this._errorMessage
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.NodeWebkit = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.NodeWebkit.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map([
      ['EACCES', 'access denied'],
      ['EEXIST', 'file exists'],
      ['EISDIR', 'is a directory'],
      ['EMFILE', 'too many open files'],
      ['ENOENT', 'no such file or directory'],
      ['ENOTDIR', 'not a directory'],
      ['ENOTEMPTY', 'directory not empty'],
      ['EPERM', 'operation not permitted']
    ])
  e.Plugins.NodeWebkit.Instance = class extends e.SDKInstanceBase {
    constructor(a, c) {
      super(a, 'nwjs')
      this._isNWjs = 'nwjs' === this._runtime.GetExportType() || (this._runtime.IsPreview() && /nwjs\//i.test(navigator.userAgent))
      this._os = this._process = this._childProcess = this._fs = this._path = null
      this._projectFilesFolder = this._userFolder = this._appFolder = this._fileError = this._currentTag = ''
      this._slash = '\\'
      this._fileList = []
      this._chosenPath = this._droppedFile = ''
      this._argv = []
      this._windowTitle = this._clipboardText = ''
      this._windowHeight = this._windowWidth = this._windowY = this._windowX = 0
      this._isNWjs && this._InitNWjs()
    }
    _InitNWjs() {
      this._path = require('path')
      this._fs = require('fs')
      this._childProcess = require('child_process')
      this._process = self.process || nw.process
      this._os = require('os')
      'win32' !== this._process.platform && (this._slash = '/')
      this._appFolder = this._path.dirname(this._process.execPath) + this._slash
      this._userFolder = this._os.homedir() + this._slash
      this._projectFilesFolder = this._process.mainModule.filename
      const a = Math.max(this._projectFilesFolder.lastIndexOf('/'), this._projectFilesFolder.lastIndexOf('\\'))
      ;-1 !== a && (this._projectFilesFolder = this._projectFilesFolder.substr(0, a + 1))
      this.AddDOMMessageHandlers([
        ['drop', c => this._OnDrop(c)],
        ['open-dlg', c => this._OnOpenDlg(c)],
        ['open-dlg-cancel', () => this._OnOpenDlgCancel()],
        ['folder-dlg', c => this._OnFolderDlg(c)],
        ['folder-dlg-cancel', () => this._OnFolderDlgCancel()],
        ['save-dlg', c => this._OnSaveDlg(c)],
        ['save-dlg-cancel', () => this._OnSaveDlgCancel()],
        ['window-change', c => this._OnWindowChange(c)],
        ['clipboard-change', c => this._OnClipboardChange(c)]
      ])
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync('init').then(c => {
          this._OnWindowChange(c)
          this._OnClipboardChange(c)
          this._argv = c.argv
        })
      )
    }
    Release() {
      super.Release()
    }
    _OnWindowChange(a) {
      this._windowTitle = a['window-title']
      this._windowX = a['window-x']
      this._windowY = a['window-y']
      this._windowWidth = a['window-width']
      this._windowHeight = a['window-height']
    }
    _OnClipboardChange(a) {
      this._clipboardText = a['clipboard-text']
    }
    _BufferToArrayBuffer(a) {
      const c = a.buffer,
        d = a.byteLength,
        f = a.byteOffset
      return c.byteLength !== a.length ? c.slice(f, f + d) : c
    }
    _GetBinaryDataSdkInstance(a) {
      return a ? ((a = a.GetFirstPicked(this._inst)) ? a.GetSdkInstance() : null) : null
    }
    _ReadBinaryFile(a) {
      return new Promise((c, d) => {
        this._fs.readFile(a, {}, (f, g) => {
          f ? d(f) : c(this._BufferToArrayBuffer(g))
        })
      })
    }
    _WriteBinaryFile(a, c) {
      e.WeakRequireInstanceOf(c, ArrayBuffer)
      const d = new Uint8Array(c)
      return new Promise((f, g) => {
        this._fs.writeFile(a, d, {}, h => {
          h ? g(h) : f()
        })
      })
    }
    _GetFileError(a) {
      return a && 'string' === typeof a.code ? b.get(a.code) || a.code : 'unknown error'
    }
    _OnFileSystemError(a) {
      this._fileError = this._GetFileError(a)
      this.Trigger(e.Plugins.NodeWebkit.Cnds.OnFileSystemError)
      this._fileError = ''
    }
    async _OnDrop(a) {
      a = a.filePaths
      for (const c of a) (this._droppedFile = c), await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFileDrop)
      this._droppedFile = ''
    }
    async _OnOpenDlg(a) {
      this._chosenPath = a.chosenPath
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnOpenDlg)
    }
    async _OnOpenDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnOpenDlgCancel)
    }
    async _OnFolderDlg(a) {
      this._chosenPath = a.chosenPath
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFolderDlg)
    }
    async _OnFolderDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnFolderDlgCancel)
    }
    async _OnSaveDlg(a) {
      this._chosenPath = a.chosenPath
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnSaveDlg)
    }
    async _OnSaveDlgCancel() {
      await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnSaveDlgCancel)
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.nodewebkit.name',
          properties: [
            {
              name: 'plugins.nodewebkit.debugger.app-folder',
              value: this._appFolder
            },
            {
              name: 'plugins.nodewebkit.debugger.user-folder',
              value: this._userFolder
            },
            {
              name: 'plugins.nodewebkit.debugger.project-files-folder',
              value: this._projectFilesFolder
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Plugins.NodeWebkit.Cnds = {
  PathExists(e) {
    return this._isNWjs ? this._fs.existsSync(e) : !1
  },
  OnBinaryFileRead(e) {
    return this._currentTag === e
  },
  OnBinaryFileWritten(e) {
    return this._currentTag === e
  },
  OnFileSystemError() {
    return !0
  },
  OnFileDrop() {
    return !0
  },
  OnOpenDlg() {
    return !0
  },
  OnFolderDlg() {
    return !0
  },
  OnSaveDlg() {
    return !0
  },
  OnOpenDlgCancel() {
    return !0
  },
  OnFolderDlgCancel() {
    return !0
  },
  OnSaveDlgCancel() {
    return !0
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a, c, d) {
    'function' === typeof a.copyfileSync
      ? a.copyfileSync(c, d)
      : ((c = a.readFileSync(c, {
          flags: 'rb'
        })),
        a.writeFileSync(d, c, {
          flags: 'wb'
        }))
  }
  e.Plugins.NodeWebkit.Acts = {
    WriteTextFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.writeFileSync(a, c, {
            encoding: 'utf8'
          })
        } catch (d) {
          console.error(`Error writing text file '${a}': `, d), this._OnFileSystemError(d)
        }
    },
    async ReadBinaryFile(a, c, d) {
      d = this._GetBinaryDataSdkInstance(d)
      if (this._isNWjs && d)
        try {
          const f = await this._ReadBinaryFile(c)
          d.SetArrayBufferTransfer(f)
          this._currentTag = a
          await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnBinaryFileRead)
          this._currentTag = ''
        } catch (f) {
          console.error(`Error reading binary file '${c}': `, f), this._OnFileSystemError(f)
        }
    },
    async WriteBinaryFile(a, c, d) {
      d = this._GetBinaryDataSdkInstance(d)
      if (this._isNWjs && d)
        try {
          const f = d.GetArrayBufferReadOnly()
          await this._WriteBinaryFile(c, f)
          this._currentTag = a
          await this.TriggerAsync(e.Plugins.NodeWebkit.Cnds.OnBinaryFileWritten)
          this._currentTag = ''
        } catch (f) {
          console.error(`Error writing binary file '${c}': `, f), this._OnFileSystemError(f)
        }
    },
    RenameFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.renameSync(a, c)
        } catch (d) {
          console.error(`Error renaming file '${a}': `, d), this._OnFileSystemError(d)
        }
    },
    DeleteFile(a) {
      if (this._isNWjs)
        try {
          this._fs.unlinkSync(a)
        } catch (c) {
          'ENOENT' !== c.code && (console.error(`Error deleting file '${a}': `, c), this._OnFileSystemError(c))
        }
    },
    CopyFile(a, c) {
      if (this._isNWjs)
        try {
          b(this._fs, a, c)
        } catch (d) {
          console.error(`Error copying file '${a}': `, d), this._OnFileSystemError(d)
        }
    },
    MoveFile(a, c) {
      if (this._isNWjs && a !== c)
        try {
          b(this._fs, a, c), this._fs.existsSync(c) && this._fs.unlinkSync(a)
        } catch (d) {
          console.error(`Error moving file '${a}': `, d), this._OnFileSystemError(d)
        }
    },
    RunFile(a) {
      this._isNWjs && this._childProcess.exec(a, () => {})
    },
    ShellOpen(a) {
      this._isNWjs &&
        this.PostToDOM('shell-cmd', {
          method: 'openItem',
          arg: a
        })
    },
    OpenBrowser(a) {
      this._isNWjs &&
        this.PostToDOM('shell-cmd', {
          method: 'openExternal',
          arg: a
        })
    },
    CreateFolder(a) {
      if (this._isNWjs)
        try {
          this._fs.mkdirSync(a)
        } catch (c) {
          console.error(`Error creating folder '${a}': `, c), this._OnFileSystemError(c)
        }
    },
    AppendFile(a, c) {
      if (this._isNWjs)
        try {
          this._fs.appendFileSync(a, c, {
            encoding: 'utf8'
          })
        } catch (d) {
          console.error(`Error appending to file '${a}': `, d), this._OnFileSystemError(d)
        }
    },
    ListFiles(a) {
      if (this._isNWjs)
        try {
          this._fileList = this._fs.readdirSync(a)
        } catch (c) {
          ;(this._fileList = []), console.error(`Error listing files at '${a}': `, c), this._OnFileSystemError(c)
        }
    },
    ShowOpenDlg(a) {
      this._isNWjs &&
        this.PostToDOM('show-open-dlg', {
          accept: a
        })
    },
    ShowFolderDlg() {
      this._isNWjs && this.PostToDOM('show-folder-dlg')
    },
    ShowSaveDlg(a) {
      this._isNWjs &&
        this.PostToDOM('show-save-dlg', {
          accept: a
        })
    },
    SetWindowX(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-x', {
          x: a
        })
    },
    SetWindowY(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-y', {
          y: a
        })
    },
    SetWindowWidth(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-width', {
          width: a
        })
    },
    SetWindowHeight(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-height', {
          height: a
        })
    },
    SetWindowTitle(a) {
      this._isNWjs &&
        ((this._windowTitle = a),
        this.PostToDOM('set-title', {
          title: a
        }))
    },
    WindowMinimize() {
      this._isNWjs &&
        this.PostToDOM('window-cmd', {
          method: 'minimize'
        })
    },
    WindowMaximize() {
      this._isNWjs &&
        this.PostToDOM('window-cmd', {
          method: 'maximize'
        })
    },
    WindowUnmaximize() {
      this._isNWjs &&
        this.PostToDOM('window-cmd', {
          method: 'unmaximize'
        })
    },
    WindowRestore() {
      this._isNWjs &&
        this.PostToDOM('window-cmd', {
          method: 'restore'
        })
    },
    WindowRequestAttention(a) {
      this._isNWjs &&
        this.PostToDOM('window-attention', {
          request: a ? 3 : 0
        })
    },
    WindowSetMaxSize(a, c) {
      this._isNWjs &&
        this.PostToDOM('set-window-max-size', {
          width: a,
          height: c
        })
    },
    WindowSetMinSize(a, c) {
      this._isNWjs &&
        this.PostToDOM('set-window-min-size', {
          width: a,
          height: c
        })
    },
    WindowSetResizable(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-resizable', {
          resizable: 0 !== a
        })
    },
    WindowSetAlwaysOnTop(a) {
      this._isNWjs &&
        this.PostToDOM('set-window-always-top', {
          top: 0 !== a
        })
    },
    ShowDevTools() {
      this._isNWjs &&
        this.PostToDOM('window-cmd', {
          method: 'showDevTools'
        })
    },
    SetClipboardText(a) {
      this._isNWjs &&
        ((this._clipboardText = a),
        this.PostToDOM('set-clipboard', {
          text: a
        }))
    },
    ClearClipboard() {
      this._isNWjs && ((this._clipboardText = ''), this.PostToDOM('clear-clipboard'))
    }
  }
}
;('use strict')
self.C3.Plugins.NodeWebkit.Exps = {
  AppFolder() {
    return this._appFolder
  },
  AppFolderURL() {
    return 'file://' + this._appFolder
  },
  ProjectFilesFolder() {
    return this._projectFilesFolder
  },
  ProjectFilesFolderURL() {
    return 'file://' + this._projectFilesFolder
  },
  UserFolder() {
    return this._userFolder
  },
  ReadFile(e) {
    if (!this._isNWjs) return ''
    let b = ''
    try {
      b = this._fs.readFileSync(e, {
        encoding: 'utf8'
      })
    } catch (a) {
      console.error(`Failed to read file '${e}': `, a), this._OnFileSystemError(a)
    }
    return b
  },
  FileSize(e) {
    if (!this._isNWjs) return 0
    let b = 0
    try {
      const a = this._fs.statSync(e)
      a && (b = a.size || 0)
    } catch (a) {
      console.error(`Failed to read file '${e}' size: `, a), this._OnFileSystemError(a)
    }
    return b
  },
  ListCount() {
    return this._fileList.length
  },
  ListAt(e) {
    e = Math.floor(e)
    return 0 > e || e >= this._fileList.length ? '' : this._fileList[e]
  },
  DroppedFile() {
    return this._droppedFile
  },
  ChosenPath() {
    return this._chosenPath
  },
  WindowX() {
    return this._windowX
  },
  WindowY() {
    return this._windowY
  },
  WindowWidth() {
    return this._windowWidth
  },
  WindowHeight() {
    return this._windowHeight
  },
  WindowTitle() {
    return this._windowTitle
  },
  ClipboardText() {
    return this._isNWjs ? this._clipboardText : ''
  },
  ArgumentCount() {
    return this._isNWjs ? this._argv.length : 0
  },
  ArgumentAt(e) {
    if (!this._isNWjs) return ''
    e = Math.floor(e)
    const b = this._argv
    return 0 > e || e >= b.length ? '' : b[e]
  },
  FileError() {
    return this._fileError
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Particles = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Particles.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(b) {
      return this.GetImageInfo().LoadStaticTexture(b, {
        sampling: this._runtime.GetSampling()
      })
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Rect)
  e.Plugins.Particles.Instance = class extends e.SDKWorldInstanceBase {
    constructor(a, c) {
      super(a)
      this._isFirstTick = !0
      this._particleEngine = a = e.New(self.ParticleEngine)
      a.ononeshotfinish = () => this._OnOneShotFinish()
      this._spawnObjectClass = null
      this._particleUpdateCallback = (f, g, h, k, m, r) => this._OnParticleUpdate(f, g, h, k, m, r)
      this._particleDestroyCallback = f => this._OnParticleDestroy(f)
      this._hasAnyDefaultParticle = !0
      c &&
        (a.SetRate(c[0]),
        a.SetSprayCone(e.toRadians(c[1])),
        a.SetSprayType(c[2] ? 'one-shot' : 'continuous-spray'),
        this._SetParticleObjectClass(this._runtime.GetObjectClassBySID(c[3])),
        a.SetInitSpeed(c[4]),
        a.SetInitSize(c[5]),
        a.SetInitOpacity(c[6] / 100),
        a.SetGrowRate(c[7]),
        a.SetInitXRandom(c[8]),
        a.SetInitYRandom(c[9]),
        a.SetInitSpeedRandom(c[10]),
        a.SetInitSizeRandom(c[11]),
        a.SetGrowRandom(c[12]),
        a.SetAcceleration(c[13]),
        a.SetGravity(c[14]),
        a.SetLifeAngleRandom(c[15]),
        a.SetLifeSpeedRandom(c[16]),
        a.SetLifeOpacityRandom(c[17]),
        a.SetDestroyModeIndex(c[18]),
        a.SetTimeout(c[19]))
      this._UpdateEngineParameters()
      this._spawnObjectClass && (this._hasAnyDefaultParticle = !1)
      'one-shot' === a.GetSprayType() ? a.CreateOneShotSpray() : a.SetSpraying(!0)
      const d = this.GetWorldInfo()
      d.SetBboxChangeEventEnabled(!0)
      this._inst.Dispatcher().addEventListener('bboxchange', () => {
        d.OverwriteBoundingBox(this._particleEngine.GetBoundingBox())
      })
      this.GetRuntime().GetRenderer().IsWebGPU() && d.SetUsePointsShaderProgram()
      this._StartTicking()
    }
    Release() {
      this._particleEngine.Release()
      this._particleDestroyCallback = this._particleUpdateCallback = this._particleEngine = null
      super.Release()
    }
    _SetParticleObjectClass(a) {
      a === this.GetObjectClass() && (a = null)
      this._spawnObjectClass = a
      this._particleEngine.onparticlecreate = a ? c => this._OnParticleCreate(c) : null
      this._spawnObjectClass || (this._hasAnyDefaultParticle = !0)
    }
    _UpdateEngineParameters() {
      const a = this._particleEngine,
        c = this.GetWorldInfo()
      a.SetMasterOpacity(c.GetOpacity())
      a.SetPixelRounding(this._runtime.IsPixelRoundingEnabled())
      a.SetSpawnX(c.GetX())
      a.SetSpawnY(c.GetY())
      a.SetSpawnAngle(c.GetAngle())
      a.SetInitSizeScale(c.GetSceneGraphScale())
    }
    _OnOneShotFinish() {
      this._runtime.DestroyInstance(this._inst)
    }
    Draw(a) {
      if (this._hasAnyDefaultParticle) {
        var c = this._objectClass.GetImageInfo(),
          d = c.GetTexture()
        if (d) {
          var f = this.GetWorldInfo(),
            g = f.GetLayer()
          this._runtime.GetCanvasManager().IsPastingToDrawingCanvas() ? b.set(-Infinity, -Infinity, Infinity, Infinity) : g.GetViewportForZ(f.GetTotalZElevation(), b)
          a.SetTexture(d)
          d = g.Get2DScaleFactorToZ(f.GetTotalZElevation())
          this._particleEngine.SetParticleScale(g.GetRenderScale() * d)
          this._particleEngine.Draw(a, c.GetTexRect(), b)
        }
      }
    }
    SaveToJson() {
      const a = this._particleEngine
      return {
        r: a.GetRate(),
        sc: a.GetSprayCone(),
        st: a.GetSprayType(),
        isp: a.GetInitSpeed(),
        isz: a.GetInitSize(),
        io: a.GetInitOpacity(),
        gr: a.GetGrowRate(),
        xr: a.GetInitXRandom(),
        yr: a.GetInitYRandom(),
        spr: a.GetInitSpeedRandom(),
        szr: a.GetInitSizeRandom(),
        grnd: a.GetGrowRandom(),
        acc: a.GetAcceleration(),
        g: a.GetGravity(),
        lar: a.GetLifeAngleRandom(),
        lsr: a.GetLifeSpeedRandom(),
        lor: a.GetLifeOpacityRandom(),
        dm: a.GetDestroyModeIndex(),
        to: a.GetTimeout(),
        s: a.IsSpraying(),
        pcc: a._GetCreateCounter(),
        ft: this._isFirstTick,
        p: a.GetParticles().map(c => c.toJSON())
      }
    }
    LoadFromJson(a) {
      var c = this._particleEngine
      c.SetRate(a.r)
      c.SetSprayCone(a.sc)
      c.SetSprayType(a.st)
      c.SetInitSpeed(a.isp)
      c.SetInitSize(a.isz)
      c.SetInitOpacity(a.io)
      c.SetGrowRate(a.gr)
      c.SetInitXRandom(a.xr)
      c.SetInitYRandom(a.yr)
      c.SetInitSpeedRandom(a.spr)
      c.SetInitSizeRandom(a.szr)
      c.SetGrowRandom(a.grnd)
      c.SetAcceleration(a.acc)
      c.SetGravity(a.g)
      c.SetLifeAngleRandom(a.lar)
      c.SetLifeSpeedRandom(a.lsr)
      c.SetLifeOpacityRandom(a.lor)
      c.SetDestroyModeIndex(a.dm)
      c.SetTimeout(a.to)
      c.SetSpraying(a.s)
      c._SetCreateCounter(a.pcc)
      this._isFirstTick = a.ft
      a = a.p
      c.SetParticleCount(a.length)
      c = c.GetParticles()
      for (let d = 0, f = c.length; d < f; ++d) c[d].setFromJSON(a[d])
    }
    Tick() {
      const a = this._runtime.GetDt(this._inst)
      this._UpdateEngineParameters()
      this._isFirstTick && 'one-shot' === this._particleEngine.GetSprayType() && this._particleEngine.ReInitAllParticles()
      this._particleEngine.Tick(a)
      this._particleEngine.IsSpraying() && this._runtime.UpdateRender()
      this.GetWorldInfo().SetBboxChanged()
      this._isFirstTick = !1
    }
    _OnParticleCreate(a) {
      const c = this._runtime.CreateInstance(this._spawnObjectClass, this.GetWorldInfo().GetLayer(), a.GetX(), a.GetY()),
        d = c.GetWorldInfo()
      d.SetSize(a.GetSize(), a.GetSize())
      d.SetAngle(a.GetAngle())
      d.SetOpacity(a.GetOpacity())
      d.SetUnpremultipliedColor(this.GetWorldInfo().GetUnpremultipliedColor())
      d.SetBboxChanged()
      d.ZOrderMoveAdjacentToInstance(this.GetInstance(), !0)
      c._TriggerOnCreated()
      a.SetUpdateCallback(this._particleUpdateCallback)
      a.SetDestroyCallback(this._particleDestroyCallback)
      return c
    }
    _OnParticleUpdate(a, c, d, f, g, h) {
      a.IsDestroyed() || ((a = a.GetWorldInfo()), a.OffsetXY(c, d), a.SetSize(a.GetWidth() + f, a.GetHeight() + f), a.SetAngle(a.GetAngle() + g), a.SetOpacity(a.GetOpacity() + h), a.SetBboxChanged())
    }
    _OnParticleDestroy(a) {
      a.IsDestroyed() || this._runtime.DestroyInstance(a)
    }
    GetPropertyValueByIndex(a) {
      const c = this._particleEngine
      switch (a) {
        case 0:
          return c.GetRate()
        case 1:
          return e.toDegrees(c.GetSprayCone())
        case 2:
          return 'one-shot' === c.GetSprayType() ? 1 : 0
        case 4:
          return c.GetInitSpeed()
        case 5:
          return c.GetInitSize()
        case 6:
          return 100 * c.GetInitOpacity()
        case 7:
          return c.GetGrowRate()
        case 8:
          return c.GetInitXRandom()
        case 9:
          return c.GetInitYRandom()
        case 10:
          return c.GetInitSpeedRandom()
        case 11:
          return c.GetInitSizeRandom()
        case 12:
          return c.GetGrowRandom()
        case 13:
          return c.GetAcceleration()
        case 14:
          return c.GetGravity()
        case 15:
          return c.GetLifeAngleRandom()
        case 16:
          return c.GetLifeSpeedRandom()
        case 17:
          return c.GetLifeOpacityRandom()
        case 18:
          return c.GetDestroyModeIndex()
        case 19:
          return c.GetTimeout()
      }
    }
    SetPropertyValueByIndex(a, c) {
      const d = this._particleEngine
      switch (a) {
        case 0:
          d.SetRate(c)
          break
        case 1:
          d.SetSprayCone(e.toRadians(c))
          break
        case 2:
          d.SetSprayType(c ? 'one-shot' : 'continuous-spray')
          break
        case 4:
          d.SetInitSpeed(c)
          break
        case 5:
          d.SetInitSize(c)
          break
        case 6:
          d.SetInitOpacity(c / 100)
          break
        case 7:
          d.SetGrowRate(c)
          break
        case 8:
          d.SetInitXRandom(c)
          break
        case 9:
          d.SetInitYRandom(c)
          break
        case 10:
          d.SetInitSpeedRandom(c)
          break
        case 11:
          d.SetInitSizeRandom(c)
          break
        case 12:
          d.SetGrowRandom(c)
          break
        case 13:
          d.SetAcceleration(c)
          break
        case 14:
          d.SetGravity(c)
          break
        case 15:
          d.SetLifeAngleRandom(c)
          break
        case 16:
          d.SetLifeSpeedRandom(c)
          break
        case 17:
          d.SetLifeOpacityRandom(c)
          break
        case 18:
          d.SetDestroyModeIndex(c)
          break
        case 19:
          d.SetTimeout(c)
      }
    }
    GetDebuggerProperties() {
      const a = this._particleEngine
      return [
        {
          title: 'plugins.particles.name',
          properties: [
            {
              name: 'plugins.particles.debugger.particle-count',
              value: a.GetParticleCount()
            },
            {
              name: 'plugins.particles.properties.type.name',
              value: ['plugins.particles.properties.type.items.' + a.GetSprayType()]
            },
            {
              name: 'plugins.particles.debugger.is-spraying',
              value: a.IsSpraying(),
              onedit: c => a.SetSpraying(c)
            },
            {
              name: 'plugins.particles.properties.rate.name',
              value: a.GetRate(),
              onedit: c => a.SetRate(c)
            },
            {
              name: 'plugins.particles.properties.spray-cone.name',
              value: e.toDegrees(a.GetSprayCone()),
              onedit: c => a.SetSprayCone(e.toRadians(c))
            },
            {
              name: 'plugins.particles.properties.speed.name',
              value: a.GetInitSpeed(),
              onedit: c => a.SetInitSpeed(c)
            },
            {
              name: 'plugins.particles.properties.size.name',
              value: a.GetInitSize(),
              onedit: c => a.SetInitSize(c)
            },
            {
              name: 'plugins.particles.properties.opacity.name',
              value: a.GetInitOpacity(),
              onedit: c => a.SetInitOpacity(c)
            },
            {
              name: 'plugins.particles.properties.grow-rate.name',
              value: a.GetGrowRate(),
              onedit: c => a.SetGrowRate(c)
            },
            {
              name: 'plugins.particles.properties.x-randomiser.name',
              value: a.GetInitXRandom(),
              onedit: c => a.SetInitXRandom(c)
            },
            {
              name: 'plugins.particles.properties.y-randomiser.name',
              value: a.GetInitYRandom(),
              onedit: c => a.SetInitYRandom(c)
            },
            {
              name: 'plugins.particles.properties.initial-speed-randomiser.name',
              value: a.GetInitSpeedRandom(),
              onedit: c => a.SetInitSpeedRandom(c)
            },
            {
              name: 'plugins.particles.properties.size-randomiser.name',
              value: a.GetInitSizeRandom(),
              onedit: c => a.SetInitSizeRandom(c)
            },
            {
              name: 'plugins.particles.properties.grow-rate-randomiser.name',
              value: a.GetGrowRandom(),
              onedit: c => a.SetGrowRandom(c)
            },
            {
              name: 'plugins.particles.properties.acceleration.name',
              value: a.GetAcceleration(),
              onedit: c => a.SetAcceleration(c)
            },
            {
              name: 'plugins.particles.properties.gravity.name',
              value: a.GetGravity(),
              onedit: c => a.SetGravity(c)
            },
            {
              name: 'plugins.particles.properties.angle-randomiser.name',
              value: a.GetLifeAngleRandom(),
              onedit: c => a.SetLifeAngleRandom(c)
            },
            {
              name: 'plugins.particles.properties.life-speed-randomiser.name',
              value: a.GetLifeSpeedRandom(),
              onedit: c => a.SetLifeSpeedRandom(c)
            },
            {
              name: 'plugins.particles.properties.opacity-randomiser.name',
              value: a.GetLifeOpacityRandom(),
              onedit: c => a.SetLifeOpacityRandom(c)
            },
            {
              name: 'plugins.particles.properties.timeout.name',
              value: a.GetTimeout(),
              onedit: c => a.SetTimeout(c)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Plugins.Particles.Cnds = {
  IsSpraying() {
    return this._particleEngine.IsSpraying()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Particles.Acts = {
    SetSpraying(b) {
      this._particleEngine.SetSpraying(0 !== b)
    },
    SetRate(b) {
      this._particleEngine.SetRate(b)
      'one-shot' === this._particleEngine.GetSprayType() && this._isFirstTick && this._particleEngine.SetParticleCount(b)
    },
    SetParticleObject(b) {
      this._SetParticleObjectClass(b)
    },
    UnsetParticleObject() {
      this._SetParticleObjectClass(null)
    },
    SetSprayCone(b) {
      this._particleEngine.SetSprayCone(e.toRadians(b))
    },
    SetInitSpeed(b) {
      this._particleEngine.SetInitSpeed(b)
    },
    SetInitSize(b) {
      this._particleEngine.SetInitSize(b)
    },
    SetInitOpacity(b) {
      this._particleEngine.SetInitOpacity(b / 100)
    },
    SetGrowRate(b) {
      this._particleEngine.SetGrowRate(b)
    },
    SetXRandomiser(b) {
      this._particleEngine.SetInitXRandom(b)
    },
    SetYRandomiser(b) {
      this._particleEngine.SetInitYRandom(b)
    },
    SetSpeedRandomiser(b) {
      this._particleEngine.SetInitSpeedRandom(b)
    },
    SetSizeRandomiser(b) {
      this._particleEngine.SetInitSizeRandom(b)
    },
    SetGrowRateRandomiser(b) {
      this._particleEngine.SetGrowRandom(b)
    },
    SetParticleAcc(b) {
      this._particleEngine.SetAcceleration(b)
    },
    SetGravity(b) {
      this._particleEngine.SetGravity(b)
    },
    SetAngleRandomiser(b) {
      this._particleEngine.SetLifeAngleRandom(b)
    },
    SetLifeSpeedRandomiser(b) {
      this._particleEngine.SetLifeSpeedRandom(b)
    },
    SetOpacityRandomiser(b) {
      this._particleEngine.SetLifeOpacityRandom(b)
    },
    SetTimeout(b) {
      this._particleEngine.SetTimeout(b)
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b)
      this._runtime.UpdateRender()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Particles.Exps = {
    ParticleCount() {
      return this._particleEngine.GetParticleCount()
    },
    Rate() {
      return this._particleEngine.GetRate()
    },
    SprayCone() {
      return e.toDegrees(this._particleEngine.GetSprayCone())
    },
    InitSpeed() {
      return this._particleEngine.GetInitSpeed()
    },
    InitSize() {
      return this._particleEngine.GetInitSize()
    },
    InitOpacity() {
      return 100 * this._particleEngine.GetInitOpacity()
    },
    InitGrowRate() {
      return this._particleEngine.GetGrowRate()
    },
    XRandom() {
      return this._particleEngine.GetInitXRandom()
    },
    YRandom() {
      return this._particleEngine.GetInitYRandom()
    },
    InitSpeedRandom() {
      return this._particleEngine.GetInitSpeedRandom()
    },
    InitGrowRandom() {
      return this._particleEngine.GetGrowRandom()
    },
    ParticleAcceleration() {
      return this._particleEngine.GetAcceleration()
    },
    Gravity() {
      return this._particleEngine.GetGravity()
    },
    ParticleAngleRandom() {
      return this._particleEngine.GetLifeAngleRandom()
    },
    ParticleSpeedRandom() {
      return this._particleEngine.GetLifeSpeedRandom()
    },
    ParticleOpacityRandom() {
      return this._particleEngine.GetLifeOpacityRandom()
    },
    Timeout() {
      return this._particleEngine.GetTimeout()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = [],
    a = new Set(['continuous-spray', 'one-shot']),
    c = ['fade-to-invisible', 'timeout-expired', 'particle-stopped']
  self.ParticleEngine = class {
    constructor() {
      this._sprayCone = this._rate = 0
      this._sprayType = 'continuous-spray'
      this._isSpraying = !1
      this._masterOpacity = 0
      this._isPixelRounding = !1
      this._initSize = this._initSpeed = this._spawnAngle = this._spawnY = this._spawnX = 0
      this._initSizeScale = 1
      this._createCounter =
        this._timeout =
        this._destroyMode =
        this._lifeOpacityRandom =
        this._lifeSpeedRandom =
        this._lifeAngleRandom =
        this._gravity =
        this._acceleration =
        this._growRandom =
        this._initSizeRandom =
        this._initSpeedRandom =
        this._yRandom =
        this._xRandom =
        this._growRate =
        this._initOpacity =
          0
      this._particleScale = 1
      this.onparticlecreate = this.ononeshotfinish = null
      this._particles = []
      this._boundingBox = new e.Rect()
      this._color = new e.Color()
    }
    Release() {
      this.Cancel()
      e.clearArray(this._particles)
      this._color = this._boundingBox = this.onparticlecreate = this.ononeshotfinish = this._particles = null
    }
    Cancel() {
      const d = this._particles
      for (let f = 0, g = d.length; f < g; ++f) d[f].Destroy()
      e.appendArray(b, d)
      e.clearArray(d)
      1e3 < b.length && e.truncateArray(b, 1e3)
      this._isSpraying = !1
    }
    CreateOneShotSpray() {
      for (let d = 0, f = this._rate; d < f; ++d) this._CreateParticle()
      this._particles.length && (this._isSpraying = !0)
    }
    _CreateParticle() {
      let d
      b.length ? ((d = b.pop()), d.SetEngine(this)) : (d = e.New(self.Particle, this))
      this._particles.push(d)
      d.Init(this.onparticlecreate)
      return d
    }
    ReInitAllParticles() {
      const d = this._particles,
        f = this.onparticlecreate
      for (let g = 0, h = d.length; g < h; ++g) d[g].Init(f)
    }
    SetParticleCount(d) {
      var f = this._particles
      if (d < f.length) {
        d = f.length - d
        for (let g = 0; g < d; ++g) {
          const h = f.pop()
          h.Destroy()
          b.push(h)
        }
        1e3 < b.length && e.truncateArray(b, 1e3)
      } else if (d > f.length) for (f = d - f.length, d = 0; d < f; ++d) this._CreateParticle()
    }
    GetParticles() {
      return this._particles
    }
    GetParticleCount() {
      return this._particles.length
    }
    Tick(d) {
      this._SpawnContinuous(d)
      this._TickParticles(d)
      this._MaybeFinishOneShot()
    }
    _SpawnContinuous(d) {
      if ('continuous-spray' === this._sprayType && this._isSpraying) {
        this._createCounter += d * this._rate
        d = Math.floor(this._createCounter)
        this._createCounter -= d
        for (let f = 0; f < d; ++f) this._CreateParticle()
      }
    }
    _SetCreateCounter(d) {
      this._createCounter = d
    }
    _GetCreateCounter() {
      return this._createCounter
    }
    _TickParticles(d) {
      const f = this._boundingBox
      f.set(this._spawnX, this._spawnY, this._spawnX, this._spawnY)
      const g = this._particles
      let h = 0
      for (let k = 0, m = g.length; k < m; ++k) {
        const r = g[k]
        g[h] = r
        r.Tick(d)
        r.IsActive() ? (++h, f.expandToContain(r.GetBoundingBox())) : (r.Destroy(), b.push(r))
      }
      e.truncateArray(g, h)
      1e3 < b.length && e.truncateArray(b, 1e3)
    }
    _MaybeFinishOneShot() {
      if ('one-shot' === this._sprayType && 0 === this._particles.length && this._isSpraying) {
        if (this.ononeshotfinish) this.ononeshotfinish()
        this._isSpraying = !1
      }
    }
    Draw(d, f, g) {
      d.StartRenderingPoints(f)
      this._color.copy(d.GetColor())
      const h = this._particles
      for (let k = 0, m = h.length; k < m; ++k) {
        const r = h[k]
        g.intersectsRect(r.GetBoundingBox()) && r.Draw(d, f)
      }
      d.FinishRenderingPoints()
    }
    GetColor() {
      return this._color
    }
    SetRate(d) {
      this._rate = +d
    }
    GetRate() {
      return this._rate
    }
    SetSprayCone(d) {
      this._sprayCone = +d
    }
    GetSprayCone() {
      return this._sprayCone
    }
    SetSprayType(d) {
      if (!a.has(d)) throw Error('invalid spray type')
      this._sprayType = d
    }
    GetSprayType() {
      return this._sprayType
    }
    SetSpraying(d) {
      this._isSpraying = !!d
    }
    IsSpraying() {
      return this._isSpraying
    }
    SetMasterOpacity(d) {
      this._masterOpacity = +d
    }
    GetMasterOpacity() {
      return this._masterOpacity
    }
    SetPixelRounding(d) {
      this._isPixelRounding = !!d
    }
    IsPixelRounding() {
      return this._isPixelRounding
    }
    SetSpawnX(d) {
      this._spawnX = +d
    }
    GetSpawnX() {
      return this._spawnX
    }
    SetSpawnY(d) {
      this._spawnY = +d
    }
    GetSpawnY() {
      return this._spawnY
    }
    SetSpawnAngle(d) {
      this._spawnAngle = +d
    }
    GetInitAngle() {
      return this._spawnAngle
    }
    SetInitSpeed(d) {
      this._initSpeed = +d
    }
    GetInitSpeed() {
      return this._initSpeed
    }
    SetInitSize(d) {
      this._initSize = +d
    }
    GetInitSize() {
      return this._initSize
    }
    SetInitSizeScale(d) {
      this._initSizeScale = +d
    }
    GetInitSizeScale() {
      return this._initSizeScale
    }
    SetInitOpacity(d) {
      this._initOpacity = +d
    }
    GetInitOpacity() {
      return this._initOpacity
    }
    SetGrowRate(d) {
      this._growRate = +d
    }
    GetGrowRate() {
      return this._growRate
    }
    SetInitXRandom(d) {
      this._xRandom = +d
    }
    GetInitXRandom() {
      return this._xRandom
    }
    SetInitYRandom(d) {
      this._yRandom = +d
    }
    GetInitYRandom() {
      return this._yRandom
    }
    SetInitSpeedRandom(d) {
      this._initSpeedRandom = +d
    }
    GetInitSpeedRandom() {
      return this._initSpeedRandom
    }
    SetInitSizeRandom(d) {
      this._initSizeRandom = +d
    }
    GetInitSizeRandom() {
      return this._initSizeRandom
    }
    SetGrowRandom(d) {
      this._growRandom = +d
    }
    GetGrowRandom() {
      return this._growRandom
    }
    SetAcceleration(d) {
      this._acceleration = +d
    }
    GetAcceleration() {
      return this._acceleration
    }
    SetGravity(d) {
      this._gravity = +d
    }
    GetGravity() {
      return this._gravity
    }
    SetLifeAngleRandom(d) {
      this._lifeAngleRandom = +d
    }
    GetLifeAngleRandom() {
      return this._lifeAngleRandom
    }
    SetLifeSpeedRandom(d) {
      this._lifeSpeedRandom = +d
    }
    GetLifeSpeedRandom() {
      return this._lifeSpeedRandom
    }
    SetLifeOpacityRandom(d) {
      this._lifeOpacityRandom = +d
    }
    GetLifeOpacityRandom() {
      return this._lifeOpacityRandom
    }
    SetDestroyMode(d) {
      d = c.indexOf(d)
      if (-1 === d) throw Error('invalid destroy mode')
      this._destroyMode = d
    }
    SetDestroyModeIndex(d) {
      this.SetDestroyMode(c[d])
    }
    GetDestroyMode() {
      return c[this._destroyMode]
    }
    GetDestroyModeIndex() {
      return this._destroyMode
    }
    SetTimeout(d) {
      this._timeout = +d
    }
    GetTimeout() {
      return this._timeout
    }
    SetParticleScale(d) {
      this._particleScale = +d
    }
    GetParticleScale() {
      return this._particleScale
    }
    GetBoundingBox() {
      return this._boundingBox
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(g) {
    return Math.random() * g - g / 2
  }
  const a = new e.Quad(),
    c = new e.Color(),
    d = self.devicePixelRatio || 1
  let f = !1
  self.Particle = class {
    constructor(g) {
      this._engine = g
      this._isActive = !1
      this._angle = this._speed = this._y = this._x = 0
      this._opacity = 1
      this._age = this._gs = this._halfSize = this._size = this._grow = this._lastOpacity = 0
      this._bbox = new e.Rect()
      this._destroyCallback = this._updateCallback = this._userData = null
    }
    SetEngine(g) {
      this._engine = g
    }
    Init(g) {
      const h = this._engine
      this._isActive = !0
      this._x = h.GetSpawnX() + b(h.GetInitXRandom())
      this._y = h.GetSpawnY() + b(h.GetInitYRandom())
      this._speed = h.GetInitSpeed() + b(h.GetInitSpeedRandom())
      this._angle = h.GetInitAngle() + b(h.GetSprayCone())
      this._lastOpacity = this._opacity = h.GetInitOpacity()
      this._size = (h.GetInitSize() + b(h.GetInitSizeRandom())) * h.GetInitSizeScale()
      this._halfSize = this._size / 2
      this._grow = h.GetGrowRate() + b(h.GetGrowRandom())
      this._age = this._gs = 0
      this._UpdateBoundingBox()
      g ? this._userData || (this._userData = g(this)) : (this._destroyCallback = this._updateCallback = this._userData = null)
    }
    SetUpdateCallback(g) {
      this._updateCallback = g
    }
    SetDestroyCallback(g) {
      this._destroyCallback = g
    }
    Destroy() {
      const g = this._destroyCallback
      g && g(this._userData)
      this._destroyCallback = this._updateCallback = this._userData = null
    }
    toJSON() {
      return [this._x, this._y, this._speed, this._angle, this._opacity, this._grow, this._size, this._gs, this._age]
    }
    setFromJSON(g) {
      this._x = g[0]
      this._y = g[1]
      this._speed = g[2]
      this._angle = g[3]
      this._opacity = g[4]
      this._grow = g[5]
      this._size = g[6]
      this._gs = g[7]
      this._age = g[8]
      this._halfSize = this._size / 2
      this._UpdateBoundingBox()
    }
    Tick(g) {
      var h = this._engine,
        k = this._speed * g,
        m = this._angle
      const r = Math.cos(m) * k
      k = Math.sin(m) * k + this._gs * g
      this._x += r
      this._y += k
      m = this._grow * g
      this._size += m
      this._halfSize = this._size / 2
      this._speed += h.GetAcceleration() * g
      this._gs += h.GetGravity() * g
      this._age += g
      this._UpdateBoundingBox()
      var w = h.GetLifeAngleRandom(),
        p = h.GetLifeSpeedRandom()
      const q = h.GetLifeOpacityRandom()
      let t = 0
      0 !== w && ((t = b(w * g)), (this._angle += t))
      0 !== p && (this._speed += b(p * g))
      0 !== q && (this._opacity = e.clamp(this._opacity + b(q * g), 0, 1))
      g = 1 <= this._size && (2 === h.GetDestroyModeIndex() ? 0 < this._speed : this._age < h.GetTimeout())
      ;(w = this._updateCallback) && g && ((p = h.GetMasterOpacity() * this._opacity), 0 === h.GetDestroyModeIndex() && (p *= 1 - this._age / h.GetTimeout()), (h = p - this._lastOpacity), (this._lastOpacity = p), w(this._userData, r, k, m, t, h))
      this._isActive = g
    }
    IsActive() {
      return this._isActive
    }
    GetBoundingBox() {
      return this._bbox
    }
    _UpdateBoundingBox() {
      const g = this._x,
        h = this._y,
        k = this._halfSize
      this._bbox.set(g - k, h - k, g + k, h + k)
    }
    Draw(g, h) {
      if (!this._userData) {
        var k = this._engine,
          m = k.GetMasterOpacity() * this._opacity
        0 === k.GetDestroyModeIndex() && (m *= 1 - this._age / k.GetTimeout())
        if (!(0 >= m)) {
          var r = this._size,
            w = r * k.GetParticleScale() * d
          if (!(1 > w)) {
            var p = this._x,
              q = this._y
            k.IsPixelRounding() && ((p = (p + 0.5) | 0), (q = (q + 0.5) | 0))
            g.IsWebGPU() ? g.Point(p, q, r, m) : w > g.GetMaxPointSize() || w < g.GetMinPointSize() ? (c.copy(k.GetColor()), c.multiplyAlpha(m), g.SetColor(c), (f = !0), a.setFromRect(this._bbox), g.Quad3(a, h)) : (f && (g.SetColor(k.GetColor()), (f = !1)), g.Point(p, q, w, m))
          }
        }
      }
    }
    GetUserData() {
      return this._userData
    }
    GetX() {
      return this._x
    }
    GetY() {
      return this._y
    }
    GetSize() {
      return this._size
    }
    GetAngle() {
      return this._angle
    }
    GetOpacity() {
      return this._opacity
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Tilemap = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
  e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL = -2147483648
  e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL = 1073741824
  e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL = 536870912
  e.Plugins.Tilemap.TILE_FLAGS_MASK = 3758096384
  e.Plugins.Tilemap.TILE_ID_MASK = 536870911
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    a = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    d = e.Plugins.Tilemap.TILE_ID_MASK
  e.Plugins.Tilemap.Type = class extends e.SDKTypeBase {
    constructor(f) {
      super(f)
      this._tilePolys = []
      this._areTilePolysCached = !1
      this._maxTileIndex = 0
    }
    Release() {
      super.Release()
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(f) {
      return this.GetImageInfo().LoadStaticTexture(f, {
        sampling: this._runtime.GetSampling()
      })
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture()
    }
    OnDynamicTextureLoadComplete() {
      for (const f of this.GetObjectClass().instancesIncludingPendingCreate()) f.GetSdkInstance()._OnDynamicTextureLoadComplete()
    }
    LoadTilemapData(f, g) {
      this._maxTileIndex = g
      for (const h of f)
        h
          ? this._tilePolys.push({
              poly: h[0],
              use: !!h[1],
              flipmap: [
                [
                  [null, null],
                  [null, null]
                ],
                [
                  [null, null],
                  [null, null]
                ]
              ]
            })
          : this._tilePolys.push(null)
    }
    _ForceCacheOfTileCollisionPolys(f, g) {
      this._areTilePolysCached = !1
      this._MaybeCacheTileCollisionPolys(f, g)
    }
    _MaybeCacheTileCollisionPolys(f, g) {
      if (!this._areTilePolysCached) {
        this._areTilePolysCached = !0
        for (let h = 0, k = this._tilePolys.length; h < k; ++h)
          this._tilePolys[h] &&
            (this._CacheTilePoly(h, f, g, !1, !1, !1),
            this._CacheTilePoly(h, f, g, !1, !1, !0),
            this._CacheTilePoly(h, f, g, !1, !0, !1),
            this._CacheTilePoly(h, f, g, !1, !0, !0),
            this._CacheTilePoly(h, f, g, !0, !1, !1),
            this._CacheTilePoly(h, f, g, !0, !1, !0),
            this._CacheTilePoly(h, f, g, !0, !0, !1),
            this._CacheTilePoly(h, f, g, !0, !0, !0))
      }
    }
    _CacheTilePoly(f, g, h, k, m, r) {
      if (!(0 > f || f >= this._tilePolys.length) && (f = this._tilePolys[f])) {
        var w = e.New(e.CollisionPoly, f.poly, f.use)
        w.transform(g, h, 0)
        r && w.diag()
        k && w.mirror(g / 2)
        m && w.flip(h / 2)
        f.flipmap[k ? 1 : 0][m ? 1 : 0][r ? 1 : 0] = null
        f.flipmap[k ? 1 : 0][m ? 1 : 0][r ? 1 : 0] = w
      }
    }
    GetTilePoly(f) {
      if (-1 === f) return null
      var g = f & d
      return 0 > g || g >= this._tilePolys.length ? null : (g = this._tilePolys[g]) ? g.flipmap[f & b ? 1 : 0][f & a ? 1 : 0][f & c ? 1 : 0] : null
    }
    IsTilePolyEnabled(f) {
      return f ? f.IsEnabled() : !0
    }
    GetMaxTileIndex() {
      return this._maxTileIndex
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    d = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    f = e.Plugins.Tilemap.TILE_FLAGS_MASK,
    g = e.Plugins.Tilemap.TILE_ID_MASK,
    h = e.New(e.Rect),
    k = e.New(e.Rect)

  function m(p) {
    const q = []
    p = p.split(',')
    for (let u = 0, A = p.length; u < A; ++u) {
      var t = p[u],
        x = t.indexOf('x')
      if (-1 < x) {
        var v = parseInt(t.substring(0, x), 10)
        t = t.substring(x + 1)
        x = parseInt(t, 10)
        t.includes('h') && (x |= a)
        t.includes('v') && (x |= c)
        for (t.includes('d') && (x |= d); 0 < v; --v) q.push(x)
      } else (v = parseInt(t, 10)), t.includes('h') && (v |= a), t.includes('v') && (v |= c), t.includes('d') && (v |= d), q.push(v)
    }
    return q
  }
  e.Plugins.Tilemap.Instance = class extends e.SDKWorldInstanceBase {
    constructor(p, q) {
      super(p)
      p = this.GetWorldInfo()
      this._tileHeight = this._tileWidth = 32
      this._mapHeight = this._mapWidth = this._tileYspacing = this._tileXspacing = this._tileYoffset = this._tileXoffset = 0
      this._lastWidth = p.GetWidth()
      this._lastHeight = p.GetHeight()
      this._cellHeight = this._cellWidth = 0
      this._tileCells = []
      this._tileTexQuads = new Map()
      this._isAnyQuadMapChanged = !0
      this._ownImageInfo = null
      q && (p.SetVisible(q[0]), (this._tileWidth = Math.max(q[1], 1)), (this._tileHeight = Math.max(q[2], 1)), (this._tileXoffset = q[3]), (this._tileYoffset = q[4]), (this._tileXspacing = q[5]), (this._tileYspacing = q[6]))
      this._cellWidth = Math.ceil(this._runtime.GetOriginalViewportWidth() / this._tileWidth)
      this._cellHeight = Math.ceil(this._runtime.GetOriginalViewportHeight() / this._tileHeight)
      this._sdkType._MaybeCacheTileCollisionPolys(this._tileWidth, this._tileHeight)
    }
    Release() {
      this._ReleaseOwnImage()
      e.clearArray(this._tileCells)
      this._tileCells = null
      this._tileTexQuads.clear()
      this._tileTexQuads = null
      super.Release()
    }
    _ReleaseOwnImage() {
      this._ownImageInfo && (this._ownImageInfo.Release(), (this._ownImageInfo = null))
    }
    LoadTilemapData(p, q, t) {
      this._mapWidth = q
      this._mapHeight = t
      this._MaybeResizeTilemap(!0)
      this.SetTilesFromRLECSV(p)
      this._MaybeBuildAllQuadMap()
    }
    _MaybeResizeTilemap(p) {
      const [q, t] = this.GetMapDisplaySize()
      if (!(q <= this._mapWidth && t <= this._mapHeight) || p) {
        if (p) {
          p = Math.ceil(this._mapHeight / this._cellHeight)
          var x = Math.ceil(this._mapWidth / this._cellWidth)
        } else
          (p = this._tileCells.length),
            (x = Math.ceil(this._mapWidth / this._cellWidth)),
            t > this._mapHeight && ((this._mapHeight = t), (p = Math.ceil(this._mapHeight / this._cellHeight))),
            q > this._mapWidth && ((this._mapWidth = q), (x = Math.ceil(this._mapWidth / this._cellWidth))),
            this._SetAllQuadMapChanged(),
            this._SetPhysicsChanged(),
            this._runtime.UpdateRender()
        var v = this._tileCells
        if (v.length < p) for (var u = v.length; u < p; ++u) v.push([])
        for (u = 0; u < p; ++u) {
          const A = v[u]
          for (let z = A.length; z < x; ++z) A.push(e.New(e.Plugins.Tilemap.TileCell, this, z, u))
        }
      }
    }
    SetTilesFromRLECSV(p) {
      p = m(p)
      let q = 0
      const t = this._mapWidth,
        x = this._cellWidth,
        v = this._cellHeight
      for (let u = 0, A = this._mapHeight; u < A; ++u)
        for (let z = 0; z < t; ++z) {
          const C = p[q++],
            E = this.GetCellAt(z, u)
          E && E.SetTileAt(z % x, u % v, C)
        }
    }
    GetTilesAsRLECSV() {
      let p = ''
      if (0 >= this._mapWidth || 0 >= this._mapHeight) return p
      let q = 1
      var t = this.GetTileAt(0, 0)
      const [x, v] = this.GetMapDisplaySize()
      let u, A, z
      for (let C = 0; C < v; ++C)
        for (let E = 0 === C ? 1 : 0; E < x; ++E) {
          const J = this.GetTileAt(E, C)
          J === t ? ++q : (-1 === t ? ((u = -1), (t = z = A = !1)) : ((u = t & g), (A = 0 !== (t & a)), (z = 0 !== (t & c)), (t = 0 !== (t & d))), (p = 1 === q ? p + ('' + u) : p + ('' + q + 'x' + u)), A && (p += 'h'), z && (p += 'v'), t && (p += 'd'), (p += ','), (q = 1), (t = J))
        }
      ;-1 === t ? ((u = -1), (t = z = A = !1)) : ((u = t & g), (A = 0 !== (t & a)), (z = 0 !== (t & c)), (t = 0 !== (t & d)))
      p = 1 === q ? p + ('' + u) : p + ('' + q + 'x' + u)
      A && (p += 'h')
      z && (p += 'v')
      t && (p += 'd')
      return p
    }
    _SetAllQuadMapChanged() {
      const p = this._tileCells
      for (let q = 0, t = p.length; q < t; ++q) {
        const x = p[q]
        for (let v = 0, u = x.length; v < u; ++v) x[v]._SetQuadMapChanged()
      }
      this._isAnyQuadMapChanged = !0
    }
    _MaybeBuildAllQuadMap() {
      if (this._isAnyQuadMapChanged) {
        this._isAnyQuadMapChanged = !1
        var p = this._tileCells
        for (let q = 0, t = p.length; q < t; ++q) {
          const x = p[q]
          for (let v = 0, u = x.length; v < u; ++v) x[v].MaybeBuildQuadMap()
        }
      }
    }
    SetTileChanged() {
      this._isAnyQuadMapChanged = !0
      this._SetPhysicsChanged()
      this._runtime.UpdateRender()
    }
    _SetPhysicsChanged() {
      this.GetWorldInfo().SetPhysicsBodyChanged(!0)
    }
    GetCellAt(p, q) {
      if (0 > p || 0 > q) return null
      q = Math.floor(q / this._cellHeight)
      if (q >= this._tileCells.length) return null
      q = this._tileCells[q]
      p = Math.floor(p / this._cellWidth)
      return p >= q.length ? null : q[p]
    }
    GetCellAtIndex(p, q) {
      if (0 > p || 0 > q || q >= this._tileCells.length) return null
      q = this._tileCells[q]
      return p >= q.length ? null : q[p]
    }
    GetTileAt(p, q) {
      p = Math.floor(p)
      q = Math.floor(q)
      if (0 > p || 0 > q || p >= this._mapWidth || q >= this._mapHeight) return -1
      const t = this.GetCellAt(p, q)
      return t ? t.GetTilesArr()[q % this._cellHeight][p % this._cellWidth] : -1
    }
    SetTileAt(p, q, t) {
      p = Math.floor(p)
      q = Math.floor(q)
      if (!(0 > p || 0 > q || p >= this._mapWidth || q >= this._mapHeight || (-1 !== t && (t & g) > this.GetMaxTileIndex()))) {
        var x = this.GetCellAt(p, q)
        x && x.SetTileAt(p % this._cellWidth, q % this._cellHeight, t)
      }
    }
    GetMaxTileIndex() {
      return this._sdkType.GetMaxTileIndex()
    }
    WorldToCellX(p) {
      return Math.floor((p - this.GetWorldInfo().GetX()) / (this._cellWidth * this._tileWidth))
    }
    WorldToCellY(p) {
      return Math.floor((p - this.GetWorldInfo().GetY()) / (this._cellHeight * this._tileHeight))
    }
    WorldToTileX(p) {
      return Math.floor((p - this.GetWorldInfo().GetX()) / this._tileWidth)
    }
    WorldToTileY(p) {
      return Math.floor((p - this.GetWorldInfo().GetY()) / this._tileHeight)
    }
    GetMapWidth() {
      return this._mapWidth
    }
    GetMapHeight() {
      return this._mapHeight
    }
    GetMapDisplayWidth() {
      return Math.floor(this.GetWorldInfo().GetWidth() / this.GetTileWidth())
    }
    GetMapDisplayHeight() {
      return Math.floor(this.GetWorldInfo().GetHeight() / this.GetTileHeight())
    }
    GetMapDisplaySize() {
      const p = this.GetWorldInfo()
      return [Math.floor(p.GetWidth() / this.GetTileWidth()), Math.floor(p.GetHeight() / this.GetTileHeight())]
    }
    GetTileWidth() {
      return this._tileWidth
    }
    GetTileHeight() {
      return this._tileHeight
    }
    GetCellWidth() {
      return this._cellWidth
    }
    GetCellHeight() {
      return this._cellHeight
    }
    GetCollisionRectCandidates(p, q) {
      var t = this.WorldToCellX(p.getLeft())
      const x = this.WorldToCellY(p.getTop()),
        v = this.WorldToCellX(p.getRight())
      for (p = this.WorldToCellY(p.getBottom()); t <= v; ++t)
        for (let u = x; u <= p; ++u) {
          const A = this.GetCellAtIndex(t, u)
          A && (A.MaybeBuildQuadMap(), e.appendArray(q, A.GetCollisionRects()))
        }
    }
    TestPointOverlapTile(p, q) {
      var t = this.WorldToTileX(p),
        x = this.WorldToTileY(q)
      t = this.GetTileAt(t, x)
      if (-1 === t) return !1
      t = this._sdkType.GetTilePoly(t)
      if (!t) return !0
      if (!this._sdkType.IsTilePolyEnabled(t)) return !1
      var v = this.GetWorldInfo()
      x = Math.floor((p - v.GetX()) / this._tileWidth) * this._tileWidth + v.GetX()
      v = Math.floor((q - v.GetY()) / this._tileHeight) * this._tileHeight + v.GetY()
      return t.containsPoint(p - x, q - v)
    }
    GetAllCollisionRects(p) {
      const q = this._tileCells
      for (let t = 0, x = q.length; t < x; ++t) {
        const v = q[t]
        for (let u = 0, A = v.length; u < A; ++u) {
          const z = v[u]
          z.MaybeBuildQuadMap()
          e.appendArray(p, z.GetCollisionRects())
        }
      }
    }
    GetCurrentImageInfo() {
      return this._ownImageInfo || this._objectClass.GetImageInfo()
    }
    GetTileUvQuad(p) {
      const q = this._tileTexQuads
      var t = q.get(p)
      if (t) return t
      var x = p & g
      t = 0 !== (p & a)
      const v = 0 !== (p & c),
        u = 0 !== (p & d)
      var A = this.GetCurrentImageInfo(),
        z = A.GetWidth(),
        C = this._tileWidth,
        E = this._tileXspacing
      C = Math.floor((Math.floor(((z - this._tileXoffset) / (C + E)) * C) + E) / C)
      z = x % C
      x = Math.floor(x / C)
      C = A.GetOffsetX() + this._tileXoffset + (this._tileWidth + this._tileXspacing) * z
      E = A.GetOffsetY() + this._tileYoffset + (this._tileHeight + this._tileYspacing) * x
      h.setWH(C, E, this._tileWidth, this._tileHeight)
      h.divide(A.GetSheetWidth(), A.GetSheetHeight())
      A = e.New(e.Quad)
      A.setFromRect(h)
      u && A.diag()
      t && A.mirror()
      v && A.flip()
      A.offset(z, x)
      q.set(p, A)
      return A
    }
    _OnDynamicTextureLoadComplete() {
      this._tileTexQuads.clear()
      this._SetAllQuadMapChanged()
    }
    Draw(p) {
      var q = this.GetCurrentImageInfo(),
        t = q.GetTexture()
      if (t) {
        h.copy(q.GetTexRect())
        h.offsetLeft(this._tileXoffset / t.GetWidth())
        h.offsetTop(this._tileYoffset / t.GetHeight())
        p.SetTilemapFillMode()
        p.SetTilemapInfo(h, t.GetWidth(), t.GetHeight(), this._tileWidth, this._tileHeight, this._tileXspacing, this._tileYspacing)
        p.SetTexture(t)
        t = this.GetWorldInfo()
        if (t.GetWidth() !== this._lastWidth || t.GetHeight() !== this._lastHeight) this._SetPhysicsChanged(), this._SetAllQuadMapChanged(), (this._lastWidth = t.GetWidth()), (this._lastHeight = t.GetHeight())
        t.GetLayer().GetViewportForZ(t.GetTotalZElevation(), k)
        q = t.GetX()
        t = t.GetY()
        this._runtime.IsPixelRoundingEnabled() && ((q = Math.round(q)), (t = Math.round(t)))
        var x = this._cellWidth * this._tileWidth,
          v = this._cellHeight * this._tileHeight,
          u = Math.floor((k.getLeft() - q) / x)
        x = Math.floor((k.getRight() - q) / x)
        var A = Math.floor((k.getTop() - t) / v)
        for (v = Math.floor((k.getBottom() - t) / v); u <= x; ++u)
          for (let z = A; z <= v; ++z) {
            const C = this.GetCellAtIndex(u, z)
            C && (C.MaybeBuildQuadMap(), C.Draw(p, k, q, t))
          }
      }
    }
    SaveToJson() {
      this._MaybeResizeTilemap()
      const [p, q] = this.GetMapDisplaySize()
      return {
        tw: this._tileWidth,
        th: this._tileHeight,
        tox: this._tileXoffset,
        toy: this._tileYoffset,
        tsx: this._tileXspacing,
        tsy: this._tileYspacing,
        w: p,
        h: q,
        d: this.GetTilesAsRLECSV()
      }
    }
    LoadFromJson(p) {
      this._tileWidth = p.tw
      this._tileHeight = p.th
      this._tileXoffset = p.tox
      this._tileYoffset = p.toy
      this._tileXspacing = p.tsx
      this._tileYspacing = p.tsy
      this._mapWidth = p.w
      this._mapHeight = p.h
      this._MaybeResizeTilemap(!0)
      this.SetTilesFromRLECSV(p.d)
      this._SetPhysicsChanged()
      this._SetAllQuadMapChanged()
    }
    GetAsJsonString() {
      this._MaybeResizeTilemap()
      const [p, q] = this.GetMapDisplaySize()
      return JSON.stringify({
        c2tilemap: !0,
        width: p,
        height: q,
        data: this.GetTilesAsRLECSV()
      })
    }
    StateComboToFlags(p) {
      switch (p) {
        case 0:
          return 0
        case 1:
          return a
        case 2:
          return c
        case 3:
          return a | d
        case 4:
          return a | c
        case 5:
          return c | d
        case 6:
          return a | c | d
        case 7:
          return d
        default:
          return 0
      }
    }
    GetPropertyValueByIndex(p) {
      switch (p) {
        case 1:
          return this._tileWidth
        case 2:
          return this._tileHeight
        case 3:
          return this._tileXoffset
        case 4:
          return this._tileYoffset
        case 5:
          return this._tileXspacing
        case 6:
          return this._tileYspacing
      }
    }
    SetPropertyValueByIndex(p, q) {
      switch (p) {
        case 1:
          if (this._tileWidth === q) break
          this._tileWidth = Math.max(q, 1)
          this._cellWidth = Math.ceil(this._runtime.GetOriginalViewportWidth() / this._tileWidth)
          this._sdkType._ForceCacheOfTileCollisionPolys()
          this._UpdateQuadMaps()
          break
        case 2:
          if (this._tileHeight === q) break
          this._tileHeight = Math.max(q, 1)
          this._cellHeight = Math.ceil(this._runtime.GetOriginalViewportHeight() / this._tileHeight)
          this._sdkType._ForceCacheOfTileCollisionPolys()
          this._UpdateQuadMaps()
          break
        case 3:
          if (this._tileXoffset === q) break
          this._tileXoffset = q
          this._UpdateQuadMaps()
          break
        case 4:
          if (this._tileYoffset === q) break
          this._tileYoffset = q
          this._UpdateQuadMaps()
          break
        case 5:
          if (this._tileXspacing === q) break
          this._tileXspacing = q
          this._UpdateQuadMaps()
          break
        case 6:
          this._tileYspacing !== q && ((this._tileYspacing = q), this._UpdateQuadMaps())
      }
    }
    _UpdateQuadMaps() {
      this._tileTexQuads.clear()
      this._SetAllQuadMapChanged()
      this._MaybeBuildAllQuadMap()
    }
    GetScriptInterfaceClass() {
      return w
    }
  }
  const r = new WeakMap(),
    w = (self.ITilemapInstance = class extends self.IWorldInstance {
      constructor() {
        super()
        r.set(this, self.IInstance._GetInitInst().GetSdkInstance())
      }
      get mapWidth() {
        return r.get(this).GetMapWidth()
      }
      get mapHeight() {
        return r.get(this).GetMapHeight()
      }
      get mapDisplayWidth() {
        return r.get(this).GetMapDisplayWidth()
      }
      get mapDisplayHeight() {
        return r.get(this).GetMapDisplayHeight()
      }
      get tileWidth() {
        return r.get(this).GetTileWidth()
      }
      get tileHeight() {
        return r.get(this).GetTileHeight()
      }
      getTileAt(p, q) {
        b.RequireFiniteNumber(p)
        b.RequireFiniteNumber(q)
        return r.get(this).GetTileAt(p, q)
      }
      setTileAt(p, q, t) {
        b.RequireFiniteNumber(p)
        b.RequireFiniteNumber(q)
        b.RequireFiniteNumber(t)
        return r.get(this).SetTileAt(p, q, t)
      }
    })
  w.TILE_FLIPPED_HORIZONTAL = a
  w.TILE_FLIPPED_VERTICAL = c
  w.TILE_FLIPPED_DIAGONAL = d
  w.TILE_FLAGS_MASK = f
  w.TILE_ID_MASK = g
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLAGS_MASK,
    a = e.Plugins.Tilemap.TILE_ID_MASK
  e.Plugins.Tilemap.Cnds = {
    CompareTileAt(c, d, f, g) {
      c = this.GetTileAt(c, d)
      ;-1 !== c && (c &= a)
      return e.compare(c, f, g)
    },
    CompareTileStateAt(c, d, f) {
      c = this.GetTileAt(c, d)
      d = 0
      ;-1 !== c && (d = c & b)
      return d === this.StateComboToFlags(f)
    },
    OnURLLoaded() {
      return !0
    },
    OnURLFailed() {
      return !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_ID_MASK
  e.Plugins.Tilemap.Acts = {
    EraseTile(a, c) {
      this._MaybeResizeTilemap()
      this.SetTileAt(a, c, -1)
    },
    SetTile(a, c, d, f) {
      this._MaybeResizeTilemap()
      this.SetTileAt(a, c, (d & b) | this.StateComboToFlags(f))
    },
    SetTileState(a, c, d) {
      const f = this.GetTileAt(a, c)
      ;-1 !== f && (this._MaybeResizeTilemap(), this.SetTileAt(a, c, (f & b) | this.StateComboToFlags(d)))
    },
    EraseTileRange(a, c, d, f) {
      const g = Math.floor(Math.max(a, 0))
      var h = Math.floor(Math.max(c, 0))
      a = Math.floor(Math.min(a + d, this._mapWidth))
      for (c = Math.floor(Math.min(c + f, this._mapHeight)); h < c; ++h) for (f = g; f < a; ++f) this.SetTileAt(f, h, -1)
    },
    SetTileRange(a, c, d, f, g, h) {
      this._MaybeResizeTilemap()
      const k = Math.floor(Math.max(a, 0))
      var m = Math.floor(Math.max(c, 0))
      a = Math.floor(Math.min(a + d, this._mapWidth))
      c = Math.floor(Math.min(c + f, this._mapHeight))
      for (g = (g & b) | this.StateComboToFlags(h); m < c; ++m) for (h = k; h < a; ++h) this.SetTileAt(h, m, g)
    },
    SetTileStateRange(a, c, d, f, g) {
      this._MaybeResizeTilemap()
      const h = Math.floor(Math.max(a, 0))
      var k = Math.floor(Math.max(c, 0))
      a = Math.floor(Math.min(a + d, this._mapWidth))
      c = Math.floor(Math.min(c + f, this._mapHeight))
      for (g = this.StateComboToFlags(g); k < c; ++k) for (f = h; f < a; ++f) (d = this.GetTileAt(f, k)), -1 !== d && this.SetTileAt(f, k, (d & b) | g)
    },
    LoadFromJSON(a) {
      let c = null
      try {
        c = JSON.parse(a)
      } catch (d) {
        console.error('[Construct 3] Failed to parse tilemap JSON: ', d)
        return
      }
      c.c2tilemap ? ((this._mapWidth = c.width), (this._mapHeight = c.height), this._MaybeResizeTilemap(!0), this.SetTilesFromRLECSV(c.data), this._SetAllQuadMapChanged(), this._SetPhysicsChanged()) : console.error('[Construct 3] Unrecognized JSON data format')
    },
    JSONDownload(a) {
      const c = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], {
          type: 'application/json'
        })
      )
      this._runtime.InvokeDownload(c, a)
    },
    async LoadURL(a, c) {
      if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== a) {
        c = this._runtime
        var d = e.New(e.ImageInfo)
        try {
          await d.LoadDynamicAsset(c, a)
          if (!d.IsLoaded()) throw Error('image failed to load')
          if (this.WasReleased()) return d.Release(), null
          if (
            !(await d.LoadStaticTexture(c.GetRenderer(), {
              sampling: this._runtime.GetSampling()
            }))
          )
            return
        } catch (f) {
          console.error('Load image from URL failed: ', f)
          this.Trigger(e.Plugins.Tilemap.Cnds.OnURLFailed)
          return
        }
        this.WasReleased() ? d.Release() : (this._ReleaseOwnImage(), (this._ownImageInfo = d), c.UpdateRender(), this._tileTexQuads.clear(), this._SetAllQuadMapChanged(), await this.TriggerAsync(e.Plugins.Tilemap.Cnds.OnURLLoaded))
      }
    },
    SetEffect(a) {
      2 <= a && a++
      this.GetWorldInfo().SetBlendMode(a)
      this._runtime.UpdateRender()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_ID_MASK
  e.Plugins.Tilemap.Exps = {
    TileAt(a, c) {
      a = this.GetTileAt(a, c)
      return -1 === a ? -1 : a & b
    },
    PositionToTileX(a) {
      return this.WorldToTileX(a)
    },
    PositionToTileY(a) {
      return this.WorldToTileY(a)
    },
    TileToPositionX(a) {
      return a * this._tileWidth + this.GetWorldInfo().GetX() + this._tileWidth / 2
    },
    TileToPositionY(a) {
      return a * this._tileHeight + this.GetWorldInfo().GetY() + this._tileHeight / 2
    },
    SnapX(a) {
      const c = this.GetWorldInfo().GetX()
      return Math.floor((a - c) / this._tileWidth) * this._tileWidth + c + this._tileWidth / 2
    },
    SnapY(a) {
      const c = this.GetWorldInfo().GetY()
      return Math.floor((a - c) / this._tileHeight) * this._tileHeight + c + this._tileHeight / 2
    },
    TilesJSON() {
      return this.GetAsJsonString()
    },
    TileWidth() {
      return this.GetTileWidth()
    },
    TileHeight() {
      return this.GetTileHeight()
    },
    MapDisplayWidth() {
      return this.GetMapDisplayWidth()
    },
    MapDisplayHeight() {
      return this.GetMapDisplayHeight()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Plugins.Tilemap.TILE_FLIPPED_HORIZONTAL,
    a = e.Plugins.Tilemap.TILE_FLIPPED_VERTICAL,
    c = e.Plugins.Tilemap.TILE_FLIPPED_DIAGONAL,
    d = e.Plugins.Tilemap.TILE_ID_MASK,
    f = e.New(e.Rect),
    g = e.New(e.Quad)
  e.Plugins.Tilemap.TileQuad = class extends e.DefendedBase {
    constructor() {
      super()
      this._tileId = this._id = -1
      this._isDiagFlip = this._isVertFlip = this._isHorizFlip = !1
      this._rc = e.New(e.Rect)
      this._uv = null
    }
    Update(h, k, m, r, w, p, q, t) {
      this._id = h
      this._tileId = h & d
      this._isHorizFlip = 0 !== (h & b)
      this._isVertFlip = 0 !== (h & a)
      this._isDiagFlip = 0 !== (h & c)
      this._rc.setWH(r * k + p, w * m + q, k, m)
      this._uv = t.GetTileUvQuad(this._id)
    }
    Draw(h, k, m, r, w) {
      f.copy(this._rc)
      f.offset(m, r)
      f.intersectsRect(k) && (g.setFromRect(f), h.Quad4(g, this._uv))
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Tilemap.TileCollisionRect = class extends e.DefendedBase {
    constructor() {
      super()
      this._id = -1
      this._poly = null
      this._rc = e.New(e.Rect)
    }
    Update(b, a, c, d, f, g, h, k) {
      this._id = b
      this._poly = a
      this._rc.setWH(f * c + h, g * d + k, c, d)
    }
    ExtendRight(b) {
      this._rc.setRight(this._rc.getRight() + b)
    }
    GetTileId() {
      return this._id
    }
    HasPoly() {
      return !!this._poly
    }
    GetPoly() {
      return this._poly
    }
    GetRect() {
      return this._rc
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Tilemap.TileCell = class extends e.DefendedBase {
    constructor(b, a, c) {
      super()
      const d = b.GetCellWidth(),
        f = b.GetCellHeight()
      this._sdkInst = b
      this._x = a
      this._y = c
      this._left = this._x * d * b.GetTileWidth()
      this._top = this._y * f * b.GetTileHeight()
      this._tiles = []
      this._quads = []
      this._collisionRects = []
      this._isQuadMapValid = !1
      for (b = 0; b < f; ++b) (a = new Int32Array(d)), a.fill(-1), this._tiles.push(a)
    }
    Clear() {
      const b = this._sdkInst.GetCellWidth()
      var a = this._sdkInst.GetCellHeight()
      const c = this._tiles
      if (c.length < a) for (let d = c.length; d < a; ++d) c.push(new Int32Array(b))
      else c.length > a && e.truncateArray(c, a)
      for (let d = 0, f = c.length; d < f; ++d) (a = c[d]), a.length !== b && ((a = new Int32Array(b)), (c[d] = a)), a.fill(-1)
    }
    _SetQuadMapChanged() {
      this._isQuadMapValid = !1
    }
    MaybeBuildQuadMap() {
      if (!this._isQuadMapValid) {
        var b = this._sdkInst,
          a = b.GetSdkType(),
          c = b.GetWorldInfo(),
          d = b.GetTileWidth(),
          f = b.GetTileHeight(),
          g = b.GetCellWidth(),
          h = b.GetCellHeight(),
          k = this._left,
          m = this._top
        if (!(0 >= d || 0 >= f)) {
          var r = Math.min(b.GetMapWidth(), Math.floor(c.GetWidth() / d))
          c = Math.min(b.GetMapHeight(), Math.floor(c.GetHeight() / f))
          r -= k / d
          c -= m / f
          r > g && (r = g)
          c > h && (c = h)
          g = this._tiles
          h = this._quads
          var w = 0
          for (var p = 0; p < c; ++p) {
            var q = g[p]
            for (var t = 0; t < r; ++t) {
              var x = q[t]
              if (-1 !== x) {
                var v = void 0
                w < h.length ? (v = h[w]) : ((v = e.New(e.Plugins.Tilemap.TileQuad)), h.push(v))
                v.Update(x, d, f, t, p, k, m, b)
                ++w
              }
            }
          }
          w < h.length && e.truncateArray(h, w)
          h = null
          w = !1
          b = this._collisionRects
          e.clearArray(b)
          for (p = 0; p < c; ++p) {
            q = g[p]
            for (t = 0; t < r; ++t) {
              x = q[t]
              v = a.GetTilePoly(x)
              const u = a.IsTilePolyEnabled(v)
              ;-1 !== x && u ? (!h || v || w ? (h && b.push(h), (h = e.New(e.Plugins.Tilemap.TileCollisionRect)), h.Update(x, v, d, f, t, p, k, m), (w = !!v)) : h.ExtendRight(d)) : h && (b.push(h), (h = null), (w = !1))
            }
            h && (b.push(h), (h = null), (w = !1))
          }
          a = b.length
          for (d = 0; d < a; ++d)
            if (((k = b[d]), !k.HasPoly()))
              for (k = k.GetRect(), m = d + 1; m < a; ++m)
                (r = b[m]),
                  (c = r.GetRect()),
                  c.getTop() < k.getBottom() || c.getTop() > k.getBottom() || c.getRight() > k.getRight() || c.getLeft() > k.getLeft() || r.HasPoly() || c.getLeft() !== k.getLeft() || c.getRight() !== k.getRight() || (b.splice(m, 1), --a, k.setBottom(k.getBottom() + f), --m)
          this._isQuadMapValid = !0
        }
      }
    }
    SetTileAt(b, a, c) {
      this._tiles[a][b] !== c && ((this._tiles[a][b] = c), (this._isQuadMapValid = !1), this._sdkInst.SetTileChanged())
    }
    GetTilesArr() {
      return this._tiles
    }
    GetCollisionRects() {
      return this._collisionRects
    }
    Draw(b, a, c, d) {
      const f = this._sdkInst,
        g = this._quads
      for (let h = 0, k = g.length; h < k; ++h) g[h].Draw(b, a, c, d, f)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.gamepad = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
      this._isSupported = !1
      this._runtime.AddLoadPromise(this._runtime.PostComponentMessageToDOMAsync('gamepad', 'is-supported').then(a => (this._isSupported = !!a)))
    }
    Release() {
      super.Release()
    }
    IsSupported() {
      return this._isSupported
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.gamepad.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  class b {
    constructor(c, d) {
      this._index = c
      this._id = d
      this._state = new a()
      this._oldState = new a()
      this._buttonsPressed = []
      this._buttonsReleased = []
    }
    GetID() {
      return this._id
    }
    Update(c, d) {
      const f = this._oldState
      this._oldState = this._state
      this._state = f
      this._state.Update(c, d)
      e.resizeArray(this._buttonsPressed, this._state.GetButtonCount(), !1)
      e.resizeArray(this._buttonsReleased, this._state.GetButtonCount(), !1)
      for (let g = 0, h = this._state.GetButtonCount(); g < h; ++g) (c = this._oldState.GetButtonAt(g)), (d = this._state.GetButtonAt(g)), 0.5 <= d && 0.5 > c && (this._buttonsPressed[g] = !0), 0.5 > d && 0.5 <= c && (this._buttonsReleased[g] = !0)
    }
    GetButtonCount() {
      return this._state.GetButtonCount()
    }
    GetAxisCount() {
      return this._state.GetAxisCount()
    }
    HasButtonBecomePressed(c) {
      c = Math.floor(c)
      return 0 > c || c >= this._buttonsPressed.length ? !1 : this._buttonsPressed[c]
    }
    HasButtonBecomeReleased(c) {
      c = Math.floor(c)
      return 0 > c || c >= this._buttonsReleased.length ? !1 : this._buttonsReleased[c]
    }
    ResetButtonPressAndReleaseFlags() {
      this._buttonsPressed.fill(!1)
      this._buttonsReleased.fill(!1)
    }
    GetButtonAt(c) {
      return this._state.GetButtonAt(c)
    }
    IsButtonDown(c) {
      return 0.5 <= this._state.GetButtonAt(c)
    }
    GetAxisAt(c) {
      return this._state.GetAxisAt(c)
    }
  }
  class a {
    constructor() {
      this._buttons = []
      this._axes = []
    }
    Update(c, d) {
      const f = this._buttons
      let g = 0
      for (let h = c.length; g < h; ++g) {
        const k = c[g]
        g === f.length ? f.push(k.value) : (f[g] = k.value)
      }
      g < f.length && e.truncateArray(f, g)
      e.shallowAssignArray(this._axes, d)
    }
    GetButtonCount() {
      return this._buttons.length
    }
    GetAxisCount() {
      return this._axes.length
    }
    GetButtonAt(c) {
      c = Math.floor(c)
      return 0 > c || c >= this._buttons.length ? 0 : this._buttons[c]
    }
    GetAxisAt(c) {
      c = Math.floor(c)
      return 0 > c || c >= this._axes.length ? 0 : this._axes[c]
    }
  }
  e.Plugins.gamepad.Instance = class extends e.SDKInstanceBase {
    constructor(c, d) {
      super(c, 'gamepad')
      this._deadZone = 25
      this._lastButton = 0
      this._lastIndex = -1
      this._gamepads = new Map()
      d && (this._deadZone = d[0])
      this.AddDOMMessageHandler('gamepad-connected', f => this._OnGamepadConnected(f))
      this.AddDOMMessageHandler('gamepad-disconnected', f => this._OnGamepadDisconnected(f))
      this.AddDOMMessageHandler('input-update', f => this._OnInputUpdate(f))
      c = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(e.Disposable.From(c, 'tick2', () => this._OnTick2()))
      this.PostToDOM('ready')
    }
    Release() {
      super.Release()
    }
    _OnGamepadConnected(c) {
      const d = c.index
      this._lastIndex = d
      c = c.id
      this._gamepads.has(d) || (this._gamepads.set(d, new b(d, c)), this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadConnected), (this._lastIndex = -1))
    }
    _OnGamepadDisconnected(c) {
      this._lastIndex = c = c.index
      this.Trigger(e.Plugins.gamepad.Cnds.OnGamepadDisconnected)
      this._gamepads.delete(c)
      this._lastIndex = -1
    }
    _OnInputUpdate(c) {
      for (const d of c) this._OnGamepadInputUpdate(d)
    }
    _OnGamepadInputUpdate(c) {
      var d = c.index
      this._gamepads.has(d) || this._OnGamepadConnected(c)
      d = this._gamepads.get(d)
      d.Update(c.buttons, c.axes)
      for (let f = 0, g = d.GetButtonCount(); f < g; ++f) d.HasButtonBecomePressed(f) && (this._lastButton = f)
    }
    _GetGamepadByIndex(c) {
      return this._gamepads.get(Math.floor(c)) || null
    }
    _OnTick2() {
      for (const c of this._gamepads.values()) c.ResetButtonPressAndReleaseFlags()
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.gamepad.name',
          properties: [
            {
              name: 'plugins.gamepad.debugger.last-button',
              value: this._lastButton
            }
          ]
        }
      ]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.gamepad.Cnds = {
    SupportsGamepad() {
      return this.GetPlugin().IsSupported()
    },
    OnGamepadConnected() {
      return !0
    },
    OnGamepadDisconnected() {
      return !0
    },
    IsButtonDown(b, a) {
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.IsButtonDown(a))) this._lastButton = a
      return b
    },
    OnButtonDown(b, a) {
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.HasButtonBecomePressed(a))) this._lastButton = a
      return b
    },
    OnButtonUp(b, a) {
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.HasButtonBecomeReleased(a))) this._lastButton = a
      return b
    },
    HasGamepads() {
      return 0 < this._gamepads.size
    },
    CompareAxis(b, a, c, d) {
      a = Math.floor(a)
      const f = this._GetGamepadByIndex(b)
      if (!f) return !1
      b = f.GetAxisAt(a)
      a = 0 === a % 2 ? f.GetAxisAt(a + 1) : f.GetAxisAt(a - 1)
      b *= 100
      Math.hypot(b, 100 * a) <= this._deadZone && (b = 0)
      return e.compare(b, c, d)
    },
    OnAnyButtonDown(b) {
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      for (let a = 0, c = b.GetButtonCount(); a < c; ++a) if (b.HasButtonBecomePressed(a)) return (this._lastButton = a), !0
      return !1
    },
    OnAnyButtonUp(b) {
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      for (let a = 0, c = b.GetButtonCount(); a < c; ++a) if (b.HasButtonBecomeReleased(a)) return (this._lastButton = a), !0
      return !1
    },
    IsButtonIndexDown(b, a) {
      a = Math.floor(a)
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.IsButtonDown(a))) this._lastButton = a
      return b
    },
    OnButtonIndexDown(b, a) {
      a = Math.floor(a)
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.HasButtonBecomePressed(a))) this._lastButton = a
      return b
    },
    OnButtonIndexUp(b, a) {
      a = Math.floor(a)
      b = this._GetGamepadByIndex(b)
      if (!b) return !1
      if ((b = b.HasButtonBecomeReleased(a))) this._lastButton = a
      return b
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.gamepad.Acts = {
    Vibrate(b, a, c, d) {
      this.PostToDOM('vibrate', {
        index: b,
        duration: a,
        weakMag: e.clamp(c / 100, 0, 1),
        strongMag: e.clamp(d / 100, 0, 1)
      })
    },
    ResetVibrate(b) {
      this.PostToDOM('reset-vibrate', {
        index: b
      })
    }
  }
}
;('use strict')
self.C3.Plugins.gamepad.Exps = {
  GamepadCount() {
    return this._gamepads.size
  },
  GamepadID(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetID() : ''
  },
  GamepadIndex() {
    return this._lastIndex
  },
  GamepadAxes(e) {
    e = this._GetGamepadByIndex(e)
    if (!e) return ''
    let b = ''
    for (let a = 0, c = e.GetAxisCount(); a < c; ++a) b += `Axis ${a}: ${Math.round(100 * e.GetAxisAt(a))}\n`
    return b
  },
  GamepadButtons(e) {
    e = this._GetGamepadByIndex(e)
    if (!e) return ''
    let b = ''
    for (let a = 0, c = e.GetButtonCount(); a < c; ++a) b += `Button ${a}: ${Math.round(100 * e.GetButtonAt(a))}\n`
    return b
  },
  RawButton(e, b) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetButtonAt(Math.floor(b)) : 0
  },
  RawAxis(e, b) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetAxisAt(Math.floor(b)) : 0
  },
  RawButtonCount(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetButtonCount() : 0
  },
  RawAxisCount(e) {
    return (e = this._GetGamepadByIndex(e)) ? e.GetAxisCount() : 0
  },
  Button(e, b) {
    return (e = this._GetGamepadByIndex(e)) ? 100 * e.GetButtonAt(Math.floor(b)) : 0
  },
  Axis(e, b) {
    b = Math.floor(b)
    const a = this._GetGamepadByIndex(e)
    if (!a) return 0
    e = a.GetAxisAt(b)
    b = 0 === b % 2 ? a.GetAxisAt(b + 1) : a.GetAxisAt(b - 1)
    e *= 100
    Math.hypot(e, 100 * b) <= this._deadZone && (e = 0)
    return e
  },
  LastButton() {
    return this._lastButton
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Keyboard = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Keyboard.Type = class extends e.SDKTypeBase {
    constructor(c) {
      super(c)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IKeyboardObjectType
    }
  }
  let b = null

  function a() {
    return b.GetSingleGlobalInstance().GetSdkInstance()
  }
  self.IKeyboardObjectType = class extends self.IObjectClass {
    constructor(c) {
      super(c)
      b = c
      c.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
    }
    isKeyDown(c) {
      const d = a()
      if ('string' === typeof c) return d.IsKeyDown(c)
      if ('number' === typeof c) return d.IsKeyCodeDown(c)
      throw new TypeError('expected string or number')
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Keyboard.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b)
      this._keysDownByString = new Set()
      this._keysDownByWhich = new Set()
      this._triggerWhich = 0
      this._triggerTypedKey = this._triggerString = ''
      b = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'keydown', c => this._OnKeyDown(c.data)),
        e.Disposable.From(b, 'keyup', c => this._OnKeyUp(c.data)),
        e.Disposable.From(b, 'window-blur', () => this._OnWindowOrKeyboardBlur()),
        e.Disposable.From(b, 'keyboard-blur', () => this._OnWindowOrKeyboardBlur())
      )
    }
    Release() {
      super.Release()
    }
    _OnKeyDown(b) {
      const a = b.which,
        c = b.code || a.toString()
      b = b.key
      this._keysDownByString.has(c) ||
        (this._keysDownByString.add(c),
        this._keysDownByWhich.add(a),
        (this._triggerString = c),
        (this._triggerWhich = a),
        (this._triggerTypedKey = b),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKey),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnKey),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCode))
    }
    _OnKeyUp(b) {
      const a = b.which,
        c = b.code || a.toString()
      b = b.key
      this._keysDownByString.delete(c)
      this._keysDownByWhich.delete(a)
      this._triggerString = c
      this._triggerWhich = a
      this._triggerTypedKey = b
      this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased)
      this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased)
      this.Trigger(e.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased)
      this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
    }
    _OnWindowOrKeyboardBlur() {
      for (const b of this._keysDownByWhich) this._keysDownByWhich.delete(b), (this._triggerWhich = b), this.Trigger(e.Plugins.Keyboard.Cnds.OnAnyKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyReleased), this.Trigger(e.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
      this._keysDownByString.clear()
    }
    IsKeyDown(b) {
      return this._keysDownByString.has(b)
    }
    IsKeyCodeDown(b) {
      return this._keysDownByWhich.has(b)
    }
    SaveToJson() {
      return {
        tk: this._triggerWhich,
        tkk: this._triggerTypedKey
      }
    }
    LoadFromJson(b) {
      this._triggerWhich = b.tk
      b.hasOwnProperty('tkk') && (this._triggerTypedKey = b.tkk)
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.keyboard.name',
          properties: [
            {
              name: 'plugins.keyboard.debugger.last-key-code',
              value: this._triggerWhich
            },
            {
              name: 'plugins.keyboard.debugger.last-key-string',
              value: e.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
            },
            {
              name: 'plugins.keyboard.debugger.last-typed-key',
              value: this._triggerTypedKey
            }
          ]
        }
      ]
    }
  }
}
{
  ;('use strict')
  const e = 'ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight'.split(' ')
  self.C3.Plugins.Keyboard.Cnds = {
    IsKeyDown(b) {
      return this._keysDownByWhich.has(b)
    },
    OnKey(b) {
      return this._triggerWhich === b
    },
    OnAnyKey() {
      return !0
    },
    OnAnyKeyReleased() {
      return !0
    },
    OnKeyReleased(b) {
      return this._triggerWhich === b
    },
    IsKeyCodeDown(b) {
      b = Math.floor(b)
      return this._keysDownByWhich.has(b)
    },
    OnKeyCode(b) {
      return this._triggerWhich === b
    },
    OnKeyCodeReleased(b) {
      return this._triggerWhich === b
    },
    OnLeftRightKeyPressed(b) {
      return this._triggerString === e[b]
    },
    OnLeftRightKeyReleased(b) {
      return this._triggerString === e[b]
    },
    IsLeftRightKeyDown(b) {
      return this._keysDownByString.has(e[b])
    }
  }
}
;('use strict')
self.C3.Plugins.Keyboard.Acts = {}
{
  ;('use strict')

  function e(b) {
    b = Math.floor(b)
    switch (b) {
      case 8:
        return 'backspace'
      case 9:
        return 'tab'
      case 13:
        return 'enter'
      case 16:
        return 'shift'
      case 17:
        return 'control'
      case 18:
        return 'alt'
      case 19:
        return 'pause'
      case 20:
        return 'capslock'
      case 27:
        return 'esc'
      case 33:
        return 'pageup'
      case 34:
        return 'pagedown'
      case 35:
        return 'end'
      case 36:
        return 'home'
      case 37:
        return '\u2190'
      case 38:
        return '\u2191'
      case 39:
        return '\u2192'
      case 40:
        return '\u2193'
      case 45:
        return 'insert'
      case 46:
        return 'del'
      case 91:
        return 'left window key'
      case 92:
        return 'right window key'
      case 93:
        return 'select'
      case 96:
        return 'numpad 0'
      case 97:
        return 'numpad 1'
      case 98:
        return 'numpad 2'
      case 99:
        return 'numpad 3'
      case 100:
        return 'numpad 4'
      case 101:
        return 'numpad 5'
      case 102:
        return 'numpad 6'
      case 103:
        return 'numpad 7'
      case 104:
        return 'numpad 8'
      case 105:
        return 'numpad 9'
      case 106:
        return 'numpad *'
      case 107:
        return 'numpad +'
      case 109:
        return 'numpad -'
      case 110:
        return 'numpad .'
      case 111:
        return 'numpad /'
      case 112:
        return 'F1'
      case 113:
        return 'F2'
      case 114:
        return 'F3'
      case 115:
        return 'F4'
      case 116:
        return 'F5'
      case 117:
        return 'F6'
      case 118:
        return 'F7'
      case 119:
        return 'F8'
      case 120:
        return 'F9'
      case 121:
        return 'F10'
      case 122:
        return 'F11'
      case 123:
        return 'F12'
      case 144:
        return 'numlock'
      case 145:
        return 'scroll lock'
      case 186:
        return ';'
      case 187:
        return '='
      case 188:
        return ','
      case 189:
        return '-'
      case 190:
        return '.'
      case 191:
        return '/'
      case 192:
        return "'"
      case 219:
        return '['
      case 220:
        return '\\'
      case 221:
        return ']'
      case 222:
        return '#'
      case 223:
        return '`'
      default:
        return String.fromCharCode(b)
    }
  }
  self.C3.Plugins.Keyboard.Exps = {
    LastKeyCode() {
      return this._triggerWhich
    },
    StringFromKeyCode(b) {
      return e(b)
    },
    TypedKey() {
      return this._triggerTypedKey
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Mouse = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Mouse.Type = class extends e.SDKTypeBase {
    constructor(c) {
      super(c)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.IMouseObjectType
    }
  }
  let b = null

  function a() {
    return b.GetSingleGlobalInstance().GetSdkInstance()
  }
  self.IMouseObjectType = class extends self.IObjectClass {
    constructor(c) {
      super(c)
      b = c
      c.GetRuntime()._GetCommonScriptInterfaces().mouse = this
    }
    getMouseX(c) {
      return a().GetMousePositionForLayer(c)[0]
    }
    getMouseY(c) {
      return a().GetMousePositionForLayer(c)[1]
    }
    getMousePosition(c) {
      return a().GetMousePositionForLayer(c)
    }
    isMouseButtonDown(c) {
      return a().IsMouseButtonDown(c)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Mouse.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, 'mouse')
      this._buttonMap = [!1, !1, !1]
      this._triggerDir = this._triggerType = this._triggerButton = this._mouseYcanvas = this._mouseXcanvas = 0
      b = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'pointermove', c => this._OnPointerMove(c.data)),
        e.Disposable.From(b, 'pointerdown', c => this._OnPointerDown(c.data)),
        e.Disposable.From(b, 'pointerup', c => this._OnPointerUp(c.data)),
        e.Disposable.From(b, 'dblclick', c => this._OnDoubleClick(c.data)),
        e.Disposable.From(b, 'wheel', c => this._OnMouseWheel(c.data)),
        e.Disposable.From(b, 'window-blur', () => this._OnWindowBlur())
      )
    }
    Release() {
      super.Release()
    }
    _OnPointerDown(b) {
      'mouse' === b.pointerType && ((this._mouseXcanvas = b.pageX - this._runtime.GetCanvasClientX()), (this._mouseYcanvas = b.pageY - this._runtime.GetCanvasClientY()), this._CheckButtonChanges(b.lastButtons, b.buttons))
    }
    _OnPointerMove(b) {
      'mouse' === b.pointerType && ((this._mouseXcanvas = b.pageX - this._runtime.GetCanvasClientX()), (this._mouseYcanvas = b.pageY - this._runtime.GetCanvasClientY()), this._CheckButtonChanges(b.lastButtons, b.buttons))
    }
    _OnPointerUp(b) {
      'mouse' === b.pointerType && this._CheckButtonChanges(b.lastButtons, b.buttons)
    }
    _CheckButtonChanges(b, a) {
      this._CheckButtonChange(b, a, 1, 0)
      this._CheckButtonChange(b, a, 4, 1)
      this._CheckButtonChange(b, a, 2, 2)
    }
    _CheckButtonChange(b, a, c, d) {
      !(b & c) && a & c ? this._OnMouseDown(d) : b & c && !(a & c) && this._OnMouseUp(d)
    }
    _OnMouseDown(b) {
      this._buttonMap[b] = !0
      this.Trigger(e.Plugins.Mouse.Cnds.OnAnyClick)
      this._triggerButton = b
      this._triggerType = 0
      this.Trigger(e.Plugins.Mouse.Cnds.OnClick)
      this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseUp(b) {
      this._buttonMap[b] && ((this._buttonMap[b] = !1), (this._triggerButton = b), this.Trigger(e.Plugins.Mouse.Cnds.OnRelease))
    }
    _OnDoubleClick(b) {
      this._triggerButton = b.button
      this._triggerType = 1
      this.Trigger(e.Plugins.Mouse.Cnds.OnClick)
      this.Trigger(e.Plugins.Mouse.Cnds.OnObjectClicked)
    }
    _OnMouseWheel(b) {
      this._triggerDir = 0 > b.deltaY ? 1 : 0
      this.Trigger(e.Plugins.Mouse.Cnds.OnWheel)
    }
    _OnWindowBlur() {
      for (let b = 0, a = this._buttonMap.length; b < a && this._buttonMap[b]; ++b) (this._buttonMap[b] = !1), (this._triggerButton = b), this.Trigger(e.Plugins.Mouse.Cnds.OnRelease)
    }
    GetMousePositionForLayer(b) {
      const a = this._runtime.GetMainRunningLayout(),
        c = this._mouseXcanvas,
        d = this._mouseYcanvas
      return 'undefined' === typeof b ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(c, d) : (b = a.GetLayer(b)) ? b.CanvasCssToLayer(c, d) : [0, 0]
    }
    IsMouseButtonDown(b) {
      b = Math.floor(b)
      return !!this._buttonMap[b]
    }
    _IsMouseOverCanvas() {
      return 0 <= this._mouseXcanvas && 0 <= this._mouseYcanvas && this._mouseXcanvas < this._runtime.GetCanvasCssWidth() && this._mouseYcanvas < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.mouse.name',
          properties: [
            {
              name: 'plugins.mouse.debugger.absolute-position',
              value: this._mouseXcanvas + ',' + this._mouseYcanvas
            },
            {
              name: 'plugins.mouse.debugger.left-button',
              value: this._buttonMap[0]
            },
            {
              name: 'plugins.mouse.debugger.middle-button',
              value: this._buttonMap[1]
            },
            {
              name: 'plugins.mouse.debugger.right-button',
              value: this._buttonMap[2]
            }
          ]
        },
        {
          title: 'plugins.mouse.debugger.position-on-each-layer',
          properties: this._runtime
            .GetMainRunningLayout()
            .GetLayers()
            .map(b => ({
              name: '$' + b.GetName(),
              value: b.CanvasCssToLayer(this._mouseXcanvas, this._mouseYcanvas).join(', ')
            }))
        }
      ]
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Mouse.Cnds = {
    OnClick(b, a) {
      return this._triggerButton === b && this._triggerType === a
    },
    OnAnyClick() {
      return !0
    },
    IsButtonDown(b) {
      return this._buttonMap[b]
    },
    OnRelease(b) {
      return this._triggerButton === b
    },
    IsOverObject(b) {
      if (!this._IsMouseOverCanvas()) return !1
      const a = this._runtime.GetCurrentCondition().IsInverted(),
        c = this._mouseXcanvas,
        d = this._mouseYcanvas
      return e.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(b, c, d, a), a)
    },
    OnObjectClicked(b, a, c) {
      if (b !== this._triggerButton || a !== this._triggerType || !this._IsMouseOverCanvas()) return !1
      b = this._mouseXcanvas
      a = this._mouseYcanvas
      return this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(c, b, a, !1)
    },
    OnWheel(b) {
      return this._triggerDir === b
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = null
  const a = 'auto pointer text crosshair move help wait none'.split(' ')
  e.Plugins.Mouse.Acts = {
    SetCursor(c) {
      c = a[c]
      b !== c && ((b = c), this.PostToDOM('cursor', c))
    },
    SetCursorSprite(c) {
      if (!e.Platform.IsMobile && c && (c = c.GetFirstPicked())) {
        var d = c.GetWorldInfo(),
          f = c.GetCurrentImageInfo()
        d &&
          f &&
          b !== f &&
          ((b = f),
          f
            .ExtractImageToCanvas()
            .then(g => e.CanvasToBlob(g))
            .then(g => {
              g = `url(${URL.createObjectURL(g)}) ${Math.round(d.GetOriginX() * f.GetWidth())} ${Math.round(d.GetOriginY() * f.GetHeight())}, auto`
              this.PostToDOM('cursor', '')
              this.PostToDOM('cursor', g)
            }))
      }
    }
  }
}
;('use strict')
self.C3.Plugins.Mouse.Exps = {
  X(e) {
    return this.GetMousePositionForLayer(e)[0]
  },
  Y(e) {
    return this.GetMousePositionForLayer(e)[1]
  },
  AbsoluteX() {
    return this._mouseXcanvas
  },
  AbsoluteY() {
    return this._mouseYcanvas
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Touch = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X
  e.Plugins.Touch.Type = class extends e.SDKTypeBase {
    constructor(d) {
      super(d)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass() {
      return self.ITouchObjectType
    }
  }
  let a = null

  function c() {
    return a.GetSingleGlobalInstance().GetSdkInstance()
  }
  self.ITouchObjectType = class extends self.IObjectClass {
    constructor(d) {
      super(d)
      a = d
      d.GetRuntime()._GetCommonScriptInterfaces().touch = this
    }
    requestPermission(d) {
      b.RequireString(d)
      const f = c()
      if ('orientation' === d) return f._RequestPermission(0)
      if ('motion' === d) return f._RequestPermission(1)
      throw Error('invalid type')
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Touch.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, 'touch')
      this._touches = new Map()
      this._isMouseDown = this._useMouseInput = !1
      this._getTouchIndex =
        this._curTouchY =
        this._curTouchX =
        this._triggerPermission =
        this._triggerId =
        this._triggerIndex =
        this._accWithGZ =
        this._accWithGY =
        this._accWithGX =
        this._accZ =
        this._accY =
        this._accX =
        this._orientGamma =
        this._orientBeta =
        this._orientAlpha =
        this._orientCompassHeading =
          0
      this._permissionPromises = []
      a && (this._useMouseInput = a[0])
      this.AddDOMMessageHandler('permission-result', c => this._OnPermissionResult(c))
      b = this.GetRuntime().Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'pointerdown', c => this._OnPointerDown(c.data)),
        e.Disposable.From(b, 'pointermove', c => this._OnPointerMove(c.data)),
        e.Disposable.From(b, 'pointerup', c => this._OnPointerUp(c.data, !1)),
        e.Disposable.From(b, 'pointercancel', c => this._OnPointerUp(c.data, !0)),
        e.Disposable.From(b, 'deviceorientation', c => this._OnDeviceOrientation(c.data)),
        e.Disposable.From(b, 'deviceorientationabsolute', c => this._OnDeviceOrientationAbsolute(c.data)),
        e.Disposable.From(b, 'devicemotion', c => this._OnDeviceMotion(c.data)),
        e.Disposable.From(b, 'tick2', c => this._OnTick2())
      )
    }
    Release() {
      this._touches.clear()
      super.Release()
    }
    _OnPointerDown(b) {
      if ('mouse' === b.pointerType)
        if (this._useMouseInput) this._isMouseDown = !0
        else return
      const a = b.pointerId
      if (!this._touches.has(a)) {
        var c = b.pageX - this._runtime.GetCanvasClientX()
        b = b.pageY - this._runtime.GetCanvasClientY()
        var d = performance.now(),
          f = this._touches.size
        this._triggerIndex = f
        this._triggerId = a
        var g = e.New(e.Plugins.Touch.TouchInfo)
        g.Init(d, c, b, a, f)
        this._touches.set(a, g)
        this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchStart)
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchStart)
        this._curTouchX = c
        this._curTouchY = b
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchObject)
      }
    }
    _OnPointerMove(b) {
      if ('mouse' !== b.pointerType || this._isMouseDown) {
        var a = this._touches.get(b.pointerId)
        if (a) {
          var c = performance.now()
          if (!(2 > c - a.GetTime())) {
            var d = b.pageX - this._runtime.GetCanvasClientX(),
              f = b.pageY - this._runtime.GetCanvasClientY()
            a.Update(c, d, f, b.width, b.height, b.pressure)
          }
        }
      }
    }
    _OnPointerUp(b, a) {
      if ('mouse' === b.pointerType)
        if (this._isMouseDown) this._isMouseDown = !1
        else return
      const c = performance.now()
      b = b.pointerId
      const d = this._touches.get(b)
      d &&
        ((this._triggerIndex = d.GetStartIndex()),
        (this._triggerId = d.GetId()),
        this.Trigger(e.Plugins.Touch.Cnds.OnNthTouchEnd),
        this.Trigger(e.Plugins.Touch.Cnds.OnTouchEnd),
        a ||
          ((a = d.ShouldTriggerTap(c)),
          'single-tap' === a
            ? (this.Trigger(e.Plugins.Touch.Cnds.OnTapGesture), (this._curTouchX = d.GetX()), (this._curTouchY = d.GetY()), this.Trigger(e.Plugins.Touch.Cnds.OnTapGestureObject))
            : 'double-tap' === a && (this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGesture), (this._curTouchX = d.GetX()), (this._curTouchY = d.GetY()), this.Trigger(e.Plugins.Touch.Cnds.OnDoubleTapGestureObject))),
        d.Release(),
        this._touches.delete(b))
    }
    _RequestPermission(b) {
      this._PostToDOMMaybeSync('request-permission', {
        type: b
      })
      return new Promise((a, c) => {
        this._permissionPromises.push({
          type: b,
          resolve: a,
          reject: c
        })
      })
    }
    _OnPermissionResult(b) {
      const a = b.result,
        c = b.type
      this._triggerPermission = c
      b = this._permissionPromises.filter(d => d.type === c)
      for (const d of b) d.resolve(a ? 'granted' : 'denied')
      this._permissionPromises = this._permissionPromises.filter(d => d.type !== c)
      a ? (this.Trigger(e.Plugins.Touch.Cnds.OnPermissionGranted), 0 === c ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(e.Plugins.Touch.Cnds.OnPermissionDenied)
    }
    _OnDeviceOrientation(b) {
      'number' === typeof b.webkitCompassHeading ? (this._orientCompassHeading = b.webkitCompassHeading) : b.absolute && (this._orientCompassHeading = b.alpha)
      this._orientAlpha = b.alpha
      this._orientBeta = b.beta
      this._orientGamma = b.gamma
    }
    _OnDeviceOrientationAbsolute(b) {
      this._orientCompassHeading = b.alpha
    }
    _OnDeviceMotion(b) {
      const a = b.acceleration
      a && ((this._accX = a.x), (this._accY = a.y), (this._accZ = a.z))
      if ((b = b.accelerationIncludingGravity)) (this._accWithGX = b.x), (this._accWithGY = b.y), (this._accWithGZ = b.z)
    }
    _OnTick2() {
      const b = performance.now()
      let a = 0
      for (const c of this._touches.values())
        c.GetTime() <= b - 50 && c._SetLastTime(b),
          c.ShouldTriggerHold(b) &&
            ((this._triggerIndex = c.GetStartIndex()),
            (this._triggerId = c.GetId()),
            (this._getTouchIndex = a),
            this.Trigger(e.Plugins.Touch.Cnds.OnHoldGesture),
            (this._curTouchX = c.GetX()),
            (this._curTouchY = c.GetY()),
            this.Trigger(e.Plugins.Touch.Cnds.OnHoldGestureObject),
            (this._getTouchIndex = 0)),
          ++a
    }
    _GetTouchByIndex(b) {
      b = Math.floor(b)
      for (const a of this._touches.values()) {
        if (0 === b) return a
        --b
      }
      return null
    }
    _IsClientPosOnCanvas(b, a) {
      return 0 <= b && 0 <= a && b < this._runtime.GetCanvasCssWidth() && a < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.touch.debugger.touches',
          properties: [...this._touches.values()].map(b => ({
            name: '$' + b.GetId(),
            value: b.GetX() + ', ' + b.GetY()
          }))
        }
      ]
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = []
  e.Plugins.Touch.Cnds = {
    OnTouchStart() {
      return !0
    },
    OnTouchEnd() {
      return !0
    },
    IsInTouch() {
      return 0 < this._touches.size
    },
    OnTouchObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    IsTouchingObject(a) {
      if (!a) return !1
      const c = a.GetCurrentSol()
      var d = c.GetInstances()
      for (const f of d) {
        d = f.GetWorldInfo()
        const g = d.GetLayer()
        for (const h of this._touches.values()) {
          if (!this._IsClientPosOnCanvas(h.GetX(), h.GetY())) continue
          const [k, m] = g.CanvasCssToLayer(h.GetX(), h.GetY(), d.GetTotalZElevation())
          if (d.ContainsPoint(k, m)) {
            b.push(f)
            break
          }
        }
      }
      return b.length ? (c.SetArrayPicked(b), a.ApplySolToContainer(), e.clearArray(b), !0) : !1
    },
    CompareTouchSpeed(a, c, d) {
      return (a = this._GetTouchByIndex(a)) ? e.compare(a.GetSpeed(), c, d) : !1
    },
    OrientationSupported() {
      return !0
    },
    MotionSupported() {
      return !0
    },
    CompareOrientation(a, c, d) {
      this._runtime.RequestDeviceOrientationEvent()
      return e.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta : this._orientGamma, c, d)
    },
    CompareAcceleration(a, c, d) {
      this._runtime.RequestDeviceMotionEvent()
      return e.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, c, d)
    },
    OnNthTouchStart(a) {
      a = Math.floor(a)
      return a === this._triggerIndex
    },
    OnNthTouchEnd(a) {
      a = Math.floor(a)
      return a === this._triggerIndex
    },
    HasNthTouch(a) {
      a = Math.floor(a)
      return this._touches.size >= a + 1
    },
    OnHoldGesture() {
      return !0
    },
    OnTapGesture() {
      return !0
    },
    OnDoubleTapGesture() {
      return !0
    },
    OnHoldGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnTapGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnDoubleTapGestureObject(a) {
      return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, this._curTouchX, this._curTouchY, !1) : !1
    },
    OnPermissionGranted(a) {
      return this._triggerPermission === a
    },
    OnPermissionDenied(a) {
      return this._triggerPermission === a
    }
  }
}
;('use strict')
self.C3.Plugins.Touch.Acts = {
  RequestPermission(e) {
    this._RequestPermission(e)
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Touch.Exps = {
    TouchCount() {
      return this._touches.size
    },
    X(b) {
      const a = this._GetTouchByIndex(this._getTouchIndex)
      return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    Y(b) {
      const a = this._GetTouchByIndex(this._getTouchIndex)
      return a ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    XAt(b, a) {
      return (b = this._GetTouchByIndex(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
    },
    YAt(b, a) {
      return (b = this._GetTouchByIndex(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
    },
    XForID(b, a) {
      return (b = this._touches.get(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
    },
    YForID(b, a) {
      return (b = this._touches.get(b)) ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
    },
    AbsoluteX() {
      const b = this._GetTouchByIndex(0)
      return b ? b.GetX() : 0
    },
    AbsoluteY() {
      const b = this._GetTouchByIndex(0)
      return b ? b.GetY() : 0
    },
    AbsoluteXAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetX() : 0
    },
    AbsoluteYAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetY() : 0
    },
    AbsoluteXForID(b) {
      return (b = this._touches.get(b)) ? b.GetX() : 0
    },
    AbsoluteYForID(b) {
      return (b = this._touches.get(b)) ? b.GetY() : 0
    },
    SpeedAt(b) {
      return (b = this._GetTouchByIndex(b)) ? b.GetSpeed() : 0
    },
    SpeedForID(b) {
      return (b = this._touches.get(b)) ? b.GetSpeed() : 0
    },
    AngleAt(b) {
      return (b = this._GetTouchByIndex(b)) ? e.toDegrees(b.GetAngle()) : 0
    },
    AngleForID(b) {
      return (b = this._touches.get(b)) ? e.toDegrees(b.GetAngle()) : 0
    },
    CompassHeading() {
      this._runtime.RequestDeviceOrientationEvent()
      return this._orientCompassHeading
    },
    Alpha() {
      this._runtime.RequestDeviceOrientationEvent()
      return this._orientAlpha
    },
    Beta() {
      this._runtime.RequestDeviceOrientationEvent()
      return this._orientBeta
    },
    Gamma() {
      this._runtime.RequestDeviceOrientationEvent()
      return this._orientGamma
    },
    AccelerationXWithG() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accWithGX
    },
    AccelerationYWithG() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accWithGY
    },
    AccelerationZWithG() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accWithGZ
    },
    AccelerationX() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accX
    },
    AccelerationY() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accY
    },
    AccelerationZ() {
      this._runtime.RequestDeviceMotionEvent()
      return this._accZ
    },
    TouchIndex() {
      return this._triggerIndex
    },
    TouchID() {
      return this._triggerId
    },
    WidthForID(b) {
      return (b = this._touches.get(b)) ? b.GetWidth() : 0
    },
    HeightForID(b) {
      return (b = this._touches.get(b)) ? b.GetHeight() : 0
    },
    PressureForID(b) {
      return (b = this._touches.get(b)) ? b.GetPressure() : 0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = -1e3,
    a = -1e3,
    c = -1e4
  e.Plugins.Touch.TouchInfo = class extends e.DefendedBase {
    constructor() {
      super()
      this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0
      this._isTooFarForHold = this._hasTriggeredHold = !1
    }
    Release() {}
    Init(d, f, g, h, k) {
      this._pointerId = h
      this._startIndex = k
      this._startTime = this._lastTime = this._time = d
      this._startX = f
      this._startY = g
      this._x = f
      this._y = g
      this._lastX = f
      this._lastY = g
    }
    Update(d, f, g, h, k, m) {
      this._lastTime = this._time
      this._time = d
      this._lastX = this._x
      this._lastY = this._y
      this._x = f
      this._y = g
      this._width = h
      this._height = k
      this._pressure = m
      !this._isTooFarForHold && 15 <= e.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
    }
    GetId() {
      return this._pointerId
    }
    GetStartIndex() {
      return this._startIndex
    }
    GetTime() {
      return this._time
    }
    _SetLastTime(d) {
      this._lastTime = d
    }
    GetX() {
      return this._x
    }
    GetY() {
      return this._y
    }
    GetSpeed() {
      const d = e.distanceTo(this._x, this._y, this._lastX, this._lastY),
        f = (this._time - this._lastTime) / 1e3
      return 0 < f ? d / f : 0
    }
    GetAngle() {
      return e.angleTo(this._lastX, this._lastY, this._x, this._y)
    }
    GetWidth() {
      return this._width
    }
    GetHeight() {
      return this._height
    }
    GetPressure() {
      return this._pressure
    }
    ShouldTriggerHold(d) {
      return this._hasTriggeredHold ? !1 : 500 <= d - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y) ? (this._hasTriggeredHold = !0) : !1
    }
    ShouldTriggerTap(d) {
      if (this._hasTriggeredHold) return ''
      if (333 >= d - this._startTime && !this._isTooFarForHold && 15 > e.distanceTo(this._startX, this._startY, this._x, this._y)) {
        if (666 >= d - c && 25 > e.distanceTo(b, a, this._x, this._y)) return (a = b = -1e3), (c = -1e4), 'double-tap'
        b = this._x
        a = this._y
        c = d
        return 'single-tap'
      }
      return ''
    }
    GetPositionForLayer(d, f, g) {
      return 'undefined' === typeof f ? d.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[g ? 0 : 1] : (d = d.GetLayer(f)) ? d.CanvasCssToLayer(this._x, this._y)[g ? 0 : 1] : 0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.TiledBg = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a) {
    switch (a) {
      case 0:
        return 'clamp-to-edge'
      case 2:
        return 'mirror-repeat'
    }
    return 'repeat'
  }
  e.Plugins.TiledBg.Type = class extends e.SDKTypeBase {
    constructor(a, c) {
      super(a)
      this._wrapY = this._wrapX = 'repeat'
      c && ((this._wrapX = b(c[0])), (this._wrapY = b(c[1])))
    }
    Release() {
      super.Release()
    }
    OnCreate() {
      this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a) {
      return this.GetImageInfo().LoadStaticTexture(a, {
        sampling: this._runtime.GetSampling(),
        wrapX: this._wrapX,
        wrapY: this._wrapY
      })
    }
    ReleaseTextures() {
      this.GetImageInfo().ReleaseTexture()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = e.New(e.Rect),
    c = e.New(e.Quad),
    d = e.New(e.Rect),
    f = e.New(e.Quad)
  e.Plugins.TiledBg.Instance = class extends e.SDKWorldInstanceBase {
    constructor(h, k) {
      super(h)
      this._imageOffsetY = this._imageOffsetX = 0
      this._imageScaleY = this._imageScaleX = 1
      this._imageAngle = 0
      this._ownImageInfo = null
      k && (this.GetWorldInfo().SetVisible(!!k[0]), (this._imageOffsetX = k[4]), (this._imageOffsetY = k[5]), (this._imageScaleX = k[6]), (this._imageScaleY = k[7]), (this._imageAngle = e.toRadians(k[8])))
    }
    Release() {
      this._ReleaseOwnImage()
      super.Release()
    }
    _ReleaseOwnImage() {
      this._ownImageInfo && (this._ownImageInfo.Release(), (this._ownImageInfo = null))
    }
    CalculateTextureCoordsFor3DFace(h, k, m) {
      var r = this.GetCurrentImageInfo()
      const w = r.GetWidth()
      r = r.GetHeight()
      const p = this._imageOffsetX / w,
        q = this._imageOffsetY / r,
        t = this._imageAngle
      d.set(0, 0, h / (w * this._imageScaleX), k / (r * this._imageScaleY))
      d.offset(-p, -q)
      0 === t ? m.setFromRect(d) : m.setFromRotatedRect(d, -t)
    }
    Draw(h) {
      var k = this.GetCurrentImageInfo(),
        m = k.GetTexture()
      if (null !== m) {
        h.SetTexture(m)
        m = k.GetWidth()
        k = k.GetHeight()
        var r = this._imageOffsetX / m,
          w = this._imageOffsetY / k,
          p = this.GetWorldInfo()
        d.set(0, 0, p.GetWidth() / (m * this._imageScaleX), p.GetHeight() / (k * this._imageScaleY))
        d.offset(-r, -w)
        p.HasMesh() ? this._DrawMesh(p, h) : this._DrawStandard(p, h)
      }
    }
    _DrawStandard(h, k) {
      let m = h.GetBoundingQuad()
      this._runtime.IsPixelRoundingEnabled() && (m = h.PixelRoundQuad(m))
      0 === this._imageAngle ? k.Quad3(m, d) : (f.setFromRotatedRect(d, -this._imageAngle), k.Quad4(m, f))
    }
    _DrawMesh(h, k) {
      const m = h.GetTransformedMesh()
      if (h.IsMeshChanged()) {
        h.CalculateBbox(a, c, !1)
        let r = c
        this._runtime.IsPixelRoundingEnabled() && (r = h.PixelRoundQuad(r))
        let w = d
        0 !== this._imageAngle && (f.setFromRotatedRect(d, -this._imageAngle), (w = f))
        m.CalculateTransformedMesh(h.GetSourceMesh(), r, w)
        h.SetMeshChanged(!1)
      }
      m.Draw(k)
    }
    GetCurrentImageInfo() {
      return this._ownImageInfo || this._objectClass.GetImageInfo()
    }
    IsOriginalSizeKnown() {
      return !0
    }
    GetTexture() {
      return this.GetCurrentImageInfo().GetTexture()
    }
    _SetMeshChanged() {
      this.GetWorldInfo().SetMeshChanged(!0)
    }
    _SetImageOffsetX(h) {
      this._imageOffsetX !== h && ((this._imageOffsetX = h), this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageOffsetX() {
      return this._imageOffsetX
    }
    _SetImageOffsetY(h) {
      this._imageOffsetY !== h && ((this._imageOffsetY = h), this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageOffsetY() {
      return this._imageOffsetY
    }
    _SetImageScaleX(h) {
      this._imageScaleX !== h && ((this._imageScaleX = h), this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageScaleX() {
      return this._imageScaleX
    }
    _SetImageScaleY(h) {
      this._imageScaleY !== h && ((this._imageScaleY = h), this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageScaleY() {
      return this._imageScaleY
    }
    _SetImageAngle(h) {
      this._imageAngle !== h && ((this._imageAngle = h), this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageAngle() {
      return this._imageAngle
    }
    GetPropertyValueByIndex(h) {
      switch (h) {
        case 4:
          return this._GetImageOffsetX()
        case 5:
          return this._GetImageOffsetY()
        case 6:
          return this._GetImageScaleX()
        case 7:
          return this._GetImageScaleY()
        case 8:
          return this._GetImageAngle()
      }
    }
    SetPropertyValueByIndex(h, k) {
      switch (h) {
        case 4:
          this._SetImageOffsetX(k)
          break
        case 5:
          this._SetImageOffsetY(k)
          break
        case 6:
          this._SetImageScaleX(k)
          break
        case 7:
          this._SetImageScaleY(k)
          break
        case 8:
          this._SetImageAngle(k)
      }
    }
    GetScriptInterfaceClass() {
      return self.ITiledBackgroundInstance
    }
  }
  const g = new WeakMap()
  self.ITiledBackgroundInstance = class extends self.IWorldInstance {
    constructor() {
      super()
      g.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set imageOffsetX(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageOffsetX(h)
    }
    get imageOffsetX() {
      return g.get(this)._GetImageOffsetX()
    }
    set imageOffsetY(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageOffsetY(h)
    }
    get imageOffsetY() {
      return g.get(this)._GetImageOffsetY()
    }
    set imageScaleX(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageScaleX(h)
    }
    get imageScaleX() {
      return g.get(this)._GetImageScaleX()
    }
    set imageScaleY(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageScaleY(h)
    }
    get imageScaleY() {
      return g.get(this)._GetImageScaleY()
    }
    set imageAngle(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageAngle(h)
    }
    get imageAngle() {
      return g.get(this)._GetImageAngle()
    }
    set imageAngleDegrees(h) {
      b.RequireFiniteNumber(h)
      g.get(this)._SetImageAngle(e.toRadians(h))
    }
    get imageAngleDegrees() {
      return e.toDegrees(g.get(this)._GetImageAngle())
    }
    get imageWidth() {
      return g.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight() {
      return g.get(this).GetCurrentImageInfo().GetHeight()
    }
  }
}
;('use strict')
self.C3.Plugins.TiledBg.Cnds = {
  OnURLLoaded() {
    return !0
  },
  OnURLFailed() {
    return !0
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.TiledBg.Acts = {
    SetImageOffsetX(b) {
      this._SetImageOffsetX(b)
    },
    SetImageOffsetY(b) {
      this._SetImageOffsetY(b)
    },
    SetImageScaleX(b) {
      this._SetImageScaleX(b / 100)
    },
    SetImageScaleY(b) {
      this._SetImageScaleY(b / 100)
    },
    SetImageAngle(b) {
      this._SetImageAngle(e.toRadians(b))
    },
    SetEffect(b) {
      this.GetWorldInfo().SetBlendMode(b)
      this._runtime.UpdateRender()
    },
    async LoadURL(b, a) {
      if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== b) {
        a = this._runtime
        var c = e.New(e.ImageInfo)
        try {
          await c.LoadDynamicAsset(a, b)
          if (!c.IsLoaded()) throw Error('image failed to load')
          if (this.WasReleased()) return c.Release(), null
          if (
            !(await c.LoadStaticTexture(a.GetRenderer(), {
              sampling: this._runtime.GetSampling(),
              wrapX: 'repeat',
              wrapY: 'repeat'
            }))
          )
            return
        } catch (d) {
          console.error('Load image from URL failed: ', d)
          this.Trigger(e.Plugins.TiledBg.Cnds.OnURLFailed)
          return
        }
        this.WasReleased() ? c.Release() : (this._ReleaseOwnImage(), (this._ownImageInfo = c), a.UpdateRender(), await this.TriggerAsync(e.Plugins.TiledBg.Cnds.OnURLLoaded))
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.TiledBg.Exps = {
    ImageWidth() {
      return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
      return this.GetCurrentImageInfo().GetHeight()
    },
    ImageOffsetX() {
      return this._imageOffsetX
    },
    ImageOffsetY() {
      return this._imageOffsetY
    },
    ImageScaleX() {
      return 100 * this._imageScaleX
    },
    ImageScaleY() {
      return 100 * this._imageScaleY
    },
    ImageAngle() {
      return e.toDegrees(this._imageAngle)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Timeline = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Timeline.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Timeline.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b)
      this.GetRuntime().GetTimelineManager().SetPluginInstance(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = null,
    a = null
  e.Plugins.Timeline.Cnds = {
    SetTriggerTimeline(c) {
      b = c
    },
    GetTriggerTimeline() {
      return b
    },
    SetTriggerKeyframe(c) {
      a = c
    },
    GetTriggerKeyframe() {
      return a
    },
    OnTimelineStarted(c) {
      return b === c
    },
    OnTimelineStartedByName(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByName(c)) if (e.equalsNoCase(b.GetName(), f.GetName())) return !0
      return !1
    },
    OnTimelineStartedByTags(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByTags(c)) if (f.HasTags(b.GetTags())) return !0
      return !1
    },
    OnAnyTimelineStarted() {
      return !0
    },
    OnTimelineFinished(c) {
      return b === c
    },
    OnTimelineFinishedByName(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByName(c)) if (e.equalsNoCase(b.GetName(), f.GetName())) return !0
      return !1
    },
    OnTimelineFinishedByTags(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByTags(c)) if (f.HasTags(b.GetTags())) return !0
      return !1
    },
    OnAnyTimelineFinished() {
      return !0
    },
    IsPlaying(c) {
      return c.IsPlaying()
    },
    IsPlayingByName(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByName(c)) if (f.IsPlaying()) return !0
      return !1
    },
    IsPlayingByTags(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByTags(c)) if (f.IsPlaying()) return !0
      return !1
    },
    IsAnyPlaying() {
      return [...this._runtime.GetTimelineManager().GetTimelines()].some(c => c.IsPlaying())
    },
    IsPaused(c) {
      return c.IsPaused()
    },
    IsPausedByName(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByName(c)) if (f.IsPaused()) return !0
      return !1
    },
    IsPausedByTags(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByTags(c)) if (f.IsPaused()) return !0
      return !1
    },
    IsAnyPaused() {
      return [...this._runtime.GetTimelineManager().GetTimelines()].some(c => c.IsPaused())
    },
    OnTimeSet(c) {
      return b === c
    },
    OnTimeSetByName(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByName(c)) if (b === f) return !0
      return !1
    },
    OnTimeSetByTags(c) {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelinesByTags(c)) if (b === f) return !0
      return !1
    },
    OnAnyKeyframeReached() {
      return !!a
    },
    OnKeyframeReached(c, d) {
      if (!a || 0 === a.GetTags().length || !c) return !1
      c = c ? c.split(' ') : []
      if (0 === d) {
        for (const f of c) if (a.HasTag(f)) return !0
        return !1
      }
      for (const f of c) if (!a.HasTag(f)) return !1
      return !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Map(),
    a = (d, f) => {
      for (const g of d) f.SetTrackInstance(g.trackId, g.instance)
    },
    c = () => {
      const d = []
      for (const [f, g] of b.entries()) {
        const h = f.GetCurrentSol().GetInstances(),
          k = g.trackIds.length
        for (let m = 0; m < k; m++)
          h[g.startIndex + m] &&
            d.push({
              trackId: g.trackIds[m],
              instance: h[g.startIndex + m]
            })
        g.startIndex += k
      }
      return d
    }
  e.Plugins.Timeline.Acts = {
    async PlayTimeline(d, f, g) {
      if (d) {
        var h = this._runtime.GetTimelineManager(),
          k = []
        if (b.size) {
          let r = c()
          do
            if (r.length) {
              var m = h.GetTimelineOfTemplateForInstances(d, r)
              m || ((m = h.CreateFromTemplate(d)), m.ClearTrackInstances(), a(r, m))
              m.SetTags(f)
              m.Play() && k.push(m.GetPlayPromise())
              r = c()
            }
          while (r.length)
        } else d.SetTags(f), d.Play() && k.push(d.GetPlayPromise())
        g || b.clear()
        await Promise.all(k)
      } else g || b.clear()
    },
    async PlayTimelineByName(d, f) {
      const g = this._runtime.GetTimelineManager(),
        h = []
      for (const k of g.GetTimelinesByName(d)) h.push(e.Plugins.Timeline.Acts.PlayTimeline.call(this, k, f, !0))
      b.clear()
      await Promise.all(h)
    },
    async PlayAllTimelines() {
      const d = this._runtime.GetTimelineManager(),
        f = []
      for (const g of d.GetTimelines()) g.Play() && f.push(g.GetPlayPromise())
      b.clear()
      await Promise.all(f)
    },
    PauseTimeline(d) {
      d && d.Stop()
    },
    PauseTimelineByName(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByName(d)) e.Plugins.Timeline.Acts.PauseTimeline.call(this, g)
    },
    PauseTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByTags(d)) e.Plugins.Timeline.Acts.PauseTimeline.call(this, g)
    },
    PauseAllTimelines() {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelines()) f.Stop()
    },
    ResumeTimeline(d) {
      d && d.Resume()
    },
    ResumeTimelineByName(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByName(d)) e.Plugins.Timeline.Acts.ResumeTimeline.call(this, g)
    },
    ResumeTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByTags(d)) e.Plugins.Timeline.Acts.ResumeTimeline.call(this, g)
    },
    ResumeAllTimelines() {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelines()) f.Resume()
    },
    StopTimeline(d) {
      d && d.Reset()
    },
    StopTimelineByName(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByName(d)) e.Plugins.Timeline.Acts.StopTimeline.call(this, g)
    },
    StopTimelineByTags(d) {
      const f = this._runtime.GetTimelineManager()
      for (const g of f.GetTimelinesByTags(d)) e.Plugins.Timeline.Acts.StopTimeline.call(this, g)
    },
    StopAllTimelines() {
      const d = this._runtime.GetTimelineManager()
      for (const f of d.GetTimelines()) f.Reset()
    },
    SetTimelineTime(d, f) {
      if (d)
        if (e.IsFiniteNumber(f)) d.SetTime(f)
        else if (e.IsString(f)) {
          const g = d.GetKeyframeWithTags(f)
          g ? d.SetTime(g.GetTime()) : e.Plugins.Timeline.Acts.SetTimelineTime.call(this, d, Number(f))
        }
    },
    SetTimelineTimeByName(d, f) {
      const g = this._runtime.GetTimelineManager()
      for (const h of g.GetTimelinesByName(d)) e.Plugins.Timeline.Acts.SetTimelineTime.call(this, h, f)
    },
    SetTimelineTimeByTags(d, f) {
      const g = this._runtime.GetTimelineManager()
      for (const h of g.GetTimelinesByTags(d)) e.Plugins.Timeline.Acts.SetTimelineTime.call(this, h, f)
    },
    SetTimelinePlaybackRate(d, f) {
      d && d.SetPlaybackRate(f)
    },
    SetTimelinePlaybackRateByName(d, f) {
      const g = this._runtime.GetTimelineManager()
      for (const h of g.GetTimelinesByName(d)) e.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, h, f)
    },
    SetTimelinePlaybackRateByTags(d, f) {
      const g = this._runtime.GetTimelineManager()
      for (const h of g.GetTimelinesByTags(d)) e.Plugins.Timeline.Acts.SetTimelinePlaybackRate.call(this, h, f)
    },
    SetInstance(d, f) {
      b.has(d) ||
        b.set(d, {
          startIndex: 0,
          trackIds: []
        })
      b.get(d).trackIds.push(f)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Timeline.Exps = {
    Time(b) {
      const a = this._runtime.GetTimelineManager()
      for (const c of a.GetTimelinesByName(b)) return c.GetTime()
      for (const c of a.GetTimelinesByTags(b)) return c.GetTime()
      return 0
    },
    TotalTime(b) {
      const a = this._runtime.GetTimelineManager()
      for (const c of a.GetTimelinesByName(b)) return c.GetTotalTime()
      for (const c of a.GetTimelinesByTags(b)) return c.GetTotalTime()
      return 0
    },
    Progress(b) {
      const a = this._runtime.GetTimelineManager()
      for (const c of a.GetTimelinesByName(b)) return c.GetTime() / c.GetTotalTime()
      for (const c of a.GetTimelinesByTags(b)) return c.GetTime() / c.GetTotalTime()
      return 0
    },
    KeyframeTags() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerKeyframe()
      return b ? b.GetTags().join(' ') : ''
    },
    TimelineName() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerTimeline()
      return b ? b.GetName() : ''
    },
    TimelineTags() {
      const b = e.Plugins.Timeline.Cnds.GetTriggerTimeline()
      return b ? b.GetStringTags() : ''
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.PlatformInfo = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.PlatformInfo.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.PlatformInfo.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b, 'platform-info')
      this._windowOuterHeight = this._windowOuterWidth = this._screenHeight = this._screenWidth = 0
      this._safeAreaInset = [0, 0, 0, 0]
      this._isWakeLockActive = this._supportsWakeLock = !1
      this.AddDOMMessageHandlers([
        ['window-resize', c => this._OnWindowResize(c)],
        ['wake-lock-acquired', c => this._OnWakeLockAcquired(c)],
        ['wake-lock-error', c => this._OnWakeLockError(c)],
        ['wake-lock-released', c => this._OnWakeLockReleased(c)]
      ])
      navigator.connection && navigator.connection.addEventListener('change', () => this._OnNetworkChange())
      this._runtime.AddLoadPromise(
        this.PostToDOMAsync('get-initial-state').then(c => {
          this._screenWidth = c.screenWidth
          this._screenHeight = c.screenHeight
          this._windowOuterWidth = c.windowOuterWidth
          this._windowOuterHeight = c.windowOuterHeight
          this._safeAreaInset = c.safeAreaInset
          this._supportsWakeLock = c.supportsWakeLock
        })
      )
    }
    Release() {
      super.Release()
    }
    _OnWindowResize(b) {
      this._windowOuterWidth = b.windowOuterWidth
      this._windowOuterHeight = b.windowOuterHeight
      this._safeAreaInset = b.safeAreaInset
    }
    async _OnNetworkChange() {
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnNetworkChange)
    }
    async _OnWakeLockAcquired() {
      this._isWakeLockActive = !0
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockAcquired)
    }
    async _OnWakeLockError() {
      this._isWakeLockActive = !1
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockError)
    }
    async _OnWakeLockReleased() {
      this._isWakeLockActive = !1
      await this.TriggerAsync(e.Plugins.PlatformInfo.Cnds.OnWakeLockReleased)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.PlatformInfo.Cnds = {
    IsOnMobile() {
      return e.Platform.IsMobile
    },
    IsOnWindows() {
      return 'Windows' === e.Platform.OS
    },
    IsOnMacOS() {
      return 'Mac OS X' === e.Platform.OS
    },
    IsOnLinux() {
      return 'Linux' === e.Platform.OS
    },
    IsOnChromeOS() {
      return 'Chrome OS' === e.Platform.OS
    },
    IsOnAndroid() {
      return 'Android' === e.Platform.OS
    },
    IsOniOS() {
      return 'iOS' === e.Platform.OS
    },
    IsWebExport() {
      const b = this._runtime.GetExportType()
      return 'html5' === b || 'scirra-arcade' === b || 'preview' === b || 'instant-games' === b
    },
    IsCordovaExport() {
      return this._runtime.IsCordova()
    },
    IsNWjsExport() {
      return 'nwjs' === this._runtime.GetExportType()
    },
    IsWindowsUWPExport() {
      return 'windows-uwp' === this._runtime.GetExportType()
    },
    IsWindowsWebView2Export() {
      return 'windows-webview2' === this._runtime.GetExportType()
    },
    IsMacOSWKWebView2Export() {
      return 'macos-wkwebview' === this._runtime.GetExportType()
    },
    OnNetworkChange() {
      return !0
    },
    OnWakeLockAcquired() {
      return !0
    },
    OnWakeLockError() {
      return !0
    },
    OnWakeLockReleased() {
      return !0
    },
    IsWakeLockActive() {
      return this._isWakeLockActive
    },
    IsWakeLockSupported() {
      return this._supportsWakeLock
    }
  }
}
;('use strict')
self.C3.Plugins.PlatformInfo.Acts = {
  RequestWakeLock() {
    this._supportsWakeLock && this._PostToDOMMaybeSync('request-wake-lock')
  },
  ReleaseWakeLock() {
    this._supportsWakeLock && ((this._isWakeLockActive = !1), this.PostToDOM('release-wake-lock'))
  }
}
;('use strict')
self.C3.Plugins.PlatformInfo.Exps = {
  Renderer() {
    if (this._runtime.GetWebGPURenderer()) return 'webgpu'
    {
      const e = this._runtime.GetWebGLRenderer()
      let b = 'webgl' + e.GetWebGLVersionNumber()
      e.HasMajorPerformanceCaveat() && (b += '-software')
      return b
    }
  },
  RendererDetail() {
    return this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
  },
  DevicePixelRatio() {
    return self.devicePixelRatio
  },
  ScreenWidth() {
    return this._screenWidth
  },
  ScreenHeight() {
    return this._screenHeight
  },
  WindowInnerWidth() {
    return this._runtime.GetCanvasManager().GetLastWidth()
  },
  WindowInnerHeight() {
    return this._runtime.GetCanvasManager().GetLastHeight()
  },
  WindowOuterWidth() {
    return this._windowOuterWidth
  },
  WindowOuterHeight() {
    return this._windowOuterHeight
  },
  CanvasCssWidth() {
    return this._runtime.GetCanvasManager().GetCssWidth()
  },
  CanvasCssHeight() {
    return this._runtime.GetCanvasManager().GetCssHeight()
  },
  CanvasDeviceWidth() {
    return this._runtime.GetCanvasManager().GetDeviceWidth()
  },
  CanvasDeviceHeight() {
    return this._runtime.GetCanvasManager().GetDeviceHeight()
  },
  Downlink() {
    return navigator.connection ? navigator.connection.downlink || 0 : 0
  },
  DownlinkMax() {
    return navigator.connection ? navigator.connection.downlinkMax || 0 : 0
  },
  ConnectionType() {
    return navigator.connection ? navigator.connection.type || 'unknown' : 'unknown'
  },
  ConnectionEffectiveType() {
    return navigator.connection ? navigator.connection.effectiveType || 'unknown' : 'unknown'
  },
  ConnectionRTT() {
    return navigator.connection ? navigator.connection.rtt || 0 : 0
  },
  HardwareConcurrency() {
    return navigator.hardwareConcurrency || 0
  },
  DeviceMemory() {
    return navigator.deviceMemory || 0
  },
  SafeAreaInsetTop() {
    return this._safeAreaInset[0]
  },
  SafeAreaInsetRight() {
    return this._safeAreaInset[1]
  },
  SafeAreaInsetBottom() {
    return this._safeAreaInset[2]
  },
  SafeAreaInsetLeft() {
    return this._safeAreaInset[3]
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.AJAX = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.AJAX.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.AJAX.Instance = class extends e.SDKInstanceBase {
    constructor(b, a) {
      super(b)
      this._curTag = this._lastData = ''
      this._progress = 0
      this._timeout = -1
      this._nextRequestHeaders = new Map()
      this._nextReponseBinaryData = null
      this._nextRequestOverrideMimeType = ''
      this._nwjsAppFolder = this._nwjsPath = this._nwjsFs = null
      if ((this._isNWjs = 'nwjs' === this._runtime.GetExportType())) (this._nwjsFs = require('fs')), (this._nwjsPath = require('path')), (this._nwjsAppFolder = this._nwjsPath.dirname((self.process || nw.process).execPath) + '\\')
    }
    Release() {
      super.Release()
    }
    async _TriggerError(b, a, c) {
      console.error(`[Construct 3] AJAX request to '${a}' (tag '${b}') failed: `, c)
      this._curTag = b
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyError)
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnError)
    }
    async _TriggerComplete(b) {
      this._curTag = b
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnAnyComplete)
      await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnComplete)
    }
    async _OnProgress(b, a) {
      a.lengthComputable && ((this._progress = a.loaded / a.total), (this._curTag = b), await this.TriggerAsync(e.Plugins.AJAX.Cnds.OnProgress))
    }
    _OnError(b, a, c) {
      if (this._isNWjs) {
        var d = this._nwjsFs,
          f = this._nwjsAppFolder + a
        d.existsSync(f)
          ? d.readFile(
              f,
              {
                encoding: 'utf8'
              },
              (g, h) => {
                g ? this._TriggerError(b, a, g) : ((this._lastData = h.replace(/\r\n/g, '\n')), this._TriggerComplete(b))
              }
            )
          : this._TriggerError(b, a, c)
      } else this._TriggerError(b, a, c)
    }
    async _DoCordovaRequest(b, a) {
      const c = this._runtime.GetAssetManager(),
        d = this._nextReponseBinaryData
      this._nextReponseBinaryData = null
      try {
        if (d) {
          const f = await c.CordovaFetchLocalFileAsArrayBuffer(a)
          d.SetArrayBufferTransfer(f)
          this._lastData = ''
        } else this._lastData = (await c.CordovaFetchLocalFileAsText(a)).replace(/\r\n/g, '\n')
        this._TriggerComplete(b)
      } catch (f) {
        this._TriggerError(b, a, f)
      }
    }
    _DoRequest(b, a, c, d) {
      return new Promise(f => {
        const g = k => {
            this._OnError(b, a, k)
            f()
          },
          h = this._nextReponseBinaryData
        this._nextReponseBinaryData = null
        try {
          const k = new XMLHttpRequest()
          k.onreadystatechange = () => {
            if (4 === k.readyState) {
              this._lastData = h ? '' : (k.responseText || '').replace(/\r\n/g, '\n')
              if (400 <= k.status) this._TriggerError(b, a, k.status + k.statusText)
              else {
                const m = this._lastData.length || (h && k.response instanceof ArrayBuffer)
                ;(this._isNWjs && !m) || (!this._isNWjs && 0 === k.status && !m) || (h && h.SetArrayBufferTransfer(k.response), this._TriggerComplete(b))
              }
              f()
            }
          }
          k.onerror = g
          k.ontimeout = g
          k.onabort = g
          k.onprogress = m => this._OnProgress(b, m)
          k.open(c, a)
          0 <= this._timeout && 'undefined' !== typeof k.timeout && (k.timeout = this._timeout)
          k.responseType = h ? 'arraybuffer' : 'text'
          d && !this._nextRequestHeaders.has('Content-Type') && ('string' !== typeof d ? k.setRequestHeader('Content-Type', 'application/octet-stream') : k.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'))
          for (const [m, r] of this._nextRequestHeaders)
            try {
              k.setRequestHeader(m, r)
            } catch (w) {
              console.error(`[Construct 3] AJAX: Failed to set header '${m}: ${r}': `, w)
            }
          this._nextRequestHeaders.clear()
          if (this._nextRequestOverrideMimeType) {
            try {
              k.overrideMimeType(this._nextRequestOverrideMimeType)
            } catch (m) {
              console.error('[Construct 3] AJAX: failed to override MIME type: ', m)
            }
            this._nextRequestOverrideMimeType = ''
          }
          d ? k.send(d) : k.send()
        } catch (k) {
          g(k)
        }
      })
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.ajax.debugger.title',
          properties: [
            {
              name: 'plugins.ajax.debugger.last-data',
              value: this._lastData
            }
          ]
        }
      ]
    }
    SaveToJson() {
      return {
        lastData: this._lastData
      }
    }
    LoadFromJson(b) {
      this._lastData = b.lastData
      this._curTag = ''
      this._progress = 0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.AJAX.Cnds = {
    OnComplete(b) {
      return e.equalsNoCase(this._curTag, b)
    },
    OnAnyComplete() {
      return !0
    },
    OnError(b) {
      return e.equalsNoCase(this._curTag, b)
    },
    OnAnyError() {
      return !0
    },
    OnProgress(b) {
      return e.equalsNoCase(this._curTag, b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.AJAX.Acts = {
    async Request(b, a) {
      this._runtime.IsCordova() && e.IsRelativeURL(a) && this._runtime.GetAssetManager().IsFileProtocol()
        ? await this._DoCordovaRequest(b, a)
        : this._runtime.IsPreview() && e.IsRelativeURL(a)
        ? ((a = this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a.toLowerCase())), await this._DoRequest(b, a, 'GET', null))
        : await this._DoRequest(b, a, 'GET', null)
    },
    async RequestFile(b, a) {
      this._runtime.IsCordova() && this._runtime.GetAssetManager().IsFileProtocol() ? await this._DoCordovaRequest(b, a) : await this._DoRequest(b, this._runtime.GetAssetManager().GetLocalUrlAsBlobUrl(a), 'GET', null)
    },
    async Post(b, a, c, d) {
      await this._DoRequest(b, a, d, c)
    },
    async PostBinary(b, a, c, d) {
      c && (c = c.GetFirstPicked(this._inst)) && ((c = c.GetSdkInstance().GetArrayBufferReadOnly()), await this._DoRequest(b, a, d, c))
    },
    SetTimeout(b) {
      this._timeout = 1e3 * b
    },
    SetHeader(b, a) {
      this._nextRequestHeaders.set(b, a)
    },
    SetResponseBinary(b) {
      b && (b = b.GetFirstPicked(this._inst)) && (this._nextReponseBinaryData = b.GetSdkInstance())
    },
    OverrideMIMEType(b) {
      this._nextRequestOverrideMimeType = b
    }
  }
}
;('use strict')
self.C3.Plugins.AJAX.Exps = {
  LastData() {
    return this._lastData
  },
  Progress() {
    return this._progress
  },
  Tag() {
    return this._curTag
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Arr = class extends e.SDKPluginBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.Arr.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IInstance

  function c(f, g, h) {
    if (g < f.length) e.truncateArray(f, g)
    else if (g > f.length)
      if ('function' === typeof h) for (var k = f.length; k < g; ++k) f.push(h())
      else for (k = f.length; k < g; ++k) f.push(h)
  }
  e.Plugins.Arr.Instance = class extends e.SDKInstanceBase {
    constructor(f, g) {
      super(f)
      this._cx = 10
      this._cz = this._cy = 1
      this._arr = null
      this._forX = []
      this._forY = []
      this._forZ = []
      this._forDepth = -1
      g && ((this._cx = g[0]), (this._cy = g[1]), (this._cz = g[2]))
      this._arr = e.MakeFilledArray(this._cx, () => e.MakeFilledArray(this._cy, () => e.MakeFilledArray(this._cz, 0)))
    }
    Release() {
      this._arr = null
      super.Release()
    }
    At(f, g, h) {
      f = Math.floor(f)
      g = Math.floor(g)
      h = Math.floor(h)
      return 0 <= f && f < this._cx && 0 <= g && g < this._cy && 0 <= h && h < this._cz ? this._arr[f][g][h] : 0
    }
    Set(f, g, h, k) {
      f = Math.floor(f)
      g = Math.floor(g)
      h = Math.floor(h)
      0 <= f && f < this._cx && 0 <= g && g < this._cy && 0 <= h && h < this._cz && (this._arr[f][g][h] = k)
    }
    SetSize(f, g, h) {
      f = Math.floor(f)
      g = Math.floor(g)
      h = Math.floor(h)
      0 > f && (f = 0)
      0 > g && (g = 0)
      0 > h && (h = 0)
      if (this._cx !== f || this._cy !== g || this._cz !== h) {
        this._cx = f
        this._cy = g
        this._cz = h
        var k = this._arr
        c(k, f, () => e.MakeFilledArray(g, () => e.MakeFilledArray(h, 0)))
        for (let m = 0; m < f; ++m) {
          c(k[m], g, () => e.MakeFilledArray(h, 0))
          for (let r = 0; r < g; ++r) c(k[m][r], h, 0)
        }
      }
    }
    GetWidth() {
      return this._cx
    }
    GetHeight() {
      return this._cy
    }
    GetDepth() {
      return this._cz
    }
    GetDebuggerProperties() {
      const f = [
          {
            title: 'plugins.arr.debugger.array-properties.title',
            properties: [
              {
                name: 'plugins.arr.properties.width.name',
                value: this._cx,
                onedit: h => this.SetSize(h, this._cy, this._cz)
              },
              {
                name: 'plugins.arr.properties.height.name',
                value: this._cy,
                onedit: h => this.SetSize(this._cx, h, this._cz)
              },
              {
                name: 'plugins.arr.properties.depth.name',
                value: this._cz,
                onedit: h => this.SetSize(this._cx, this._cy, h)
              },
              {
                name: 'plugins.arr.properties.elements.name',
                value: this._cx * this._cy * this._cz
              }
            ]
          }
        ],
        g = []
      if (1 === this._cy && 1 === this._cz)
        for (let h = 0; h < this._cx; ++h)
          g.push({
            name: '$' + h,
            value: this._arr[h][0][0],
            onedit: k => (this._arr[h][0][0] = k)
          })
      else
        for (let h = 0; h < this._cx; ++h)
          g.push({
            name: '$' + h,
            value: this._arr[h].toString()
          })
      g.length &&
        f.push({
          title: 'plugins.arr.debugger.array-data.title',
          properties: g
        })
      return f
    }
    GetAsJsonString() {
      return JSON.stringify({
        c2array: !0,
        size: [this._cx, this._cy, this._cz],
        data: this._arr
      })
    }
    SaveToJson() {
      return {
        size: [this._cx, this._cy, this._cz],
        data: this._arr
      }
    }
    LoadFromJson(f) {
      const g = f.size
      this._cx = g[0]
      this._cy = g[1]
      this._cz = g[2]
      this._arr = f.data
    }
    _GetForX() {
      return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
    }
    _GetForY() {
      return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0
    }
    _GetForZ() {
      return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
    }
    GetScriptInterfaceClass() {
      return self.IArrayInstance
    }
  }
  const d = new WeakMap()
  self.IArrayInstance = class extends a {
    constructor() {
      super()
      d.set(this, a._GetInitInst().GetSdkInstance())
    }
    get width() {
      return d.get(this).GetWidth()
    }
    get height() {
      return d.get(this).GetHeight()
    }
    get depth() {
      return d.get(this).GetDepth()
    }
    setSize(f, g = 1, h = 1) {
      b.RequireFiniteNumber(f)
      b.RequireFiniteNumber(g)
      b.RequireFiniteNumber(h)
      d.get(this).SetSize(f, g, h)
    }
    getAt(f, g = 0, h = 0) {
      b.RequireFiniteNumber(f)
      b.RequireFiniteNumber(g)
      b.RequireFiniteNumber(h)
      return d.get(this).At(f, g, h)
    }
    setAt(f, g, h = 0, k = 0) {
      b.RequireFiniteNumber(g)
      b.RequireFiniteNumber(h)
      b.RequireFiniteNumber(k)
      if ('number' !== typeof f && 'string' !== typeof f) throw new TypeError('invalid type')
      d.get(this).Set(g, h, k, f)
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a, c, d, f, g) {
    a.PushCopySol(d)
    c.Retrigger(f, g)
    a.PopSol(d)
  }
  e.Plugins.Arr.Cnds = {
    CompareX(a, c, d) {
      return e.compare(this.At(a, 0, 0), c, d)
    },
    CompareXY(a, c, d, f) {
      return e.compare(this.At(a, c, 0), d, f)
    },
    CompareXYZ(a, c, d, f, g) {
      return e.compare(this.At(a, c, d), f, g)
    },
    ArrForEach(a) {
      const c = this._runtime,
        d = c.GetEventSheetManager(),
        f = c.GetCurrentEvent(),
        g = f.GetSolModifiers(),
        h = c.GetEventStack(),
        k = h.GetCurrentStackFrame(),
        m = h.Push(f),
        r = ++this._forDepth,
        w = this._forX
      var p = this._forY,
        q = this._forZ
      const t = this._cx,
        x = this._cy
      var v = this._cz
      r === this._forX.length ? (w.push(0), p.push(0), q.push(0)) : ((w[r] = 0), (p[r] = 0), (q[r] = 0))
      c.SetDebuggingEnabled(!1)
      if (0 === a) for (a = 0; a < t; ++a) for (let u = 0; u < x; ++u) for (let A = 0; A < v; ++A) (w[r] = a), (p[r] = u), (q[r] = A), b(d, f, g, k, m)
      else if (1 === a) for (q = 0; q < t; ++q) for (v = 0; v < x; ++v) (w[r] = q), (p[r] = v), b(d, f, g, k, m)
      else for (p = 0; p < t; ++p) (w[r] = p), b(d, f, g, k, m)
      c.SetDebuggingEnabled(!0)
      this._forDepth--
      h.Pop()
      return !1
    },
    CompareCurrent(a, c) {
      return e.compare(this.At(this._GetForX(), this._GetForY(), this._GetForZ()), a, c)
    },
    Contains(a) {
      const c = this._cx,
        d = this._cy,
        f = this._cz,
        g = this._arr
      for (let h = 0; h < c; ++h) for (let k = 0; k < d; ++k) for (let m = 0; m < f; ++m) if (g[h][k][m] === a) return !0
      return !1
    },
    IsEmpty() {
      return 0 === this._cx || 0 === this._cy || 0 === this._cz
    },
    CompareSize(a, c, d) {
      let f = 0
      switch (a) {
        case 0:
          f = this._cx
          break
        case 1:
          f = this._cy
          break
        case 2:
          f = this._cz
      }
      return e.compare(f, c, d)
    }
  }
}
{
  ;('use strict')
  const e = self.C3

  function b(a, c) {
    if ('number' === typeof a && 'number' === typeof c) return a - c
    a = a.toString()
    c = c.toString()
    return a < c ? -1 : a > c ? 1 : 0
  }
  e.Plugins.Arr.Acts = {
    Clear(a) {
      const c = this._cx,
        d = this._cy,
        f = this._cz,
        g = this._arr
      for (let h = 0; h < c; ++h) for (let k = 0; k < d; ++k) for (let m = 0; m < f; ++m) g[h][k][m] = a
    },
    SetSize(a, c, d) {
      this.SetSize(a, c, d)
    },
    SetX(a, c) {
      this.Set(a, 0, 0, c)
    },
    SetXY(a, c, d) {
      this.Set(a, c, 0, d)
    },
    SetXYZ(a, c, d, f) {
      this.Set(a, c, d, f)
    },
    Push(a, c, d) {
      var f = this._cx,
        g = this._cy
      const h = this._cz,
        k = this._arr
      if (0 === d) (f = e.MakeFilledArray(g, () => e.MakeFilledArray(h, c))), 0 === a ? k.push(f) : k.unshift(f), this._cx++
      else if (1 === d) {
        for (g = 0; g < f; ++g) (d = e.MakeFilledArray(h, c)), 0 === a ? k[g].push(d) : k[g].unshift(d)
        this._cy++
      } else {
        for (d = 0; d < f; ++d) for (let m = 0; m < g; ++m) 0 === a ? k[d][m].push(c) : k[d][m].unshift(c)
        this._cz++
      }
    },
    Pop(a, c) {
      const d = this._cx
      var f = this._cy,
        g = this._cz
      const h = this._arr
      if (0 === c) 0 !== d && (0 === a ? h.pop() : h.shift(), this._cx--)
      else if (1 === c) {
        if (0 !== f) {
          for (f = 0; f < d; ++f) 0 === a ? h[f].pop() : h[f].shift()
          this._cy--
        }
      } else if (0 !== g) {
        for (c = 0; c < d; ++c) for (g = 0; g < f; ++g) 0 === a ? h[c][g].pop() : h[c][g].shift()
        this._cz--
      }
    },
    Reverse(a) {
      const c = this._cx
      var d = this._cy,
        f = this._cz
      const g = this._arr
      if (0 !== c && 0 !== d && 0 !== f)
        if (0 === a) g.reverse()
        else if (1 === a) for (d = 0; d < c; ++d) g[d].reverse()
        else for (a = 0; a < c; ++a) for (f = 0; f < d; ++f) g[a][f].reverse()
    },
    Sort(a) {
      const c = this._cx
      var d = this._cy,
        f = this._cz
      const g = this._arr
      if (0 !== c && 0 !== d && 0 !== f)
        if (0 === a) g.sort((h, k) => b(h[0][0], k[0][0]))
        else if (1 === a) for (d = 0; d < c; ++d) g[d].sort((h, k) => b(h[0], k[0]))
        else for (a = 0; a < c; ++a) for (f = 0; f < d; ++f) g[a][f].sort(b)
    },
    Delete(a, c) {
      a = Math.floor(a)
      if (!(0 > a)) {
        var d = this._cx,
          f = this._cy,
          g = this._cz,
          h = this._arr
        if (0 === c) a >= d || (h.splice(a, 1), this._cx--)
        else if (1 === c) {
          if (!(a >= f)) {
            for (f = 0; f < d; ++f) h[f].splice(a, 1)
            this._cy--
          }
        } else if (!(a >= g)) {
          for (c = 0; c < d; ++c) for (g = 0; g < f; ++g) h[c][g].splice(a, 1)
          this._cz--
        }
      }
    },
    Insert(a, c, d) {
      c = Math.floor(c)
      if (!(0 > c)) {
        var f = this._cx,
          g = this._cy,
          h = this._cz,
          k = this._arr
        if (0 === d)
          c > f ||
            (k.splice(
              c,
              0,
              e.MakeFilledArray(g, () => e.MakeFilledArray(h, a))
            ),
            this._cx++)
        else if (1 === d) {
          if (!(c > g)) {
            for (g = 0; g < f; ++g) k[g].splice(c, 0, e.MakeFilledArray(h, a))
            this._cy++
          }
        } else if (!(c > h)) {
          for (d = 0; d < f; ++d) for (let m = 0; m < g; ++m) k[d][m].splice(c, 0, a)
          this._cz++
        }
      }
    },
    JSONLoad(a) {
      let c = null
      try {
        c = JSON.parse(a)
      } catch (d) {
        console.error('[Construct 3] Failed to parse JSON: ', d)
        return
      }
      c.c2array && ((a = c.size), (this._cx = a[0]), (this._cy = a[1]), (this._cz = a[2]), (this._arr = c.data))
    },
    JSONDownload(a) {
      const c = URL.createObjectURL(
        new Blob([this.GetAsJsonString()], {
          type: 'application/json'
        })
      )
      this._runtime.InvokeDownload(c, a)
    }
  }
}
;('use strict')
self.C3.Plugins.Arr.Exps = {
  At(e, b, a) {
    return this.At(e, b || 0, a || 0)
  },
  Width() {
    return this._cx
  },
  Height() {
    return this._cy
  },
  Depth() {
    return this._cz
  },
  CurX() {
    return this._GetForX()
  },
  CurY() {
    return this._GetForY()
  },
  CurZ() {
    return this._GetForZ()
  },
  CurValue() {
    return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
  },
  Front() {
    return this.At(0, 0, 0)
  },
  Back() {
    return this.At(this._cx - 1, 0, 0)
  },
  IndexOf(e) {
    const b = this._arr
    for (let a = 0, c = this._cx; a < c; ++a) if (b[a][0][0] === e) return a
    return -1
  },
  LastIndexOf(e) {
    const b = this._arr
    for (let a = this._cx - 1; 0 <= a; --a) if (b[a][0][0] === e) return a
    return -1
  },
  AsJSON() {
    return this.GetAsJsonString()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.sliderbar = class extends e.SDKDOMPluginBase {
    constructor(b) {
      super(b, 'sliderbar')
      this.AddElementMessageHandler('click', (a, c) => a._OnClick(c))
      this.AddElementMessageHandler('change', (a, c) => a._OnChange(c))
      this.AddElementMessageHandler('input', (a, c) => a._OnInput(c))
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.sliderbar.Type = class extends e.SDKTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X
  e.Plugins.sliderbar.Instance = class extends e.SDKDOMInstanceBase {
    constructor(c, d) {
      super(c, 'sliderbar')
      this._min = this._value = 0
      this._max = 100
      this._step = 1
      this._title = ''
      this._isEnabled = !0
      this._id = ''
      d && ((this._value = d[0]), (this._min = d[1]), (this._max = d[2]), (this._step = d[3]), (this._title = d[4]), this.GetWorldInfo().SetVisible(d[5]), (this._isEnabled = d[6]), (this._id = d[7]))
      this.CreateElement({
        id: this._id
      })
    }
    Release() {
      super.Release()
    }
    GetElementState() {
      return {
        value: this._value,
        min: this._min,
        max: this._max,
        step: this._step,
        title: this._title,
        isEnabled: this._isEnabled
      }
    }
    async _OnClick(c) {
      this.GetScriptInterface().dispatchEvent(e.New(e.Event, 'click', !0))
      await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnClicked)
    }
    async _OnChange(c) {
      this._value = c.value
      this.GetScriptInterface().dispatchEvent(e.New(e.Event, 'change', !0))
      await this.TriggerAsync(e.Plugins.sliderbar.Cnds.OnChanged)
    }
    _OnInput(c) {
      this._value = c.value
    }
    Draw(c) {}
    _SetValue(c) {
      this._value !== c && ((this._value = c), this.UpdateElementState())
    }
    _GetValue() {
      return this._value
    }
    _SetMaximum(c) {
      this._max !== c && ((this._max = c), this.UpdateElementState())
    }
    _GetMaximum() {
      return this._max
    }
    _SetMinimum(c) {
      this._min !== c && ((this._min = c), this.UpdateElementState())
    }
    _GetMinimum() {
      return this._min
    }
    _SetTooltip(c) {
      this._title !== c && ((this._title = c), this.UpdateElementState())
    }
    _GetTooltip() {
      return this._title
    }
    _SetStep(c) {
      this._step !== c && ((this._step = c), this.UpdateElementState())
    }
    _GetStep() {
      return this._step
    }
    _SetEnabled(c) {
      c = !!c
      this._isEnabled !== c && ((this._isEnabled = c), this.UpdateElementState())
    }
    _IsEnabled() {
      return this._isEnabled
    }
    SaveToJson() {
      return {
        v: this._value,
        min: this._min,
        max: this._max,
        s: this._step,
        t: this._title,
        e: this._isEnabled,
        id: this._id
      }
    }
    LoadFromJson(c) {
      this._value = c.v
      this._min = c.min
      this._max = c.max
      this._step = c.s
      this._title = c.t
      this._isEnabled = c.e
      this._id = c.id
      this.UpdateElementState()
    }
    GetPropertyValueByIndex(c) {
      switch (c) {
        case 0:
          return this._GetValue()
        case 1:
          return this._GetMinimum()
        case 2:
          return this._GetMaximum()
        case 3:
          return this._GetStep()
        case 4:
          return this._GetTooltip()
        case 6:
          return this._IsEnbled()
        case 7:
          return this._id
      }
    }
    SetPropertyValueByIndex(c, d) {
      switch (c) {
        case 0:
          this._SetValue(d)
          break
        case 1:
          this._SetMinimum(d)
          break
        case 2:
          this._SetMaximum(d)
          break
        case 3:
          this._SetStep(d)
          break
        case 4:
          this._SetTooltip(d)
          break
        case 6:
          this._SetEnabled(d)
          break
        case 7:
          this._id !== d && ((this._id = d), this.UpdateElementState())
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'plugins.sliderbar.name',
          properties: [
            {
              name: 'plugins.sliderbar.properties.value.name',
              value: this._GetValue(),
              onedit: c => this._SetValue(c)
            },
            {
              name: 'plugins.sliderbar.properties.minimum.name',
              value: this._GetMinimum(),
              onedit: c => this._SetMinimum(c)
            },
            {
              name: 'plugins.sliderbar.properties.maximum.name',
              value: this._GetMaximum(),
              onedit: c => this._SetMaximum(c)
            },
            {
              name: 'plugins.sliderbar.properties.step.name',
              value: this._GetStep(),
              onedit: c => this._SetStep(c)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.ISliderBarInstance
    }
  }
  const a = new WeakMap()
  self.ISliderBarInstance = class extends self.IDOMInstance {
    constructor() {
      super()
      a.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set value(c) {
      b.RequireFiniteNumber(c)
      a.get(this)._SetValue(c)
    }
    get value() {
      return a.get(this)._GetValue()
    }
    set maximum(c) {
      b.RequireFiniteNumber(c)
      a.get(this)._SetMaximum(c)
    }
    get maximum() {
      return a.get(this)._GetMaximum()
    }
    set minimum(c) {
      b.RequireFiniteNumber(c)
      a.get(this)._SetMinimum(c)
    }
    get minimum() {
      return a.get(this)._GetMinimum()
    }
    set step(c) {
      b.RequireFiniteNumber(c)
      a.get(this)._SetStep(c)
    }
    get step() {
      return a.get(this)._GetStep()
    }
    set tooltip(c) {
      b.RequireString(c)
      a.get(this)._SetTooltip(c)
    }
    get tooltip() {
      return a.get(this)._GetTooltip()
    }
    set isEnabled(c) {
      a.get(this)._SetEnabled(c)
    }
    get isEnabled() {
      return a.get(this)._IsEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Plugins.sliderbar.Cnds = {
    OnClicked() {
      return !0
    },
    OnChanged() {
      return !0
    },
    CompareValue(b, a) {
      return e.compare(this._GetValue(), b, a)
    }
  }
}
;('use strict')
self.C3.Plugins.sliderbar.Acts = {
  SetTooltip(e) {
    this._SetTooltip(e)
  },
  SetValue(e) {
    this._SetValue(e)
  },
  SetMaximum(e) {
    this._SetMaximum(e)
  },
  SetMinimum(e) {
    this._SetMinimum(e)
  },
  SetStep(e) {
    this._SetStep(e)
  }
}
;('use strict')
self.C3.Plugins.sliderbar.Exps = {
  Value() {
    return this._GetValue()
  },
  Maximum() {
    return this._GetMaximum()
  },
  Minimum() {
    return this._GetMinimum()
  },
  Step() {
    return this._GetStep()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Tween = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Tween.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Behaviors.Tween
  b.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(a, c) {
      super(a)
      this._allowMultiple = !1
      this._enabled = !0
      c && ((this._allowMultiple = !1), (this._enabled = !!c[0]))
      this._activeTweens = new Map()
      this._disabledTweens = []
      this._waitingForReleaseTweens = new Map()
      this._waitingForReleaseTweensJson = this._disabledTweensJson = this._activeTweensJson = this._finishingTween = null
      this._finishingTweenName = ''
      this._enabled && this._StartTicking2()
      this._afterLoad = d => this._OnAfterLoad(d)
      this.GetRuntime().Dispatcher().addEventListener('afterload', this._afterLoad)
    }
    Release() {
      this.GetRuntime().Dispatcher().removeEventListener('afterload', this._afterLoad)
      this._afterLoad = null
      this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), (this._finishingTween = null))
      this.ReleaseAndCompleteTweens()
      this._tweens = null
      this.ClearDisabledList()
      this._disabledTweens = null
      this._ReleaseWaitingTweens()
      this._waitingForReleaseTweens = null
      super.Release()
    }
    SetEnabled(a) {
      ;(this._enabled = a) ? this._StartTicking2() : this._StopTicking2()
    }
    GetEnabled() {
      return this._enabled
    }
    AddToDisabledList(a) {
      this._disabledTweens.push(a)
    }
    IsInDisabledList(a) {
      return this._disabledTweens.includes(a)
    }
    ClearDisabledList() {
      e.clearArray(this._disabledTweens)
    }
    GetFinishingTween() {
      return this._finishingTween
    }
    IsInstanceValid() {
      const a = this.GetObjectInstance()
      return a ? !a.IsDestroyed() : !1
    }
    GetTween(a, c, d = !1) {
      if ((c = c ? this.PropertyTweens(c, d) : this.AllTweens(d)) && c.length) for (const f of c) if (f.HasTags(a)) return f
    }
    GetTweenIncludingWaitingForRelease(a, c) {
      return this.GetTween(a, c, !0)
    }
    *GetTweens(a, c, d = !1) {
      if ((c = c ? this.PropertyTweens(c, d) : this.AllTweens(d)) && c.length) for (const f of c) f.HasTags(a) && (yield f)
    }
    *GetTweensIncludingWaitingForRelease(a, c) {
      yield* this.GetTweens(a, c, !0)
    }
    PropertyTweens(a, c) {
      if (c) return (c = this._activeTweens.get(a)), (a = this._waitingForReleaseTweens.get(a)), c || (c = []), a || (a = []), c.concat(a).filter(d => d)
      ;(a = this._activeTweens.get(a)) || (a = [])
      return a.filter(d => d)
    }
    AllTweens(a) {
      if (a) {
        a = [...this._activeTweens.values()].flat()
        const c = [...this._waitingForReleaseTweens.values()].flat()
        return a.concat(c).filter(d => d)
      }
      return [...this._activeTweens.values()].flat().filter(c => c)
    }
    AllTweensIncludingWaitingForRelease() {
      return this.AllTweens(!0)
    }
    SaveToJson() {
      return {
        s: !1,
        e: !!this._enabled,
        at: this._SaveActiveTweensToJson(),
        dt: this._SaveDisabledTweensToJson(),
        wt: this._SaveWaitingForReleaseTweensToJson(),
        ft: this._SaveFinishingTweenToJson()
      }
    }
    LoadFromJson(a) {
      a && ((this._activeTweensJson = a.at), (this._disabledTweensJson = a.dt), (this._waitingForReleaseTweensJson = a.wt), (this._finishingTweenName = a.ft), (this._allowMultiple = !1), (this._enabled = !!a.e))
    }
    _OnAfterLoad(a) {
      a = this.GetRuntime().GetTimelineManager()
      this._PopulateTweenMap(this._activeTweensJson, this._activeTweens, a)
      if (this._disabledTweensJson) {
        e.clearArray(this._disabledTweens)
        for (const c of this._disabledTweensJson) this._PopulateTweenArray(this._disabledTweens, c, a)
      }
      this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, a)
      this._finishingTween = this._GetTween(this._finishingTweenName, a)
      this._enabled ? this._StartTicking2() : this._StopTicking2()
    }
    _PopulateTweenMap(a, c, d) {
      if (a)
        for (const g in a) {
          let h = c.get(g)
          h ? e.clearArray(h) : (h = [])
          var f = a[g]
          for (const k of f)
            this._PopulateTweenArray(h, k.name, d)
              ? this._LoadTweenFromJson(k.name, k, d)
              : ((f = e.Tween.Build({
                  runtime: this.GetRuntime(),
                  json: k
                })),
                f.AddCompletedCallback(m => this._FinishTriggers(m)),
                d.AddScheduledTimeline(f),
                this._PopulateTweenArray(h, f, d))
          c.set(g, h)
        }
    }
    _GetTween(a, c) {
      return c.GetScheduledOrPlayingTimelineByName(a)
    }
    _PopulateTweenArray(a, c, d) {
      if ('string' === typeof c) {
        if ((c = this._GetTween(c, d))) return !!a.push(c)
      } else return !!a.push(c)
      return !1
    }
    _LoadTweenFromJson(a, c, d) {
      'string' === typeof a ? (a = this._GetTween(a, d)) && a._LoadFromJson(c) : a._LoadFromJson(c)
    }
    _SaveActiveTweensToJson() {
      const a = {}
      for (const [c, d] of this._activeTweens) a[c] = d.map(f => f._SaveToJson())
      return a
    }
    _SaveDisabledTweensToJson() {
      return this._disabledTweens.map(a => a.GetName())
    }
    _SaveWaitingForReleaseTweensToJson() {
      const a = {}
      for (const [c, d] of this._waitingForReleaseTweens) a[c] = d.map(f => f._SaveToJson())
      return a
    }
    _SaveFinishingTweenToJson() {
      return this._finishingTween ? this._finishingTween.GetName() : ''
    }
    Tick2() {
      this._ReleaseWaitingTweens()
    }
    CreateTween(a) {
      var c = b.Config.GetPropertyTracksConfig(a.property, a.startValue, a.endValue, a.ease, a.resultMode, this.GetObjectInstance())
      const d = b.Maps.GetPropertyFromIndex(a.property)
      b.Maps.IsValueId(d) || this.ReleaseTweens(a.property)
      c = e.Tween.Build({
        runtime: this.GetRuntime(),
        id: d,
        tags: a.tags,
        time: a.time,
        instance: this.GetObjectInstance(),
        releaseOnComplete: !!a.releaseOnComplete,
        loop: !!a.loop,
        pingPong: !!a.pingPong,
        initialValueMode: a.initialValueMode,
        propertyTracksConfig: c
      })
      c.AddCompletedCallback(f => this._FinishTriggers(f))
      this._AddTween(c, a.property)
      return c
    }
    ReleaseTween(a, c = !1) {
      var d = a.GetId()
      if (this._activeTweens.has(d) && (d = this._activeTweens.get(d))) {
        const f = d.indexOf(a)
        ;-1 !== f && d.splice(f, 1)
      }
      a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(c), this._AddToWaitingList(a))
    }
    ReleaseTweens(a, c = !1) {
      if (e.IsFiniteNumber(a)) {
        var d = b.Maps.GetPropertyFromIndex(a)
        if (this._activeTweens.has(d)) {
          d = this._activeTweens.get(d)
          var f = this.GetFinishingTween()
          for (var g of d) g === f || g.IsReleased() || this._IsInWaitingList(g) || (g.Stop(c), g.Release())
          e.clearArray(d)
        }
      } else {
        g = this.GetFinishingTween()
        for (d of this.AllTweens()) d === g || d.IsReleased() || this._IsInWaitingList(d) || (d.Stop(c), d.Release())
        for (f of this._activeTweens.keys()) e.clearArray(this._activeTweens.get(f)), this._activeTweens.delete(f)
        this._activeTweens.clear()
      }
    }
    ReleaseAndCompleteTween(a) {
      this.ReleaseTween(a, !0)
    }
    ReleaseAndCompleteTweens() {
      this.ReleaseTweens(NaN, !0)
    }
    GetPropertyValueByIndex(a) {
      switch (a) {
        case 0:
          return this._enabled
      }
    }
    SetPropertyValueByIndex(a, c) {
      switch (a) {
        case 0:
          this._enabled = !!c
      }
    }
    _GetBehaviorType(a) {
      a = a.GetInstance().GetBehaviorInstances()
      for (const c of a) if (((a = c.GetBehaviorType()), a.GetInstanceSdkCtor() === this.constructor)) return a
    }
    Trigger(a, c, d, f) {
      return this._runtime ? super.Trigger(a) : c.Trigger(a, d, f)
    }
    _FinishTriggers(a) {
      this._finishingTween = a
      b.Cnds.SetFinishingTween(a)
      let c, d
      if (this.GetRuntime()) (c = this._inst), (d = this._runtime), this.Trigger(b.Cnds.OnTweensFinished), this.Trigger(b.Cnds.OnAnyTweensFinished), this.ReleaseTween(a)
      else {
        c = a.GetInstance()
        if (!c || (c && c.IsDestroyed())) return
        d = c.GetRuntime()
        const f = this._GetBehaviorType(a)
        this.Trigger(b.Cnds.OnTweensFinished, d, c, f)
        this.Trigger(b.Cnds.OnAnyTweensFinished, d, c, f)
        a.Stop()
      }
      this._finishingTween = null
      b.Cnds.SetFinishingTween(null)
      a.GetDestroyInstanceOnComplete() && d.DestroyInstance(c)
    }
    _AddTween(a, c) {
      c = b.Maps.GetPropertyFromIndex(c)
      this._activeTweens.has(c) || this._activeTweens.set(c, [])
      this._activeTweens.get(c).push(a)
    }
    _AddToWaitingList(a) {
      const c = a.GetId()
      this._waitingForReleaseTweens.has(c) || this._waitingForReleaseTweens.set(c, [])
      this._waitingForReleaseTweens.get(c).push(a)
    }
    _IsInWaitingList(a) {
      const c = a.GetId()
      return this._waitingForReleaseTweens.has(c) ? this._waitingForReleaseTweens.get(c).includes(a) : !1
    }
    _ReleaseWaitingTweens() {
      if (this._waitingForReleaseTweens.size) {
        for (const a of this._waitingForReleaseTweens.values()) {
          for (const c of a) c.IsReleased() || c.Release()
          e.clearArray(a)
        }
        this._waitingForReleaseTweens.clear()
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  let b = null
  e.Behaviors.Tween.Cnds = {
    SetFinishingTween(a) {
      b = a
    },
    OnTweensFinished(a) {
      return b.HasTags(a)
    },
    OnAnyTweensFinished() {
      return !0
    },
    IsPlaying(a) {
      return ((a = [...this.GetTweensIncludingWaitingForRelease(a)]), a.length) ? a.some(e.Tween.IsPlaying) : !1
    },
    IsAnyPlaying() {
      const a = [...this.AllTweensIncludingWaitingForRelease()]
      return a && a.length ? a.some(e.Tween.IsPlaying) : !1
    },
    IsPaused(a) {
      return ((a = [...this.GetTweensIncludingWaitingForRelease(a)]), a.length) ? a.some(e.Tween.IsPaused) : !1
    },
    IsAnyPaused() {
      const a = [...this.AllTweensIncludingWaitingForRelease()]
      return a && a.length ? a.some(e.Tween.IsPaused) : !1
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.Ease,
    a = e.Behaviors.Tween
  a.Acts = {
    SetEnabled(c) {
      this.SetEnabled(!!c)
      for (const d of this.AllTweens()) c ? this.IsInDisabledList(d) && d.Resume() : ((d.IsPlaying() || d.IsScheduled()) && this.AddToDisabledList(d), d.Stop())
      c && this.ClearDisabledList()
    },
    async TweenOneProperty(...c) {
      this.GetEnabled() && this.IsInstanceValid() && ((c = this.CreateTween(a.TweenArguments.OneProperty(this, ...c))), c.Play() && (await c.GetPlayPromise()))
    },
    async TweenTwoProperties(...c) {
      this.GetEnabled() && this.IsInstanceValid() && ((c = this.CreateTween(a.TweenArguments.TwoProperties(this, ...c))), c.Play() && (await c.GetPlayPromise()))
    },
    async TweenValue(...c) {
      this.GetEnabled() && this.IsInstanceValid() && ((c = this.CreateTween(a.TweenArguments.ValueProperty(this, ...c))), c.Play() && (await c.GetPlayPromise()))
    },
    PauseTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.GetTweens(c)) d.Stop()
    },
    PauseAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const c of this.AllTweens()) c.Stop()
    },
    ResumeTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.GetTweens(c)) d.Resume()
    },
    ResumeAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const c of this.AllTweens()) c.Resume()
    },
    StopTweens(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.GetTweens(c)) this.ReleaseTween(d)
    },
    StopAllTweens() {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const c of this.AllTweens()) this.ReleaseTween(c)
    },
    SetOnePropertyTweensEndValue(c, d, f) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = e.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(d)
        for (const g of this.GetTweens(c)) g.BeforeSetEndValues([d]), g.SetEndValue(f, d)
      }
    },
    SetTwoPropertiesTweensEndValue(c, d, f, g) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = e.Behaviors.Tween.Maps.GetRealProperties(d)
        for (const h of this.GetTweens(c)) h.BeforeSetEndValues(d), h.SetEndValue(f, d[0]), h.SetEndValue(g, d[1])
      }
    },
    SetValuePropertyTweensStartValue(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const f of this.GetTweens(c, 'value')) f.SetStartValue(d, 'value')
    },
    SetValuePropertyTweensEndValue(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const f of this.GetTweens(c, 'value')) f.BeforeSetEndValues(['value']), f.SetEndValue(d, 'value')
    },
    SetTweensEase(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        d = b.GetEaseFromIndex(d)
        for (const f of this.GetTweens(c)) f.SetEase(d)
      }
    },
    SetAllTweensEase(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) {
        c = b.GetEaseFromIndex(c)
        for (const d of this.AllTweens()) d.SetEase(c)
      }
    },
    SetTweensTime(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const f of this.GetTweens(c)) f.SetTime(d)
    },
    SetAllTweensTime(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.AllTweens()) d.SetTime(c)
    },
    SetTweensPlaybackRate(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const f of this.GetTweens(c)) f.SetPlaybackRate(d)
    },
    SetAllTweensPlaybackRate(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.AllTweens()) d.SetPlaybackRate(c)
    },
    SetTweensDestroyOnComplete(c, d) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const f of this.GetTweens(c)) f.SetDestroyInstanceOnComplete(!!d)
    },
    SetAllTweensDestroyOnComplete(c) {
      if (this.GetEnabled() && this.IsInstanceValid()) for (const d of this.AllTweens()) d.SetDestroyInstanceOnComplete(!!c)
    }
  }
}
;('use strict')
self.C3.Behaviors.Tween.Exps = {
  Time(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e)) ? e.GetTime() : 0
  },
  Progress(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e)) ? e.GetTime() / e.GetTotalTime() : 0
  },
  Value(e) {
    return (e = this.GetTweenIncludingWaitingForRelease(e, 'value')) ? e.GetPropertyTrack('value').GetSourceAdapterValue() : 0
  },
  Tags() {
    return this.GetFinishingTween() ? this.GetFinishingTween().GetStringTags() : ''
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.Ease,
    a = ['position', 'size', 'scale'],
    c = 'offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY'.split(' '),
    d = ['value'],
    f = [].concat(a).concat(c).concat(d),
    g = {
      position: ['offsetX', 'offsetY'],
      size: ['offsetWidth', 'offsetHeight'],
      scale: ['offsetScaleX', 'offsetScaleY']
    },
    h = Object.assign(
      {},
      f.reduce(
        (k, m) =>
          Object.assign({}, k, {
            [m]: [m]
          }),
        {}
      ),
      g
    )
  e.Behaviors.Tween.Maps = class {
    constructor() {}
    static GetEases() {
      return [...b.GetRuntimeEaseNames()]
    }
    static GetEaseFromIndex(k) {
      return [...b.GetRuntimeEaseNames()][k]
    }
    static GetPropertyFromIndex(k) {
      return f[k]
    }
    static GetPropertyIndexFromName(k) {
      return f.indexOf(k)
    }
    static GetPairPropertyFromIndex(k) {
      return a[k]
    }
    static GetSinglePropertyFromIndex(k) {
      return c[k]
    }
    static GetValuePropertyFromIndex(k) {
      return d[k]
    }
    static GetPairProperties(k) {
      return g[k]
    }
    static GetRealProperties(k) {
      return e.IsString(k) ? h[k] : h[f[k]]
    }
    static IsPairId(k) {
      return !!g[k]
    }
    static IsColorId(k) {
      return 'offsetColor' === k
    }
    static IsAngleId(k) {
      return 'offsetAngle' === k
    }
    static IsOpacityId(k) {
      return 'offsetOpacity' === k
    }
    static IsValueId(k) {
      return 'value' === k
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = new Map()
  b.Config = class {
    constructor() {}
    static GetPropertyTracksConfig(c, d, f, g, h, k) {
      0 === a.size && this._CreateConfigObjects()
      var m = b.PropertyTypes.Pick(c)
      m = a.get(m)
      e.IsFiniteNumber(c) && (c = b.Maps.GetPropertyFromIndex(c))
      return this._GetConfig(m, c, d, f, g, h, k)
    }
    static TransformValue(c, d) {
      return e.Behaviors.Tween.GetPropertyTracksConfig(c).valueGetter(d)
    }
    static _CreateConfigObjects() {
      const c = b.PropertyTypes,
        d = b.ValueGetters
      this._AddConfigObject(c.PAIR, this._GetPairConfig, d._GetPropertyValue)
      this._AddConfigObject(c.COLOR, this._GetColorConfig, d._GetColorPropertyValue)
      this._AddConfigObject(c.ANGLE, this._GetAngleConfig, d._GetPropertyAngleValue)
      this._AddConfigObject(c.VALUE, this._GetValueConfig, d._GetPropertyValue)
      this._AddConfigObject(c.OTHER, this._GetCommonConfig, d._GetPropertyValue)
    }
    static _AddConfigObject(c, d, f) {
      a.set(c, this._CreateConfigObject(c, d, f))
    }
    static _CreateConfigObject(c, d, f) {
      return {
        name: c,
        configFunc: d,
        valueGetter: f
      }
    }
    static _GetConfig(c, d, f, g, h, k, m) {
      return c.configFunc(d, c.valueGetter(f), c.valueGetter(g), h, k, m)
    }
    static _GetPairConfig(c, d, f, g, h, k) {
      return b.Maps.GetPairProperties(c).map((m, r) => ({
        sourceId: 'world-instance',
        property: m,
        type: 'float',
        valueType: 'numeric',
        startValue: d[r],
        endValue: f[r],
        ease: b.Maps.GetEaseFromIndex(g),
        resultMode: h
      }))
    }
    static _GetColorConfig(c, d, f, g, h, k) {
      return e.Plugins.Text && k.GetPlugin() instanceof e.Plugins.Text
        ? {
            sourceId: 'plugin',
            sourceArgs: [7],
            property: 'color',
            type: 'color',
            valueType: 'color',
            startValue: d,
            endValue: f,
            ease: b.Maps.GetEaseFromIndex(g),
            resultMode: h
          }
        : {
            sourceId: 'world-instance',
            property: c,
            type: 'color',
            valueType: 'color',
            startValue: d,
            endValue: f,
            ease: b.Maps.GetEaseFromIndex(g),
            resultMode: h
          }
    }
    static _GetAngleConfig(c, d, f, g, h, k) {
      return {
        sourceId: 'world-instance',
        property: c,
        type: 'angle',
        valueType: 'angle',
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(g),
        resultMode: h
      }
    }
    static _GetCommonConfig(c, d, f, g, h, k) {
      return {
        sourceId: 'world-instance',
        property: c,
        type: 'float',
        valueType: 'numeric',
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(g),
        resultMode: h
      }
    }
    static _GetValueConfig(c, d, f, g, h, k) {
      return {
        sourceId: 'value',
        property: c,
        type: 'float',
        valueType: 'numeric',
        startValue: d,
        endValue: f,
        ease: b.Maps.GetEaseFromIndex(g),
        resultMode: h
      }
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = Object.assign(
      {},
      {
        resultMode: 'absolute'
      },
      {
        tags: '',
        property: '',
        time: 0,
        ease: 0,
        releaseOnComplete: 0,
        loop: !1,
        pingPong: !1
      }
    ),
    c = Object.assign({}, a, {
      initialValueMode: 'current-state',
      startValue: 0,
      endValue: 0
    }),
    d = Object.assign({}, a, {
      initialValueMode: 'current-state',
      startValue: [0, 0],
      endValue: [0, 0]
    }),
    f = Object.assign({}, a, {
      initialValueMode: 'current-state',
      startValue: [0, 0, 0],
      endValue: [0, 0, 0]
    }),
    g = Object.assign({}, c, {
      initialValueMode: 'start-value'
    })
  b.TweenArguments = class {
    constructor() {}
    static _SetCommonProperties(h, k, m, r, w, p, q) {
      h.tags = k
      h.time = m
      h.ease = r
      h.releaseOnComplete = w
      h.loop = p
      h.pingPong = q
    }
    static OneProperty(h, k, m, r, w, p, q, t, x) {
      h = b.Maps.GetSinglePropertyFromIndex(m)
      m = b.Maps.IsColorId(h) ? f : c
      this._SetCommonProperties(m, k, w, p, q, t, x)
      b.Maps.IsColorId(h) ? ((f.endValue[0] = e.GetRValue(r)), (f.endValue[1] = e.GetGValue(r)), (f.endValue[2] = e.GetBValue(r)), (f.property = b.Maps.GetPropertyIndexFromName(h))) : b.Maps.IsOpacityId(h) ? (c.endValue = r / 100) : (c.endValue = r)
      m.property = b.Maps.GetPropertyIndexFromName(h)
      return m
    }
    static TwoProperties(h, k, m, r, w, p, q, t, x, v) {
      this._SetCommonProperties(d, k, p, q, t, x, v)
      h = b.Maps.GetPairPropertyFromIndex(m)
      d.endValue[0] = r
      d.endValue[1] = w
      d.property = b.Maps.GetPropertyIndexFromName(h)
      return d
    }
    static ValueProperty(h, k, m, r, w, p, q, t, x) {
      this._SetCommonProperties(g, k, w, p, q, t, x)
      g.startValue = m
      g.endValue = r
      g.property = b.Maps.GetPropertyIndexFromName('value')
      return g
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.Behaviors.Tween,
    a = []
  b.PropertyTypes = class {
    constructor() {}
    static Pick(c) {
      0 === a.length &&
        (a.push({
          checkFunc: b.Maps.IsPairId,
          result: this.PAIR
        }),
        a.push({
          checkFunc: b.Maps.IsColorId,
          result: this.COLOR
        }),
        a.push({
          checkFunc: b.Maps.IsAngleId,
          result: this.ANGLE
        }),
        a.push({
          checkFunc: b.Maps.IsValueId,
          result: this.VALUE
        }),
        a.push({
          checkFunc: () => !0,
          result: this.OTHER
        }))
      e.IsFiniteNumber(c) && (c = e.Behaviors.Tween.Maps.GetPropertyFromIndex(c))
      for (const d of a) if (d.checkFunc(c)) return d.result
    }
    static get PAIR() {
      return 'pair'
    }
    static get COLOR() {
      return 'color'
    }
    static get ANGLE() {
      return 'angle'
    }
    static get VALUE() {
      return 'value'
    }
    static get OTHER() {
      return 'other'
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Tween.ValueGetters = class {
    constructor() {}
    static _GetPropertyAngleValue(b) {
      b = e.toRadians(parseFloat(b))
      return e.clampAngle(b)
    }
    static _GetColorPropertyValue(b) {
      return b.slice(0)
    }
    static _GetPropertyValue(b) {
      return b
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Bullet = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Bullet.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance
  e.Behaviors.Bullet.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(d, f) {
      super(d)
      d = this.GetWorldInfo()
      this._g = this._acc = this._speed = 0
      this._isStepping = this._setAngle = this._bounceOffSolid = !1
      this._isEnabled = !0
      this._dy = this._dx = 0
      this._lastX = d.GetX()
      this._lastY = d.GetY()
      this._lastKnownAngle = d.GetAngle()
      this._travelled = 0
      this._stepSize = Math.min(Math.abs(d.GetWidth()), Math.abs(d.GetHeight()) / 2)
      this._stopStepping = !1
      f && ((this._speed = f[0]), (this._acc = f[1]), (this._g = f[2]), (this._bounceOffSolid = !!f[3]), (this._setAngle = !!f[4]), (this._isStepping = !!f[5]), (this._isEnabled = !!f[6]))
      f = d.GetAngle()
      this._dx = Math.cos(f) * this._speed
      this._dy = Math.sin(f) * this._speed
      this._isEnabled && (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking())
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      const d = {
        dx: this._dx,
        dy: this._dy,
        lx: this._lastX,
        ly: this._lastY,
        lka: this._lastKnownAngle,
        t: this._travelled
      }
      0 !== this._acc && (d.acc = this._acc)
      0 !== this._g && (d.g = this._g)
      this._isStepping && (d.st = this._isStepping)
      this._isEnabled || (d.e = this._isEnabled)
      this._bounceOffSolid && (d.bos = this._bounceOffSolid)
      this._setAngle && (d.sa = this._setAngle)
      return d
    }
    LoadFromJson(d) {
      this._dx = d.dx
      this._dy = d.dy
      this._lastX = d.lx
      this._lastY = d.ly
      this._lastKnownAngle = d.lka
      this._travelled = d.t
      this._acc = d.hasOwnProperty('acc') ? d.acc : 0
      this._g = d.hasOwnProperty('g') ? d.g : 0
      this._isStepping = d.hasOwnProperty('st') ? d.st : !1
      this._bounceOffSolid = d.hasOwnProperty('bos') ? d.bos : !1
      this._setAngle = d.hasOwnProperty('sa') ? d.sa : !1
      this._SetEnabled(d.hasOwnProperty('e') ? d.e : !0)
    }
    Tick() {
      if (this._isEnabled) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo()
        if (f.GetAngle() !== this._lastKnownAngle) {
          var g = f.GetAngle()
          if (this._setAngle) {
            var h = e.distanceTo(0, 0, this._dx, this._dy)
            this._dx = Math.cos(g) * h
            this._dy = Math.sin(g) * h
          }
          this._lastKnownAngle = g
        }
        g = h = 0
        if (0 !== this._acc) {
          let k = e.distanceTo(0, 0, this._dx, this._dy),
            m
          m = 0 === this._dx && 0 === this._dy ? f.GetAngle() : e.angleTo(0, 0, this._dx, this._dy)
          k += this._acc * d
          h = Math.cos(m) * this._acc
          g = Math.sin(m) * this._acc
          0 > k && (g = h = k = 0)
          this._dx = Math.cos(m) * k
          this._dy = Math.sin(m) * k
        }
        0 !== this._g && ((this._dy += this._g * d), (g += this._g))
        this._lastX = f.GetX()
        this._lastY = f.GetY()
        if (0 !== this._dx || 0 !== this._dy)
          (h = this._dx * d + 0.5 * h * d * d),
            (d = this._dy * d + 0.5 * g * d * d),
            (g = e.distanceTo(0, 0, h, d)),
            this._MoveBy(h, d, g),
            (this._travelled += g),
            !this._setAngle || (0 === h && 0 === d) || ((d = e.angleTo(0, 0, h, d)), f.SetAngle(d), (this._lastKnownAngle = f.GetAngle())),
            f.SetBboxChanged()
      }
    }
    _MoveBy(d, f, g) {
      const h = this.GetWorldInfo()
      if (!this._isStepping || g <= this._stepSize) h.OffsetXY(d, f), h.SetBboxChanged(), this._isStepping && this.Trigger(e.Behaviors.Bullet.Cnds.OnStep)
      else {
        this._stopStepping = !1
        var k = h.GetX(),
          m = h.GetY(),
          r = k + d,
          w = m + f
        f = e.angleTo(0, 0, d, f)
        d = Math.cos(f) * this._stepSize
        f = Math.sin(f) * this._stepSize
        g = Math.floor(g / this._stepSize)
        for (let p = 1; p <= g; ++p) if ((h.SetXY(k + d * p, m + f * p), h.SetBboxChanged(), this.Trigger(e.Behaviors.Bullet.Cnds.OnStep), this._inst.IsDestroyed() || this._stopStepping)) return
        h.SetXY(r, w)
        h.SetBboxChanged()
        this.Trigger(e.Behaviors.Bullet.Cnds.OnStep)
      }
    }
    PostTick() {
      if (this._isEnabled && this._bounceOffSolid && (0 !== this._dx || 0 !== this._dy)) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo(),
          g = this._runtime.GetCollisionEngine(),
          h = g.TestOverlapSolid(this._inst)
        if (h) {
          g.RegisterCollision(this._inst, h)
          h = e.distanceTo(0, 0, this._dx, this._dy)
          const k = g.CalculateBounceAngle(this._inst, this._lastX, this._lastY)
          this._dx = Math.cos(k) * h
          this._dy = Math.sin(k) * h
          f.OffsetXY(this._dx * d, this._dy * d)
          f.SetBboxChanged()
          this._setAngle && (f.SetAngle(k), (this._lastKnownAngle = f.GetAngle()), f.SetBboxChanged())
          g.PushOutSolid(this._inst, this._dx / h, this._dy / h, Math.max(2.5 * h * d, 30)) || g.PushOutSolidNearest(this._inst, 100)
        }
      }
    }
    GetPropertyValueByIndex(d) {
      switch (d) {
        case 0:
          return this._GetSpeed()
        case 1:
          return this._GetAcceleration()
        case 2:
          return this._GetGravity()
        case 4:
          return this._setAngle
        case 5:
          return this._isStepping
        case 6:
          return this._IsEnabled()
      }
    }
    SetPropertyValueByIndex(d, f) {
      switch (d) {
        case 0:
          this._SetSpeed(f)
          break
        case 1:
          this._acc = f
          break
        case 2:
          this._g = f
          break
        case 4:
          this._setAngle = !!f
          break
        case 5:
          this._isStepping = !!f
          break
        case 6:
          this._SetEnabled(!!f)
      }
    }
    _SetSpeed(d) {
      const f = e.angleTo(0, 0, this._dx, this._dy)
      this._dx = Math.cos(f) * d
      this._dy = Math.sin(f) * d
    }
    _GetSpeed() {
      return e.round6dp(e.distanceTo(0, 0, this._dx, this._dy))
    }
    _SetAcceleration(d) {
      this._acc = d
    }
    _GetAcceleration() {
      return this._acc
    }
    _SetGravity(d) {
      this._g = d
    }
    _GetGravity() {
      return this._g
    }
    _SetAngleOfMotion(d) {
      const f = e.distanceTo(0, 0, this._dx, this._dy)
      this._dx = Math.cos(d) * f
      this._dy = Math.sin(d) * f
    }
    _GetAngleOfMotion() {
      return e.angleTo(0, 0, this._dx, this._dy)
    }
    _SetBounceOffSolids(d) {
      d = !!d
      this._bounceOffSolid !== d && ((this._bounceOffSolid = d), this._isEnabled && (this._bounceOffSolid ? this._StartPostTicking() : this._StopPostTicking()))
    }
    _IsBounceOffSolids() {
      return this._bounceOffSolid
    }
    _SetDistanceTravelled(d) {
      this._travelled = d
    }
    _GetDistanceTravelled() {
      return this._travelled
    }
    _SetEnabled(d) {
      ;(this._isEnabled = !!d) ? (this._StartTicking(), this._bounceOffSolid && this._StartPostTicking()) : (this._StopTicking(), this._StopPostTicking())
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.bullet.debugger.vector-x',
              value: this._dx,
              onedit: d => (this._dx = d)
            },
            {
              name: 'behaviors.bullet.debugger.vector-y',
              value: this._dy,
              onedit: d => (this._dy = d)
            },
            {
              name: 'behaviors.bullet.properties.speed.name',
              value: this._GetSpeed(),
              onedit: d => this._SetSpeed(d)
            },
            {
              name: 'behaviors.bullet.debugger.angle-of-motion',
              value: e.toDegrees(this._GetAngleOfMotion())
            },
            {
              name: 'behaviors.bullet.properties.gravity.name',
              value: this._GetGravity(),
              onedit: d => this._SetGravity(d)
            },
            {
              name: 'behaviors.bullet.properties.acceleration.name',
              value: this._GetAcceleration(),
              onedit: d => this._SetAcceleration(d)
            },
            {
              name: 'behaviors.bullet.debugger.distance-travelled',
              value: this._GetDistanceTravelled()
            },
            {
              name: 'behaviors.bullet.properties.enabled.name',
              value: this._IsEnabled(),
              onedit: d => this._SetEnabled(d)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.IBulletBehaviorInstance
    }
  }
  const c = new WeakMap()
  self.IBulletBehaviorInstance = class extends a {
    constructor() {
      super()
      c.set(this, a._GetInitInst().GetSdkInstance())
    }
    get speed() {
      return c.get(this)._GetSpeed()
    }
    set speed(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetSpeed(d)
    }
    get acceleration() {
      return c.get(this)._GetAcceleration()
    }
    set acceleration(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetAcceleration(d)
    }
    get gravity() {
      return c.get(this)._GetGravity()
    }
    set gravity(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetGravity(d)
    }
    get angleOfMotion() {
      return c.get(this)._GetAngleOfMotion()
    }
    set angleOfMotion(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetAngleOfMotion(d)
    }
    get bounceOffSolids() {
      return c.get(this)._IsBounceOffSolids()
    }
    set bounceOffSolids(d) {
      c.get(this)._SetBounceOffSolids(!!d)
    }
    get distanceTravelled() {
      return c.get(this)._GetDistanceTravelled()
    }
    set distanceTravelled(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetDistanceTravelled(d)
    }
    get isEnabled() {
      return c.get(this)._IsEnabled()
    }
    set isEnabled(d) {
      c.get(this)._SetEnabled(d)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Bullet.Cnds = {
    CompareSpeed(b, a) {
      return e.compare(Math.sqrt(this._dx * this._dx + this._dy * this._dy), b, a)
    },
    CompareTravelled(b, a) {
      return e.compare(this._GetDistanceTravelled(), b, a)
    },
    OnStep() {
      return !0
    },
    IsEnabled() {
      return this._IsEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Bullet.Acts = {
    SetSpeed(b) {
      this._SetSpeed(b)
    },
    SetAcceleration(b) {
      this._SetAcceleration(b)
    },
    SetGravity(b) {
      this._SetGravity(b)
    },
    SetAngleOfMotion(b) {
      this._SetAngleOfMotion(e.toRadians(b))
    },
    Bounce(b) {
      if (b && (b = b.GetFirstPicked(this._inst))) {
        var a = this._inst.GetWorldInfo(),
          c = this._runtime.GetCollisionEngine(),
          d = this._runtime.GetDt(this._inst),
          f = e.distanceTo(0, 0, this._dx, this._dy),
          g = c.CalculateBounceAngle(this._inst, this._lastX, this._lastY, b)
        this._dx = Math.cos(g) * f
        this._dy = Math.sin(g) * f
        a.OffsetXY(this._dx * d, this._dy * d)
        a.SetBboxChanged()
        this._setAngle && (a.SetAngle(g), (this._lastKnownAngle = a.GetAngle()), a.SetBboxChanged())
        0 !== f && (this._bounceOffSolid ? c.PushOutSolid(this._inst, this._dx / f, this._dy / f, Math.max(2.5 * f * d, 30)) || c.PushOutSolidNearest(this._inst, 100) : c.PushOut(this._inst, this._dx / f, this._dy / f, Math.max(2.5 * f * d, 30), b))
      }
    },
    SetBounceOffSolids(b) {
      this._SetBounceOffSolids(b)
    },
    SetDistanceTravelled(b) {
      this._SetDistanceTravelled(b)
    },
    SetEnabled(b) {
      this._SetEnabled(b)
    },
    StopStepping() {
      this._stopStepping = !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Bullet.Exps = {
    Speed() {
      return this._GetSpeed()
    },
    Acceleration() {
      return this._GetAcceleration()
    },
    AngleOfMotion() {
      return e.toDegrees(this._GetAngleOfMotion())
    },
    DistanceTravelled() {
      return this._GetDistanceTravelled()
    },
    Gravity() {
      return this._GetGravity()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.solid = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.solid.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set()
  e.Behaviors.solid.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(a, c) {
      super(a)
      this.SetEnabled(!0)
      c && (this.SetEnabled(c[0]), this.SetTags(c[1]))
    }
    Release() {
      super.Release()
    }
    SetEnabled(a) {
      this._inst._SetSolidEnabled(!!a)
    }
    IsEnabled() {
      return this._inst._IsSolidEnabled()
    }
    SetTags(a) {
      const c = this._inst.GetSavedDataMap()
      if (a.trim()) {
        var d = c.get('solidTags')
        d || ((d = new Set()), c.set('solidTags', d))
        d.clear()
        for (const f of a.split(' ')) f && d.add(f.toLowerCase())
      } else c.delete('solidTags')
    }
    GetTags() {
      return this._inst.GetSavedDataMap().get('solidTags') || b
    }
    SaveToJson() {
      return {
        e: this.IsEnabled()
      }
    }
    LoadFromJson(a) {
      this.SetEnabled(a.e)
    }
    GetPropertyValueByIndex(a) {
      switch (a) {
        case 0:
          return this.IsEnabled()
      }
    }
    SetPropertyValueByIndex(a, c) {
      switch (a) {
        case 0:
          this.SetEnabled(c)
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.solid.properties.enabled.name',
              value: this.IsEnabled(),
              onedit: a => this.SetEnabled(a)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.solid.Cnds = {
  IsEnabled() {
    return this.IsEnabled()
  }
}
;('use strict')
self.C3.Behaviors.solid.Acts = {
  SetEnabled(e) {
    this.SetEnabled(e)
  },
  SetTags(e) {
    this.SetTags(e)
  }
}
;('use strict')
self.C3.Behaviors.solid.Exps = {}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Sin = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Sin.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = 2 * Math.PI,
    d = Math.PI / 2,
    f = (3 * Math.PI) / 2,
    g = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7]
  e.Behaviors.Sin.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(r, w) {
      super(r)
      this._mag = this._period = this._wave = this._movement = this._i = 0
      this._isEnabled = !0
      this._ratio = this._lastKnownValue2 = this._lastKnownValue = this._initialValue2 = this._initialValue = this._magnitudeRandom = this._periodOffsetRandom = this._periodRandom = this._baseMag = this._basePeriodOffset = this._basePeriod = 0
      w &&
        ((this._movement = g[w[0]]),
        (this._wave = w[1]),
        (this._periodRandom = this._runtime.Random() * w[3]),
        (this._basePeriod = w[2]),
        (this._period = w[2]),
        (this._period += this._periodRandom),
        (this._basePeriodOffset = w[4]),
        0 !== this._period && ((this._periodOffsetRandom = this._runtime.Random() * w[5]), (this._i = (w[4] / this._period) * c), (this._i += (this._periodOffsetRandom / this._period) * c)),
        (this._magnitudeRandom = this._runtime.Random() * w[7]),
        (this._baseMag = w[6]),
        (this._mag = w[6]),
        (this._mag += this._magnitudeRandom),
        (this._isEnabled = !!w[8]))
      5 === this._movement && (this._mag = e.toRadians(this._mag))
      this.Init()
      this._isEnabled && this._StartTicking()
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        i: this._i,
        e: this._isEnabled,
        mv: this._movement,
        w: this._wave,
        p: this._period,
        mag: this._mag,
        iv: this._initialValue,
        iv2: this._initialValue2,
        r: this._ratio,
        lkv: this._lastKnownValue,
        lkv2: this._lastKnownValue2
      }
    }
    LoadFromJson(r) {
      this._i = r.i
      this._SetEnabled(r.e)
      this._movement = r.mv
      this._wave = r.w
      this._period = r.p
      this._mag = r.mag
      this._initialValue = r.iv
      this._initialValue2 = r.iv2
      this._ratio = r.r
      this._lastKnownValue = r.lkv
      this._lastKnownValue2 = r.lkv2
    }
    Init() {
      const r = this._inst.GetWorldInfo()
      switch (this._movement) {
        case 0:
          this._initialValue = r.GetX()
          break
        case 1:
          this._initialValue = r.GetY()
          break
        case 2:
          this._initialValue = r.GetWidth()
          this._ratio = r.GetHeight() / r.GetWidth()
          break
        case 3:
          this._initialValue = r.GetWidth()
          break
        case 4:
          this._initialValue = r.GetHeight()
          break
        case 5:
          this._initialValue = r.GetAngle()
          break
        case 6:
          this._initialValue = r.GetOpacity()
          break
        case 7:
          this._initialValue = 0
          break
        case 8:
          this._initialValue = r.GetX()
          this._initialValue2 = r.GetY()
          break
        case 9:
          this._initialValue = r.GetZElevation()
      }
      this._lastKnownValue = this._initialValue
      this._lastKnownValue2 = this._initialValue2
    }
    WaveFunc(r) {
      r %= c
      switch (this._wave) {
        case 0:
          return Math.sin(r)
        case 1:
          return r <= d ? r / d : r <= f ? 1 - (2 * (r - d)) / Math.PI : (r - f) / d - 1
        case 2:
          return (2 * r) / c - 1
        case 3:
          return (-2 * r) / c + 1
        case 4:
          return r < Math.PI ? -1 : 1
      }
      return 0
    }
    Tick() {
      const r = this._runtime.GetDt(this._inst)
      this._isEnabled && 0 !== r && ((this._i = 0 === this._period ? 0 : (this._i + (r / this._period) * c) % c), this._UpdateFromPhase())
    }
    _UpdateFromPhase() {
      const r = this._inst.GetWorldInfo()
      switch (this._movement) {
        case 0:
          r.GetX() !== this._lastKnownValue && (this._initialValue += r.GetX() - this._lastKnownValue)
          r.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag)
          this._lastKnownValue = r.GetX()
          break
        case 1:
          r.GetY() !== this._lastKnownValue && (this._initialValue += r.GetY() - this._lastKnownValue)
          r.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag)
          this._lastKnownValue = r.GetY()
          break
        case 2:
          r.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag)
          r.SetHeight(r.GetWidth() * this._ratio)
          break
        case 3:
          r.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag)
          break
        case 4:
          r.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag)
          break
        case 5:
          r.GetAngle() !== this._lastKnownValue && (this._initialValue = e.clampAngle(this._initialValue + (r.GetAngle() - this._lastKnownValue)))
          r.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag)
          this._lastKnownValue = r.GetAngle()
          break
        case 6:
          r.SetOpacity(this._initialValue + (this.WaveFunc(this._i) * this._mag) / 100)
          break
        case 8:
          r.GetX() !== this._lastKnownValue && (this._initialValue += r.GetX() - this._lastKnownValue)
          r.GetY() !== this._lastKnownValue2 && (this._initialValue2 += r.GetY() - this._lastKnownValue2)
          r.SetX(this._initialValue + Math.cos(r.GetAngle()) * this.WaveFunc(this._i) * this._mag)
          r.SetY(this._initialValue2 + Math.sin(r.GetAngle()) * this.WaveFunc(this._i) * this._mag)
          this._lastKnownValue = r.GetX()
          this._lastKnownValue2 = r.GetY()
          break
        case 9:
          r.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag)
      }
      r.SetBboxChanged()
    }
    _OnSpriteFrameChanged(r, w) {}
    _SetPeriod(r) {
      this._period = r
    }
    _GetPeriod() {
      return this._period
    }
    _SetMagnitude(r) {
      this._mag = r
    }
    _SetMagnitude_ConvertAngle(r) {
      5 === this._movement && (r = e.toRadians(r))
      this._SetMagnitude(r)
    }
    _GetMagnitude() {
      return this._mag
    }
    _GetMagnitude_ConvertAngle() {
      let r = this._GetMagnitude()
      5 === this._movement && (r = e.toDegrees(r))
      return r
    }
    _SetMovement(r) {
      5 === this._movement && 5 !== r && (this._mag = e.toDegrees(this._mag))
      this._movement = r
      this.Init()
    }
    _GetMovement() {
      return this._movement
    }
    _SetWave(r) {
      this._wave = r
    }
    _GetWave() {
      return this._wave
    }
    _SetPhase(r) {
      this._i = e.clamp(r, 0, 2 * Math.PI)
      this._UpdateFromPhase()
    }
    _GetPhase() {
      return this._i
    }
    _SetEnabled(r) {
      ;(this._isEnabled = !!r) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetPropertyValueByIndex(r) {
      switch (r) {
        case 0:
          return this._movement
        case 1:
          return this._wave
        case 2:
          return this._basePeriod
        case 6:
          return this._baseMag
        case 8:
          return this._isEnabled
      }
    }
    SetPropertyValueByIndex(r, w) {
      switch (r) {
        case 0:
          this._movement = g[w]
          this.Init()
          break
        case 1:
          this._wave = w
          break
        case 2:
          this._basePeriod = w
          this._period = this._basePeriod + this._periodRandom
          this._isEnabled || (0 !== this._period ? ((this._i = (this._basePeriodOffset / this._period) * c), (this._i += (this._periodOffsetRandom / this._period) * c)) : (this._i = 0))
          break
        case 6:
          this._baseMag = w
          this._mag = this._baseMag + this._magnitudeRandom
          5 === this._movement && (this._mag = e.toRadians(this._mag))
          break
        case 8:
          this._isEnabled = !!w
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.sin.properties.enabled.name',
              value: this._IsEnabled(),
              onedit: r => this._SetEnabled(r)
            },
            {
              name: 'behaviors.sin.properties.period.name',
              value: this._GetPeriod(),
              onedit: r => this._SetPeriod(r)
            },
            {
              name: 'behaviors.sin.properties.magnitude.name',
              value: this._GetMagnitude_ConvertAngle(),
              onedit: r => this._SetMagnitude_ConvertAngle(r)
            },
            {
              name: 'behaviors.sin.debugger.value',
              value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.ISineBehaviorInstance
    }
  }
  const h = new WeakMap(),
    k = 'horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation'.split(' '),
    m = ['sine', 'triangle', 'sawtooth', 'reverse-sawtooth', 'square']
  self.ISineBehaviorInstance = class extends a {
    constructor() {
      super()
      h.set(this, a._GetInitInst().GetSdkInstance())
    }
    set period(r) {
      b.RequireFiniteNumber(r)
      h.get(this)._SetPeriod(r)
    }
    get period() {
      return h.get(this)._GetPeriod()
    }
    set magnitude(r) {
      b.RequireFiniteNumber(r)
      h.get(this)._SetMagnitude(r)
    }
    get magnitude() {
      return h.get(this)._GetMagnitude()
    }
    set phase(r) {
      h.get(this)._SetPhase(r)
    }
    get phase() {
      return h.get(this)._GetPhase()
    }
    set movement(r) {
      b.RequireString(r)
      r = k.indexOf(r)
      if (-1 === r) throw Error('invalid movement')
      h.get(this)._SetMovement(r)
    }
    get movement() {
      return k[h.get(this)._GetMovement()]
    }
    set wave(r) {
      b.RequireString(r)
      r = m.indexOf(r)
      if (-1 === r) throw Error('invalid wave')
      h.get(this)._SetWave(r)
    }
    get wave() {
      return m[h.get(this)._GetWave()]
    }
    get value() {
      const r = h.get(this)
      return r.WaveFunc(r._GetPhase()) * r._GetMagnitude()
    }
    updateInitialState() {
      h.get(this).Init()
    }
    set isEnabled(r) {
      h.get(this)._SetEnabled(!!r)
    }
    get isEnabled() {
      return h.get(this)._IsEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Sin.Cnds = {
    IsEnabled() {
      return this._IsEnabled()
    },
    CompareMovement(b) {
      return this._GetMovement() === b
    },
    ComparePeriod(b, a) {
      return e.compare(this._GetPeriod(), b, a)
    },
    CompareMagnitude(b, a) {
      return e.compare(this._GetMagnitude_ConvertAngle(), b, a)
    },
    CompareWave(b) {
      return this._GetWave() === b
    }
  }
}
;('use strict')
self.C3.Behaviors.Sin.Acts = {
  SetEnabled(e) {
    this._SetEnabled(0 !== e)
  },
  SetPeriod(e) {
    this._SetPeriod(e)
  },
  SetMagnitude(e) {
    this._SetMagnitude_ConvertAngle(e)
  },
  SetMovement(e) {
    this._SetMovement(e)
  },
  SetWave(e) {
    this._wave = e
  },
  SetPhase(e) {
    const b = 2 * Math.PI
    this._SetPhase((e * b) % b)
  },
  UpdateInitialState() {
    this.Init()
  }
}
;('use strict')
self.C3.Behaviors.Sin.Exps = {
  CyclePosition() {
    return this._GetPhase() / (2 * Math.PI)
  },
  Period() {
    return this._GetPeriod()
  },
  Magnitude() {
    return this._GetMagnitude_ConvertAngle()
  },
  Value() {
    return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Orbit = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Orbit.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Orbit.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._acceleration = this._speed = 0
      this._isEnabled = !0
      this._offsetAngle = this._majorAxis = this._minorAxis = 0
      this._matchRotation = !1
      this._targetY = this._targetX = 0
      this._targetObject = null
      this._targetUid = -1
      this._totalAbsoluteRotation = this._totalRotation = this._rotation = 0
      a && ((this._speed = e.toRadians(a[0])), (this._acceleration = e.toRadians(a[1])), (this._isEnabled = a[6]), (this._minorAxis = a[2]), (this._majorAxis = a[3]), (this._offsetAngle = e.toRadians(a[4])), (this._matchRotation = a[5]))
      b = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'instancedestroy', c => this._OnInstanceDestroyed(c.instance)),
        e.Disposable.From(b, 'afterload', c => this._OnAfterLoad())
      )
      this._SetEnabled(this._isEnabled)
      b = this._inst.GetWorldInfo()
      this._targetX = b.GetX()
      this._targetY = b.GetY()
      this._rotation = b.GetAngle()
    }
    Release() {
      this._targetObject = null
      super.Release()
    }
    SaveToJson() {
      return {
        s: this._speed,
        a: this._acceleration,
        r: this._rotation,
        e: this._isEnabled,
        a1: this._majorAxis,
        a2: this._minorAxis,
        oa: this._offsetAngle,
        mr: this._matchRotation,
        tx: this._targetX,
        ty: this._targetY,
        tuid: this._targetObject ? this._targetObject.GetUID() : -1
      }
    }
    LoadFromJson(b) {
      this._speed = b.s
      this._acceleration = b.a
      this._rotation = b.r
      this._majorAxis = b.a1
      this._minorAxis = b.a2
      this._offsetAngle = b.oa
      this._matchRotation = b.mr
      this._targetX = b.tx
      this._targetY = b.ty
      this._targetUid = b.tuid
      this._SetEnabled(b.e)
    }
    _OnAfterLoad() {
      ;-1 === this._targetUid ? (this._targetObject = null) : ((this._targetObject = this._runtime.GetInstanceByUID(this._targetUid)), (this._targetUid = -1))
    }
    _OnInstanceDestroyed(b) {
      this._targetObject === b && (this._targetObject = null)
    }
    _Initialise() {
      if (this._shouldInitialise) {
        var b = this._inst.GetWorldInfo()
        this._targetX = b.GetX()
        this._targetY = b.GetY()
        this._rotation = b.GetAngle()
        this._shouldInitialise = !1
      }
    }
    _UpdateTarget() {
      if (this._targetObject) {
        var b = this._targetObject.GetWorldInfo()
        this._targetX = b.GetX()
        this._targetY = b.GetY()
      }
    }
    _ShouldTickLate() {
      return !!this._targetObject
    }
    Tick() {
      this._TickInternal()
    }
    Tick2() {
      this._TickInternal()
    }
    _TickInternal() {
      if (this._isEnabled) {
        var b = this._runtime.GetDt(this._inst)
        if (0 !== b) {
          0 !== this._acceleration && (this._speed += this._acceleration * b)
          var a = this._inst.GetWorldInfo()
          b *= this._speed
          this._rotation = e.clampAngle(this._rotation + b)
          this._totalRotation += b
          this._totalAbsoluteRotation += Math.abs(b)
          b = this._minorAxis * Math.cos(this._rotation)
          var c = this._majorAxis * Math.sin(this._rotation),
            d = Math.cos(this._offsetAngle),
            f = Math.sin(this._offsetAngle)
          this._UpdateTarget()
          a.SetXY(this._targetX + (b * d - c * f), this._targetY + (b * f + c * d))
          this._matchRotation && a.SetAngle(this._rotation + this._offsetAngle + 0.5 * Math.PI)
          a.SetBboxChanged()
        }
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return e.toDegrees(this._speed)
        case 1:
          return e.toDegrees(this._acceleration)
        case 6:
          return this._isEnabled
        case 2:
          return this._minorAxis
        case 3:
          return this._majorAxis
        case 4:
          return this._offsetAngle
        case 5:
          return this._matchRotation
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._speed = e.toRadians(a)
          break
        case 1:
          this._acceleration = e.toRadians(a)
          break
        case 6:
          this._SetEnabled(a)
          break
        case 2:
          this._minorAxis = a
          break
        case 3:
          this._majorAxis = a
          break
        case 4:
          this._offsetAngle = a
          break
        case 5:
          this._matchRotation = a
      }
    }
    _SetEnabled(b) {
      this._isEnabled = !!b
      this._ShouldTickLate() ? (this._isEnabled ? this._StartTicking2() : this._StopTicking2()) : this._isEnabled ? this._StartTicking() : this._StopTicking()
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.orbit.debugger.rotation',
              value: e.toDegrees(this._rotation)
            },
            {
              name: 'behaviors.orbit.debugger.total-rotation',
              value: e.toDegrees(this._totalRotation)
            },
            {
              name: 'behaviors.orbit.debugger.total-absolute-rotation',
              value: e.toDegrees(this._totalAbsoluteRotation)
            },
            {
              name: 'behaviors.orbit.properties.speed.name',
              value: e.toDegrees(this._speed),
              onedit: b => (this._speed = e.toRadians(b))
            },
            {
              name: 'behaviors.orbit.properties.acceleration.name',
              value: e.toDegrees(this._acceleration),
              onedit: b => (this._acceleration = e.toRadians(b))
            },
            {
              name: 'behaviors.orbit.properties.primary-axis.name',
              value: this._majorAxis,
              onedit: b => (this._majorAxis = b)
            },
            {
              name: 'behaviors.orbit.properties.secondary-axis.name',
              value: this._minorAxis,
              onedit: b => (this._minorAxis = b)
            },
            {
              name: 'behaviors.orbit.properties.offset-angle.name',
              value: e.toDegrees(this._offsetAngle),
              onedit: b => (this._offsetAngle = e.toRadians(b))
            },
            {
              name: 'behaviors.orbit.properties.match-rotation.name',
              value: this._matchRotation,
              onedit: b => (this._matchRotation = !!b)
            },
            {
              name: 'behaviors.orbit.properties.enabled.name',
              value: this._isEnabled,
              onedit: b => this._SetEnabled(b)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Orbit.Cnds = {
  IsEnabled() {
    return this._isEnabled
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Orbit.Acts = {
    SetSpeed(b) {
      this._speed = e.toRadians(b)
    },
    SetTarget(b, a) {
      this._targetObject = null
      this._targetX = b
      this._targetY = a
    },
    SetRotation(b) {
      this._rotation = e.toRadians(b)
    },
    SetOffsetAngle(b) {
      this._offsetAngle = e.toRadians(b)
    },
    SetRadius(b, a) {
      this._minorAxis = b
      this._majorAxis = a
    },
    SetMatchRotation(b) {
      this._matchRotation = !!b
    },
    Pin(b) {
      if (b && (b = b.GetFirstPicked(this._inst)) && b.GetWorldInfo()) {
        var a = this._isEnabled
        a && this._SetEnabled(!1)
        this._targetObject = b
        a && this._SetEnabled(!0)
      }
    },
    Unpin() {
      const b = this._isEnabled
      b && this._SetEnabled(!1)
      this._targetObject = null
      b && this._SetEnabled(!0)
    },
    SetAcceleration(b) {
      this._acceleration = e.toRadians(b)
    },
    SetEnabled(b) {
      this._SetEnabled(b)
    },
    ResetTotalRotation() {
      this._totalAbsoluteRotation = this._totalRotation = 0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Orbit.Exps = {
    Speed() {
      return e.toDegrees(this._speed)
    },
    Acceleration() {
      return e.toDegrees(this._acceleration)
    },
    PrimaryRadius() {
      return this._majorAxis
    },
    SecondaryRadius() {
      return this._minorAxis
    },
    OffsetAngle() {
      return e.toDegrees(this._offsetAngle)
    },
    Rotation() {
      return e.toDegrees(this._rotation)
    },
    TotalRotation() {
      return e.toDegrees(this._totalRotation)
    },
    TotalAbsoluteRotation() {
      return e.toDegrees(this._totalAbsoluteRotation)
    },
    TargetX() {
      return this._targetX
    },
    TargetY() {
      return this._targetY
    },
    DistanceToTarget() {
      return Math.sqrt((this._minorAxis * Math.cos(this._rotation)) ** 2 + (this._majorAxis * Math.sin(this._rotation)) ** 2)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Pin = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Pin.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Pin.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._pinInst = null
      this._pinUid = -1
      this._mode = ''
      this._propSet = new Set()
      this._lastKnownAngle = this._dz = this._dAngle = this._dHeight = this._dWidth = this._dy = this._dx = this._pinImagePoint = this._pinAngle = this._pinDist = 0
      this._destroy = !1
      a && (this._destroy = a[0])
      b = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(b, 'instancedestroy', c => this._OnInstanceDestroyed(c.instance)),
        e.Disposable.From(b, 'afterload', c => this._OnAfterLoad())
      )
    }
    Release() {
      this._pinInst = null
      super.Release()
    }
    _SetPinInst(b) {
      b ? ((this._pinInst = b), this._StartTicking2()) : ((this._pinInst = null), this._StopTicking2())
    }
    _Pin(b, a, c) {
      if (b && (b = b.GetFirstPicked(this._inst)))
        if (((this._mode = a), this._SetPinInst(b), (a = this._inst.GetWorldInfo()), (b = b.GetWorldInfo()), 'properties' === this._mode)) {
          const d = this._propSet
          d.clear()
          for (const f of c) d.add(f)
          this._dx = a.GetX() - b.GetX()
          this._dy = a.GetY() - b.GetY()
          this._dAngle = a.GetAngle() - b.GetAngle()
          this._lastKnownAngle = a.GetAngle()
          this._dz = a.GetZElevation() - b.GetZElevation()
          d.has('x') && d.has('y') && ((this._pinAngle = e.angleTo(b.GetX(), b.GetY(), a.GetX(), a.GetY()) - b.GetAngle()), (this._pinDist = e.distanceTo(b.GetX(), b.GetY(), a.GetX(), a.GetY())))
          d.has('width-abs') ? (this._dWidth = a.GetWidth() - b.GetWidth()) : d.has('width-scale') && (this._dWidth = a.GetWidth() / b.GetWidth())
          d.has('height-abs') ? (this._dHeight = a.GetHeight() - b.GetHeight()) : d.has('height-scale') && (this._dHeight = a.GetHeight() / b.GetHeight())
        } else this._pinDist = e.distanceTo(b.GetX(), b.GetY(), a.GetX(), a.GetY())
    }
    SaveToJson() {
      const b = this._propSet,
        a = this._mode,
        c = {
          uid: this._pinInst ? this._pinInst.GetUID() : -1,
          m: a
        }
      if ('rope' === a || 'bar' === a) c.pd = this._pinDist
      else if ('properties' === a) {
        c.ps = [...this._propSet]
        b.has('imagepoint') ? (c.ip = this._pinImagePoint) : b.has('x') && b.has('y') ? ((c.pa = this._pinAngle), (c.pd = this._pinDist)) : (b.has('x') && (c.dx = this._dx), b.has('y') && (c.dy = this._dy))
        b.has('angle') && ((c.da = this._dAngle), (c.lka = this._lastKnownAngle))
        if (b.has('width-abs') || b.has('width-scale')) c.dw = this._dWidth
        if (b.has('height-abs') || b.has('height-scale')) c.dh = this._dHeight
        b.has('z') && (c.dz = this._dz)
      }
      return c
    }
    LoadFromJson(b) {
      const a = b.m,
        c = this._propSet
      c.clear()
      this._pinUid = b.uid
      if ('number' === typeof a) this._LoadFromJson_Legacy(b)
      else if (((this._mode = a), 'rope' === a || 'bar' === a)) this._pinDist = b.pd
      else if ('properties' === a) {
        for (const d of b.ps) c.add(d)
        c.has('imagepoint') ? (this._pinImagePoint = b.ip) : c.has('x') && c.has('y') ? ((this._pinAngle = b.pa), (this._pinDist = b.pd)) : (c.has('x') && (this._dx = b.dx), c.has('y') && (this._dy = b.dy))
        c.has('angle') && ((this._dAngle = b.da), (this._lastKnownAngle = b.lka || 0))
        if (c.has('width-abs') || c.has('width-scale')) this._dWidth = b.dw
        if (c.has('height-abs') || c.has('height-scale')) this._dHeight = b.dh
        c.has('z') && (this._dz = b.dz)
      }
    }
    _LoadFromJson_Legacy(b) {
      const a = this._propSet,
        c = b.msa,
        d = b.tsa,
        f = b.pa,
        g = b.pd
      switch (b.m) {
        case 0:
          this._mode = 'properties'
          a.add('x').add('y').add('angle')
          this._pinAngle = f
          this._pinDist = g
          this._dAngle = c - d
          this._lastKnownAngle = b.lka
          break
        case 1:
          this._mode = 'properties'
          a.add('x').add('y')
          this._pinAngle = f
          this._pinDist = g
          break
        case 2:
          this._mode = 'properties'
          a.add('angle')
          this._dAngle = c - d
          this._lastKnownAngle = b.lka
          break
        case 3:
          this._mode = 'rope'
          this._pinDist = b.pd
          break
        case 4:
          ;(this._mode = 'bar'), (this._pinDist = b.pd)
      }
    }
    _OnAfterLoad() {
      ;-1 === this._pinUid ? this._SetPinInst(null) : (this._SetPinInst(this._runtime.GetInstanceByUID(this._pinUid)), (this._pinUid = -1))
    }
    _OnInstanceDestroyed(b) {
      this._pinInst === b && (this._SetPinInst(null), this._destroy && this._runtime.DestroyInstance(this._inst))
    }
    Tick2() {
      var b = this._pinInst
      if (b) {
        var a = b.GetWorldInfo(),
          c = this._inst.GetWorldInfo(),
          d = this._mode,
          f = !1
        if ('rope' === d || 'bar' === d) {
          if (((b = e.distanceTo(c.GetX(), c.GetY(), a.GetX(), a.GetY())), b > this._pinDist || ('bar' === d && b < this._pinDist))) (f = e.angleTo(a.GetX(), a.GetY(), c.GetX(), c.GetY())), c.SetXY(a.GetX() + Math.cos(f) * this._pinDist, a.GetY() + Math.sin(f) * this._pinDist), (f = !0)
        } else {
          d = this._propSet
          if (d.has('imagepoint')) {
            const [g, h] = b.GetImagePoint(this._pinImagePoint)
            c.EqualsXY(g, h) || (c.SetXY(g, h), (f = !0))
          } else if (d.has('x') && d.has('y')) {
            b = a.GetX() + Math.cos(a.GetAngle() + this._pinAngle) * this._pinDist
            const g = a.GetY() + Math.sin(a.GetAngle() + this._pinAngle) * this._pinDist
            c.EqualsXY(b, g) || (c.SetXY(b, g), (f = !0))
          } else (b = a.GetX() + this._dx), d.has('x') && b !== c.GetX() && (c.SetX(b), (f = !0)), (b = a.GetY() + this._dy), d.has('y') && b !== c.GetY() && (c.SetY(b), (f = !0))
          d.has('angle') && (this._lastKnownAngle !== c.GetAngle() && (this._dAngle = e.clampAngle(this._dAngle + (c.GetAngle() - this._lastKnownAngle))), (b = e.clampAngle(a.GetAngle() + this._dAngle)), b !== c.GetAngle() && (c.SetAngle(b), (f = !0)), (this._lastKnownAngle = c.GetAngle()))
          d.has('width-abs') && ((b = a.GetWidth() + this._dWidth), b !== c.GetWidth() && (c.SetWidth(b), (f = !0)))
          d.has('width-scale') && ((b = a.GetWidth() * this._dWidth), b !== c.GetWidth() && (c.SetWidth(b), (f = !0)))
          d.has('height-abs') && ((b = a.GetHeight() + this._dHeight), b !== c.GetHeight() && (c.SetHeight(b), (f = !0)))
          d.has('height-scale') && ((b = a.GetHeight() * this._dHeight), b !== c.GetHeight() && (c.SetHeight(b), (f = !0)))
          d.has('z') && ((b = a.GetZElevation() + this._dz), b !== c.GetZElevation() && (c.SetZElevation(b), this._runtime.UpdateRender()))
        }
        f && c.SetBboxChanged()
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.pin.debugger.is-pinned',
              value: !!this._pinInst
            },
            {
              name: 'behaviors.pin.debugger.pinned-uid',
              value: this._pinInst ? this._pinInst.GetUID() : 0
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Pin.Cnds = {
  IsPinned() {
    return !!this._pinInst
  },
  WillDestroy() {
    return this._destroy
  }
}
;('use strict')
self.C3.Behaviors.Pin.Acts = {
  PinByDistance(e, b) {
    this._Pin(e, 0 === b ? 'rope' : 'bar')
  },
  PinByProperties(e, b, a, c, d, f, g) {
    const h = []
    b && h.push('x')
    a && h.push('y')
    c && h.push('angle')
    g && h.push('z')
    1 === d ? h.push('width-abs') : 2 === d && h.push('width-scale')
    1 === f ? h.push('height-abs') : 2 === f && h.push('height-scale')
    0 !== h.length && this._Pin(e, 'properties', h)
  },
  PinByImagePoint(e, b, a, c, d, f) {
    const g = ['imagepoint']
    a && g.push('angle')
    f && g.push('z')
    1 === c ? g.push('width-abs') : 2 === c && g.push('width-scale')
    1 === d ? g.push('height-abs') : 2 === d && g.push('height-scale')
    this._pinImagePoint = b
    this._Pin(e, 'properties', g)
  },
  SetPinDistance(e) {
    if ('rope' === this._mode || 'bar' === this._mode) this._pinDist = Math.max(e, 0)
  },
  SetDestroy(e) {
    this._destroy = e
  },
  Unpin() {
    this._SetPinInst(null)
    this._mode = ''
    this._propSet.clear()
    this._pinImagePoint = ''
  },
  Pin(e, b) {
    switch (b) {
      case 0:
        this._Pin(e, 'properties', ['x', 'y', 'angle'])
        break
      case 1:
        this._Pin(e, 'properties', ['x', 'y'])
        break
      case 2:
        this._Pin(e, 'properties', ['angle'])
        break
      case 3:
        this._Pin(e, 'rope')
        break
      case 4:
        this._Pin(e, 'bar')
    }
  }
}
;('use strict')
self.C3.Behaviors.Pin.Exps = {
  PinnedUID() {
    return this._pinInst ? this._pinInst.GetUID() : -1
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Platform = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Platform.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance

  function c(g, h, k, m, r) {
    return e.clamp(g * r + 0.5 * m * r * r, h * r, k * r)
  }
  e.Behaviors.Platform.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(g, h) {
      super(g)
      this._keyboardDisposables = null
      this._simJump = this._simRight = this._simLeft = this._ignoreInput = this._canDoubleJump = this._doubleJumped = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
      this._lastFloorObject = null
      this._loadFloorUid = -1
      this._lastFloorY = this._lastFloorX = 0
      this._wasOnFloor = this._floorIsJumpthru = !1
      this._wasOverJumpthru = !!this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
      this._loadJumpthruUid = -1
      this._animMode = 'stopped'
      this._fallThrough = 0
      this._isFirstTick = !0
      this._rightY = this._rightX = this._downY = this._downX = this._dy = this._dx = 0
      this._g1 = this._g = 1500
      this._ga = e.toRadians(90)
      this._maxSpeed = 330
      this._dec = this._acc = 1500
      this._jumpStrength = 650
      this._maxFall = 1e3
      this._enableDoubleJump = !1
      this._sustainTime = this._jumpSustain = 0
      this._defaultControls = !0
      this._ceilingCollisionMode = 0
      this._isEnabled = !0
      h && ((this._maxSpeed = h[0]), (this._acc = h[1]), (this._dec = h[2]), (this._jumpStrength = h[3]), (this._g = h[4]), (this._maxFall = h[5]), (this._enableDoubleJump = !!h[6]), (this._jumpSustain = h[7] / 1e3), (this._defaultControls = !!h[8]), (this._isEnabled = !!h[9]))
      g = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(g, 'instancedestroy', k => this._OnInstanceDestroyed(k.instance)),
        e.Disposable.From(g, 'afterload', k => this._OnAfterLoad())
      )
      this._defaultControls && this._BindEvents()
      this._isEnabled && this._StartPostTicking()
      this._UpdateGravity()
      this._inst.GetUnsavedDataMap().set('isPlatformBehavior', !0)
    }
    Release() {
      this._keyboardDisposables && (this._keyboardDisposables.Release(), (this._keyboardDisposables = null))
      this._wasOverJumpthru = this._lastFloorObject = null
      super.Release()
    }
    _BindEvents() {
      if (!this._keyboardDisposables) {
        var g = this._runtime.Dispatcher()
        this._keyboardDisposables = new e.CompositeDisposable(
          e.Disposable.From(g, 'keydown', h => this._OnKeyDown(h.data)),
          e.Disposable.From(g, 'keyup', h => this._OnKeyUp(h.data)),
          e.Disposable.From(g, 'window-blur', () => this._OnWindowOrKeyboardBlur()),
          e.Disposable.From(g, 'keyboard-blur', () => this._OnWindowOrKeyboardBlur())
        )
      }
    }
    _UnBindEvents() {
      this._keyboardDisposables && (this._keyboardDisposables.Release(), (this._keyboardDisposables = null))
    }
    _OnInstanceDestroyed(g) {
      this._lastFloorObject === g && (this._lastFloorObject = null)
      this._wasOverJumpthru === g && (this._wasOverJumpthru = null)
    }
    _OnKeyDown(g) {
      switch (g.key) {
        case 'ArrowLeft':
          this._leftKey = !0
          break
        case 'ArrowRight':
          this._rightKey = !0
          break
        case 'ArrowUp':
          this._jumpKey = !0
      }
    }
    _OnKeyUp(g) {
      switch (g.key) {
        case 'ArrowLeft':
          this._leftKey = !1
          break
        case 'ArrowRight':
          this._rightKey = !1
          break
        case 'ArrowUp':
          this._jumped = this._jumpKey = !1
      }
    }
    _OnWindowOrKeyboardBlur() {
      this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
    }
    SaveToJson() {
      return {
        ii: this._ignoreInput,
        lfx: this._lastFloorX,
        lfy: this._lastFloorY,
        lfo: this._lastFloorObject ? this._lastFloorObject.GetUID() : -1,
        am: this._animMode,
        en: this._isEnabled,
        fall: this._fallThrough,
        ft: this._isFirstTick,
        dx: this._dx,
        dy: this._dy,
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        js: this._jumpStrength,
        g: this._g,
        g1: this._g1,
        mf: this._maxFall,
        wof: this._wasOnFloor,
        woj: this._wasOverJumpthru ? this._wasOverJumpthru.GetUID() : -1,
        ga: this._ga,
        edj: this._enableDoubleJump,
        cdj: this._canDoubleJump,
        dj: this._doubleJumped,
        sus: this._jumpSustain,
        dc: this._defaultControls,
        cc: this._ceilingCollisionMode
      }
    }
    LoadFromJson(g) {
      this._ignoreInput = g.ii
      this._lastFloorX = g.lfx
      this._lastFloorY = g.lfy
      this._loadFloorUid = g.lfo
      this._animMode = g.am
      const h = g.en
      this._fallThrough = g.fall
      this._isFirstTick = g.ft
      this._dx = g.dx
      this._dy = g.dy
      this._maxSpeed = g.ms
      this._acc = g.acc
      this._dec = g.dec
      this._jumpStrength = g.js
      this._g = g.g
      this._g1 = g.g1
      this._maxFall = g.mf
      this._wasOnFloor = g.wof
      this._loadJumpthruUid = g.woj
      this._ga = g.ga
      this._enableDoubleJump = g.edj
      this._canDoubleJump = g.cdj
      this._doubleJumped = g.dj
      this._jumpSustain = g.sus
      this._defaultControls = g.dc
      this._ceilingCollisionMode = g.cc || 0
      this._simJump = this._simRight = this._simLeft = this._jumped = this._jumpKey = this._rightKey = this._leftKey = !1
      this._sustainTime = 0
      this._defaultControls ? this._BindEvents() : this._UnBindEvents()
      this._SetEnabled(h)
      this._UpdateGravity()
    }
    _OnAfterLoad() {
      this._lastFloorObject = -1 === this._loadFloorUid ? null : this._runtime.GetInstanceByUID(this._loadFloorUid)
      this._wasOverJumpthru = -1 === this._loadJumpthruUid ? null : this._runtime.GetInstanceByUID(this._loadJumpthruUid)
    }
    _UpdateGravity() {
      this._downX = Math.cos(this._ga)
      this._downY = Math.sin(this._ga)
      this._rightX = Math.cos(this._ga - Math.PI / 2)
      this._rightY = Math.sin(this._ga - Math.PI / 2)
      this._downX = e.round6dp(this._downX)
      this._downY = e.round6dp(this._downY)
      this._rightX = e.round6dp(this._rightX)
      this._rightY = e.round6dp(this._rightY)
      this._g1 = this._g
      0 > this._g && ((this._downX *= -1), (this._downY *= -1), (this._g = Math.abs(this._g)))
    }
    _GetGDir() {
      return 0 > this._g ? -1 : 1
    }
    _IsOnFloor() {
      var g = this._inst.GetWorldInfo()
      const h = this._runtime.GetCollisionEngine(),
        k = this._inst
      var m = this._lastFloorObject
      const r = g.GetX(),
        w = g.GetY()
      g.OffsetXY(this._downX, this._downY)
      g.SetBboxChanged()
      if (m && h.TestOverlap(k, m) && (!m.GetObjectClass().HasSolidBehavior() || h.IsSolidCollisionAllowed(m, k))) return g.SetXY(r, w), g.SetBboxChanged(), m
      {
        let p = h.TestOverlapSolid(k)
        m = null
        p || 0 !== this._fallThrough || (m = h.TestOverlapJumpthru(k, !0))
        g.SetXY(r, w)
        g.SetBboxChanged()
        if (p) {
          if (h.TestOverlap(k, p)) return null
          this._floorIsJumpthru = !1
          return p
        }
        if (m && m.length) {
          g = 0
          for (let q = 0, t = m.length; q < t; ++q) (m[g] = m[q]), h.TestOverlap(k, m[q]) || ++g
          if (1 <= g) return (this._floorIsJumpthru = !0), m[0]
        }
        return null
      }
    }
    PostTick() {
      if (this._isEnabled) {
        var g = this._runtime.GetDt(this._inst)
        this._jumpKey || this._simJump || (this._jumped = !1)
        var h = this._leftKey || this._simLeft,
          k = this._rightKey || this._simRight,
          m = this._jumpKey || this._simJump,
          r = m && !this._jumped
        this._simJump = this._simRight = this._simLeft = !1
        this._ignoreInput && (r = m = k = h = !1)
        m || (this._sustainTime = 0)
        this._HandleFirstTick()
        var [w, , p] = this._TrackMovingPlatform(),
          q = this._IsOnFloor(),
          t = q && !this._wasOnFloor,
          x
        ;[x, q] = this._MaybePushOutSolid(q)
        if (!x) {
          this._TrackFloor(q, p, w, m)
          r = this._HandleJump(q, r, m)
          q || this._ApplyJumpGravity(r, m, g)
          this._wasOnFloor = !!q
          h = this._ApplyHorizontalAcceleration(h, k, g)
          k = !1
          m = 0
          0 !== this._dx && (k = this._HandleHorizontalMovement(g, h, q, r))
          if (0 !== this._dy) {
            const [v, u] = this._HandleVerticalMovement(g, q)
            k = k || v
            m = u
          }
          !k && t && 0 > this._dy && 0 < m && ((this._dy = 0), (k = !0))
          this._HandleAnimationTriggers(q, k, r)
          0 < this._fallThrough && this._fallThrough--
          this._wasOverJumpthru = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst)
        }
      }
    }
    _HandleFirstTick() {
      if (this._isFirstTick) {
        var g = this._inst,
          h = this._runtime.GetCollisionEngine()
        ;(h.TestOverlapSolid(g) || h.TestOverlapJumpthru(g)) && h.PushOutSolid(g, -this._downX, -this._downY, 4, !0)
        this._isFirstTick = !1
      }
    }
    _TrackMovingPlatform() {
      var g = this._lastFloorObject,
        h = g ? g.GetWorldInfo() : null
      let k = 0,
        m = 0
      var r = !1
      if (g && 0 === this._dy && (h.GetY() !== this._lastFloorY || h.GetX() !== this._lastFloorX)) {
        g = this._inst
        r = g.GetWorldInfo()
        const w = this._runtime.GetCollisionEngine(),
          p = h.GetX()
        h = h.GetY()
        k = p - this._lastFloorX
        m = h - this._lastFloorY
        r.OffsetXY(k, m)
        r.SetBboxChanged()
        this._lastFloorX = p
        this._lastFloorY = h
        r = !0
        w.TestOverlapSolid(g) && w.PushOutSolid(g, -k, -m, 2.5 * Math.hypot(k, m))
      }
      return [k, m, r]
    }
    _MaybePushOutSolid(g) {
      let h = !1
      var k = this._inst,
        m = k.GetWorldInfo()
      const r = this._runtime.GetCollisionEngine(),
        w = r.TestOverlapSolid(k)
      if (!w) return [!1, g]
      const p = Math.abs(m.GetWidth())
      m = Math.abs(m.GetHeight())
      k.GetSavedDataMap().get('inputPredicted')
        ? r.PushOutSolid(k, -this._downX, -this._downY, 10, !1)
        : r.PushOutSolidAxis(k, -this._downX, -this._downY, m / 8)
        ? (r.RegisterCollision(k, w), (this._lastFloorObject = g = w), (k = w.GetWorldInfo()), (this._lastFloorX = k.GetX()), (this._lastFloorY = k.GetY()), (this._floorIsJumpthru = !1))
        : r.PushOutSolidAxis(k, this._rightX, this._rightY, p / 2) || r.PushOutSolidAxis(k, this._downX, this._downY, m / 2) || r.PushOutSolidNearest(k, Math.max(p, m) / 2)
        ? r.RegisterCollision(k, w)
        : (h = !0)
      return [h, g]
    }
    _TrackFloor(g, h, k, m) {
      const r = this._inst,
        w = this._runtime.GetCollisionEngine()
      if (g) {
        m = this._downX
        const p = this._downY,
          q = this._rightX,
          t = this._rightY
        this._canDoubleJump = this._doubleJumped = !1
        0 < this._dy && (this._wasOnFloor || (w.PushInFractional(r, -m, -p, g, 16), (this._wasOnFloor = !0)), (this._dy = 0))
        this._lastFloorObject !== g
          ? ((this._lastFloorObject = g), (k = g.GetWorldInfo()), (this._lastFloorX = k.GetX()), (this._lastFloorY = k.GetY()), w.RegisterCollision(r, g))
          : h && (g = w.TestOverlapSolid(r)) && (w.RegisterCollision(r, g), 0 !== k && (0 < k ? w.PushOutSolid(r, -q, -t) : w.PushOutSolid(r, q, t)), w.PushOutSolid(r, -m, -p))
      } else m || (this._canDoubleJump = !0)
    }
    _HandleJump(g, h, k) {
      if ((g && h) || (!g && this._enableDoubleJump && k && this._canDoubleJump && !this._doubleJumped)) {
        h = this._inst
        k = h.GetWorldInfo()
        const m = this._runtime.GetCollisionEngine(),
          r = k.GetX(),
          w = k.GetY()
        k.OffsetXY(-this._downX, -this._downY)
        k.SetBboxChanged()
        m.TestOverlapSolid(h) ? (h = !1) : ((this._sustainTime = this._jumpSustain), this.Trigger(e.Behaviors.Platform.Cnds.OnJump), (this._animMode = 'jumping'), (this._dy = -this._jumpStrength), (h = !0), g ? (this._jumped = !0) : (this._doubleJumped = !0))
        k.SetXY(r, w)
        k.SetBboxChanged()
      }
      return h
    }
    _ApplyJumpGravity(g, h, k) {
      h && 0 < this._sustainTime ? ((this._dy = -this._jumpStrength), (this._sustainTime -= k)) : ((this._lastFloorObject = null), (this._dy += this._g * k), this._dy > this._maxFall && (this._dy = this._maxFall))
      g && (this._jumped = !0)
    }
    _ApplyHorizontalAcceleration(g, h, k) {
      const m = this._acc,
        r = this._dec
      g === h && (0 > this._dx ? ((this._dx += r * k), 0 < this._dx && (this._dx = 0)) : 0 < this._dx && ((this._dx -= r * k), 0 > this._dx && (this._dx = 0)))
      let w = 0
      g && !h && (w = 0 < this._dx ? -(m + r) : -m)
      h && !g && (w = 0 > this._dx ? m + r : m)
      this._dx += w * k
      this._dx = e.clamp(this._dx, -this._maxSpeed, this._maxSpeed)
      return w
    }
    _HandleHorizontalMovement(g, h, k, m) {
      const r = this._inst
      var w = r.GetWorldInfo()
      const p = this._runtime.GetCollisionEngine(),
        q = this._downX,
        t = this._downY,
        x = this._rightX,
        v = this._rightY
      var u = this._maxSpeed
      let A = !1
      var z = w.GetX()
      let C = w.GetY()
      var E = c(this._dx, -u, u, h, g) * x
      const J = c(this._dx, -u, u, h, g) * v
      w.OffsetXY(x * (1 < this._dx ? 1 : -1) - q, v * (1 < this._dx ? 1 : -1) - t)
      w.SetBboxChanged()
      h = !1
      u = p.TestOverlapSolid(r)
      w.SetXY(z + E, C + J)
      w.SetBboxChanged()
      let F = p.TestOverlapSolid(r)
      !F && k && (F = p.TestOverlapJumpthru(r)) && (w.SetXY(z, C), w.SetBboxChanged(), p.TestOverlap(r, F) ? ((F = null), (h = !1)) : (h = !0), w.SetXY(z + E, C + J), w.SetBboxChanged())
      F
        ? ((E = Math.abs(this._dx * g) + 2), u || !p.PushOutSolid(r, -q, -t, E, h, F))
          ? (p.RegisterCollision(r, F),
            (E = Math.max(Math.abs(this._dx * g * 2.5), 30)),
            p.PushOutSolid(r, x * (0 > this._dx ? 1 : -1), v * (0 > this._dx ? 1 : -1), E, !1)
              ? !k || h || this._floorIsJumpthru || ((z = w.GetX()), (C = w.GetY()), w.OffsetXY(q, t), p.TestOverlapSolid(r) ? p.PushOutSolid(r, -q, -t, 3, !1) || (w.SetXY(z, C), w.SetBboxChanged()) : (w.SetXY(z, C), w.SetBboxChanged()))
              : (w.SetXY(z, C), w.SetBboxChanged()),
            h || (this._dx = 0))
          : !u && !m && Math.abs(this._dy) < Math.abs(this._jumpStrength / 4) && ((this._dy = 0), k || (A = !0))
        : ((z = this._IsOnFloor()),
          k && !z
            ? ((g = Math.ceil(Math.abs(this._dx * g)) + 2), (z = w.GetX()), (C = w.GetY()), w.OffsetXY(q * g, t * g), w.SetBboxChanged(), p.TestOverlapSolid(r) || p.TestOverlapJumpthru(r) ? p.PushOutSolid(r, -q, -t, g + 2, !0) : (w.SetXY(z, C), w.SetBboxChanged()))
            : z && (!k && this._floorIsJumpthru && ((this._lastFloorObject = z), (w = z.GetWorldInfo()), (this._lastFloorX = w.GetX()), (this._lastFloorY = w.GetY()), (this._dy = 0), (A = !0)), 0 === this._dy && p.PushInFractional(r, -q, -t, z, 16)))
      return A
    }
    _HandleVerticalMovement(g, h) {
      const k = this._inst,
        m = k.GetWorldInfo(),
        r = this._runtime.GetCollisionEngine(),
        w = this._downX,
        p = this._downY
      let q = !1,
        t = m.GetX(),
        x = m.GetY()
      const v = c(this._dy, -Infinity, this._maxFall, this._g, g)
      m.OffsetXY(v * w, v * p)
      var u = m.GetX()
      const A = m.GetY()
      m.SetBboxChanged()
      let z = r.TestOverlapSolid(k)
      var C = !1
      if (!z && 0 < this._dy && !h) {
        if ((C = 0 < this._fallThrough ? null : r.TestOverlapJumpthru(k, !0)) && C.length) {
          if (this._wasOverJumpthru) {
            m.SetXY(t, x)
            m.SetBboxChanged()
            h = 0
            for (let E = 0, J = C.length; E < J; ++E) (C[h] = C[E]), r.TestOverlap(k, C[E]) || ++h
            e.truncateArray(C, h)
            m.SetXY(u, A)
            m.SetBboxChanged()
          }
          1 <= C.length && (z = C[0])
        }
        C = !!z
      }
      if (z)
        if ((r.RegisterCollision(k, z), (this._sustainTime = 0), (u = 1.1), C && !this._wasOverJumpthru && (u = 2), r.PushOutSolid(k, w * (0 > this._dy ? 1 : -1), p * (0 > this._dy ? 1 : -1), Math.max(Math.abs(this._dy * g * u), 2), C, z))) {
          this._lastFloorObject = z
          g = z.GetWorldInfo()
          this._lastFloorX = g.GetX()
          this._lastFloorY = g.GetY()
          ;(this._floorIsJumpthru = C) && (q = !0)
          if (0 < this._dy || 0 === this._ceilingCollisionMode) this._dy = 0
          0 > this._dy && 1 === this._ceilingCollisionMode && r.PushInFractional(k, w, p, z, 32)
        } else m.SetXY(t, x), m.SetBboxChanged(), (this._wasOnFloor = !0), C || (this._dy = 0)
      return [q, v]
    }
    _HandleAnimationTriggers(g, h, k) {
      'falling' !== this._animMode && 0 < this._dy && !g && (this.Trigger(e.Behaviors.Platform.Cnds.OnFall), (this._animMode = 'falling'))
      ;(g || h) &&
        0 <= this._dy &&
        ('falling' === this._animMode || h || (k && 0 === this._dy)
          ? (this.Trigger(e.Behaviors.Platform.Cnds.OnLand), (this._animMode = 0 === this._dx && 0 === this._dy ? 'stopped' : 'moving'))
          : ('stopped' !== this._animMode && 0 === this._dx && 0 === this._dy && (this.Trigger(e.Behaviors.Platform.Cnds.OnStop), (this._animMode = 'stopped')),
            'moving' === this._animMode || (0 === this._dx && 0 === this._dy) || k || (this.Trigger(e.Behaviors.Platform.Cnds.OnMove), (this._animMode = 'moving'))))
    }
    _IsMoving() {
      return 0 !== this._GetVectorX() || 0 !== this._GetVectorY()
    }
    _CheckIfStandingOnFloor() {
      if (0 !== this._dy) return !1
      const g = this._inst
      var h = this.GetWorldInfo()
      const k = this._runtime.GetCollisionEngine(),
        m = h.GetX(),
        r = h.GetY()
      h.OffsetXY(this._downX, this._downY)
      h.SetBboxChanged()
      const w = k.TestOverlapSolid(g)
      let p = null
      w || 0 !== this._fallThrough || (p = k.TestOverlapJumpthru(g, !0))
      h.SetXY(m, r)
      h.SetBboxChanged()
      if (w) return !k.TestOverlap(g, w)
      if (p && p.length) {
        h = 0
        for (let q = 0, t = p.length; q < t; ++q) (p[h] = p[q]), k.TestOverlap(g, p[q]) || h++
        if (1 <= h) return !0
      }
      return !1
    }
    _IsByWall(g) {
      const h = this._inst,
        k = this.GetWorldInfo(),
        m = this._runtime.GetCollisionEngine(),
        r = k.GetX(),
        w = k.GetY()
      0 === g ? k.OffsetXY(2 * -this._rightX, 2 * -this._rightY) : k.OffsetXY(2 * this._rightX, 2 * this._rightY)
      k.SetBboxChanged()
      if (!m.TestOverlapSolid(h)) return k.SetXY(r, w), k.SetBboxChanged(), !1
      k.OffsetXY(3 * -this._downX, 3 * -this._downY)
      k.SetBboxChanged()
      g = !!m.TestOverlapSolid(h)
      k.SetXY(r, w)
      k.SetBboxChanged()
      return g
    }
    _FallThroughJumpThru() {
      const g = this.GetWorldInfo(),
        h = g.GetX(),
        k = g.GetY()
      g.OffsetXY(this._downX, this._downY)
      g.SetBboxChanged()
      const m = this._runtime.GetCollisionEngine().TestOverlapJumpthru(this._inst, !1)
      g.SetXY(h, k)
      g.SetBboxChanged()
      m && ((this._fallThrough = 3), (this._lastFloorObject = null))
    }
    _ResetDoubleJump(g) {
      this._doubleJumped = !g
    }
    _GetSpeed() {
      return Math.hypot(this._dx, this._dy)
    }
    _GetMovingAngle() {
      return Math.atan2(this._dy, this._dx)
    }
    _IsJumping() {
      return 0 > this._dy
    }
    _IsFalling() {
      return 0 < this._dy
    }
    _SetMaxSpeed(g) {
      this._maxSpeed = Math.max(g, 0)
    }
    _GetMaxSpeed() {
      return this._maxSpeed
    }
    _SetAcceleration(g) {
      this._acc = Math.max(g, 0)
    }
    _GetAcceleration() {
      return this._acc
    }
    _SetDeceleration(g) {
      this._dec = Math.max(g, 0)
    }
    _GetDeceleration() {
      return this._dec
    }
    _SetJumpStrength(g) {
      this._jumpStrength = Math.max(g, 0)
    }
    _GetJumpStrength() {
      return this._jumpStrength
    }
    _SetMaxFallSpeed(g) {
      this._maxFall = Math.max(g, 0)
    }
    _GetMaxFallSpeed() {
      return this._maxFall
    }
    _SetGravity(g) {
      if (this._g1 !== g) {
        this._g = g
        this._UpdateGravity()
        g = this._runtime.GetCollisionEngine()
        var h = this.GetWorldInfo()
        g.TestOverlapSolid(this._inst) && (g.PushOutSolid(this._inst, this._downX, this._downY, 10), h.OffsetXY(2 * this._downX, 2 * this._downY), h.SetBboxChanged())
        this._lastFloorObject = null
      }
    }
    _GetGravity() {
      return this._g
    }
    _SetGravityAngle(g) {
      g = e.clampAngle(g)
      this._ga !== g && ((this._ga = g), this._UpdateGravity(), (this._lastFloorObject = null))
    }
    _GetGravityAngle() {
      return this._ga
    }
    _SetDoubleJumpEnabled(g) {
      this._enableDoubleJump = !!g
    }
    _IsDoubleJumpEnabled() {
      return this._enableDoubleJump
    }
    _SetJumpSustain(g) {
      this._jumpSustain = g
    }
    _GetJumpSustain() {
      return this._jumpSustain
    }
    _SetCeilingCollisionMode(g) {
      this._ceilingCollisionMode = g
    }
    _GetCeilingCollisionMode() {
      return this._ceilingCollisionMode
    }
    _SetVectorX(g) {
      this._dx = g
    }
    _GetVectorX() {
      return this._dx
    }
    _SetVectorY(g) {
      this._dy = g
    }
    _GetVectorY() {
      return this._dy
    }
    _SimulateControl(g) {
      if (this._isEnabled)
        switch (g) {
          case 0:
            this._simLeft = !0
            break
          case 1:
            this._simRight = !0
            break
          case 2:
            this._simJump = !0
        }
    }
    _SetDefaultControls(g) {
      g = !!g
      this._defaultControls !== g && ((this._defaultControls = g) ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()))
    }
    _IsDefaultControls() {
      return this._defaultControls
    }
    _SetIgnoreInput(g) {
      this._ignoreInput = !!g
    }
    _IsIgnoreInput() {
      return this._ignoreInput
    }
    _SetEnabled(g) {
      g = !!g
      this._isEnabled !== g && ((this._isEnabled = g) ? this._StartPostTicking() : (this._StopPostTicking(), (this._lastFloorObject = null), (this._simJump = this._simRight = this._simLeft = !1)))
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetPropertyValueByIndex(g) {
      switch (g) {
        case 0:
          return this._GetMaxSpeed()
        case 1:
          return this._GetAcceleration()
        case 2:
          return this._GetDeceleration()
        case 3:
          return this._GetJumpStrength()
        case 4:
          return this._GetGravity()
        case 5:
          return this._GetMaxFallSpeed()
        case 6:
          return this._IsDoubleJumpEnabled()
        case 7:
          return 1e3 * this._GetJumpSustain()
        case 8:
          return this._IsDefaultControls()
        case 9:
          return this._IsEnabled()
      }
    }
    SetPropertyValueByIndex(g, h) {
      switch (g) {
        case 0:
          this._SetMaxSpeed(h)
          break
        case 1:
          this._SetAcceleration(h)
          break
        case 2:
          this._SetDeceleration(h)
          break
        case 3:
          this._SetJumpStrength(h)
          break
        case 4:
          this._SetGravity(h)
          break
        case 5:
          this._SetMaxFallSpeed(h)
          break
        case 6:
          this._SetDoubleJumpEnabled(!!h)
          break
        case 7:
          this._SetJumpSustain(h / 1e3)
          break
        case 8:
          this._SetDefaultControls(!!h)
          break
        case 9:
          this._SetEnabled(!!h)
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.platform.debugger.vector-x',
              value: this._GetVectorX(),
              onedit: g => this._SetVectorX(g)
            },
            {
              name: 'behaviors.platform.debugger.vector-y',
              value: this._GetVectorY(),
              onedit: g => this._SetVectorY(g)
            },
            {
              name: 'behaviors.platform.properties.max-speed.name',
              value: this._GetMaxSpeed(),
              onedit: g => this._SetMaxSpeed(g)
            },
            {
              name: 'behaviors.platform.properties.acceleration.name',
              value: this._GetAcceleration(),
              onedit: g => this._SetAcceleration(g)
            },
            {
              name: 'behaviors.platform.properties.deceleration.name',
              value: this._GetDeceleration(),
              onedit: g => this._SetDeceleration(g)
            },
            {
              name: 'behaviors.platform.properties.jump-strength.name',
              value: this._GetJumpStrength(),
              onedit: g => this._SetJumpStrength(g)
            },
            {
              name: 'behaviors.platform.properties.gravity.name',
              value: this._GetGravity(),
              onedit: g => this._SetGravity(g)
            },
            {
              name: 'behaviors.platform.debugger.gravity-angle',
              value: e.toDegrees(this._GetGravityAngle()),
              onedit: g => this._SetGravityAngle(e.toRadians(g))
            },
            {
              name: 'behaviors.platform.properties.max-fall-speed.name',
              value: this._GetMaxFallSpeed(),
              onedit: g => this._SetMaxFallSpeed(g)
            },
            {
              name: 'behaviors.platform.debugger.animation-mode',
              value: ['behaviors.platform.debugger.anim-' + this._animMode]
            },
            {
              name: 'behaviors.platform.properties.enabled.name',
              value: this._IsEnabled(),
              onedit: g => this._SetEnabled(g)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.IPlatformBehaviorInstance
    }
  }
  const d = new WeakMap(),
    f = new Map([
      ['left', 0],
      ['right', 1],
      ['jump', 2]
    ])
  self.IPlatformBehaviorInstance = class extends a {
    constructor() {
      super()
      d.set(this, a._GetInitInst().GetSdkInstance())
    }
    fallThrough() {
      d.get(this)._FallThroughJumpThru()
    }
    resetDoubleJump(g) {
      d.get(this)._ResetDoubleJump(!!g)
    }
    simulateControl(g) {
      b.RequireString(g)
      g = f.get(g)
      if ('number' !== typeof g) throw Error('invalid control')
      d.get(this)._SimulateControl(g)
    }
    get speed() {
      return d.get(this)._GetSpeed()
    }
    get maxSpeed() {
      return d.get(this)._GetMaxSpeed()
    }
    set maxSpeed(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetMaxSpeed(g)
    }
    get acceleration() {
      return d.get(this)._GetAcceleration()
    }
    set acceleration(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetAcceleration(g)
    }
    get deceleration() {
      return d.get(this)._GetDeceleration()
    }
    set deceleration(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetDeceleration(g)
    }
    get jumpStrength() {
      return d.get(this)._GetJumpStrength()
    }
    set jumpStrength(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetJumpStrength(g)
    }
    get maxFallSpeed() {
      return d.get(this)._GetMaxFallSpeed()
    }
    set maxFallSpeed(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetMaxFallSpeed(g)
    }
    get gravity() {
      return d.get(this)._GetGravity()
    }
    set gravity(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetGravity(g)
    }
    get gravityAngle() {
      return d.get(this)._GetGravityAngle()
    }
    set gravityAngle(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetGravityAngle(g)
    }
    get isDoubleJumpEnabled() {
      return d.get(this)._IsDoubleJumpEnabled()
    }
    set isDoubleJumpEnabled(g) {
      d.get(this)._SetDoubleJumpEnabled(!!g)
    }
    get jumpSustain() {
      return d.get(this)._GetJumpSustain()
    }
    set jumpSustain(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetJumpSustain(g)
    }
    get ceilingCollisionMode() {
      return 0 === d.get(this)._GetCeilingCollisionMode() ? 'stop' : 'preserve-momentum'
    }
    set ceilingCollisionMode(g) {
      b.RequireString(g)
      const h = d.get(this)
      if ('stop' === g) h._SetCeilingCollisionMode(0)
      else if ('preserve-momentum' === g) h._SetCeilingCollisionMode(1)
      else throw Error('invalid mode')
    }
    get isOnFloor() {
      return d.get(this)._CheckIfStandingOnFloor()
    }
    isByWall(g) {
      b.RequireString(g)
      const h = d.get(this)
      if ('left' === g) return h._IsByWall(0)
      if ('right' === g) return h._IsByWall(1)
      throw Error('invalid side')
    }
    get isMoving() {
      return d.get(this)._IsMoving()
    }
    get isJumping() {
      return d.get(this)._IsJumping()
    }
    get isFalling() {
      return d.get(this)._IsFalling()
    }
    get vectorX() {
      return d.get(this)._GetVectorX()
    }
    set vectorX(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetVectorX(g)
    }
    get vectorY() {
      return d.get(this)._GetVectorY()
    }
    set vectorY(g) {
      b.RequireFiniteNumber(g)
      d.get(this)._SetVectorY(g)
    }
    get isDefaultControls() {
      return d.get(this)._IsDefaultControls()
    }
    set isDefaultControls(g) {
      d.get(this)._SetDefaultControls(!!g)
    }
    get isIgnoringInput() {
      return d.get(this)._IsIgnoreInput()
    }
    set isIgnoringInput(g) {
      d.get(this)._SetIgnoreInput(!!g)
    }
    get isEnabled() {
      return d.get(this)._IsEnabled()
    }
    set isEnabled(g) {
      d.get(this)._SetEnabled(!!g)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Platform.Cnds = {
    IsMoving() {
      return this._IsMoving()
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a)
    },
    IsOnFloor() {
      return this._CheckIfStandingOnFloor()
    },
    IsByWall(b) {
      return this._IsByWall(b)
    },
    IsJumping() {
      return this._IsJumping()
    },
    IsFalling() {
      return this._IsFalling()
    },
    IsDoubleJumpEnabled() {
      return this._IsDoubleJumpEnabled()
    },
    OnJump() {
      return !0
    },
    OnFall() {
      return !0
    },
    OnStop() {
      return !0
    },
    OnMove() {
      return !0
    },
    OnLand() {
      return !0
    },
    IsEnabled() {
      return this._IsEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Platform.Acts = {
    SetMaxSpeed(b) {
      this._SetMaxSpeed(b)
    },
    SetAcceleration(b) {
      this._SetAcceleration(b)
    },
    SetDeceleration(b) {
      this._SetDeceleration(b)
    },
    SetJumpStrength(b) {
      this._SetJumpStrength(b)
    },
    SetMaxFallSpeed(b) {
      this._SetMaxFallSpeed(b)
    },
    SetGravity(b) {
      this._SetGravity(b)
    },
    SimulateControl(b) {
      this._SimulateControl(b)
    },
    SetIgnoreInput(b) {
      this._SetIgnoreInput(!!b)
    },
    SetVectorX(b) {
      this._SetVectorX(b)
    },
    SetVectorY(b) {
      this._SetVectorY(b)
    },
    SetGravityAngle(b) {
      this._SetGravityAngle(e.toRadians(b))
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b)
    },
    FallThrough() {
      this._FallThroughJumpThru()
    },
    SetDoubleJumpEnabled(b) {
      this._SetDoubleJumpEnabled(0 !== b)
    },
    SetJumpSustain(b) {
      this._SetJumpSustain(b / 1e3)
    },
    SetCeilingCollision(b) {
      this._SetCeilingCollisionMode(b)
    },
    SetDefaultControls(b) {
      this._SetDefaultControls(b)
    },
    ResetDoubleJump(b) {
      this._ResetDoubleJump(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Platform.Exps = {
    Speed() {
      return this._GetSpeed()
    },
    MaxSpeed() {
      return this._GetMaxSpeed()
    },
    Acceleration() {
      return this._GetAcceleration()
    },
    Deceleration() {
      return this._GetDeceleration()
    },
    JumpStrength() {
      return this._GetJumpStrength()
    },
    Gravity() {
      return this._GetGravity()
    },
    GravityAngle() {
      return e.toDegrees(this._GetGravityAngle())
    },
    MaxFallSpeed() {
      return this._GetMaxFallSpeed()
    },
    MovingAngle() {
      return e.toDegrees(this._GetMovingAngle())
    },
    VectorX() {
      return this._GetVectorX()
    },
    VectorY() {
      return this._GetVectorY()
    },
    JumpSustain() {
      return 1e3 * this._GetJumpSustain()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Timer = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Timer.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Timer.SingleTimer = class {
    constructor(b, a, c, d) {
      this._current = e.New(e.KahanSum)
      this._current.Set(b || 0)
      this._total = e.New(e.KahanSum)
      this._total.Set(a || 0)
      this._duration = c || 0
      this._isRegular = !!d
      this._isPaused = !1
    }
    GetCurrentTime() {
      return this._current.Get()
    }
    GetTotalTime() {
      return this._total.Get()
    }
    GetDuration() {
      return this._duration
    }
    SetPaused(b) {
      this._isPaused = !!b
    }
    IsPaused() {
      return this._isPaused
    }
    Add(b) {
      this._current.Add(b)
      this._total.Add(b)
    }
    HasFinished() {
      return this._current.Get() >= this._duration
    }
    Update() {
      if (this.HasFinished())
        if (this._isRegular) this._current.Subtract(this._duration)
        else return !0
      return !1
    }
    SaveToJson() {
      return {
        c: this._current.Get(),
        t: this._total.Get(),
        d: this._duration,
        r: this._isRegular,
        p: this._isPaused
      }
    }
    LoadFromJson(b) {
      this._current.Set(b.c)
      this._total.Set(b.t)
      this._duration = b.d
      this._isRegular = !!b.r
      this._isPaused = !!b.p
    }
  }
  e.Behaviors.Timer.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._timers = new Map()
    }
    Release() {
      this._timers.clear()
      super.Release()
    }
    _UpdateTickState() {
      0 < this._timers.size ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2())
    }
    SaveToJson() {
      const b = {}
      for (const [a, c] of this._timers.entries()) b[a] = c.SaveToJson()
      return b
    }
    LoadFromJson(b) {
      this._timers.clear()
      for (const [a, c] of Object.entries(b)) (b = new e.Behaviors.Timer.SingleTimer()), b.LoadFromJson(c), this._timers.set(a, b)
      this._UpdateTickState()
    }
    Tick() {
      const b = this._runtime.GetDt(this._inst)
      for (const a of this._timers.values()) a.IsPaused() || a.Add(b)
    }
    Tick2() {
      for (const [b, a] of this._timers.entries()) a.Update() && this._timers.delete(b)
    }
    GetDebuggerProperties() {
      return [
        {
          title: 'behaviors.timer.debugger.timers',
          properties: [...this._timers.entries()].map(b => ({
            name: '$' + b[0],
            value: `${Math.round(10 * b[1].GetCurrentTime()) / 10} / ${Math.round(10 * b[1].GetDuration()) / 10}`
          }))
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Timer.Cnds = {
  OnTimer(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.HasFinished() : !1
  },
  IsTimerRunning(e) {
    return this._timers.has(e.toLowerCase())
  },
  IsTimerPaused(e) {
    return (e = this._timers.get(e.toLowerCase())) && e.IsPaused()
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Timer.Acts = {
    StartTimer(b, a, c) {
      b = new e.Behaviors.Timer.SingleTimer(0, 0, b, 1 === a)
      this._timers.set(c.toLowerCase(), b)
      this._UpdateTickState()
    },
    StopTimer(b) {
      this._timers.delete(b.toLowerCase())
      this._UpdateTickState()
    },
    PauseResumeTimer(b, a) {
      ;(b = this._timers.get(b.toLowerCase())) && b.SetPaused(0 === a)
    }
  }
}
;('use strict')
self.C3.Behaviors.Timer.Exps = {
  CurrentTime(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetCurrentTime() : 0
  },
  TotalTime(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetTotalTime() : 0
  },
  Duration(e) {
    return (e = this._timers.get(e.toLowerCase())) ? e.GetDuration() : 0
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Flash = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Flash.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Flash.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._timeLeft = this._stageTimeLeft = this._stage = this._offTime = this._onTime = 0
      this._StartTicking()
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        on: this._onTime,
        off: this._offTime,
        s: this._stage,
        stl: this._stageTimeLeft,
        tl: this._timeLeft
      }
    }
    LoadFromJson(b) {
      this._onTime = b.on
      this._offTime = b.off
      this._stage = b.s
      this._stageTimeLeft = b.stl
      this._timeLeft = null === b.tl ? Infinity : b.tl
    }
    Tick() {
      if (!(0 >= this._timeLeft)) {
        var b = this._runtime.GetDt(this._inst)
        this._timeLeft -= b
        if (0 >= this._timeLeft) return (this._timeLeft = 0), this._inst.GetWorldInfo().SetVisible(!0), this._runtime.UpdateRender(), this.DebugTrigger(e.Behaviors.Flash.Cnds.OnFlashEnded)
        this._stageTimeLeft -= b
        0 >= this._stageTimeLeft && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(!1), (this._stage = 1), (this._stageTimeLeft += this._offTime)) : (this._inst.GetWorldInfo().SetVisible(!0), (this._stage = 0), (this._stageTimeLeft += this._onTime)), this._runtime.UpdateRender())
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.flash.debugger.on-time',
              value: this._onTime,
              onedit: b => (this._onTime = b)
            },
            {
              name: 'behaviors.flash.debugger.off-time',
              value: this._offTime,
              onedit: b => (this._offTime = b)
            },
            {
              name: 'behaviors.flash.debugger.is-flashing',
              value: 0 < this._timeLeft
            },
            {
              name: 'behaviors.flash.debugger.time-left',
              value: this._timeLeft
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Flash.Cnds = {
  IsFlashing() {
    return 0 < this._timeLeft
  },
  OnFlashEnded() {
    return !0
  }
}
;('use strict')
self.C3.Behaviors.Flash.Acts = {
  Flash(e, b, a) {
    this._onTime = e
    this._offTime = b
    this._stage = 1
    this._stageTimeLeft = b
    this._timeLeft = a
    this._inst.GetWorldInfo().SetVisible(!1)
    this._runtime.UpdateRender()
  },
  StopFlashing() {
    this._timeLeft = 0
    this._inst.GetWorldInfo().SetVisible(!0)
    this._runtime.UpdateRender()
  }
}
;('use strict')
self.C3.Behaviors.Flash.Exps = {}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.scrollto = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
      this._shakeMode = this._shakeEnd = this._shakeStart = this._shakeMag = 0
    }
    Release() {
      super.Release()
    }
    SetShakeMagnitude(b) {
      this._shakeMag = b
    }
    GetShakeMagnitude() {
      return this._shakeMag
    }
    SetShakeStart(b) {
      this._shakeStart = b
    }
    GetShakeStart() {
      return this._shakeStart
    }
    SetShakeEnd(b) {
      this._shakeEnd = b
    }
    GetShakeEnd() {
      return this._shakeEnd
    }
    SetShakeMode(b) {
      this._shakeMode = b
    }
    GetShakeMode() {
      return this._shakeMode
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.scrollto.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.scrollto.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._isEnabled = !0
      a && (this._isEnabled = a[0])
      this._isEnabled && this._StartTicking2()
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      const b = this.GetBehavior()
      return {
        e: this._isEnabled,
        smg: b.GetShakeMagnitude(),
        ss: b.GetShakeStart(),
        se: b.GetShakeEnd(),
        smd: b.GetShakeMode()
      }
    }
    LoadFromJson(b) {
      const a = this.GetBehavior()
      a.SetShakeMagnitude(b.smg)
      a.SetShakeStart(b.ss)
      a.SetShakeEnd(b.se)
      a.SetShakeMode(b.smd)
      ;(this._isEnabled = b.e) ? this._StartTicking2() : this._StopTicking2()
    }
    IsEnabled() {
      return this._isEnabled
    }
    Tick2() {
      if (this.IsEnabled()) {
        this._runtime.GetDt(this._inst)
        var b = this.GetBehavior(),
          a = b.GetInstances(),
          c = 0,
          d = 0,
          f = 0
        for (var g of a) (a = g.GetBehaviorInstanceFromCtor(e.Behaviors.scrollto)) && a.GetSdkInstance().IsEnabled() && ((a = g.GetWorldInfo()), (c += a.GetX()), (d += a.GetY()), ++f)
        g = this._inst.GetWorldInfo().GetLayout()
        var h = this._runtime.GetGameTime(),
          k = (a = 0)
        h >= b.GetShakeStart() &&
          h < b.GetShakeEnd() &&
          ((a = b.GetShakeMagnitude() * Math.min(this._runtime.GetTimeScale(), 1)),
          0 === b.GetShakeMode() && (a *= 1 - (h - b.GetShakeStart()) / (b.GetShakeEnd() - b.GetShakeStart())),
          (b = this._runtime.Random() * Math.PI * 2),
          (h = this._runtime.Random() * a),
          (a = Math.cos(b) * h),
          (k = Math.sin(b) * h))
        g.SetScrollX(c / f + a)
        g.SetScrollY(d / f + k)
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this._isEnabled
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          ;(this._isEnabled = !!a) ? this._StartTicking2() : this._StopTicking2()
      }
    }
  }
}
;('use strict')
self.C3.Behaviors.scrollto.Cnds = {
  IsEnabled() {
    return this._isEnabled
  }
}
;('use strict')
self.C3.Behaviors.scrollto.Acts = {
  Shake(e, b, a) {
    const c = this.GetBehavior()
    c.SetShakeMagnitude(e)
    c.SetShakeStart(this._runtime.GetGameTime())
    c.SetShakeEnd(this._runtime.GetGameTime() + b)
    c.SetShakeMode(a)
  },
  SetEnabled(e) {
    ;(this._isEnabled = 0 !== e) ? this._StartTicking2() : this._StopTicking2()
  }
}
;('use strict')
self.C3.Behaviors.scrollto.Exps = {}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.MoveTo = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.MoveTo.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance
  e.Behaviors.MoveTo.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(d, f) {
      super(d)
      this._maxSpeed = 200
      this._dec = this._acc = 600
      this._rotateSpeed = 0
      this._setAngle = !0
      this._stopOnSolids = !1
      this._isEnabled = !0
      this._speed = 0
      this._movingAngle = this.GetWorldInfo().GetAngle()
      this._waypoints = []
      f && ((this._maxSpeed = f[0]), (this._acc = f[1]), (this._dec = f[2]), (this._rotateSpeed = e.toRadians(f[3])), (this._setAngle = f[4]), (this._stopOnSolids = f[5]), (this._isEnabled = f[6]))
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        rs: this._rotateSpeed,
        sa: this._setAngle,
        sos: this._stopOnSolids,
        s: this._speed,
        ma: this._movingAngle,
        wp: this._waypoints.map(d => ({
          x: d.x,
          y: d.y
        })),
        e: this._isEnabled
      }
    }
    LoadFromJson(d) {
      this._maxSpeed = d.ms
      this._acc = d.acc
      this._dec = d.dec
      this._rotateSpeed = d.rs
      this._setAngle = d.sa
      this._stopOnSolids = d.sos
      this._speed = d.s
      this._movingAngle = d.ma
      this._waypoints = d.wp.map(f => ({
        x: f.x,
        y: f.y
      }))
      this._SetEnabled(d.e)
      this._isEnabled && 0 < this._waypoints.length && this._StartTicking()
    }
    _AddWaypoint(d, f, g) {
      g && e.clearArray(this._waypoints)
      this._waypoints.push({
        x: d,
        y: f
      })
      this._isEnabled && this._StartTicking()
    }
    _GetWaypointCount() {
      return this._waypoints.length
    }
    _GetWaypointXAt(d) {
      d = Math.floor(d)
      return 0 > d || d >= this._waypoints.length ? 0 : this._waypoints[d].x
    }
    _GetWaypointYAt(d) {
      d = Math.floor(d)
      return 0 > d || d >= this._waypoints.length ? 0 : this._waypoints[d].y
    }
    _IsMoving() {
      return 0 < this._waypoints.length
    }
    _Stop() {
      e.clearArray(this._waypoints)
      this._speed = 0
      this._StopTicking()
    }
    _GetTargetX() {
      return 0 < this._waypoints.length ? this._waypoints[0].x : 0
    }
    _GetTargetY() {
      return 0 < this._waypoints.length ? this._waypoints[0].y : 0
    }
    _SetSpeed(d) {
      this._IsMoving() && (this._speed = Math.min(d, this._maxSpeed))
    }
    _GetSpeed() {
      return this._speed
    }
    _SetMaxSpeed(d) {
      this._maxSpeed = Math.max(d, 0)
      this._SetSpeed(this._speed)
    }
    _GetMaxSpeed() {
      return this._maxSpeed
    }
    _IsRotationEnabled() {
      return 0 !== this._rotateSpeed
    }
    Tick() {
      if (this._isEnabled && this._IsMoving()) {
        var d = this._runtime.GetDt(this._inst),
          f = this._inst.GetWorldInfo(),
          g = f.GetX(),
          h = f.GetY(),
          k = f.GetAngle(),
          m = this._speed,
          r = this._maxSpeed,
          w = this._acc,
          p = this._dec,
          q = this._GetTargetX(),
          t = this._GetTargetY(),
          x = e.angleTo(g, h, q, t),
          v = !1
        0 < p && 1 === this._waypoints.length && ((v = ((0.5 * m * m) / p) * 1.0001), (v = e.distanceSquared(g, h, q, t) <= v * v)) && ((r = e.distanceTo(g, h, q, t)), (this._speed = r = m = Math.sqrt(2 * p * r)))
        if (this._IsRotationEnabled()) {
          var u = e.angleDiff(this._movingAngle, x)
          if (u > Number.EPSILON) {
            const A = u / this._rotateSpeed
            u *= e.distanceTo(f.GetX(), f.GetY(), q, t) / (2 * Math.sin(u))
            r = Math.min(r, e.clamp(u / A, 0, this._maxSpeed))
          }
        }
        m = Math.min(m * d + 0.5 * (v ? -p : w) * d * d, r * d)
        if (v) {
          if (0 < p && ((this._speed = Math.max(this._speed - p * d, 0)), 0 === this._speed)) {
            this._OnArrived(f, q, t)
            return
          }
        } else this._speed = 0 === w ? r : Math.min(this._speed + w * d, r)
        e.distanceSquared(f.GetX(), f.GetY(), q, t) <= m * m
          ? this._OnArrived(f, q, t)
          : (this._IsRotationEnabled() ? (this._movingAngle = e.angleRotate(this._movingAngle, x, this._rotateSpeed * d)) : (this._movingAngle = x),
            f.OffsetXY(Math.cos(this._movingAngle) * m, Math.sin(this._movingAngle) * m),
            this._setAngle && f.SetAngle(this._movingAngle),
            f.SetBboxChanged(),
            this._CheckSolidCollision(g, h, k))
      }
    }
    _OnArrived(d, f, g) {
      d.SetXY(f, g)
      d.SetBboxChanged()
      this._waypoints.shift()
      0 === this._waypoints.length && ((this._speed = 0), this._StopTicking())
      this.GetScriptInterface().dispatchEvent(e.New(e.Event, 'arrived'))
      this.Trigger(e.Behaviors.MoveTo.Cnds.OnArrived)
    }
    _CheckSolidCollision(d, f, g) {
      const h = this._runtime.GetCollisionEngine()
      if (this._stopOnSolids && h.TestOverlapSolid(this._inst)) {
        this._Stop()
        const m = this._inst.GetWorldInfo()
        var k = m.GetX()
        const r = m.GetY(),
          w = e.angleTo(k, r, d, f)
        k = e.distanceTo(k, r, d, f)
        h.PushOutSolid(this._inst, Math.cos(w), Math.sin(w), Math.max(k, 1)) || (m.SetXY(d, f), m.SetAngle(g), m.SetBboxChanged())
        this.GetScriptInterface().dispatchEvent(e.New(e.Event, 'hitsolid'))
        this.Trigger(e.Behaviors.MoveTo.Cnds.OnHitSolid)
      }
    }
    _IsSetAngle() {
      return this._setAngle
    }
    _SetSetAngle(d) {
      this._setAngle = !!d
    }
    _SetAngleOfMotion(d) {
      this._movingAngle = d
      this._isEnabled && this._setAngle && !this._IsMoving() && ((d = this.GetWorldInfo()), d.SetAngle(this._movingAngle), d.SetBboxChanged())
    }
    _GetAngleOfMotion() {
      return this._movingAngle
    }
    _SetAcceleration(d) {
      this._acc = Math.max(d, 0)
    }
    _GetAcceleration() {
      return this._acc
    }
    _SetDeceleration(d) {
      this._dec = Math.max(d, 0)
    }
    _GetDeceleration() {
      return this._dec
    }
    _SetRotateSpeed(d) {
      this._rotateSpeed = Math.max(d, 0)
    }
    _GetRotateSpeed() {
      return this._rotateSpeed
    }
    _SetStopOnSolids(d) {
      this._stopOnSolids = !!d
    }
    _IsStopOnSolids() {
      return this._stopOnSolids
    }
    _SetEnabled(d) {
      d = !!d
      this._isEnabled !== d && ((this._isEnabled = d) && this._IsMoving() ? this._StartTicking() : this._StopTicking())
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetPropertyValueByIndex(d) {
      switch (d) {
        case 0:
          return this._GetMaxSpeed()
        case 1:
          return this._GetAcceleration()
        case 2:
          return this._GetDeceleration()
        case 3:
          return e.toDegrees(this._GetRotateSpeed())
        case 4:
          return this._IsSetAngle()
        case 5:
          return this._IsStopOnSolids()
        case 6:
          return this._IsEnabled()
      }
    }
    SetPropertyValueByIndex(d, f) {
      switch (d) {
        case 0:
          this._SetMaxSpeed(f)
          break
        case 1:
          this._SetAcceleration(f)
          break
        case 2:
          this._SetDeceleration(f)
          break
        case 3:
          this._SetRotateSpeed(e.toRadians(f))
          break
        case 4:
          this._SetSetAngle(f)
          break
        case 5:
          this._SetStopOnSolids(f)
          break
        case 6:
          this._SetEnabled(f)
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.moveto.debugger.speed',
              value: this._GetSpeed(),
              onedit: d => this._SetSpeed(d)
            },
            {
              name: 'behaviors.moveto.debugger.angle-of-motion',
              value: e.toDegrees(this._GetAngleOfMotion()),
              onedit: d => (this._movingAngle = e.toRadians(d))
            },
            {
              name: 'behaviors.moveto.debugger.target-x',
              value: this._GetTargetX()
            },
            {
              name: 'behaviors.moveto.debugger.target-y',
              value: this._GetTargetY()
            },
            {
              name: 'behaviors.moveto.debugger.waypoint-count',
              value: this._GetWaypointCount()
            },
            {
              name: 'behaviors.moveto.properties.max-speed.name',
              value: this._GetMaxSpeed(),
              onedit: d => this._SetMaxSpeed(d)
            },
            {
              name: 'behaviors.moveto.properties.acceleration.name',
              value: this._GetAcceleration(),
              onedit: d => this._SetAcceleration(d)
            },
            {
              name: 'behaviors.moveto.properties.deceleration.name',
              value: this._GetDeceleration(),
              onedit: d => this._SetDeceleration(d)
            },
            {
              name: 'behaviors.moveto.properties.rotate-speed.name',
              value: e.toDegrees(this._GetRotateSpeed()),
              onedit: d => this._SetRotateSpeed(e.toRadians(d))
            },
            {
              name: 'behaviors.moveto.properties.enabled.name',
              value: this._IsEnabled(),
              onedit: d => this._SetEnabled(d)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.IMoveToBehaviorInstance
    }
  }
  const c = new WeakMap()
  self.IMoveToBehaviorInstance = class extends a {
    constructor() {
      super()
      c.set(this, a._GetInitInst().GetSdkInstance())
    }
    moveToPosition(d, f, g = !0) {
      b.RequireFiniteNumber(d)
      b.RequireFiniteNumber(f)
      c.get(this)._AddWaypoint(d, f, !!g)
    }
    getTargetX() {
      return c.get(this)._GetTargetX()
    }
    getTargetY() {
      return c.get(this)._GetTargetY()
    }
    getTargetPosition() {
      const d = c.get(this)
      return [d._GetTargetX(), d._GetTargetY()]
    }
    getWaypointCount() {
      return c.get(this)._GetWaypointCount()
    }
    getWaypointX(d) {
      b.RequireFiniteNumber(d)
      return c.get(this)._GetWaypointXAt(d)
    }
    getWaypointY(d) {
      b.RequireFiniteNumber(d)
      return c.get(this)._GetWaypointYAt(d)
    }
    getWaypoint(d) {
      b.RequireFiniteNumber(d)
      const f = c.get(this)
      return [f._GetWaypointXAt(d), f._GetWaypointYAt(d)]
    }
    stop() {
      c.get(this)._Stop()
    }
    get isMoving() {
      return c.get(this)._IsMoving()
    }
    get speed() {
      return c.get(this)._GetSpeed()
    }
    set speed(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetSpeed(d)
    }
    get maxSpeed() {
      return c.get(this)._GetMaxSpeed()
    }
    set maxSpeed(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetMaxSpeed(d)
    }
    get acceleration() {
      return c.get(this)._GetAcceleration()
    }
    set acceleration(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetAcceleration(d)
    }
    get deceleration() {
      return c.get(this)._GetDeceleration()
    }
    set deceleration(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetDeceleration(d)
    }
    get angleOfMotion() {
      return c.get(this)._GetAngleOfMotion()
    }
    set angleOfMotion(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetAngleOfMotion(d)
    }
    get rotateSpeed() {
      return c.get(this)._GetRotateSpeed()
    }
    set rotateSpeed(d) {
      b.RequireFiniteNumber(d)
      c.get(this)._SetRotateSpeed(d)
    }
    get isStopOnSolids() {
      return c.get(this)._IsStopOnSolids()
    }
    set isStopOnSolids(d) {
      c.get(this)._SetStopOnSolids(d)
    }
    get isEnabled() {
      return c.get(this)._IsEnabled()
    }
    set isEnabled(d) {
      c.get(this)._SetEnabled(d)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.MoveTo.Cnds = {
    IsMoving() {
      return this._IsMoving()
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a)
    },
    IsEnabled() {
      return this._IsEnabled()
    },
    OnArrived() {
      return !0
    },
    OnHitSolid() {
      return !0
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.MoveTo.Acts = {
    MoveToPosition(b, a, c) {
      this._AddWaypoint(b, a, 0 === c)
    },
    MoveToObject(b, a, c) {
      if (b && (b = b.GetPairedInstance(this._inst)) && b.GetWorldInfo()) {
        var [d, f] = b.GetImagePoint(a)
        this._AddWaypoint(d, f, 0 === c)
      }
    },
    MoveAlongPathfindingPath(b) {
      var a = this._inst.GetBehaviorSdkInstanceFromCtor(e.Behaviors.Pathfinding)
      if (a && ((a = a._GetPath()), 0 !== a.length))
        for (let c = 0, d = a.length; c < d; ++c) {
          const f = a[c]
          this._AddWaypoint(f.x, f.y, 0 === c && 0 === b)
        }
    },
    MoveAlongTimeline(b, a, c) {
      if ((a = a ? b.GetTrackById(a) : e.first(b.GetTracks())))
        if (((b = a.GetPropertyTrack('offsetX')), (a = a.GetPropertyTrack('offsetY')), b && a)) {
          var d = [...b.GetPropertyKeyframeValues()],
            f = [...a.GetPropertyKeyframeValues()]
          if (0 !== d.length && 0 !== f.length) {
            var g = 0,
              h = 0,
              k = this._inst.GetWorldInfo()
            'relative' === b.GetResultMode() && (g = k.GetX())
            'relative' === a.GetResultMode() && (h = k.GetY())
            for (let m = 0, r = Math.min(d.length, f.length); m < r; ++m) this._AddWaypoint(d[m] + g, f[m] + h, 0 === m && 0 === c)
          }
        }
    },
    MoveAlongTimelineByName(b, a, c) {
      ;(b = this._runtime.GetTimelineManager().GetTimelineByName(b)) && e.Behaviors.MoveTo.Acts.MoveAlongTimeline.call(this, b, a, c)
    },
    Stop() {
      this._Stop()
    },
    SetMovingAngle(b) {
      this._SetAngleOfMotion(e.toRadians(b))
    },
    SetSpeed(b) {
      this._SetSpeed(b)
    },
    SetMaxSpeed(b) {
      this._SetMaxSpeed(b)
    },
    SetAcceleration(b) {
      this._SetAcceleration(b)
    },
    SetDeceleration(b) {
      this._SetDeceleration(b)
    },
    SetRotateSpeed(b) {
      this._SetRotateSpeed(e.toRadians(b))
    },
    SetStopOnSolids(b) {
      this._SetStopOnSolids(b)
    },
    SetEnabled(b) {
      this._SetEnabled(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.MoveTo.Exps = {
    Speed() {
      return this._GetSpeed()
    },
    MaxSpeed() {
      return this._GetMaxSpeed()
    },
    Acceleration() {
      return this._GetAcceleration()
    },
    Deceleration() {
      return this._GetDeceleration()
    },
    MovingAngle() {
      return e.toDegrees(this._GetAngleOfMotion())
    },
    RotateSpeed() {
      return e.toDegrees(this._GetRotateSpeed())
    },
    TargetX() {
      return this._GetTargetX()
    },
    TargetY() {
      return this._GetTargetY()
    },
    WaypointCount() {
      return this._GetWaypointCount()
    },
    WaypointXAt(b) {
      return this._GetWaypointXAt(b)
    },
    WaypointYAt(b) {
      return this._GetWaypointYAt(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.LOS = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.LOS.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
      this._obstacleTypes = []
    }
    Release() {
      e.clearArray(this._obstacleTypes)
      super.Release()
    }
    OnCreate() {}
    GetObstacleTypes() {
      return this._obstacleTypes
    }
    FindLOSBehavior(b) {
      const a = this.GetBehaviorType()
      for (const c of b.GetBehaviorInstances()) if (c.GetBehaviorType() === a) return c.GetSdkInstance()
      return null
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = []
  e.Behaviors.LOS.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(f, g) {
      super(f)
      this._obstacleMode = 0
      this._range = 1e4
      this._cone = e.toRadians(360)
      this._useCollisionCells = !0
      this._ray = new e.Ray()
      g && ((this._obstacleMode = g[0]), (this._range = g[1]), (this._cone = e.toRadians(g[2])), (this._useCollisionCells = g[3]))
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        r: this._range,
        c: this._cone,
        om: this._obstacleMode,
        ucc: this._useCollisionCells,
        t: this.GetSdkType()
          .GetObstacleTypes()
          .map(f => f.GetSID())
      }
    }
    LoadFromJson(f) {
      this._range = f.r
      this._cone = f.c
      this._obstacleMode = f.om || 0
      this._useCollisionCells = !!f.ucc
      const g = this.GetSdkType().GetObstacleTypes()
      e.clearArray(g)
      for (const h of f.t) (f = this._runtime.GetObjectClassBySID(h)) && g.push(f)
    }
    HasLOSToInstance(f, g) {
      const h = f.GetUID(),
        [k, m] = f.GetImagePoint(g)
      return this.HasLOSTo(k, m) || this._ray.hitUid === h
    }
    HasLOSTo(f, g) {
      const h = this.GetWorldInfo()
      let k = h.GetAngle()
      0 > h.GetWidth() && (k += Math.PI)
      return this.HasLOSBetweenPositions(h.GetX(), h.GetY(), k, f, g)
    }
    HasLOSBetweenPositions(f, g, h, k, m) {
      var r = this._range
      if (e.distanceSquared(f, g, k, m) > r * r) return !1
      r = e.angleTo(f, g, k, m)
      return e.angleDiff(h, r) > this._cone / 2 ? !1 : !this.CastRay(f, g, k, m, this._useCollisionCells).DidCollide()
    }
    _GetCollisionCandidates(f, g) {
      if (g) {
        g = this.GetWorldInfo().GetLayer()
        var h = this._runtime.GetCollisionEngine()
        0 === this._obstacleMode ? h.GetSolidCollisionCandidates(g, f.rect, c) : h.GetObjectClassesCollisionCandidates(g, this._GetObstacleTypes(), f.rect, c)
        return c
      }
      if (0 === this._obstacleMode) return (f = this._runtime.GetSolidBehavior()) ? f.GetInstances() : c
      for (h of this._GetObstacleTypes()) e.appendArray(c, h.GetInstances())
      return c
    }
    _GetObstacleTypes() {
      return this.GetSdkType().GetObstacleTypes()
    }
    CastRay(f, g, h, k, m) {
      f = this._ray.Set(f, g, h, k)
      m = this._GetCollisionCandidates(f, m)
      g = this._runtime.GetCollisionEngine()
      h = 0 === this._obstacleMode
      k = this._inst
      for (let r = 0, w = m.length; r < w; ++r) {
        const p = m[r]
        p !== k && ((h && !g.IsSolidCollisionAllowed(p, k)) || g.TestRayIntersectsInstance(p, f))
      }
      f.Complete()
      e.clearArray(c)
      return f
    }
    _GetRay() {
      return this._ray
    }
    _GetRayHitX() {
      const f = this._ray
      return f.DidCollide() ? f.hitX : 0
    }
    _GetRayHitY() {
      const f = this._ray
      return f.DidCollide() ? f.hitY : 0
    }
    _GetRayHitDistance() {
      const f = this._ray
      return f.DidCollide() ? f.distance : 0
    }
    _GetRayHitUID() {
      const f = this._ray
      return f.DidCollide() ? f.hitUid : -1
    }
    _GetRayNormalX(f) {
      const g = this._ray
      return g.DidCollide() ? g.hitX + f * g.normalX : 0
    }
    _GetRayNormalY(f) {
      const g = this._ray
      return g.DidCollide() ? g.hitY + f * g.normalY : 0
    }
    _GetRayNormalAngle() {
      const f = this._ray
      return f.DidCollide() ? f.hitNormal : 0
    }
    _GetRayReflectionX(f) {
      const g = this._ray
      return g.DidCollide() ? g.hitX + f * g.reflectionX : 0
    }
    _GetRayReflectionY(f) {
      const g = this._ray
      return g.DidCollide() ? g.hitY + f * g.reflectionY : 0
    }
    _GetRayReflectionAngle() {
      const f = this._ray
      return f.DidCollide() ? Math.atan2(f.reflectionY, f.reflectionX) : 0
    }
    _SetRange(f) {
      this._range = f
    }
    _GetRange() {
      return this._range
    }
    _SetConeOfView(f) {
      this._cone = f
    }
    _GetConeOfView() {
      return this._cone
    }
    GetPropertyValueByIndex(f) {
      switch (f) {
        case 0:
          return this._obstacleMode
        case 1:
          return this._range
        case 2:
          return e.toDegrees(this._cone)
        case 3:
          return this._useCollisionCells
      }
    }
    SetPropertyValueByIndex(f, g) {
      switch (f) {
        case 0:
          this._obstacleMode = g
          break
        case 1:
          this._range = g
          break
        case 2:
          this._cone = e.toRadians(g)
          break
        case 3:
          this._useCollisionCells = !!g
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.los.properties.range.name',
              value: this._GetRange(),
              onedit: f => this._SetRange(f)
            },
            {
              name: 'behaviors.los.properties.cone-of-view.name',
              value: e.toDegrees(this._GetConeOfView()),
              onedit: f => this._SetConeOfView(e.toRadians(f))
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.ILOSBehaviorInstance
    }
  }
  const d = new WeakMap()
  self.ILOSBehaviorInstance = class extends a {
    constructor() {
      super()
      const f = a._GetInitInst().GetSdkInstance()
      d.set(this, f)
      this.ray = new self.ILOSBehaviorRay(f)
    }
    set range(f) {
      b.RequireFiniteNumber(f)
      d.get(this)._SetRange(f)
    }
    get range() {
      return d.get(this)._GetRange()
    }
    set coneOfView(f) {
      b.RequireFiniteNumber(f)
      d.get(this)._SetConeOfView(f)
    }
    get coneOfView() {
      return d.get(this)._GetConeOfView()
    }
    hasLOStoPosition(f, g) {
      b.RequireNumber(f)
      b.RequireNumber(g)
      return d.get(this).HasLOSTo(f, g)
    }
    hasLOSBetweenPositions(f, g, h, k, m) {
      b.RequireNumber(f)
      b.RequireNumber(g)
      b.RequireNumber(h)
      b.RequireNumber(k)
      b.RequireNumber(m)
      return d.get(this).HasLOSBetweenPositions(f, g, h, k, m)
    }
    castRay(f, g, h, k, m = !0) {
      b.RequireNumber(f)
      b.RequireNumber(g)
      b.RequireNumber(h)
      b.RequireNumber(k)
      d.get(this).CastRay(f, g, h, k, m)
      return this.ray
    }
  }
  self.ILOSBehaviorRay = class {
    constructor(f) {
      d.set(this, f)
    }
    get didCollide() {
      return d.get(this)._GetRay().DidCollide()
    }
    get hitX() {
      return d.get(this)._GetRayHitX()
    }
    get hitY() {
      return d.get(this)._GetRayHitY()
    }
    get hitDistance() {
      return d.get(this)._GetRayHitDistance()
    }
    get hitUid() {
      return d.get(this)._GetRayHitUID()
    }
    getNormalX(f) {
      b.RequireFiniteNumber(f)
      return d.get(this)._GetRayNormalX(f)
    }
    getNormalY(f) {
      b.RequireFiniteNumber(f)
      return d.get(this)._GetRayNormalY(f)
    }
    get normalAngle() {
      return d.get(this)._GetRayNormalAngle()
    }
    getReflectionX(f) {
      b.RequireFiniteNumber(f)
      return d.get(this)._GetRayReflectionX(f)
    }
    getReflectionY(f) {
      b.RequireFiniteNumber(f)
      return d.get(this)._GetRayReflectionY(f)
    }
    get reflectionAngle() {
      return d.get(this)._GetRayReflectionAngle()
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = new Set(),
    a = new Set()
  e.Behaviors.LOS.Cnds = {
    HasLOSToPosition(c, d) {
      return this.HasLOSTo(c, d)
    },
    RayIntersected() {
      return this._ray.DidCollide()
    },
    HasLOSBetweenPositions(c, d, f, g, h) {
      return this.HasLOSBetweenPositions(c, d, e.toRadians(f), g, h)
    },
    HasLOSToObject(c, d) {
      if (!c) return !1
      var f = this._runtime.GetCurrentCondition()
      const g = f.GetEventBlock().IsOrBlock()
      var h = f.GetRuntime()
      const k = f.GetObjectClass().GetCurrentSol()
      c = c.GetCurrentSol()
      let m = k.GetInstances(),
        r = c.GetInstances()
      k.IsSelectAll() ? e.clearArray(k._GetOwnElseInstances()) : g && (m = h.IsCurrentConditionFirst() && !k._GetOwnElseInstances().length && k._GetOwnInstances().length ? k._GetOwnInstances() : k._GetOwnElseInstances())
      c.IsSelectAll() ? e.clearArray(c._GetOwnElseInstances()) : g && (r = h.IsCurrentConditionFirst() && !c._GetOwnElseInstances().length && c._GetOwnInstances().length ? c._GetOwnInstances() : c._GetOwnElseInstances())
      f = f.IsInverted()
      h = this.GetSdkType()
      for (const w of m) {
        let p = !1
        const q = h.FindLOSBehavior(w)
        if (0 === r.length) f && (p = !0)
        else for (const t of r) w !== t && e.xor(q.HasLOSToInstance(t, d), f) && ((p = !0), a.add(t))
        p && b.add(w)
      }
      g ? (m === k._GetOwnElseInstances() ? k.TransferElseInstancesToOwn(b) : (k.AddElseInstances(b, m), k.SetSetPicked(b)), r === c._GetOwnElseInstances() ? c.TransferElseInstancesToOwn(a) : (c.AddElseInstances(a, r), c.SetSetPicked(a))) : (k.SetSetPicked(b), c.SetSetPicked(a))
      b.clear()
      a.clear()
      return k.HasAnyInstances()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.LOS.Acts = {
    SetRange(b) {
      this._SetRange(b)
    },
    SetCone(b) {
      this._SetConeOfView(e.toRadians(b))
    },
    CastRay(b, a, c, d, f) {
      this.CastRay(b, a, c, d, f)
    },
    AddObstacle(b) {
      const a = this.GetSdkType().GetObstacleTypes()
      if (!a.includes(b)) {
        for (const c of a) if (c.IsFamily() && c.FamilyHasMember(b)) return
        a.push(b)
      }
    },
    ClearObstacles() {
      e.clearArray(this.GetSdkType().GetObstacleTypes())
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.LOS.Exps = {
    Range() {
      return this._GetRange()
    },
    ConeOfView() {
      return e.toDegrees(this._GetConeOfView())
    },
    HitX() {
      return this._GetRayHitX()
    },
    HitY() {
      return this._GetRayHitY()
    },
    HitDistance() {
      return this._GetRayHitDistance()
    },
    HitUID() {
      return this._GetRayHitUID()
    },
    NormalX(b) {
      return this._GetRayNormalX(b)
    },
    NormalY(b) {
      return this._GetRayNormalY(b)
    },
    NormalAngle() {
      return e.toDegrees(this._GetRayNormalAngle())
    },
    ReflectionX(b) {
      return this._GetRayReflectionX(b)
    },
    ReflectionY(b) {
      return this._GetRayReflectionY(b)
    },
    ReflectionAngle() {
      return e.toDegrees(this._GetRayReflectionAngle())
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.jumpthru = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.jumpthru.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.jumpthru.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this.SetEnabled(!0)
      a && this.SetEnabled(a[0])
    }
    Release() {
      super.Release()
    }
    SetEnabled(b) {
      this._inst._SetJumpthruEnabled(!!b)
    }
    IsEnabled() {
      return this._inst._IsJumpthruEnabled()
    }
    SaveToJson() {
      return {
        e: this.IsEnabled()
      }
    }
    LoadFromJson(b) {
      this.SetEnabled(b.e)
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this.IsEnabled()
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this.SetEnabled(a)
      }
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.jumpthru.properties.enabled.name',
              value: this.IsEnabled(),
              onedit: b => this.SetEnabled(b)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.jumpthru.Cnds = {
  IsEnabled() {
    return this.IsEnabled()
  }
}
;('use strict')
self.C3.Behaviors.jumpthru.Acts = {
  SetEnabled(e) {
    this.SetEnabled(e)
  }
}
;('use strict')
self.C3.Behaviors.jumpthru.Exps = {}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Turret = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Turret.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
      this._targetTypes = []
    }
    Release() {
      e.clearArray(this._targetTypes)
      super.Release()
    }
    OnCreate() {}
    GetTargetTypes() {
      return this._targetTypes
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = e.New(e.Rect),
    a = []
  e.Behaviors.Turret.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(c, d) {
      super(c)
      this._range = 300
      this._rateOfFire = 1
      this._isRotateEnabled = !0
      this._rotateSpeed = e.toRadians(180)
      this._targetMode = 0
      this._predictiveAim = !1
      this._projectileSpeed = 500
      this._isEnabled = this._useCollisionCells = !0
      this._fireTimeCount = this._lastCheckTime = 0
      this._currentTarget = null
      this._loadTargetUid = -1
      this._oldTargetY = this._oldTargetX = 0
      this._lastSpeeds = [0, 0, 0, 0]
      this._speedsCount = 0
      this._firstTickWithTarget = !0
      d && ((this._range = d[0]), (this._rateOfFire = d[1]), (this._isRotateEnabled = !!d[2]), (this._rotateSpeed = e.toRadians(d[3])), (this._targetMode = d[4]), (this._predictiveAim = !!d[5]), (this._projectileSpeed = d[6]), (this._useCollisionCells = !!d[7]), (this._isEnabled = !!d[8]))
      this._fireTimeCount = this._rateOfFire
      c = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(c, 'instancedestroy', f => this._OnInstanceDestroyed(f.instance)),
        e.Disposable.From(c, 'afterload', f => this._OnAfterLoad())
      )
      this._isEnabled && this._StartTicking()
    }
    Release() {
      this._currentTarget = null
      super.Release()
    }
    _OnAfterLoad() {
      this._currentTarget = -1 === this._loadTargetUid ? null : this._runtime.GetInstanceByUID(this._loadTargetUid)
    }
    _OnInstanceDestroyed(c) {
      this._currentTarget === c && (this._currentTarget = null)
    }
    SaveToJson() {
      return {
        r: this._range,
        rof: this._rateOfFire,
        re: this._isRotateEnabled,
        rs: this._rotateSpeed,
        tm: this._targetMode,
        pa: this._predictiveAim,
        ps: this._projectileSpeed,
        ucc: this._useCollisionCells,
        e: this._isEnabled,
        lct: this._lastCheckTime,
        ftc: this._fireTimeCount,
        t: this._currentTarget ? this._currentTarget.GetUID() : -1,
        ox: this._oldTargetX,
        oy: this._oldTargetY,
        ls: this._lastSpeeds,
        sc: this._speedsCount,
        targs: this.GetSdkType()
          .GetTargetTypes()
          .map(c => c.GetSID())
      }
    }
    LoadFromJson(c) {
      this._range = c.r
      this._rateOfFire = c.rof
      this._isRotateEnabled = c.re
      this._rotateSpeed = c.rs
      this._targetMode = c.tm
      this._predictiveAim = c.pa
      this._projectileSpeed = c.ps
      this._useCollisionCells = c.ucc
      this._SetEnabled(c.e)
      this._lastCheckTime = c.lct
      this._fireTimeCount = c.ftc
      this._loadTargetUid = c.t
      this._oldTargetX = c.ox
      this._oldTargetY = c.oy
      this._lastSpeeds = c.ls
      this._speedsCount = c.sc
      const d = this.GetSdkType().GetTargetTypes()
      e.clearArray(d)
      for (const f of c.targs) (c = this._runtime.GetObjectClassBySID(f)) && d.push(c)
    }
    AddSpeed(c) {
      4 > this._speedsCount ? ((this._lastSpeeds[this._speedsCount] = c), this._speedsCount++) : (this._lastSpeeds.shift(), this._lastSpeeds.push(c))
    }
    GetSpeed() {
      let c = 0
      for (let d = 0; d < this._speedsCount; ++d) c += this._lastSpeeds[d]
      return c / this._speedsCount
    }
    IsInRange(c) {
      var d = this.GetWorldInfo()
      const f = c.GetWorldInfo()
      c = f.GetX() - d.GetX()
      d = f.GetY() - d.GetY()
      return c * c + d * d <= this._range * this._range
    }
    LookForFirstTarget() {
      const c = this.GetWorldInfo(),
        d = this.GetSdkType().GetTargetTypes(),
        f = this._runtime.GetCollisionEngine()
      if (this._useCollisionCells) b.set(c.GetX() - this._range, c.GetY() - this._range, c.GetX() + this._range, c.GetY() + this._range), f.GetObjectClassesCollisionCandidates(null, d, b, a)
      else for (const g of d) e.appendArray(a, g.GetInstances())
      for (const g of a)
        if (this.IsInRange(g)) {
          this._currentTarget = g
          e.clearArray(a)
          return
        }
      e.clearArray(a)
    }
    LookForNearestTarget() {
      var c = this.GetWorldInfo(),
        d = this.GetSdkType().GetTargetTypes(),
        f = this._runtime.GetCollisionEngine()
      const g = c.GetX()
      c = c.GetY()
      let h = this._range * this._range
      this._currentTarget = null
      if (this._useCollisionCells) b.set(g - this._range, c - this._range, g + this._range, c + this._range), f.GetObjectClassesCollisionCandidates(null, d, b, a)
      else for (const k of d) e.appendArray(a, k.GetInstances())
      for (const k of a) (f = k.GetWorldInfo()), (d = g - f.GetX()), (f = c - f.GetY()), (d = d * d + f * f), d < h && ((this._currentTarget = k), (h = d))
      e.clearArray(a)
    }
    _OnTargetAcquired() {
      this._speedsCount = 0
      this._firstTickWithTarget = !0
      const c = this._currentTarget.GetWorldInfo()
      this._oldTargetX = c.GetX()
      this._oldTargetY = c.GetY()
      this.Trigger(e.Behaviors.Turret.Cnds.OnTargetAcquired)
    }
    Tick() {
      if (this._isEnabled) {
        var c = this._runtime.GetDt(this._inst),
          d = this._runtime.GetGameTime(),
          f = this.GetWorldInfo()
        this._currentTarget && !this.IsInRange(this._currentTarget) && ((this._currentTarget = null), (this._speedsCount = 0), (this._firstTickWithTarget = !0))
        d >= this._lastCheckTime + 0.1 &&
          (((this._lastCheckTime = d), 0 !== this._targetMode || this._currentTarget)
            ? 1 === this._targetMode && ((d = this._currentTarget), this.LookForNearestTarget(), this._currentTarget && this._currentTarget !== d && this._OnTargetAcquired())
            : (this.LookForFirstTarget(), this._currentTarget && this._OnTargetAcquired()))
        this._fireTimeCount += c
        if (this._currentTarget) {
          var g = this._currentTarget.GetWorldInfo()
          d = e.angleTo(f.GetX(), f.GetY(), g.GetX(), g.GetY())
          if (this._predictiveAim) {
            var h = f.GetX()
            const k = f.GetY(),
              m = g.GetX()
            g = g.GetY()
            const r = e.angleTo(m, g, this._oldTargetX, this._oldTargetY)
            this._firstTickWithTarget || this.AddSpeed(e.distanceTo(m, g, this._oldTargetX, this._oldTargetY) / c)
            const w = this.GetSpeed(),
              p = g - k,
              q = m - h
            h = Math.asin((w * Math.sin(r) * (h - m) - w * Math.cos(r) * (k - g)) / this._projectileSpeed / Math.sqrt(p * p + q * q)) - Math.atan2(p, -q) + Math.PI
            isNaN(h) || (d = h)
          }
          this._isRotateEnabled && (f.SetAngle(e.angleRotate(f.GetAngle(), d, this._rotateSpeed * c)), f.SetBboxChanged())
          this._fireTimeCount >= this._rateOfFire &&
            (!this._isRotateEnabled || 0.1 >= e.toDegrees(e.angleDiff(f.GetAngle(), d))) &&
            (!this._predictiveAim || 4 <= this._speedsCount) &&
            ((this._fireTimeCount -= this._rateOfFire), this._fireTimeCount >= this._rateOfFire && (this._fireTimeCount = 0), this.Trigger(e.Behaviors.Turret.Cnds.OnShoot))
          this._currentTarget && ((g = this._currentTarget.GetWorldInfo()), (this._oldTargetX = g.GetX()), (this._oldTargetY = g.GetY()))
          this._firstTickWithTarget = !1
        }
        this._fireTimeCount > this._rateOfFire && (this._fireTimeCount = this._rateOfFire)
      }
    }
    GetPropertyValueByIndex(c) {
      switch (c) {
        case 0:
          return this._range
        case 1:
          return this._rateOfFire
        case 2:
          return this._isRotateEnabled
        case 3:
          return e.toDegrees(this._rotateSpeed)
        case 4:
          return this._targetMode
        case 5:
          return this._predictiveAim
        case 6:
          return this._projectileSpeed
        case 7:
          return this._useCollisionCells
        case 8:
          return this._isEnabled
      }
    }
    SetPropertyValueByIndex(c, d) {
      switch (c) {
        case 0:
          this._range = d
          break
        case 1:
          this._rateOfFire = d
          break
        case 2:
          this._isRotateEnabled = !!d
          break
        case 3:
          if (!this._isRotateEnabled) break
          this._rotateSpeed = e.toRadians(d)
          break
        case 4:
          this._targetMode = d
          break
        case 5:
          this._predictiveAim = !!d
          break
        case 6:
          if (!this._predictiveAim) break
          this._projectileSpeed = d
          break
        case 7:
          this._useCollisionCells = !!d
          break
        case 8:
          this._SetEnabled(d)
      }
    }
    _SetEnabled(c) {
      ;(this._isEnabled = !!c) ? this._StartTicking() : this._StopTicking()
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.turret.properties.range.name',
              value: this._range,
              onedit: c => (this._range = c)
            },
            {
              name: 'behaviors.turret.properties.rate-of-fire.name',
              value: this._rateOfFire,
              onedit: c => (this._rateOfFire = c)
            },
            {
              name: 'behaviors.turret.properties.rotate-speed.name',
              value: e.toDegrees(this._rotateSpeed),
              onedit: c => (this._rotateSpeed = e.toRadians(c))
            },
            {
              name: 'behaviors.turret.properties.predictive-aim.name',
              value: this._predictiveAim,
              onedit: c => (this._predictiveAim = c)
            },
            {
              name: 'behaviors.turret.properties.projectile-speed.name',
              value: this._projectileSpeed,
              onedit: c => (this._projectileSpeed = c)
            },
            {
              name: 'behaviors.turret.debugger.has-target',
              value: !!this._currentTarget
            },
            {
              name: 'behaviors.turret.debugger.target-uid',
              value: this._currentTarget ? this._currentTarget.GetUID() : 0
            },
            {
              name: 'behaviors.turret.properties.enabled.name',
              value: this._isEnabled,
              onedit: c => this._SetEnabled(c)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Turret.Cnds = {
  HasTarget() {
    return !!this._currentTarget
  },
  OnShoot() {
    return !0
  },
  OnTargetAcquired() {
    return !0
  },
  IsEnabled() {
    return this._isEnabled
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Turret.Acts = {
    AcquireTarget(b) {
      if (b) {
        b = b.GetCurrentSol().GetInstances()
        for (const a of b)
          if (this._currentTarget !== a && this.IsInRange(a)) {
            this._currentTarget = a
            this._OnTargetAcquired()
            break
          }
      }
    },
    AddTarget(b) {
      const a = this.GetSdkType().GetTargetTypes()
      if (!a.includes(b)) {
        for (const c of a) if (c.IsFamily() && c.FamilyHasMember(b)) return
        a.push(b)
      }
    },
    ClearTargets() {
      e.clearArray(this.GetSdkType().GetTargetTypes())
    },
    UnacquireTarget() {
      this._currentTarget = null
      this._speedsCount = 0
      this._firstTickWithTarget = !0
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b)
    },
    SetRange(b) {
      this._range = b
    },
    SetRateOfFire(b) {
      this._rateOfFire = b
    },
    SetRotate(b) {
      this._isRotateEnabled = 0 !== b
    },
    SetRotateSpeed(b) {
      this._rotateSpeed = e.toRadians(b)
    },
    SetTargetMode(b) {
      this._targetMode = b
    },
    SetPredictiveAim(b) {
      this._predictiveAim = 0 !== b
    },
    SetProjectileSpeed(b) {
      this._projectileSpeed = b
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Turret.Exps = {
    TargetUID() {
      return this._currentTarget ? this._currentTarget.GetUID() : 0
    },
    Range() {
      return this._range
    },
    RateOfFire() {
      return this._rateOfFire
    },
    RotateSpeed() {
      return e.toDegrees(this._rotateSpeed)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.EightDir = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.EightDir.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance
  e.Behaviors.EightDir.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(f, g) {
      super(f)
      this._simRight = this._simLeft = this._simDown = this._simUp = this._ignoreInput = this._rightKey = this._leftKey = this._downKey = this._upKey = !1
      this._dy = this._dx = 0
      this._maxSpeed = 200
      this._acc = 600
      this._dec = 500
      this._angleMode = this._directions = 3
      this._isEnabled = this._defaultControls = !0
      g && ((this._maxSpeed = g[0]), (this._acc = g[1]), (this._dec = g[2]), (this._directions = g[3]), (this._angleMode = g[4]), (this._defaultControls = !!g[5]), (this._isEnabled = !!g[6]))
      this._isEnabled && this._StartTicking()
      this._defaultControls && this._BindEvents()
    }
    _BindEvents() {
      if (!this._disposables) {
        var f = this._runtime.Dispatcher()
        this._disposables = new e.CompositeDisposable(
          e.Disposable.From(f, 'keydown', g => this._OnKeyDown(g.data)),
          e.Disposable.From(f, 'keyup', g => this._OnKeyUp(g.data)),
          e.Disposable.From(f, 'window-blur', () => this._OnWindowOrKeyboardBlur()),
          e.Disposable.From(f, 'keyboard-blur', () => this._OnWindowOrKeyboardBlur())
        )
      }
    }
    _UnBindEvents() {
      this._disposables && (this._disposables.Release(), (this._disposables = null))
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        dx: this._dx,
        dy: this._dy,
        e: this._isEnabled,
        ms: this._maxSpeed,
        acc: this._acc,
        dec: this._dec,
        d: this._directions,
        am: this._angleMode,
        dc: this._defaultControls,
        ii: this._ignoreInput
      }
    }
    LoadFromJson(f) {
      this._dx = f.dx
      this._dy = f.dy
      this._SetEnabled(f.e)
      this._maxSpeed = f.ms
      this._acc = f.acc
      this._dec = f.dec
      this._directions = f.d
      this._angleMode = f.am
      this._defaultControls = f.dc
      this._ignoreInput = f.ii
      this._simRight = this._simLeft = this._simDown = this._simUp = this._rightKey = this._leftKey = this._downKey = this._upKey = !1
      this._defaultControls ? this._BindEvents() : this._UnBindEvents()
    }
    _OnKeyDown(f) {
      switch (f.key) {
        case 'ArrowLeft':
          this._leftKey = !0
          break
        case 'ArrowUp':
          this._upKey = !0
          break
        case 'ArrowRight':
          this._rightKey = !0
          break
        case 'ArrowDown':
          this._downKey = !0
      }
    }
    _OnKeyUp(f) {
      switch (f.key) {
        case 'ArrowLeft':
          this._leftKey = !1
          break
        case 'ArrowUp':
          this._upKey = !1
          break
        case 'ArrowRight':
          this._rightKey = !1
          break
        case 'ArrowDown':
          this._downKey = !1
      }
    }
    _OnWindowOrKeyboardBlur() {
      this._rightKey = this._leftKey = this._downKey = this._upKey = !1
    }
    Tick() {
      var f = this._runtime.GetDt(this._inst)
      const g = this._runtime.GetCollisionEngine()
      var h = this._leftKey || this._simLeft,
        k = this._rightKey || this._simRight,
        m = this._upKey || this._simUp,
        r = this._downKey || this._simDown
      this._simDown = this._simUp = this._simRight = this._simLeft = !1
      if (this._isEnabled) {
        var w = g.TestOverlapSolid(this._inst)
        if (w && (g.RegisterCollision(this._inst, w), !g.PushOutSolidNearest(this._inst))) return
        this._ignoreInput && (h = k = m = r = !1)
        0 === this._directions ? (h = k = !1) : 1 === this._directions && (m = r = !1)
        2 === this._directions && (m || r) && (h = k = !1)
        h === k && (0 > this._dx ? (this._dx = Math.min(this._dx + this._dec * f, 0)) : 0 < this._dx && (this._dx = Math.max(this._dx - this._dec * f, 0)))
        m === r && (0 > this._dy ? (this._dy = Math.min(this._dy + this._dec * f, 0)) : 0 < this._dy && (this._dy = Math.max(this._dy - this._dec * f, 0)))
        var p = (w = 0)
        h && !k && (w = 0 < this._dx ? -(this._acc + this._dec) : -this._acc)
        k && !h && (w = 0 > this._dx ? this._acc + this._dec : this._acc)
        m && !r && (p = 0 < this._dy ? -(this._acc + this._dec) : -this._acc)
        r && !m && (p = 0 > this._dy ? this._acc + this._dec : this._acc)
        this._dx += w * f
        this._dy += p * f
        if (0 !== this._dx || 0 !== this._dy) {
          k = Math.atan2(this._dy, this._dx)
          h = this._maxSpeed * Math.cos(k)
          k = this._maxSpeed * Math.sin(k)
          Math.sqrt(this._dx * this._dx + this._dy * this._dy) > this._maxSpeed && ((this._dx = h), (this._dy = k))
          var q = Math.abs(h) * f
          r = Math.abs(k) * f
          h = this._inst.GetWorldInfo()
          const t = h.GetX()
          m = h.GetY()
          k = h.GetAngle()
          q = e.clamp(this._dx * f + 0.5 * w * f * f, -q, q)
          h.OffsetX(q)
          h.SetBboxChanged()
          if ((w = g.TestOverlapSolid(this._inst))) g.PushOutSolid(this._inst, 0 > this._dx ? 1 : -1, 0, Math.max(Math.abs(Math.floor(q)), 1)) || (h.SetX(t), h.SetBboxChanged()), (this._dx = 0), g.RegisterCollision(this._inst, w)
          f = e.clamp(this._dy * f + 0.5 * p * f * f, -r, r)
          h.OffsetY(f)
          h.SetBboxChanged()
          if ((w = g.TestOverlapSolid(this._inst))) g.PushOutSolid(this._inst, 0, 0 > this._dy ? 1 : -1, Math.max(Math.abs(Math.floor(f)), 1)) || (h.SetY(m), h.SetBboxChanged()), (this._dy = 0), g.RegisterCollision(this._inst, w)
          f = e.round6dp(this._dx)
          p = e.round6dp(this._dy)
          ;(0 === f && 0 === p) ||
            !this._inst.GetPlugin().IsRotatable() ||
            (1 === this._angleMode ? h.SetAngle(e.toRadians(90 * Math.round(e.toDegrees(Math.atan2(p, f)) / 90))) : 2 === this._angleMode ? h.SetAngle(e.toRadians(45 * Math.round(e.toDegrees(Math.atan2(p, f)) / 45))) : 3 === this._angleMode && h.SetAngle(Math.atan2(p, f)))
          h.SetBboxChanged()
          h.GetAngle() != k && (w = g.TestOverlapSolid(this._inst)) && (h.SetAngle(k), h.SetBboxChanged(), g.RegisterCollision(this._inst, w))
        }
      }
    }
    GetPropertyValueByIndex(f) {
      switch (f) {
        case 0:
          return this._GetMaxSpeed()
        case 1:
          return this._GetAcceleration()
        case 2:
          return this._GetDeceleration()
        case 3:
          return this._directions
        case 4:
          return this._angleMode
        case 5:
          return this._IsDefaultControls()
        case 6:
          return this._IsEnabled()
      }
    }
    SetPropertyValueByIndex(f, g) {
      switch (f) {
        case 0:
          this._SetMaxSpeed(g)
          break
        case 1:
          this._SetAcceleration(g)
          break
        case 2:
          this._SetDeceleration(g)
          break
        case 3:
          this._directions = g
          break
        case 4:
          this._angleMode = g
          break
        case 5:
          this._SetDefaultControls(!!g)
          break
        case 6:
          this._SetEnabled(!!g)
      }
    }
    _Stop() {
      this._dy = this._dx = 0
    }
    _Reverse() {
      this._dx *= -1
      this._dy *= -1
    }
    _MaybeClampSpeed() {
      const f = Math.hypot(this._dx, this._dy)
      f > this._maxSpeed && this._SetSpeed(f)
    }
    _SetSpeed(f) {
      f = e.clamp(f, 0, this._maxSpeed)
      const g = Math.atan2(this._dy, this._dx)
      this._dx = f * Math.cos(g)
      this._dy = f * Math.sin(g)
    }
    _GetSpeed() {
      return Math.hypot(this._dx, this._dy)
    }
    _SetMaxSpeed(f) {
      this._maxSpeed = Math.max(f, 0)
    }
    _GetMaxSpeed() {
      return this._maxSpeed
    }
    _SetAcceleration(f) {
      this._acc = Math.max(f, 0)
    }
    _GetAcceleration() {
      return this._acc
    }
    _SetDeceleration(f) {
      this._dec = Math.max(f, 0)
    }
    _GetDeceleration() {
      return this._dec
    }
    _GetMovingAngle() {
      return Math.atan2(this._dy, this._dx)
    }
    _SetVectorX(f) {
      this._dx = f
      this._MaybeClampSpeed()
    }
    _GetVectorX() {
      return this._dx
    }
    _SetVectorY(f) {
      this._dy = f
      this._MaybeClampSpeed()
    }
    _GetVectorY() {
      return this._dy
    }
    _SimulateControl(f) {
      if (this._isEnabled)
        switch (f) {
          case 0:
            this._simLeft = !0
            break
          case 1:
            this._simRight = !0
            break
          case 2:
            this._simUp = !0
            break
          case 3:
            this._simDown = !0
        }
    }
    _SetDefaultControls(f) {
      f = !!f
      this._defaultControls !== f && ((this._defaultControls = f) ? this._BindEvents() : (this._UnBindEvents(), this._OnWindowOrKeyboardBlur()))
    }
    _IsDefaultControls() {
      return this._defaultControls
    }
    _SetIgnoreInput(f) {
      this._ignoreInput = !!f
    }
    _IsIgnoreInput() {
      return this._ignoreInput
    }
    _SetEnabled(f) {
      ;(this._isEnabled = !!f) ? this._StartTicking() : ((this._simDown = this._simUp = this._simRight = this._simLeft = !1), this._StopTicking())
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.eightdir.debugger.vector-x',
              value: this._GetVectorX(),
              onedit: f => this._SetVectorX(f)
            },
            {
              name: 'behaviors.eightdir.debugger.vector-y',
              value: this._GetVectorY(),
              onedit: f => this._SetVectorY(f)
            },
            {
              name: 'behaviors.eightdir.debugger.speed',
              value: this._GetSpeed(),
              onedit: f => this._SetSpeed(f)
            },
            {
              name: 'behaviors.eightdir.debugger.angle-of-motion',
              value: e.toDegrees(this._GetMovingAngle())
            },
            {
              name: 'behaviors.eightdir.properties.max-speed.name',
              value: this._GetMaxSpeed(),
              onedit: f => this._SetMaxSpeed(f)
            },
            {
              name: 'behaviors.eightdir.properties.acceleration.name',
              value: this._GetAcceleration(),
              onedit: f => this._SetAcceleration(f)
            },
            {
              name: 'behaviors.eightdir.properties.deceleration.name',
              value: this._GetDeceleration(),
              onedit: f => this._SetDeceleration(f)
            },
            {
              name: 'behaviors.eightdir.properties.enabled.name',
              value: this._IsEnabled(),
              onedit: f => this._SetEnabled(f)
            }
          ]
        }
      ]
    }
    GetScriptInterfaceClass() {
      return self.I8DirectionBehaviorInstance
    }
  }
  const c = new WeakMap(),
    d = new Map([
      ['left', 0],
      ['right', 1],
      ['up', 2],
      ['down', 3]
    ])
  self.I8DirectionBehaviorInstance = class extends a {
    constructor() {
      super()
      c.set(this, a._GetInitInst().GetSdkInstance())
    }
    stop() {
      c.get(this)._Stop()
    }
    reverse() {
      c.get(this)._Reverse()
    }
    simulateControl(f) {
      b.RequireString(f)
      f = d.get(f)
      if ('number' !== typeof f) throw Error('invalid control')
      c.get(this)._SimulateControl(f)
    }
    get speed() {
      return c.get(this)._GetSpeed()
    }
    set speed(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetSpeed(f)
    }
    get maxSpeed() {
      return c.get(this)._GetMaxSpeed()
    }
    set maxSpeed(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetMaxSpeed(f)
    }
    get acceleration() {
      return c.get(this)._GetAcceleration()
    }
    set acceleration(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetAcceleration(f)
    }
    get deceleration() {
      return c.get(this)._GetDeceleration()
    }
    set deceleration(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetDeceleration(f)
    }
    get vectorX() {
      return c.get(this)._GetVectorX()
    }
    set vectorX(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetVectorX(f)
    }
    get vectorY() {
      return c.get(this)._GetVectorY()
    }
    set vectorY(f) {
      b.RequireFiniteNumber(f)
      c.get(this)._SetVectorX(f)
    }
    get isDefaultControls() {
      return c.get(this)._IsDefaultControls()
    }
    set isDefaultControls(f) {
      c.get(this)._SetDefaultControls(!!f)
    }
    get isIgnoringInput() {
      return c.get(this)._IsIgnoreInput()
    }
    set isIgnoringInput(f) {
      c.get(this)._SetIgnoreInput(!!f)
    }
    get isEnabled() {
      return c.get(this)._IsEnabled()
    }
    set isEnabled(f) {
      c.get(this)._SetEnabled(!!f)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.EightDir.Cnds = {
    IsMoving() {
      return 1e-10 < this._GetSpeed()
    },
    CompareSpeed(b, a) {
      return e.compare(this._GetSpeed(), b, a)
    },
    IsEnabled() {
      return this._IsEnabled()
    }
  }
}
;('use strict')
self.C3.Behaviors.EightDir.Acts = {
  Stop() {
    this._Stop()
  },
  Reverse() {
    this._Reverse()
  },
  SetIgnoreInput(e) {
    this._SetIgnoreInput(e)
  },
  SetSpeed(e) {
    this._SetSpeed(e)
  },
  SetMaxSpeed(e) {
    this._SetMaxSpeed(e)
  },
  SetAcceleration(e) {
    this._SetAcceleration(e)
  },
  SetDeceleration(e) {
    this._SetDeceleration(e)
  },
  SimulateControl(e) {
    this._SimulateControl(e)
  },
  SetEnabled(e) {
    this._SetEnabled(e)
  },
  SetVectorX(e) {
    this._SetVectorX(e)
  },
  SetVectorY(e) {
    this._SetVectorY(e)
  },
  SetDefaultControls(e) {
    this._SetDefaultControls(!!e)
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.EightDir.Exps = {
    Speed() {
      return this._GetSpeed()
    },
    MaxSpeed() {
      return this._GetMaxSpeed()
    },
    Acceleration() {
      return this._GetAcceleration()
    },
    Deceleration() {
      return this._GetDeceleration()
    },
    MovingAngle() {
      return e.toDegrees(this._GetMovingAngle())
    },
    VectorX() {
      return this._GetVectorX()
    },
    VectorY() {
      return this._GetVectorY()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Rotate = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Rotate.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Rotate.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._acceleration = this._speed = 0
      this._isEnabled = !0
      a && ((this._speed = e.toRadians(a[0])), (this._acceleration = e.toRadians(a[1])), (this._isEnabled = a[2]))
      this._isEnabled && this._StartTicking()
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        s: this._speed,
        a: this._acceleration,
        e: this._isEnabled
      }
    }
    LoadFromJson(b) {
      this._speed = b.s
      this._acceleration = b.a
      this._SetEnabled(b.e)
    }
    Tick() {
      if (this._isEnabled) {
        var b = this._runtime.GetDt(this._inst)
        if (0 !== b && (0 !== this._acceleration && (this._speed += this._acceleration * b), 0 !== this._speed)) {
          const a = this._inst.GetWorldInfo()
          a.SetAngle(a.GetAngle() + this._speed * b)
          a.SetBboxChanged()
        }
      }
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return e.toDegrees(this._speed)
        case 1:
          return e.toDegrees(this._acceleration)
        case 2:
          return this._isEnabled
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._speed = e.toRadians(a)
          break
        case 1:
          this._acceleration = e.toRadians(a)
          break
        case 2:
          this._SetEnabled(a)
      }
    }
    _SetEnabled(b) {
      ;(this._isEnabled = !!b) ? this._StartTicking() : this._StopTicking()
    }
    GetDebuggerProperties() {
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: [
            {
              name: 'behaviors.rotate.properties.speed.name',
              value: e.toDegrees(this._speed),
              onedit: b => (this._speed = e.toRadians(b))
            },
            {
              name: 'behaviors.rotate.properties.acceleration.name',
              value: e.toDegrees(this._acceleration),
              onedit: b => (this._acceleration = e.toRadians(b))
            },
            {
              name: 'behaviors.rotate.properties.enabled.name',
              value: this._isEnabled,
              onedit: b => this._SetEnabled(b)
            }
          ]
        }
      ]
    }
  }
}
;('use strict')
self.C3.Behaviors.Rotate.Cnds = {
  IsEnabled() {
    return this._isEnabled
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Rotate.Acts = {
    SetSpeed(b) {
      this._speed = e.toRadians(b)
    },
    SetAcceleration(b) {
      this._acceleration = e.toRadians(b)
    },
    SetEnabled(b) {
      this._SetEnabled(b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Rotate.Exps = {
    Speed() {
      return e.toDegrees(this._speed)
    },
    Acceleration() {
      return e.toDegrees(this._acceleration)
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X
  let a = null,
    c = null,
    d = [],
    f = null,
    g = null

  function h(m, r, w) {
    var p = m.GetSavedDataMap()
    const q = r.GetSavedDataMap()
    w
      ? ((p = p.get('Physics_DisabledCollisions')) && p.delete(r.GetSID()), (r = q.get('Physics_DisabledCollisions')) && r.delete(m.GetSID()))
      : ((w = p.get('Physics_DisabledCollisions')), w || ((w = new Set()), p.set('Physics_DisabledCollisions', w)), (p = q.get('Physics_DisabledCollisions')), p || ((p = new Set()), q.set('Physics_DisabledCollisions', p)), w.add(r.GetSID()), p.add(m.GetSID()))
  }
  e.Behaviors.Physics = class extends e.SDKBehaviorBase {
    constructor(m) {
      m.scriptInterfaceClass = self.IPhysicsBehavior
      super(m)
      this._world = null
      this._worldG = 10
      this._worldScale = 0.02
      this._worldManifold = null
      this._lastUpdateTick = -1
      this._steppingMode = 1
      this._velocityIterations = 8
      this._positionIterations = 3
      this._allCollisionsEnabled = !0
      this._runtime.AddLoadPromise(this._LoadBox2DWasm())
    }
    async _LoadBox2DWasm() {
      const m = await this._runtime.GetAssetManager().GetProjectFileUrl('box2d.wasm')
      await new Promise(r => {
        self
          .Box2DWasmModule({
            wasmBinaryFile: m
          })
          .then(w => {
            f = w
            this._InitBox2DWorld()
            r()
          })
      })
    }
    _InitBox2DWorld() {
      const m = this._runtime.GetCollisionEngine()
      a = e.Behaviors.Physics.GetVec2(0, 0)
      c = e.Behaviors.Physics.GetVec2(0, 0)
      this._world = new f.b2World(e.Behaviors.Physics.GetTempVec2A(0, this._worldG), !0)
      var r = new f.JSContactListener()
      r.BeginContact = w => {
        var p = f.wrapPointer(w, f.b2Contact)
        w = e.Behaviors.Physics.Instance.LookupBehInstFromBody(p.GetFixtureA().GetBody())
        p = e.Behaviors.Physics.Instance.LookupBehInstFromBody(p.GetFixtureB().GetBody())
        m.RegisterCollision(w.GetObjectInstance(), p.GetObjectInstance())
      }
      r.EndContact = () => {}
      r.PreSolve = () => {}
      r.PostSolve = () => {}
      this._world.SetContactListener(r)
      r = new f.JSContactFilter()
      r.ShouldCollide = (w, p) => {
        if (this._allCollisionsEnabled) return !0
        w = f.wrapPointer(w, f.b2Fixture)
        p = f.wrapPointer(p, f.b2Fixture)
        w = e.Behaviors.Physics.Instance.LookupBehInstFromBody(w.GetBody())
        p = e.Behaviors.Physics.Instance.LookupBehInstFromBody(p.GetBody())
        w = w.GetObjectInstance().GetObjectClass()
        const q = p.GetObjectInstance().GetObjectClass()
        p = w.GetSID()
        const t = q.GetSID()
        return (w = w.GetSavedDataMap().get('Physics_DisabledCollisions')) && w.has(t) ? !1 : (w = q.GetSavedDataMap().get('Physics_DisabledCollisions')) && w.has(p) ? !1 : !0
      }
      this._world.SetContactFilter(r)
      this._worldManifold = new f.b2WorldManifold()
    }
    Release() {
      super.Release()
    }
    GetBox2D() {
      return f
    }
    GetWorld() {
      return this._world
    }
    GetWorldScale() {
      return this._worldScale
    }
    GetSteppingMode() {
      return this._steppingMode
    }
    SetSteppingMode(m) {
      this._steppingMode = m
    }
    SetLastUpdateTick(m) {
      this._lastUpdateTick = m
    }
    GetLastUpdateTick() {
      return this._lastUpdateTick
    }
    SetVelocityIterations(m) {
      this._velocityIterations = Math.max(m, 1)
    }
    GetVelocityIterations() {
      return this._velocityIterations
    }
    SetPositionIterations(m) {
      this._positionIterations = Math.max(m, 1)
    }
    GetPositionIterations() {
      return this._positionIterations
    }
    SetIterations(m, r) {
      this.SetVelocityIterations(m)
      this.SetPositionIterations(r)
    }
    GetGravity() {
      return this._worldG
    }
    SetGravity(m) {
      m !== this._worldG && (this._world.SetGravity(e.Behaviors.Physics.GetTempVec2A(0, m)), (this._worldG = m), this._WakeUpAllPhysicsBodies())
    }
    _WakeUpAllPhysicsBodies() {
      for (const r of this.GetInstances()) {
        var m = e.Behaviors.Physics.Instance.LookupBehInstFromInst(r)
        m && (m = m.GetBody()) && m.SetAwake(!0)
      }
    }
    DisableShouldCollideFastPath() {
      this._allCollisionsEnabled = !1
    }
    SetCollisionsEnabled(m, r, w) {
      w = !!w
      if (m && r) {
        if (r.IsFamily()) for (const p of r.GetFamilyMembers()) h(m, p, w)
        else h(m, r, w)
        this.DisableShouldCollideFastPath()
      }
    }
    GetWorldManifold() {
      return this._worldManifold
    }
    static GetPhysicsCollisionKey() {
      return 'Physics_DisabledCollisions'
    }
    static GetVec2(m, r) {
      if (d.length) {
        const w = d.pop()
        w.set_x(m)
        w.set_y(r)
        return w
      }
      return new f.b2Vec2(m, r)
    }
    static FreeVec2(m) {
      d.push(m)
    }
    static GetTempVec2A(m, r) {
      a.set_x(m)
      a.set_y(r)
      return a
    }
    static GetTempVec2B(m, r) {
      c.set_x(m)
      c.set_y(r)
      return c
    }
    static CreatePolygonShape(m) {
      const r = new f.b2PolygonShape(),
        w = f._malloc(8 * m.length)
      var p = 0
      for (let q = 0; q < m.length; ++q) (f.HEAPF32[(w + p) >> 2] = m[q].get_x()), (f.HEAPF32[(w + (p + 4)) >> 2] = m[q].get_y()), (p += 8)
      p = f.wrapPointer(w, f.b2Vec2)
      r.Set(p, m.length)
      f._free(w)
      return r
    }
  }
  const k = ['fixed', 'variable']
  self.IPhysicsBehavior = class extends self.IBehavior {
    constructor(m) {
      super(m)
      g = m
    }
    set worldGravity(m) {
      b.RequireFiniteNumber(m)
      g.SetGravity(m)
    }
    get worldGravity() {
      return g.GetGravity()
    }
    set steppingMode(m) {
      m = k.indexOf(m)
      if (0 > m) throw Error('invalid stepping mode')
      g.SetSteppingMode(k[m])
    }
    get steppingMode() {
      return k[g.GetSteppingMode()]
    }
    set velocityIterations(m) {
      b.RequireFiniteNumber(m)
      g.SetVelocityIterations(m)
    }
    get velocityIterations() {
      return g.GetVelocityIterations()
    }
    set positionIterations(m) {
      b.RequireFiniteNumber(m)
      g.SetPositionIterations(m)
    }
    get positionIterations() {
      return g.GetPositionIterations()
    }
    setCollisionsEnabled(m, r, w) {
      const p = g.GetRuntime()
      m = p._UnwrapIObjectClass(m)
      r = p._UnwrapIObjectClass(r)
      g.SetCollisionsEnabled(m, r, !!w)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Physics.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = self.C3X,
    a = self.IBehaviorInstance,
    c = new WeakMap(),
    d = new WeakMap(),
    f = new WeakMap(),
    g = e.Behaviors.Physics.GetTempVec2A,
    h = e.Behaviors.Physics.GetTempVec2B,
    k = e.New(e.Rect),
    m = e.New(e.Quad)
  e.Behaviors.Physics.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(p, q) {
      super(p)
      p = this.GetBehavior()
      const t = this.GetWorldInfo()
      this._box2d = p.GetBox2D()
      this._world = p.GetWorld()
      this._worldScale = p.GetWorldScale()
      this._isImmovable = !1
      this._collisionMask = 0
      this._preventRotation = !1
      this._density = 1
      this._friction = 0.5
      this._restitution = 0.2
      this._linearDamping = 0
      this._angularDamping = 0.01
      this._isBullet = !1
      this._isEnabled = !0
      this._body = null
      this._fixtures = []
      this._myJoints = []
      this._myCreatedJoints = []
      this._joiningMe = new Set()
      this._lastKnownX = t.GetX()
      this._lastKnownY = t.GetY()
      this._lastKnownAngle = t.GetAngle()
      this._lastHeight = this._lastWidth = 0
      this._lastTickOverride = !1
      q && ((this._isImmovable = !!q[0]), (this._collisionMask = q[1]), (this._preventRotation = !!q[2]), (this._density = q[3]), (this._friction = q[4]), (this._restitution = q[5]), (this._linearDamping = q[6]), (this._angularDamping = q[7]), (this._isBullet = !!q[8]), (this._isEnabled = !!q[9]))
      q = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(
        e.Disposable.From(q, 'instancedestroy', x => this._OnInstanceDestroyed(x.instance)),
        e.Disposable.From(q, 'beforeload', () => this._OnBeforeLoad()),
        e.Disposable.From(q, 'afterload', () => this._OnAfterLoad())
      )
      d.set(this._inst, this)
      this._isEnabled && this._StartTicking()
    }
    PostCreate() {
      this._CreateBody()
    }
    Release() {
      this._DestroyMyJoints()
      e.clearArray(this._myCreatedJoints)
      this._joiningMe.clear()
      this._body && (this._DestroyFixtures(), this._world.DestroyBody(this._body), (this._body = null))
      super.Release()
    }
    _CreateFixture(p) {
      if (this._body) return (p = this._body.CreateFixture(p)), this._fixtures.push(p), p
    }
    _DestroyFixtures() {
      if (this._body) {
        for (const p of this._fixtures) this._body.DestroyFixture(p)
        e.clearArray(this._fixtures)
      }
    }
    _GetBoundingQuadExcludingMesh() {
      const p = this.GetWorldInfo()
      return p.HasMesh() ? (p.CalculateBbox(k, m, !1), m) : p.GetBoundingQuad()
    }
    _Destroy(p) {
      this._box2d.destroy(p)
    }
    _CreateBody() {
      if (this._isEnabled) {
        var p = this._box2d.b2FixtureDef,
          q = this._box2d.b2BodyDef,
          t = this.GetWorldInfo()
        if (!this._body) {
          q = new q()
          q.set_type(this._isImmovable ? 0 : 2)
          var x = this._GetBoundingQuadExcludingMesh()
          q.set_position(h(x.midX() * this._worldScale, x.midY() * this._worldScale))
          q.set_angle(t.GetAngle())
          q.set_fixedRotation(this._preventRotation)
          q.set_linearDamping(this._linearDamping)
          q.set_angularDamping(this._angularDamping)
          q.set_bullet(this._isBullet)
          this._body = this._world.CreateBody(q)
          this._Destroy(q)
          c.set(this._body, this)
        }
        this._DestroyFixtures()
        p = new p()
        p.set_density(this._density)
        p.set_friction(this._friction)
        p.set_restitution(this._restitution)
        x = t.HasOwnCollisionPoly()
        q = this._collisionMask
        x || this._inst.HasTilemap() || 0 !== q || (q = 1)
        x = Math.max(Math.abs(t.GetWidth()), 1)
        var v = Math.max(Math.abs(t.GetHeight()), 1)
        0 === q ? (this._inst.HasTilemap() ? this._CreateTilemapFixtures(p) : this._CreatePolygonFixture(p, x, v)) : 1 === q ? this._CreateBoundingBoxFixture(p, x, v) : this._CreateCircleFixture(p, x, v)
        this._lastWidth = t.GetWidth()
        this._lastHeight = t.GetHeight()
        t.SetPhysicsBodyChanged(!1)
        this._Destroy(p)
      }
    }
    _CreateBoundingBoxFixture(p, q, t) {
      const x = new this._box2d.b2PolygonShape()
      x.SetAsBox(q * this._worldScale * 0.5, t * this._worldScale * 0.5)
      p.set_shape(x)
      this._CreateFixture(p)
      this._Destroy(x)
    }
    _CreateCircleFixture(p, q, t) {
      const x = new this._box2d.b2CircleShape()
      x.set_m_radius(Math.min(q, t) * this._worldScale * 0.5)
      p.set_shape(x)
      this._CreateFixture(p)
      this._Destroy(x)
    }
    _CreatePolygonFixture(p, q, t) {
      var x = this.GetWorldInfo(),
        v = 0 > x.GetWidth()
      const u = 0 > x.GetHeight(),
        A = this._worldScale
      var z = x.GetAngle()
      0 !== z && (x.SetAngle(0), x.SetBboxChanged())
      var C = this._GetBoundingQuadExcludingMesh()
      const E = C.midX() - x.GetX()
      C = C.midY() - x.GetY()
      0 !== z && (x.SetAngle(z), x.SetBboxChanged())
      z = x.GetCustomTransformedCollisionPoly(v ? -q : q, u ? -t : t, 0).pointsArr()
      const J = z.length / 2
      x = []
      for (let F = 0; F < J; ++F) x.push(e.Behaviors.Physics.GetVec2(z[2 * F] - E, z[2 * F + 1] - C))
      v !== u && x.reverse()
      v = e.Behaviors.Physics.Separator.Separate(x, q * t)
      for (const F of x) e.Behaviors.Physics.FreeVec2(F)
      if (v.length)
        for (const F of v) {
          for (const I of F) I.set_x(I.get_x() * A), I.set_y(I.get_y() * A)
          q = e.Behaviors.Physics.CreatePolygonShape(F)
          p.set_shape(q)
          this._CreateFixture(p)
          this._Destroy(q)
          for (const I of F) e.Behaviors.Physics.FreeVec2(I)
        }
      else this._CreateBoundingBoxFixture(p, q, t)
    }
    _CreateTilemapFixtures(p) {
      var q = this.GetWorldInfo(),
        t = this._GetBoundingQuadExcludingMesh()
      const x = t.midX() - q.GetX()
      q = t.midY() - q.GetY()
      t = this._worldScale
      const v = e.Behaviors.Physics.GetVec2,
        u = e.Behaviors.Physics.FreeVec2,
        A = []
      this._inst.GetSdkInstance().GetAllCollisionRects(A)
      const z = []
      for (let I = 0, L = A.length; I < L; ++I) {
        var C = A[I],
          E = C.GetRect(),
          J = C.GetPoly()
        if (J) {
          var F = f.get(J)
          if (!F) {
            F = J.pointsArr()
            const N = J.pointCount()
            for (let S = 0; S < N; ++S) z.push(v(F[2 * S], F[2 * S + 1]))
            C = C.GetTileId() & 3758096384
            ;(-2147483648 === C || 1073741824 === C || 536870912 === C || (C & -2147483648 && C & 1073741824 && C & 536870912)) && z.reverse()
            F = e.Behaviors.Physics.Separator.Separate(z, E.width() * E.height())
            f.set(J, F)
            for (const S of z) u(S)
            e.clearArray(z)
          }
          for (let N = 0, S = F.length; N < S; ++N) {
            J = F[N]
            for (let V = 0, U = J.length; V < U; ++V) z.push(v((E.getLeft() + J[V].get_x() - x) * t, (E.getTop() + J[V].get_y() - q) * t))
            J = e.Behaviors.Physics.CreatePolygonShape(z)
            p.set_shape(J)
            this._CreateFixture(p)
            this._Destroy(J)
            for (const V of z) u(V)
            e.clearArray(z)
          }
        } else
          z.push(v((E.getLeft() - x) * t, (E.getTop() - q) * t)),
            z.push(v((E.getRight() - x) * t, (E.getTop() - q) * t)),
            z.push(v((E.getRight() - x) * t, (E.getBottom() - q) * t)),
            z.push(v((E.getLeft() - x) * t, (E.getBottom() - q) * t)),
            (E = e.Behaviors.Physics.CreatePolygonShape(z)),
            p.set_shape(E),
            this._CreateFixture(p),
            this._Destroy(E)
        for (const N of z) u(N)
        e.clearArray(z)
      }
    }
    _DestroyBody() {
      this._body && (this._DestroyMyJoints(), c.delete(this._body), this._DestroyFixtures(), this._world.DestroyBody(this._body), (this._body = null))
    }
    _DestroyMyJoints() {
      for (const p of this._myJoints) this._world.DestroyJoint(p)
      e.clearArray(this._myJoints)
    }
    _RecreateMyJoints() {
      for (const p of this._myCreatedJoints)
        switch (p.type) {
          case 0:
            this._DoCreateDistanceJoint(...p.params)
            break
          case 1:
            this._DoCreateRevoluteJoint(...p.params)
            break
          case 2:
            this._DoCreateLimitedRevoluteJoint(...p.params)
            break
          case 3:
            this._DoCreatePrismaticJoint(...p.params)
        }
    }
    _GetInstImagePoint(p) {
      var q = this.GetWorldInfo()
      return -1 === p ? [q.GetX(), q.GetY()] : 0 === p && this._body ? ((p = this._body.GetPosition()), (q = this._body.GetLocalCenter()), [(p.get_x() + q.get_x()) / this._worldScale, (p.get_y() + q.get_y()) / this._worldScale]) : this._inst.GetImagePoint(p)
    }
    _CreateDistanceJoint(p, q, t, x, v) {
      this._isEnabled &&
        q &&
        q !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(q) &&
        (this._myCreatedJoints.push({
          type: 0,
          params: [p, q.GetUID(), t, x, v]
        }),
        this._DoCreateDistanceJoint(p, q.GetUID(), t, x, v))
    }
    _DoCreateDistanceJoint(p, q, t, x, v) {
      if (this._isEnabled) {
        var u = this._runtime.GetInstanceByUID(q)
        if (u && u !== this._inst && d.has(u)) {
          q = e.Behaviors.Physics.Instance.LookupBehInstFromInst(u)
          q._joiningMe.add(this._inst)
          this._UpdateBodyToMatchInstance(!1)
          q._UpdateBodyToMatchInstance(!1)
          var [A, z] = this._GetInstImagePoint(p),
            [C, E] = u.GetImagePoint(t)
          p = A - C
          t = z - E
          u = this._worldScale
          var J = new this._box2d.b2DistanceJointDef()
          J.Initialize(this._body, q.GetBody(), g(A * u, z * u), h(C * u, E * u))
          J.set_length(Math.hypot(p, t) * u)
          J.set_dampingRatio(x)
          J.set_frequencyHz(v)
          this._myJoints.push(this._world.CreateJoint(J))
          this._Destroy(J)
        }
      }
    }
    _CreateRevoluteJoint(p, q) {
      this._isEnabled &&
        q &&
        q !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(q) &&
        (this._myCreatedJoints.push({
          type: 1,
          params: [p, q.GetUID()]
        }),
        this._DoCreateRevoluteJoint(p, q.GetUID()))
    }
    _DoCreateRevoluteJoint(p, q) {
      if (this._isEnabled && (q = this._runtime.GetInstanceByUID(q)) && q !== this._inst && d.has(q)) {
        q = e.Behaviors.Physics.Instance.LookupBehInstFromInst(q)
        q._joiningMe.add(this._inst)
        this._UpdateBodyToMatchInstance(!1)
        q._UpdateBodyToMatchInstance(!1)
        var [t, x] = this._GetInstImagePoint(p)
        p = this._worldScale
        var v = new this._box2d.b2RevoluteJointDef()
        v.Initialize(this._body, q.GetBody(), g(t * p, x * p))
        this._myJoints.push(this._world.CreateJoint(v))
        this._Destroy(v)
      }
    }
    _CreateLimitedRevoluteJoint(p, q, t, x) {
      this._isEnabled &&
        q &&
        q !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(q) &&
        ((t = e.toDegrees(t)),
        (x = e.toDegrees(x)),
        this._myCreatedJoints.push({
          type: 2,
          params: [p, q.GetUID(), t, x]
        }),
        this._DoCreateLimitedRevoluteJoint(p, q.GetUID(), t, x))
    }
    _DoCreateLimitedRevoluteJoint(p, q, t, x) {
      if (this._isEnabled && (q = this._runtime.GetInstanceByUID(q)) && q !== this._inst && d.has(q)) {
        q = e.Behaviors.Physics.Instance.LookupBehInstFromInst(q)
        q._joiningMe.add(this._inst)
        this._UpdateBodyToMatchInstance(!1)
        q._UpdateBodyToMatchInstance(!1)
        var [v, u] = this._GetInstImagePoint(p)
        p = this._worldScale
        var A = new this._box2d.b2RevoluteJointDef()
        A.Initialize(this._body, q.GetBody(), g(v * p, u * p))
        A.set_enableLimit(!0)
        A.set_lowerAngle(e.toRadians(t))
        A.set_upperAngle(e.toRadians(x))
        this._myJoints.push(this._world.CreateJoint(A))
        this._Destroy(A)
      }
    }
    _CreatePrismaticJoint(p, q, t, x, v, u, A, z, C) {
      this._isEnabled &&
        q &&
        q !== this._inst &&
        e.Behaviors.Physics.Instance.LookupBehInstFromInst(q) &&
        ((t = e.toDegrees(t)),
        (z = e.toDegrees(z)),
        this._myCreatedJoints.push({
          type: 3,
          params: [p, q.GetUID(), t, x, v, u, A, z, C]
        }),
        this._DoCreatePrismaticJoint(p, q.GetUID(), t, x, v, u, A, z, C))
    }
    _DoCreatePrismaticJoint(p, q, t, x, v, u, A, z, C) {
      if (this._isEnabled && (q = this._runtime.GetInstanceByUID(q)) && q !== this._inst && d.has(q)) {
        q = e.Behaviors.Physics.Instance.LookupBehInstFromInst(q)
        q._joiningMe.add(this._inst)
        this._UpdateBodyToMatchInstance(!1)
        q._UpdateBodyToMatchInstance(!1)
        var [E, J] = this._GetInstImagePoint(p)
        t = e.toRadians(t)
        p = Math.cos(t)
        t = Math.sin(t)
        var F = this._worldScale,
          I = new this._box2d.b2PrismaticJointDef()
        I.Initialize(this._body, q.GetBody(), g(E * F, J * F), h(p, t))
        I.set_enableLimit(!!x)
        I.set_lowerTranslation(v * F)
        I.set_upperTranslation(u * F)
        I.set_enableMotor(!!A)
        I.set_motorSpeed(e.toRadians(z))
        I.set_maxMotorForce(C)
        this._myJoints.push(this._world.CreateJoint(I))
        this._Destroy(I)
      }
    }
    _RemoveJoints() {
      this._isEnabled && (this._DestroyMyJoints(), e.clearArray(this._myCreatedJoints), this._joiningMe.clear())
    }
    _OnInstanceDestroyed(p) {
      const q = p.GetUID()
      let t = 0
      for (let x = 0, v = this._myCreatedJoints.length; x < v; ++x)
        (this._myCreatedJoints[t] = this._myCreatedJoints[x]), t < this._myJoints.length && (this._myJoints[t] = this._myJoints[x]), this._myCreatedJoints[x].params[1] === q ? x < this._myJoints.length && this._world.DestroyJoint(this._myJoints[x]) : ++t
      e.truncateArray(this._myCreatedJoints, t)
      t < this._myJoints.length && e.truncateArray(this._myJoints, t)
      this._joiningMe.delete(p)
    }
    GetBody() {
      return this._body
    }
    static LookupBehInstFromBody(p) {
      return c.get(p) || null
    }
    static LookupBehInstFromInst(p) {
      return d.get(p) || null
    }
    SaveToJson() {
      const p = {
        e: this._isEnabled,
        pr: this._preventRotation,
        d: this._density,
        fr: this._friction,
        re: this._restitution,
        ld: this._linearDamping,
        ad: this._angularDamping,
        b: this._isBullet,
        mcj: this._myCreatedJoints
      }
      if (this._isEnabled) {
        const q = this._body.GetLinearVelocity()
        p.vx = q.get_x()
        p.vy = q.get_y()
        p.om = this._body.GetAngularVelocity()
      }
      return p
    }
    _OnBeforeLoad() {
      this._DestroyMyJoints()
      e.clearArray(this._myCreatedJoints)
      this._joiningMe.clear()
    }
    LoadFromJson(p) {
      this._DestroyBody()
      this._isEnabled = p.e
      this._preventRotation = p.pr
      this._density = p.d
      this._friction = p.fr
      this._restitution = p.re
      this._linearDamping = p.ld
      this._angularDamping = p.ad
      this._isBullet = p.b
      this._myCreatedJoints = p.mcj
      const q = this.GetWorldInfo()
      this._lastKnownX = q.GetX()
      this._lastKnownY = q.GetY()
      this._lastKnownAngle = q.GetAngle()
      this._lastWidth = q.GetWidth()
      this._lastHeight = q.GetHeight()
      this._isEnabled && (this._CreateBody(), this._body.SetLinearVelocity(g(p.vx, p.vy)), this._body.SetAngularVelocity(p.om), (0 === p.vx && 0 === p.vy && 0 === p.om) || this._body.SetAwake(!0), (this._myCreatedJoints = p.mcj))
      this._isEnabled ? this._StartTicking() : this._StopTicking()
    }
    _OnAfterLoad() {
      this._isEnabled && this._RecreateMyJoints()
    }
    Tick() {
      if (this._isEnabled) {
        var p = this._runtime,
          q = this.GetBehavior()
        if (0 === q.GetSteppingMode()) var t = p.GetTimeScale() / 60
        else (t = p.GetDt(this._inst)), t > 1 / 30 && (t = 1 / 30)
        var x = p.GetTickCountNoSave()
        if (x > q.GetLastUpdateTick() && 0 < p.GetTimeScale()) {
          p = this._runtime.IsDebug()
          let v = 0
          p && (v = performance.now())
          0 !== t && this._world.Step(t, q.GetVelocityIterations(), q.GetPositionIterations())
          this._world.ClearForces()
          p && self.C3Debugger.AddPhysicsTime(performance.now() - v)
          q.SetLastUpdateTick(x)
        }
        this._UpdateBodyToMatchInstance(!0)
      }
    }
    _UpdateBodyToMatchInstance(p) {
      const q = this._inst.GetWorldInfo()
      var t = this._worldScale
      ;(q.GetWidth() !== this._lastWidth || q.GetHeight() !== this._lastHeight || q.IsPhysicsBodyChanged()) && this._CreateBody()
      var x = this._body,
        v = q.GetX() !== this._lastKnownX || q.GetY() !== this._lastKnownY,
        u = q.GetAngle() !== this._lastKnownAngle
      if (v) {
        var A = this._GetBoundingQuadExcludingMesh()
        const z = A.midX()
        A = A.midY()
        const C = z - this._lastKnownX,
          E = A - this._lastKnownY
        u ? x.SetTransform(g(z * t, A * t), q.GetAngle()) : x.SetTransform(g(z * t, A * t), x.GetAngle())
        p && (x.SetLinearVelocity(g(C, E)), (this._lastTickOverride = !0))
        x.SetAwake(!0)
      } else p && this._lastTickOverride && ((p = this._GetBoundingQuadExcludingMesh()), (this._lastTickOverride = !1), x.SetLinearVelocity(g(0, 0)), x.SetTransform(g(p.midX() * t, p.midY() * t), x.GetAngle()))
      !v && u && (x.SetTransform(x.GetPosition(), q.GetAngle()), x.SetAwake(!0))
      u = x.GetPosition()
      v = u.get_x() / t
      t = u.get_y() / t
      x = x.GetAngle()
      if (v !== q.GetX() || t !== q.GetY() || x !== q.GetAngle()) if ((q.SetXY(v, t), q.SetAngle(x), q.SetBboxChanged(), (t = this._GetBoundingQuadExcludingMesh()), (x = t.midX() - q.GetX()), (t = t.midY() - q.GetY()), 0 !== x || 0 !== t)) q.OffsetXY(-x, -t), q.SetBboxChanged()
      this._lastKnownX = q.GetX()
      this._lastKnownY = q.GetY()
      this._lastKnownAngle = q.GetAngle()
    }
    GetPropertyValueByIndex(p) {
      switch (p) {
        case 2:
          return this._IsPreventRotate()
        case 3:
          return this._GetDensity()
        case 4:
          return this._GetFriction()
        case 5:
          return this._GetElasticity()
        case 6:
          return this._GetLinearDamping()
        case 7:
          return this._GetAngularDamping()
        case 8:
          return this._IsBullet()
        case 9:
          return this._IsEnabled()
      }
    }
    SetPropertyValueByIndex(p, q) {
      switch (p) {
        case 2:
          this._SetPreventRotate(q)
          break
        case 3:
          this._SetDensity(q)
          break
        case 4:
          this._SetFriction(q)
          break
        case 5:
          this._SetElasticity(q)
          break
        case 6:
          this._SetLinearDamping(q)
          break
        case 7:
          this._SetAngularDamping(q)
          break
        case 8:
          this._SetBullet(q)
          break
        case 9:
          this._SetEnabled(q)
      }
    }
    _SetEnabled(p) {
      p = !!p
      this._isEnabled && !p ? (this._DestroyBody(), (this._isEnabled = !1), this._StopTicking()) : !this._isEnabled && p && ((this._isEnabled = !0), this._CreateBody(), this._StartTicking())
    }
    _IsEnabled() {
      return this._isEnabled
    }
    GetDebuggerProperties() {
      const p = [
        {
          name: 'behaviors.physics.properties.enabled.name',
          value: this._IsEnabled(),
          onedit: q => this._SetEnabled(q)
        },
        {
          name: 'behaviors.physics.properties.immovable.name',
          value: this._IsImmovable(),
          onedit: q => this._SetImmovable(q)
        },
        {
          name: 'behaviors.physics.properties.density.name',
          value: this._GetDensity(),
          onedit: q => this._SetDensity(q)
        },
        {
          name: 'behaviors.physics.properties.friction.name',
          value: this._GetFriction(),
          onedit: q => this._SetFriction(q)
        },
        {
          name: 'behaviors.physics.properties.elasticity.name',
          value: this._GetElasticity(),
          onedit: q => this._SetElasticity(q)
        },
        {
          name: 'behaviors.physics.properties.linear-damping.name',
          value: this._GetLinearDamping(),
          onedit: q => this._SetLinearDamping(q)
        },
        {
          name: 'behaviors.physics.properties.angular-damping.name',
          value: this._GetAngularDamping(),
          onedit: q => this._SetAngularDamping(q)
        }
      ]
      this._isEnabled &&
        (p.push({
          name: 'behaviors.physics.debugger.is-sleeping',
          value: this._IsSleeping()
        }),
        p.push({
          name: 'behaviors.physics.debugger.velocity-x',
          value: this._GetVelocityX(),
          onedit: q => this._SetVelocity(q, this._GetVelocityY())
        }),
        p.push({
          name: 'behaviors.physics.debugger.velocity-y',
          value: this._GetVelocityY(),
          onedit: q => this._SetVelocity(this._GetVelocityX(), q)
        }),
        p.push({
          name: 'behaviors.physics.debugger.angular-velocity',
          value: e.toDegrees(this._GetAngularVelocity()),
          onedit: q => this._SetAngularVelocity(e.toRadians(q))
        }),
        p.push({
          name: 'behaviors.physics.debugger.mass',
          value: this._GetMass()
        }))
      return [
        {
          title: '$' + this.GetBehaviorType().GetName(),
          properties: p
        }
      ]
    }
    _ApplyForce(p, q, t) {
      const [x, v] = this._GetInstImagePoint(t)
      this._DoApplyForce(p, q, x, v)
    }
    _ApplyForceToward(p, q, t, x) {
      const [v, u] = this._GetInstImagePoint(x)
      q = e.angleTo(v, u, q, t)
      this._DoApplyForce(Math.cos(q) * p, Math.sin(q) * p, v, u)
    }
    _ApplyForceAtAngle(p, q, t) {
      const [x, v] = this._GetInstImagePoint(t)
      this._DoApplyForce(Math.cos(q) * p, Math.sin(q) * p, x, v)
    }
    _DoApplyForce(p, q, t, x) {
      if (this._isEnabled) {
        var v = this._worldScale
        this._body.ApplyForce(g(p, q), h(t * v, x * v), !0)
      }
    }
    _ApplyImpulse(p, q, t) {
      const [x, v] = this._GetInstImagePoint(t)
      this._DoApplyImpulse(p, q, x, v)
    }
    _ApplyImpulseToward(p, q, t, x) {
      const [v, u] = this._GetInstImagePoint(x)
      q = e.angleTo(v, u, q, t)
      this._DoApplyImpulse(Math.cos(q) * p, Math.sin(q) * p, v, u)
    }
    _ApplyImpulseAtAngle(p, q, t) {
      const [x, v] = this._GetInstImagePoint(t)
      this._DoApplyImpulse(Math.cos(q) * p, Math.sin(q) * p, x, v)
    }
    _DoApplyImpulse(p, q, t, x) {
      if (this._isEnabled) {
        var v = this._worldScale
        this._body.ApplyLinearImpulse(g(p, q), h(t * v, x * v), !0)
        p = this.GetWorldInfo()
        this._lastKnownX = p.GetX()
        this._lastKnownY = p.GetY()
        this._lastTickOverride = !1
      }
    }
    _ApplyTorque(p) {
      this._isEnabled && this._body.ApplyTorque(p, !0)
    }
    _ApplyTorqueToAngle(p, q) {
      q = e.angleClockwise(this.GetWorldInfo().GetAngle(), q) ? -1 : 1
      this._ApplyTorque(p * q)
    }
    _ApplyTorqueToPosition(p, q, t) {
      var x = this.GetWorldInfo()
      q = e.angleTo(x.GetX(), x.GetY(), q, t)
      x = e.angleClockwise(x.GetAngle(), q) ? -1 : 1
      this._ApplyTorque(p * x)
    }
    _SetAngularVelocity(p) {
      this._isEnabled && (this._body.SetAngularVelocity(p), this._body.SetAwake(!0))
    }
    _GetAngularVelocity() {
      return this._isEnabled ? this._body.GetAngularVelocity() : 0
    }
    _SetVelocity(p, q) {
      if (this._isEnabled) {
        var t = this._worldScale
        this._body.SetLinearVelocity(g(p * t, q * t))
        this._body.SetAwake(!0)
        p = this.GetWorldInfo()
        this._lastKnownX = p.GetX()
        this._lastKnownY = p.GetY()
        this._lastTickOverride = !1
      }
    }
    _GetVelocity() {
      if (!this._isEnabled) return [0, 0]
      const p = this._worldScale,
        q = this._body.GetLinearVelocity()
      return [q.get_x() / p, q.get_y() / p]
    }
    _GetVelocityX() {
      return this._isEnabled ? this._body.GetLinearVelocity().get_x() / this._worldScale : 0
    }
    _GetVelocityY() {
      return this._isEnabled ? this._body.GetLinearVelocity().get_y() / this._worldScale : 0
    }
    _SetDensity(p) {
      if (this._isEnabled && this._density !== p) {
        this._density = p
        for (const q of this._fixtures) q.SetDensity(p)
        this._body.ResetMassData()
      }
    }
    _GetDensity() {
      return this._isEnabled ? this._density : 0
    }
    _SetFriction(p) {
      if (this._isEnabled && this._friction !== p) {
        this._friction = p
        for (var q of this._fixtures) q.SetFriction(p)
        for (p = this._body.GetContactList(); this._box2d.getPointer(p); p = p.get_next()) (q = p.get_contact()) && q.ResetFriction()
      }
    }
    _GetFriction() {
      return this._isEnabled ? this._friction : 0
    }
    _SetElasticity(p) {
      if (this._isEnabled && this._restitution !== p) {
        this._restitution = p
        for (const q of this._fixtures) q.SetRestitution(p)
      }
    }
    _GetElasticity() {
      return this._isEnabled ? this._restitution : 0
    }
    _SetLinearDamping(p) {
      this._isEnabled && this._linearDamping !== p && ((this._linearDamping = p), this._body.SetLinearDamping(p))
    }
    _GetLinearDamping() {
      return this._isEnabled ? this._linearDamping : 0
    }
    _SetAngularDamping(p) {
      this._isEnabled && this._angularDamping !== p && ((this._angularDamping = p), this._body.SetAngularDamping(p))
    }
    _GetAngularDamping() {
      return this._isEnabled ? this._angularDamping : 0
    }
    _SetImmovable(p) {
      this._isEnabled && ((p = !!p), this._isImmovable !== p && ((this._isImmovable = p), this._body.SetType(this._isImmovable ? 0 : 2), this._body.SetAwake(!0)))
    }
    _IsImmovable() {
      return this._isImmovable
    }
    _SetPreventRotate(p) {
      this._isEnabled && ((p = !!p), this._preventRotation !== p && ((this._preventRotation = p), this._body.SetFixedRotation(this._preventRotation), this._body.SetAngularVelocity(0), this._body.SetAwake(!0)))
    }
    _IsPreventRotate() {
      return this._preventRotation
    }
    _SetBullet(p) {
      this._isEnabled && ((p = !!p), this._isBullet !== p && ((this._isBullet = p), this._body.SetBullet(this._isBullet), this._body.SetAwake(!0)))
    }
    _IsBullet() {
      return this._isBullet
    }
    _GetMass() {
      return this._isEnabled ? this._body.GetMass() / this._worldScale : 0
    }
    _GetCenterOfMassX() {
      return this._isEnabled ? (this._body.GetPosition().get_x() + this._body.GetLocalCenter().get_x()) / this._worldScale : 0
    }
    _GetCenterOfMassY() {
      return this._isEnabled ? (this._body.GetPosition().get_y() + this._body.GetLocalCenter().get_y()) / this._worldScale : 0
    }
    _GetCenterOfMass() {
      if (!this._isEnabled) return [0, 0]
      const p = this._body.GetPosition(),
        q = this._body.GetLocalCenter(),
        t = this._worldScale
      return [(p.get_x() + q.get_x()) / t, (p.get_y() + q.get_y()) / t]
    }
    _IsSleeping() {
      return this._isEnabled ? !this._body.IsAwake() : !1
    }
    _GetContactCount() {
      if (!this._isEnabled) return 0
      let p = 0
      for (let t = this._body.GetContactList(); this._box2d.getPointer(t); t = t.get_next()) {
        var q = t.get_contact()
        q && ((q = q.GetManifold().get_pointCount()), (p += q))
      }
      return p
    }
    _GetContactPositionAt(p) {
      p = Math.floor(p)
      if (!this._isEnabled) return [0, 0]
      var q = 0
      for (let x = this._body.GetContactList(); this._box2d.getPointer(x); x = x.get_next()) {
        var t = x.get_contact()
        if (!t) continue
        const v = t.GetManifold().get_pointCount()
        if (p >= q && p < q + v) return (p -= q), (q = this.GetBehavior().GetWorldManifold()), t.GetWorldManifold(q), (t = q.get_points(p)), [t.get_x() / this._worldScale, t.get_y() / this._worldScale]
        q += v
      }
      return [0, 0]
    }
    GetScriptInterfaceClass() {
      return self.IPhysicsBehaviorInstance
    }
  }
  const r = new WeakMap()

  function w(p, q) {
    return r.get(p).GetRuntime()._UnwrapIWorldInstance(q)
  }
  self.IPhysicsBehaviorInstance = class extends a {
    constructor() {
      super()
      r.set(this, a._GetInitInst().GetSdkInstance())
    }
    get isEnabled() {
      return r.get(this)._IsEnabled()
    }
    set isEnabled(p) {
      r.get(this)._SetEnabled(p)
    }
    applyForce(p, q, t = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._ApplyForce(p, q, t)
    }
    applyForceTowardPosition(p, q, t, x = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      b.RequireFiniteNumber(t)
      r.get(this)._ApplyForceToward(p, q, t, x)
    }
    applyForceAtAngle(p, q, t = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._ApplyForceAtAngle(p, q, t)
    }
    applyImpulse(p, q, t = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._ApplyImpulse(p, q, t)
    }
    applyImpulseTowardPosition(p, q, t, x = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      b.RequireFiniteNumber(t)
      r.get(this)._ApplyImpulseToward(p, q, t, x)
    }
    applyImpulseAtAngle(p, q, t = 0) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._ApplyImpulseAtAngle(p, q, t)
    }
    applyTorque(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._ApplyTorque(p)
    }
    applyTorqueToAngle(p, q) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._ApplyTorqueToAngle(p, q)
    }
    applyTorqueToPosition(p, q, t) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      b.RequireFiniteNumber(t)
      r.get(this)._ApplyTorqueToPosition(p, q, t)
    }
    set angularVelocity(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetAngularVelocity(p)
    }
    get angularVelocity() {
      return r.get(this)._GetAngularVelocity()
    }
    setVelocity(p, q) {
      b.RequireFiniteNumber(p)
      b.RequireFiniteNumber(q)
      r.get(this)._SetVelocity(p, q)
    }
    getVelocityX() {
      return r.get(this)._GetVelocityX()
    }
    getVelocityY() {
      return r.get(this)._GetVelocityY()
    }
    getVelocity() {
      return r.get(this)._GetVelocity()
    }
    set density(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetDensity(p)
    }
    get density() {
      return r.get(this)._GetDensity()
    }
    set friction(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetFriction(p)
    }
    get friction() {
      return r.get(this)._GetFriction()
    }
    set elasticity(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetElasticity(p)
    }
    get elasticity() {
      return r.get(this)._GetElasticity()
    }
    set linearDamping(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetLinearDamping(p)
    }
    get linearDamping() {
      return r.get(this)._GetLinearDamping()
    }
    set angularDamping(p) {
      b.RequireFiniteNumber(p)
      r.get(this)._SetAngularDamping(p)
    }
    get angularDamping() {
      return r.get(this)._GetAngularDamping()
    }
    set isImmovable(p) {
      r.get(this)._SetImmovable(p)
    }
    get isImmovable() {
      return r.get(this)._IsImmovable()
    }
    set isPreventRotation(p) {
      r.get(this)._SetPreventRotate(p)
    }
    get isPreventRotation() {
      return r.get(this)._IsPreventRotate()
    }
    set isBullet(p) {
      r.get(this)._SetBullet(p)
    }
    get isBullet() {
      return r.get(this)._IsBullet()
    }
    get mass() {
      return r.get(this)._GetMass()
    }
    getCenterOfMassX() {
      return r.get(this)._GetCenterOfMassX()
    }
    getCenterOfMassY() {
      return r.get(this)._GetCenterOfMassY()
    }
    getCenterOfMass() {
      return r.get(this)._GetCenterOfMass()
    }
    getContactCount() {
      return r.get(this)._GetContactCount()
    }
    getContactX(p) {
      b.RequireFiniteNumber(p)
      return r.get(this)._GetContactPositionAt(p)[0]
    }
    getContactY(p) {
      b.RequireFiniteNumber(p)
      return r.get(this)._GetContactPositionAt(p)[1]
    }
    getContact(p) {
      b.RequireFiniteNumber(p)
      return r.get(this)._GetContactPositionAt(p)
    }
    get isSleeping() {
      return r.get(this)._IsSleeping()
    }
    createDistanceJoint(p, q, t, x, v) {
      b.RequireFiniteNumber(x)
      b.RequireFiniteNumber(v)
      q = w(this, q)
      r.get(this)._CreateDistanceJoint(p, q, t, x, v)
    }
    createRevoluteJoint(p, q) {
      q = w(this, q)
      r.get(this)._CreateRevoluteJoint(p, q)
    }
    createLimitedRevoluteJoint(p, q, t, x) {
      b.RequireFiniteNumber(t)
      b.RequireFiniteNumber(x)
      q = w(this, q)
      r.get(this)._CreateLimitedRevoluteJoint(p, q, t, x)
    }
    createPrismaticJoint(p, q, t, x, v, u, A, z, C) {
      q = w(this, q)
      r.get(this)._CreatePrismaticJoint(p, q, t, x, v, u, A, z, C)
    }
    removeAllJoints() {
      r.get(this)._RemoveJoints()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Physics.Cnds = {
    IsSleeping() {
      return this._IsSleeping()
    },
    CompareVelocity(b, a, c) {
      if (!this._isEnabled) return !1
      if (0 === b) b = this._GetVelocityX()
      else if (1 === b) b = this._GetVelocityY()
      else {
        const [d, f] = this._GetVelocity()
        b = Math.hypot(d, f)
      }
      return e.compare(b, a, c)
    },
    CompareAngularVelocity(b, a) {
      if (!this._isEnabled) return !1
      const c = e.toDegrees(this._GetAngularVelocity())
      return e.compare(c, b, a)
    },
    CompareMass(b, a) {
      if (!this._isEnabled) return !1
      const c = this._GetMass()
      return e.compare(c, b, a)
    },
    IsEnabled() {
      return this._IsEnabled()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Physics.Acts = {
    ApplyForce(b, a, c) {
      this._ApplyForce(b, a, c)
    },
    ApplyForceToward(b, a, c, d) {
      this._ApplyForceToward(b, a, c, d)
    },
    ApplyForceAtAngle(b, a, c) {
      this._ApplyForceAtAngle(b, e.toRadians(a), c)
    },
    ApplyImpulse(b, a, c) {
      this._ApplyImpulse(b, a, c)
    },
    ApplyImpulseToward(b, a, c, d) {
      this._ApplyImpulseToward(b, a, c, d)
    },
    ApplyImpulseAtAngle(b, a, c) {
      this._ApplyImpulseAtAngle(b, e.toRadians(a), c)
    },
    ApplyTorque(b) {
      this._ApplyTorque(e.toRadians(b))
    },
    ApplyTorqueToAngle(b, a) {
      this._ApplyTorqueToAngle(e.toRadians(b), e.toRadians(a))
    },
    ApplyTorqueToPosition(b, a, c) {
      this._ApplyTorqueToPosition(e.toRadians(b), a, c)
    },
    SetAngularVelocity(b) {
      this._SetAngularVelocity(e.toRadians(b))
    },
    CreateDistanceJoint(b, a, c, d, f) {
      a && ((a = a.GetFirstPicked(this._inst)), this._CreateDistanceJoint(b, a, c, d, f))
    },
    CreateRevoluteJoint(b, a) {
      a && ((a = a.GetFirstPicked(this._inst)), this._CreateRevoluteJoint(b, a))
    },
    CreateLimitedRevoluteJoint(b, a, c, d) {
      a && ((a = a.GetFirstPicked(this._inst)), this._CreateLimitedRevoluteJoint(b, a, e.toRadians(c), e.toRadians(d)))
    },
    CreatePrismaticJoint(b, a, c, d, f, g, h, k, m) {
      a && ((a = a.GetFirstPicked(this._inst)), this._CreatePrismaticJoint(b, a, e.toRadians(c), d, f, g, h, e.toRadians(k), m))
    },
    RemoveJoints() {
      this._RemoveJoints()
    },
    SetWorldGravity(b) {
      this.GetBehavior().SetGravity(b)
    },
    SetSteppingMode(b) {
      this.GetBehavior().SetSteppingMode(b)
    },
    SetIterations(b, a) {
      this.GetBehavior().SetIterations(b, a)
    },
    SetVelocity(b, a) {
      this._SetVelocity(b, a)
    },
    SetDensity(b) {
      this._SetDensity(b)
    },
    SetFriction(b) {
      this._SetFriction(b)
    },
    SetElasticity(b) {
      this._SetElasticity(b)
    },
    SetLinearDamping(b) {
      this._SetLinearDamping(b)
    },
    SetAngularDamping(b) {
      this._SetAngularDamping(b)
    },
    SetImmovable(b) {
      this._SetImmovable(b)
    },
    EnableCollisions(b, a) {
      this.GetBehavior().SetCollisionsEnabled(this.GetObjectClass(), b, 0 !== a)
    },
    SetPreventRotate(b) {
      this._SetPreventRotate(0 !== b)
    },
    SetBullet(b) {
      this._SetBullet(0 !== b)
    },
    SetEnabled(b) {
      this._SetEnabled(0 !== b)
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Physics.Exps = {
    VelocityX() {
      return this._GetVelocityX()
    },
    VelocityY() {
      return this._GetVelocityY()
    },
    AngularVelocity() {
      return e.toDegrees(this._GetAngularVelocity())
    },
    Mass() {
      return this._GetMass()
    },
    CenterOfMassX() {
      return this._GetCenterOfMassX()
    },
    CenterOfMassY() {
      return this._GetCenterOfMassY()
    },
    Density() {
      return this._GetDensity()
    },
    Friction() {
      return this._GetFriction()
    },
    Elasticity() {
      return this._GetElasticity()
    },
    LinearDamping() {
      return this._GetLinearDamping()
    },
    AngularDamping() {
      return this._GetAngularDamping()
    },
    ContactCount() {
      return this._GetContactCount()
    },
    ContactXAt(b) {
      return this._GetContactPositionAt(b)[0]
    },
    ContactYAt(b) {
      return this._GetContactPositionAt(b)[1]
    }
  }
}
{
  ;('use strict')
  const e = self.C3,
    b = {}
  e.Behaviors.Physics.Separator = b
  const a = e.Behaviors.Physics.GetVec2,
    c = e.Behaviors.Physics.FreeVec2

  function d(h) {
    return a(h.get_x(), h.get_y())
  }
  b.det = function (h, k, m, r, w, p) {
    return h * r + m * p + w * k - k * m - r * w - p * h
  }
  b.hitRay = function (h, k, m, r, w, p, q, t) {
    var x = m - h,
      v = r - k,
      u = q - w
    const A = t - p
    u = (u * (p - k) - A * (w - h)) / (v * u - x * A)
    x = h + u * x
    v = k + u * v
    h = b.isOnSegment(m, r, h, k, x, v)
    w = b.isOnSegment(x, v, w, p, q, t)
    return h && w ? a(x, v) : null
  }
  b.isOnSegment = function (h, k, m, r, w, p) {
    return ((m + 0.1 >= h && h >= w - 0.1) || (m - 0.1 <= h && h <= w + 0.1)) && ((r + 0.1 >= k && k >= p - 0.1) || (r - 0.1 <= k && k <= p + 0.1)) && b.isOnLine(h, k, m, r, w, p)
  }
  b.isOnLine = function (h, k, m, r, w, p) {
    return 0.1 < Math.abs(w - m) ? 0.1 > Math.abs(((p - r) / (w - m)) * (h - m) + r - k) : 0.1 > Math.abs(h - m)
  }
  b.pointsMatch = function (h, k, m, r) {
    return 0.1 > Math.abs(m - h) && 0.1 > Math.abs(r - k)
  }
  b.Separate = function (h, k) {
    h = b.calcShapes(h)
    let m = []
    for (let r = 0, w = h.length; r < w; ++r) {
      const p = h[r],
        q = []
      let t = 0
      for (let x = 0, v = p.length; x < v; ++x) {
        const u = p[x],
          A = p[(x + 1) % v]
        t += u.get_x() * A.get_y() - u.get_y() * A.get_x()
        q.push(a(u.get_x(), u.get_y()))
      }
      t = Math.abs(t / 2)
      if (t >= 0.001 * k) m.push(q)
      else for (let x = 0, v = q.length; x < v; x++) c(q[x])
    }
    return (m = f(m))
  }
  b.calcShapes = function (h) {
    var k
    let m
    var r
    let w
    let p, q, t, x
    let v
    var u = 0
    let A = 0,
      z,
      C = [],
      E = []
    for (E.push(h); E.length; ) {
      h = E[0]
      m = h.length
      z = !0
      for (k = 0; k < m; k++) {
        p = k
        q = k < m - 1 ? k + 1 : k + 1 - m
        var J = k < m - 2 ? k + 2 : k + 2 - m
        t = h[p]
        x = h[q]
        J = h[J]
        J = b.det(t.get_x(), t.get_y(), x.get_x(), x.get_y(), J.get_x(), J.get_y())
        if (0 > J) {
          z = !1
          var F = 1e9
          for (r = 0; r < m; r++)
            if (r !== p && r !== q) {
              k = r
              J = r < m - 1 ? r + 1 : 0
              var I = h[k]
              var L = h[J]
              if ((I = b.hitRay(t.get_x(), t.get_y(), x.get_x(), x.get_y(), I.get_x(), I.get_y(), L.get_x(), L.get_y()))) (L = x.get_x() - I.get_x()), (w = x.get_y() - I.get_y()), (L = L * L + w * w), L < F ? ((A = k), (u = J), (v = I), (F = L)) : c(I)
            }
          if (1e9 === F) return []
          r = []
          F = []
          k = A
          J = u
          I = h[k]
          L = h[J]
          u = !1
          b.pointsMatch(v.get_x(), v.get_y(), L.get_x(), L.get_y()) || (r.push(v), (u = !0))
          b.pointsMatch(v.get_x(), v.get_y(), I.get_x(), I.get_y()) || (F.push(v), (u = !0))
          u || c(v)
          A = -1
          for (u = p; ; ) {
            if (u !== J) r.push(h[u])
            else {
              if (0 > A || A >= m) return []
              b.isOnSegment(L.get_x(), L.get_y(), h[A].get_x(), h[A].get_y(), t.get_x(), t.get_y()) || r.push(h[u])
              break
            }
            A = u
            0 > u - 1 ? (u = m - 1) : u--
          }
          r.reverse()
          A = -1
          for (u = q; ; ) {
            if (u !== k) F.push(h[u])
            else {
              if (0 > A || A >= m) return []
              u !== k || b.isOnSegment(I.get_x(), I.get_y(), h[A].get_x(), h[A].get_y(), x.get_x(), x.get_y()) || F.push(h[u])
              break
            }
            A = u
            u + 1 > m - 1 ? (u = 0) : u++
          }
          E.push(r, F)
          E.shift()
          break
        }
      }
      z && C.push(E.shift())
    }
    return C
  }

  function f(h) {
    const k = []
    for (const m of h) 8 >= m.length ? k.push(m) : k.push.apply(k, g(m))
    return k
  }

  function g(h) {
    const k = []
    k.push(h.splice(0, 8))
    const m = k[0][0]
    let r = k[0][7]
    for (; h.length; ) {
      const w = h.splice(0, Math.min(h.length, 6))
      let p = w[w.length - 1]
      w.push(d(m))
      w.push(d(r))
      k.push(w)
      r = p
    }
    return k
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Anchor = class extends e.SDKBehaviorBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Anchor.Type = class extends e.SDKBehaviorTypeBase {
    constructor(b) {
      super(b)
    }
    Release() {
      super.Release()
    }
    OnCreate() {}
  }
}
{
  ;('use strict')
  const e = self.C3
  e.Behaviors.Anchor.Instance = class extends e.SDKBehaviorInstanceBase {
    constructor(b, a) {
      super(b)
      this._anchorTop = this._anchorLeft = 2
      this._anchorBottom = this._anchorRight = 0
      this._isEnabled = !0
      b = this._inst.GetWorldInfo().GetBoundingBox()
      this._xLeft = b.getLeft()
      this._yTop = b.getTop()
      this._xRight = this._runtime.GetOriginalViewportWidth() - b.getLeft()
      this._yBottom = this._runtime.GetOriginalViewportHeight() - b.getTop()
      this._rDiff = this._runtime.GetOriginalViewportWidth() - b.getRight()
      this._bDiff = this._runtime.GetOriginalViewportHeight() - b.getBottom()
      a && ((this._anchorLeft = a[0]), (this._anchorTop = a[1]), (this._anchorRight = a[2]), (this._anchorBottom = a[3]), (this._isEnabled = !!a[4]))
      a = this._runtime.Dispatcher()
      this._disposables = new e.CompositeDisposable(e.Disposable.From(a, 'layoutchange', () => this._OnLayoutChange()))
      this._isEnabled && this._StartTicking()
    }
    Release() {
      super.Release()
    }
    SaveToJson() {
      return {
        xl: this._xLeft,
        yt: this._yTop,
        xr: this._xRight,
        yb: this._yBottom,
        rd: this._rDiff,
        bd: this._bDiff,
        al: this._anchorLeft,
        at: this._anchorTop,
        ar: this._anchorRight,
        ab: this._anchorBottom,
        e: this._isEnabled
      }
    }
    LoadFromJson(b) {
      this._xLeft = b.xl
      this._yTop = b.yt
      this._xRight = b.xr
      this._yBottom = b.yb
      this._rDiff = b.rd
      this._bDiff = b.bd
      this._anchorLeft = b.al
      this._anchorTop = b.at
      this._anchorRight = b.ar
      this._anchorBottom = b.ab
      ;(this._isEnabled = b.e) ? this._StartTicking() : this._StopTicking()
    }
    _UpdatePosition() {
      if (this._isEnabled) {
        var b = this._inst.GetWorldInfo(),
          a = b.GetLayer().GetViewport()
        if (0 === this._anchorLeft) {
          var c = a.getLeft() + this._xLeft - b.GetBoundingBox().getLeft()
          0 !== c && (b.OffsetX(c), b.SetBboxChanged())
        } else 1 === this._anchorLeft && ((c = a.getRight() - this._xRight - b.GetBoundingBox().getLeft()), 0 !== c && (b.OffsetX(c), b.SetBboxChanged()))
        0 === this._anchorTop ? ((c = a.getTop() + this._yTop - b.GetBoundingBox().getTop()), 0 !== c && (b.OffsetY(c), b.SetBboxChanged())) : 1 === this._anchorTop && ((c = a.getBottom() - this._yBottom - b.GetBoundingBox().getTop()), 0 !== c && (b.OffsetY(c), b.SetBboxChanged()))
        1 === this._anchorRight && ((c = a.getRight() - this._rDiff - b.GetBoundingBox().getRight()), 0 !== c && (b.OffsetX(b.GetOriginX() * c), b.SetWidth(Math.max(b.GetWidth() + c), 0), b.SetBboxChanged(), (this._rDiff = a.getRight() - b.GetBoundingBox().getRight())))
        1 === this._anchorBottom && ((c = a.getBottom() - this._bDiff - b.GetBoundingBox().getBottom()), 0 !== c && (b.OffsetY(b.GetOriginY() * c), b.SetHeight(Math.max(b.GetHeight() + c, 0)), b.SetBboxChanged(), (this._bDiff = a.getBottom() - b.GetBoundingBox().getBottom())))
      }
    }
    Tick() {
      this._UpdatePosition()
    }
    _OnLayoutChange() {
      this._UpdatePosition()
    }
    GetPropertyValueByIndex(b) {
      switch (b) {
        case 0:
          return this._anchorLeft
        case 1:
          return this._anchorTop
        case 2:
          return this._anchorRight
        case 3:
          return this._anchorBottom
        case 4:
          return this._isEnabled
      }
    }
    SetPropertyValueByIndex(b, a) {
      switch (b) {
        case 0:
          this._anchorLeft = a
          break
        case 1:
          this._anchorTop = a
          break
        case 2:
          this._anchorRight = a
          break
        case 3:
          this._anchorBottom = a
          break
        case 4:
          ;(this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
      }
    }
  }
}
;('use strict')
self.C3.Behaviors.Anchor.Cnds = {
  IsEnabled() {
    return this._isEnabled
  }
}
;('use strict')
self.C3.Behaviors.Anchor.Acts = {
  SetEnabled(e) {
    this._isEnabled && 0 === e
      ? ((this._isEnabled = !1), this._StopTicking())
      : this._isEnabled ||
        0 === e ||
        ((e = this._inst.GetWorldInfo().GetBoundingBox()),
        (this._xLeft = e.getLeft()),
        (this._yTop = e.getTop()),
        (this._xRight = this._runtime.GetOriginalViewportWidth() - e.getLeft()),
        (this._yBottom = this._runtime.GetOriginalViewportHeight() - e.getTop()),
        (this._rDiff = this._runtime.GetOriginalViewportWidth() - e.getRight()),
        (this._bDiff = this._runtime.GetOriginalViewportHeight() - e.getBottom()),
        (this._isEnabled = !0),
        this._StartTicking())
  }
}
;('use strict')
self.C3.Behaviors.Anchor.Exps = {}
{
  const e = self.C3
  self.C3_GetObjectRefTable = function () {
    return [
      e.Plugins.Text,
      e.Plugins.Sprite,
      e.Behaviors.Tween,
      e.Plugins.Spritefont2,
      e.Plugins.Dictionary,
      e.Plugins.Audio,
      e.Plugins.Browser,
      e.Plugins.LocalStorage,
      e.Plugins.NodeWebkit,
      e.Behaviors.Bullet,
      e.Behaviors.solid,
      e.Behaviors.Sin,
      e.Behaviors.Orbit,
      e.Plugins.Particles,
      e.Behaviors.Pin,
      e.Plugins.Tilemap,
      e.Plugins.gamepad,
      e.Plugins.Keyboard,
      e.Plugins.Mouse,
      e.Plugins.Touch,
      e.Behaviors.Platform,
      e.Behaviors.Timer,
      e.Behaviors.Flash,
      e.Behaviors.scrollto,
      e.Plugins.TiledBg,
      e.Behaviors.MoveTo,
      e.Behaviors.LOS,
      e.Plugins.Timeline,
      e.Behaviors.jumpthru,
      e.Plugins.PlatformInfo,
      e.Plugins.AJAX,
      e.Plugins.Arr,
      e.Plugins.sliderbar,
      e.Behaviors.Turret,
      e.Behaviors.EightDir,
      e.Behaviors.Rotate,
      e.Behaviors.Physics,
      e.Behaviors.Anchor,
      e.Plugins.System.Cnds.IsGroupActive,
      e.Plugins.Sprite.Cnds.OnCreated,
      e.Plugins.Sprite.Acts.SetSize,
      e.Plugins.Sprite.Acts.SetPos,
      e.Plugins.Sprite.Exps.X,
      e.Plugins.Sprite.Exps.Y,
      e.Plugins.Sprite.Acts.AddChild,
      e.Plugins.Sprite.Acts.MoveToLayer,
      e.Plugins.Sprite.Cnds.CompareInstanceVar,
      e.Plugins.Sprite.Exps.ImagePointX,
      e.Plugins.Sprite.Exps.ImagePointY,
      e.Plugins.Sprite.Cnds.IsOverlapping,
      e.Behaviors.MoveTo.Acts.MoveToObject,
      e.Behaviors.Platform.Acts.SetEnabled,
      e.Behaviors.scrollto.Acts.SetEnabled,
      e.Plugins.Keyboard.Cnds.OnKey,
      e.Plugins.gamepad.Cnds.OnButtonDown,
      e.Plugins.System.Cnds.CompareVar,
      e.Plugins.System.Acts.CreateObject,
      e.Plugins.Audio.Acts.Play,
      e.Plugins.Sprite.Acts.SetVisible,
      e.Plugins.Sprite.Acts.SetInstanceVar,
      e.Plugins.System.Acts.AddVar,
      e.Plugins.Sprite.Cnds.IsBoolInstanceVarSet,
      e.Behaviors.Platform.Acts.SetIgnoreInput,
      e.Behaviors.Platform.Acts.SetGravityAngle,
      e.Plugins.System.Exps.layoutangle,
      e.Behaviors.Platform.Acts.SetGravity,
      e.Behaviors.Platform.Acts.SetMaxFallSpeed,
      e.Behaviors.Platform.Cnds.IsOnFloor,
      e.Behaviors.Timer.Acts.StartTimer,
      e.Behaviors.Platform.Acts.SetDeceleration,
      e.Behaviors.Platform.Acts.SetMaxSpeed,
      e.Plugins.System.Cnds.TriggerOnce,
      e.Plugins.Browser.Acts.ConsoleLog,
      e.Behaviors.Platform.Cnds.IsByWall,
      e.Behaviors.Platform.Acts.SimulateControl,
      e.Behaviors.Platform.Acts.SetVectorX,
      e.Behaviors.Platform.Exps.VectorX,
      e.Plugins.Sprite.Cnds.IsOverlappingOffset,
      e.Behaviors.Platform.Cnds.IsFalling,
      e.Behaviors.Tween.Acts.TweenTwoProperties,
      e.Plugins.Sprite.Acts.RotateTowardAngle,
      e.Behaviors.Platform.Acts.SetVectorY,
      e.Plugins.Sprite.Acts.RotateCounterclockwise,
      e.Plugins.Sprite.Acts.RotateClockwise,
      e.Plugins.Sprite.Acts.SetBoolInstanceVar,
      e.Plugins.Audio.Acts.FadeVolume,
      e.Plugins.TiledBg.Cnds.CompareInstanceVar,
      e.Plugins.TiledBg.Cnds.IsBoolInstanceVarSet,
      e.Plugins.Sprite.Acts.SetOpacity,
      e.Plugins.System.Acts.SubVar,
      e.Behaviors.scrollto.Acts.Shake,
      e.Plugins.System.Acts.Wait,
      e.Plugins.System.Acts.SetTimescale,
      e.Plugins.System.Exps.timescale,
      e.Behaviors.Tween.Cnds.IsPlaying,
      e.Plugins.System.Acts.SetLayerOpacity,
      e.Behaviors.Tween.Exps.Value,
      e.Behaviors.Tween.Cnds.OnTweensFinished,
      e.Plugins.System.Acts.GoToLayout,
      e.Plugins.Sprite.Cnds.OnCollision,
      e.Plugins.System.Acts.SetVar,
      e.Plugins.Sprite.Acts.SetAnim,
      e.Plugins.System.Cnds.PickByComparison,
      e.Plugins.Sprite.Acts.SetCollisions,
      e.Behaviors.Tween.Acts.TweenOneProperty,
      e.Plugins.Touch.Cnds.OnTouchObject,
      e.Behaviors.Timer.Cnds.IsTimerRunning,
      e.Plugins.System.Cnds.Compare,
      e.Behaviors.Timer.Exps.CurrentTime,
      e.Plugins.Keyboard.Cnds.IsKeyDown,
      e.Plugins.gamepad.Cnds.IsButtonDown,
      e.Plugins.gamepad.Cnds.CompareAxis,
      e.Plugins.Touch.Cnds.IsTouchingObject,
      e.Behaviors.Platform.Exps.VectorY,
      e.Plugins.System.Exps.dt,
      e.Plugins.Sprite.Acts.SetHeight,
      e.Plugins.Sprite.Exps.Height,
      e.Behaviors.Timer.Acts.StopTimer,
      e.Behaviors.Tween.Acts.TweenValue,
      e.Plugins.Sprite.Acts.SetAngle,
      e.Behaviors.Platform.Cnds.OnLand,
      e.Behaviors.Tween.Acts.StopTweens,
      e.Plugins.Sprite.Cnds.OnAnimFinished,
      e.Plugins.Sprite.Acts.Spawn,
      e.Plugins.Sprite.Acts.SubInstanceVar,
      e.Behaviors.LOS.Acts.SetCone,
      e.Behaviors.LOS.Acts.SetRange,
      e.Plugins.Sprite.Acts.SetEffectEnabled,
      e.Behaviors.Sin.Acts.SetEnabled,
      e.Plugins.TiledBg.Acts.SetBoolInstanceVar,
      e.Plugins.System.Acts.WaitForPreviousActions,
      e.Behaviors.solid.Acts.SetEnabled,
      e.Plugins.TiledBg.Acts.SetEffectParam,
      e.Behaviors.Rotate.Acts.SetSpeed,
      e.Plugins.System.Exps.choose,
      e.Behaviors.Rotate.Acts.SetEnabled,
      e.Plugins.System.Acts.ToggleBoolVar,
      e.Plugins.System.Cnds.OnLayoutStart,
      e.Plugins.Particles.Acts.SetPosToObject,
      e.Behaviors.Platform.Cnds.CompareSpeed,
      e.Plugins.Particles.Acts.SetSpraying,
      e.Plugins.Particles.Acts.SetVisible,
      e.Plugins.Particles.Cnds.OnCreated,
      e.Plugins.Particles.Acts.SetAngle,
      e.Plugins.Particles.Cnds.IsOnScreen,
      e.Behaviors.Flash.Acts.Flash,
      e.Plugins.Sprite.Cnds.CompareOpacity,
      e.Plugins.Sprite.Acts.Destroy,
      e.Plugins.Sprite.Cnds.IsOnScreen,
      e.Behaviors.Physics.Acts.ApplyImpulseAtAngle,
      e.Plugins.System.Exps.random,
      e.Behaviors.Bullet.Acts.SetEnabled,
      e.Behaviors.Bullet.Acts.SetSpeed,
      e.Behaviors.Bullet.Acts.SetAngleOfMotion,
      e.Plugins.Sprite.Cnds.IsAnimPlaying,
      e.Plugins.Sprite.Cnds.CompareX,
      e.Behaviors.Tween.Cnds.IsAnyPlaying,
      e.Plugins.Sprite.Exps.UID,
      e.Plugins.TiledBg.Acts.SetImageOffsetX,
      e.Plugins.TiledBg.Exps.ImageOffsetX,
      e.Plugins.TiledBg.Cnds.OnCreated,
      e.Plugins.TiledBg.Acts.SetInstanceVar,
      e.Plugins.TiledBg.Exps.Y,
      e.Plugins.TiledBg.Exps.Angle,
      e.Plugins.Sprite.Cnds.IsBetweenAngles,
      e.Plugins.TiledBg.Exps.X,
      e.Plugins.Particles.Acts.SetYRandomiser,
      e.Plugins.Particles.Acts.SetXRandomiser,
      e.Plugins.Particles.Acts.SetPos,
      e.Plugins.Sprite.Acts.StopAnim,
      e.Plugins.Sprite.Cnds.CompareY,
      e.Behaviors.Bullet.Acts.SetGravity,
      e.Behaviors.Bullet.Acts.SetAcceleration,
      e.Plugins.Sprite.Acts.ZMoveToObject,
      e.Plugins.Sprite.Acts.SetX,
      e.Plugins.System.Exps.layoutwidth,
      e.Plugins.System.Exps.viewportleft,
      e.Plugins.Sprite.Exps.Width,
      e.Plugins.System.Exps.viewportright,
      e.Behaviors.Timer.Cnds.OnTimer,
      e.Plugins.System.Cnds.OnLayoutEnd,
      e.Plugins.System.Exps.layoutname,
      e.Plugins.Dictionary.Acts.AddKey,
      e.Plugins.Arr.Exps.AsJSON,
      e.Plugins.LocalStorage.Acts.SetItem,
      e.Plugins.Dictionary.Exps.AsJSON,
      e.Plugins.LocalStorage.Cnds.IsProcessingSets,
      e.Plugins.LocalStorage.Cnds.OnAllSetsComplete,
      e.Plugins.Browser.Acts.Close,
      e.Plugins.Browser.Acts.Reload,
      e.Plugins.Touch.Cnds.OnHoldGesture,
      e.Plugins.Arr.Acts.Clear,
      e.Plugins.Dictionary.Acts.DeleteKey,
      e.Plugins.System.Cnds.OnLoadFinished,
      e.Plugins.Audio.Acts.Preload,
      e.Plugins.Browser.Exps.Domain,
      e.Plugins.System.Exps.tokenat,
      e.Plugins.LocalStorage.Acts.GetItem,
      e.Plugins.AJAX.Acts.RequestFile,
      e.Plugins.LocalStorage.Cnds.OnItemGet,
      e.Plugins.Dictionary.Acts.JSONLoad,
      e.Plugins.LocalStorage.Exps.ItemValue,
      e.Plugins.Dictionary.Cnds.HasKey,
      e.Plugins.Dictionary.Exps.Get,
      e.Plugins.Dictionary.Cnds.CompareValue,
      e.Plugins.System.Acts.SetBoolVar,
      e.Plugins.Arr.Acts.JSONLoad,
      e.Plugins.AJAX.Cnds.OnComplete,
      e.Plugins.AJAX.Exps.LastData,
      e.Plugins.System.Acts.SetLayerTransparent,
      e.Plugins.System.Cnds.CompareTime,
      e.Plugins.Keyboard.Cnds.OnAnyKey,
      e.Plugins.gamepad.Cnds.OnAnyButtonDown,
      e.Plugins.Touch.Cnds.OnTouchStart,
      e.Plugins.Text.Acts.TypewriterText,
      e.Plugins.Arr.Exps.At,
      e.Plugins.System.Exps.layeropacity,
      e.Plugins.System.Acts.SetLayoutEffectEnabled,
      e.Plugins.System.Acts.SetLayoutEffectParam,
      e.Behaviors.Platform.Acts.SetCeilingCollision,
      e.Behaviors.Pin.Acts.PinByProperties,
      e.Plugins.Text.Cnds.CompareInstanceVar,
      e.Plugins.Text.Acts.AppendText,
      e.Plugins.System.Exps.projectversion,
      e.Plugins.TiledBg.Acts.SetVisible,
      e.Plugins.TiledBg.Acts.SetPos,
      e.Plugins.System.Exps.viewporttop,
      e.Plugins.System.Exps.viewportbottom,
      e.Plugins.System.Cnds.ForEach,
      e.Plugins.PlatformInfo.Cnds.IsOnMobile,
      e.Plugins.Browser.Cnds.IsPortraitLandscape,
      e.Plugins.System.Exps.layoutscale,
      e.Plugins.System.Acts.SetLayoutScale,
      e.Plugins.System.Cnds.CompareBoolVar,
      e.Plugins.Particles.Acts.Destroy,
      e.Plugins.TiledBg.Acts.Destroy,
      e.Behaviors.Timer.Acts.PauseResumeTimer,
      e.Plugins.System.Cnds.Else,
      e.Plugins.Text.Acts.SetVisible,
      e.ScriptsInEvents.GlobalSettings_Event181_Act6,
      e.Plugins.System.Exps.min,
      e.Plugins.System.Exps.max,
      e.Plugins.System.Exps.scrollx,
      e.Plugins.System.Exps.scrolly,
      e.Plugins.System.Acts.ScrollX,
      e.Plugins.System.Acts.ScrollY,
      e.Behaviors.Timer.Cnds.IsTimerPaused,
      e.Plugins.Text.Cnds.IsRunningTypewriterText,
      e.Plugins.Audio.Acts.SetMuted,
      e.Plugins.Audio.Cnds.IsTagPlaying,
      e.Plugins.Audio.Acts.SetVolume,
      e.Plugins.Text.Cnds.OnCreated,
      e.Plugins.Text.Acts.SetInstanceVar,
      e.Plugins.Text.Exps.Height,
      e.Plugins.Text.Exps.Width,
      e.Plugins.System.Exps.find,
      e.Plugins.Sprite.Exps.LayerName,
      e.Plugins.System.Exps.originalwindowwidth,
      e.Plugins.Sprite.Acts.SetY,
      e.Plugins.System.Exps.originalwindowheight,
      e.Plugins.Text.Acts.SetWrapping,
      e.Plugins.Text.Acts.AddChild,
      e.Plugins.Text.Cnds.IsBoolInstanceVarSet,
      e.Plugins.Text.Acts.SetPos,
      e.Plugins.Text.Acts.ToggleBoolInstanceVar,
      e.Plugins.Arr.Acts.SetX,
      e.Plugins.Arr.Acts.SetXY,
      e.Plugins.Text.Acts.SetText,
      e.Plugins.Text.Cnds.OnTypewriterTextFinished,
      e.Plugins.Audio.Acts.Stop,
      e.Plugins.System.Cnds.Every,
      e.Behaviors.Timer.Exps.Duration,
      e.Plugins.Sprite.Acts.AddInstanceVar,
      e.Plugins.System.Exps.zeropad,
      e.ScriptsInEvents.Achievements_Event1_Act2,
      e.Plugins.Browser.Acts.GoToURLWindow,
      e.Plugins.Touch.Cnds.OnHoldGestureObject,
      e.Plugins.gamepad.Cnds.HasGamepads
    ]
  }
  self.C3_JsPropNameTable = [
    {
      ClearText: 0
    },
    {
      Var: 0
    },
    {
      ControlsText: 0
    },
    {
      CreditsText: 0
    },
    {
      CreditsText2: 0
    },
    {
      DeathsTxt: 0
    },
    {
      Variable1: 0
    },
    {
      debug: 0
    },
    {
      Variable: 0
    },
    {
      Debug_LB: 0
    },
    {
      Active: 0
    },
    {
      Tween: 0
    },
    {
      Dialogue_Box: 0
    },
    {
      FailedtoKillBS: 0
    },
    {
      FailedtoRescueP: 0
    },
    {
      index: 0
    },
    {
      LB_RSC_SCR: 0
    },
    {
      LB_RSC_USRNM: 0
    },
    {
      LB_RVG_SCR: 0
    },
    {
      LB_RVG_USR: 0
    },
    {
      LB_USER_RES: 0
    },
    {
      LD_USER_RVG: 0
    },
    {
      Leaderboard: 0
    },
    {
      Leaderboard_text: 0
    },
    {
      PlayerStat_RescueTime: 0
    },
    {
      StatsText: 0
    },
    {
      CurrentBoard: 0
    },
    {
      textKey: 0
    },
    {
      textSmallSquares: 0
    },
    {
      BestRescue: 0
    },
    {
      BestRevengeDic: 0
    },
    {
      Dictionary: 0
    },
    {
      LB_Rescue_G10: 0
    },
    {
      Audio: 0
    },
    {
      Browser: 0
    },
    {
      LocalStorage: 0
    },
    {
      NWjs: 0
    },
    {
      Bullet: 0
    },
    {
      Bullet_0: 0
    },
    {
      States: 0
    },
    {
      Zone: 0
    },
    {
      Lava: 0
    },
    {
      ActiveZoneObject: 0
    },
    {
      Saw_State: 0
    },
    {
      Saw_Zones: 0
    },
    {
      ZoneNumber: 0
    },
    {
      State: 0
    },
    {
      SinMove: 0
    },
    {
      SinSize: 0
    },
    {
      Solid: 0
    },
    {
      SawNeon: 0
    },
    {
      SinMover: 0
    },
    {
      Orbiter: 0
    },
    {
      Sine: 0
    },
    {
      Orbit: 0
    },
    {
      Platform: 0
    },
    {
      zone_P: 0
    },
    {
      Particle_Death_Splat: 0
    },
    {
      Particle_Red_1: 0
    },
    {
      Particles_Explosion: 0
    },
    {
      Particles_Fire: 0
    },
    {
      Particles_Laser_Death: 0
    },
    {
      Particles_Level_Exit: 0
    },
    {
      Particles_Portal_Orange: 0
    },
    {
      Particles_Respawn: 0
    },
    {
      Particles_Self_Destruct: 0
    },
    {
      Pin: 0
    },
    {
      Particles_Trail_Player: 0
    },
    {
      InstanceRate: 0
    },
    {
      Particles_Water_Bubbles: 0
    },
    {
      Particles_Water_Splash: 0
    },
    {
      Particles_Blue_Portal: 0
    },
    {
      Particles_Checkpoint: 0
    },
    {
      particles_water: 0
    },
    {
      Zones: 0
    },
    {
      particles_water_spray: 0
    },
    {
      Particle_Death_Fountain: 0
    },
    {
      Level_Tilemap: 0
    },
    {
      TMStructuralNEON: 0
    },
    {
      TMStructuralFLAPPY: 0
    },
    {
      StartX: 0
    },
    {
      StartY: 0
    },
    {
      Align: 0
    },
    {
      Touch_Jump: 0
    },
    {
      Touch_Left: 0
    },
    {
      Touch_Right: 0
    },
    {
      Gamepad: 0
    },
    {
      Keyboard: 0
    },
    {
      Mouse: 0
    },
    {
      Touch: 0
    },
    {
      CoD: 0
    },
    {
      CharacterState_Meta: 0
    },
    {
      normalState: 0
    },
    {
      swimmingState: 0
    },
    {
      Block_Affector: 0
    },
    {
      conveyorState: 0
    },
    {
      PausedState: 0
    },
    {
      Jumped: 0
    },
    {
      Floored: 0
    },
    {
      WallFall: 0
    },
    {
      Jump: 0
    },
    {
      Move_Left: 0
    },
    {
      Move_Right: 0
    },
    {
      Color: 0
    },
    {
      LightAffector: 0
    },
    {
      zoneTransferState: 0
    },
    {
      PowerBoost: 0
    },
    {
      SafeZoneState: 0
    },
    {
      BoxState: 0
    },
    {
      MoveRight: 0
    },
    {
      MoveLeft: 0
    },
    {
      flappyJumps: 0
    },
    {
      flappyRotate: 0
    },
    {
      Timer: 0
    },
    {
      Flash: 0
    },
    {
      ScrollTo: 0
    },
    {
      Player: 0
    },
    {
      PopUpText: 0
    },
    {
      CP: 0
    },
    {
      Checkpoint: 0
    },
    {
      Respawn: 0
    },
    {
      Water: 0
    },
    {
      Instance: 0
    },
    {
      Entered: 0
    },
    {
      Force: 0
    },
    {
      OrangePortalEntrance: 0
    },
    {
      OrangePortalExit: 0
    },
    {
      BluePortalExit: 0
    },
    {
      BluePortalEntrance: 0
    },
    {
      Corpse_Lava: 0
    },
    {
      Statess: 0
    },
    {
      Zoness: 0
    },
    {
      InstanceVar: 0
    },
    {
      Dialogue: 0
    },
    {
      Spoken: 0
    },
    {
      AISmallSquares: 0
    },
    {
      Platform_Slider: 0
    },
    {
      Power: 0
    },
    {
      Bouncer: 0
    },
    {
      SwitchNumber: 0
    },
    {
      Activate: 0
    },
    {
      Type: 0
    },
    {
      Inverted: 0
    },
    {
      Switch: 0
    },
    {
      ver: 0
    },
    {
      TextDebug: 0
    },
    {
      Water_Top: 0
    },
    {
      Spikes: 0
    },
    {
      Red: 0
    },
    {
      Green: 0
    },
    {
      Blue: 0
    },
    {
      blood: 0
    },
    {
      GameZone: 0
    },
    {
      YTrans: 0
    },
    {
      Camera: 0
    },
    {
      lightSaw: 0
    },
    {
      lightPlayer: 0
    },
    {
      lightWater: 0
    },
    {
      lightRespawn: 0
    },
    {
      StateSecurity: 0
    },
    {
      DistanceX: 0
    },
    {
      OrbitX: 0
    },
    {
      OrbitY: 0
    },
    {
      MoveTo: 0
    },
    {
      LineOfSight: 0
    },
    {
      SecurityBot: 0
    },
    {
      Timeline: 0
    },
    {
      lightSecurity: 0
    },
    {
      Number: 0
    },
    {
      Closed: 0
    },
    {
      Jumpthru: 0
    },
    {
      Dash: 0
    },
    {
      dtSpeed: 0
    },
    {
      Direction: 0
    },
    {
      MoveDown: 0
    },
    {
      PlayerActive: 0
    },
    {
      Conveyor: 0
    },
    {
      lightConveyor: 0
    },
    {
      DoorNumber: 0
    },
    {
      Door: 0
    },
    {
      LightDoor: 0
    },
    {
      lightAngleMin: 0
    },
    {
      lightAngleMax: 0
    },
    {
      Spotted: 0
    },
    {
      HP: 0
    },
    {
      Engagable: 0
    },
    {
      SafeBox: 0
    },
    {
      Level: 0
    },
    {
      lightWarp: 0
    },
    {
      distance: 0
    },
    {
      OriginalY: 0
    },
    {
      ZoneTransfer: 0
    },
    {
      ElevatorChains: 0
    },
    {
      StartWidth: 0
    },
    {
      Laser: 0
    },
    {
      lightLaser: 0
    },
    {
      PlatformInfo: 0
    },
    {
      Gridbackground: 0
    },
    {
      Logo: 0
    },
    {
      NeonLogo: 0
    },
    {
      AIExclaimation: 0
    },
    {
      DialogueTop1: 0
    },
    {
      DialogueTop2: 0
    },
    {
      EndingDialogue: 0
    },
    {
      BigSquare: 0
    },
    {
      StartHeight: 0
    },
    {
      UIStart: 0
    },
    {
      MenuType: 0
    },
    {
      MenuIndex: 0
    },
    {
      UIMarker: 0
    },
    {
      TouchMenu: 0
    },
    {
      BigSquareTextMenu: 0
    },
    {
      BigSquareTextBox: 0
    },
    {
      AJAX: 0
    },
    {
      ArraySquareDiag: 0
    },
    {
      NormalHeight: 0
    },
    {
      SquishedHeight: 0
    },
    {
      PineApple: 0
    },
    {
      lightPlayerDeath: 0
    },
    {
      StartText: 0
    },
    {
      lightSwitch: 0
    },
    {
      lightSafeBox: 0
    },
    {
      DashBox: 0
    },
    {
      SecurityBubble: 0
    },
    {
      PineAppleText: 0
    },
    {
      CameraClassic: 0
    },
    {
      CameraMode: 0
    },
    {
      SliderBar: 0
    },
    {
      On: 0
    },
    {
      SecuritySwitch: 0
    },
    {
      startwidth: 0
    },
    {
      startheight: 0
    },
    {
      SecurityBlock: 0
    },
    {
      Turret: 0
    },
    {
      SawTurret: 0
    },
    {
      SawRound: 0
    },
    {
      CheckerTexture: 0
    },
    {
      lightPlatform: 0
    },
    {
      UIOptions: 0
    },
    {
      UIQuit: 0
    },
    {
      Bar: 0
    },
    {
      WidescreenBars: 0
    },
    {
      Character: 0
    },
    {
      TextOptions: 0
    },
    {
      UIDash: 0
    },
    {
      inTouch: 0
    },
    {
      UISquare: 0
    },
    {
      CamPlayer: 0
    },
    {
      Heart: 0
    },
    {
      HeartParticles: 0
    },
    {
      Index: 0
    },
    {
      UICherry: 0
    },
    {
      Grabbed: 0
    },
    {
      Collected: 0
    },
    {
      InitialX: 0
    },
    {
      InitialY: 0
    },
    {
      Cherry: 0
    },
    {
      ArraySmallSquaresDialogueCheck: 0
    },
    {
      CameraOff: 0
    },
    {
      CameraZoom: 0
    },
    {
      MusicOn: 0
    },
    {
      SFX: 0
    },
    {
      languageUIIndex: 0
    },
    {
      Language: 0
    },
    {
      PerformanceMode: 0
    },
    {
      Credits: 0
    },
    {
      Back: 0
    },
    {
      Controls: 0
    },
    {
      Data: 0
    },
    {
      ControlsImages: 0
    },
    {
      ArrayBigSquareDiagRandom: 0
    },
    {
      ArrayBigSquareTowerTop: 0
    },
    {
      ArrayBigSquareTopFall: 0
    },
    {
      X: 0
    },
    {
      TextDeaths: 0
    },
    {
      DeathScrolls: 0
    },
    {
      KillScroll: 0
    },
    {
      PineappleKills: 0
    },
    {
      delay: 0
    },
    {
      TextKill: 0
    },
    {
      TextRevenge: 0
    },
    {
      ArrayDiagend: 0
    },
    {
      ArraySmallSquareDown: 0
    },
    {
      StatVar: 0
    },
    {
      TextStats: 0
    },
    {
      TextReset: 0
    },
    {
      EOFace80s: 0
    },
    {
      LogoText: 0
    },
    {
      var: 0
    },
    {
      TextIntro: 0
    },
    {
      PineAppleIMG: 0
    },
    {
      '8Direction': 0
    },
    {
      CharacterIMG: 0
    },
    {
      ArrayIntroText: 0
    },
    {
      Fullscreen: 0
    },
    {
      Support: 0
    },
    {
      ArrayOptionsLanguage: 0
    },
    {
      ArrayCredits: 0
    },
    {
      TextCredits: 0
    },
    {
      LanguagesIndividual: 0
    },
    {
      TextCopyRight: 0
    },
    {
      SM_YouTube: 0
    },
    {
      SM_Instagram: 0
    },
    {
      SM_Facebook: 0
    },
    {
      SM_Twitter: 0
    },
    {
      SM_TikToc: 0
    },
    {
      RotateWarning: 0
    },
    {
      EraseData: 0
    },
    {
      DataErase: 0
    },
    {
      GameOver: 0
    },
    {
      TextGameOver: 0
    },
    {
      ArrayGameOver: 0
    },
    {
      UIPurchase: 0
    },
    {
      UIGORestart: 0
    },
    {
      GameOverCam: 0
    },
    {
      Discord: 0
    },
    {
      SM_Discord: 0
    },
    {
      UIRestorePurchase: 0
    },
    {
      privacyspolicy: 0
    },
    {
      SteamLogo: 0
    },
    {
      SteamLogo2: 0
    },
    {
      AppStoreWhite: 0
    },
    {
      googleplaybadge: 0
    },
    {
      itchbadge: 0
    },
    {
      heightStart: 0
    },
    {
      heightEnd: 0
    },
    {
      Pipe: 0
    },
    {
      Horizontal: 0
    },
    {
      Vertical: 0
    },
    {
      pipeRedTube: 0
    },
    {
      jumpCountPlayer: 0
    },
    {
      RespawnEffect: 0
    },
    {
      Mover: 0
    },
    {
      moveLeft: 0
    },
    {
      StartAngle: 0
    },
    {
      BulletX: 0
    },
    {
      pipeRedFull: 0
    },
    {
      pipePurple: 0
    },
    {
      blowRight: 0
    },
    {
      blowLeft: 0
    },
    {
      PurplePipeVolume: 0
    },
    {
      PurplePipeParticles: 0
    },
    {
      scaleStart: 0
    },
    {
      Zoom: 0
    },
    {
      PipeRespawn: 0
    },
    {
      Wings: 0
    },
    {
      RedPipeTubeCurve: 0
    },
    {
      RedPipeCorner: 0
    },
    {
      RedPipeCurved: 0
    },
    {
      flappyJumpVolume: 0
    },
    {
      startX: 0
    },
    {
      ActiveZone: 0
    },
    {
      WingsPlayer: 0
    },
    {
      particlesHeat: 0
    },
    {
      BluePipeTube: 0
    },
    {
      BluePipeTubeCurve2: 0
    },
    {
      PlayerWingsFor: 0
    },
    {
      PineappleWings: 0
    },
    {
      EndZoomTriggeBox: 0
    },
    {
      CameraMoveEndTrigger: 0
    },
    {
      Anim: 0
    },
    {
      Cloud: 0
    },
    {
      Feather: 0
    },
    {
      ParticleFeather: 0
    },
    {
      ParticleFeatherP: 0
    },
    {
      BigSquareWings: 0
    },
    {
      PineappleExplosion: 0
    },
    {
      BigTowerLogo: 0
    },
    {
      PreviouslyOn: 0
    },
    {
      FLAPPY: 0
    },
    {
      Cloud2: 0
    },
    {
      Credits2: 0
    },
    {
      Controls2: 0
    },
    {
      Stats: 0
    },
    {
      Sprite: 0
    },
    {
      Controls3: 0
    },
    {
      EOFace80s2: 0
    },
    {
      EODude: 0
    },
    {
      EO_Dude_1024x: 0
    },
    {
      EO_Dude_512x: 0
    },
    {
      textLoading: 0
    },
    {
      A: 0
    },
    {
      D: 0
    },
    {
      W: 0
    },
    {
      space: 0
    },
    {
      AButton: 0
    },
    {
      Dpad: 0
    },
    {
      EOTextLogo: 0
    },
    {
      CMGLogo: 0
    },
    {
      level: 0
    },
    {
      triggerboxLevelTransfer: 0
    },
    {
      Rotate: 0
    },
    {
      Sine_Movement: 0
    },
    {
      Sine_Size: 0
    },
    {
      Family_Saws: 0
    },
    {
      BulletDestroyers: 0
    },
    {
      TimeScalePause: 0
    },
    {
      Physics: 0
    },
    {
      Particles_Red: 0
    },
    {
      Particles_Black: 0
    },
    {
      UIText: 0
    },
    {
      Leaderboards: 0
    },
    {
      Family_Players: 0
    },
    {
      Family_NPC: 0
    },
    {
      Family_TMs: 0
    },
    {
      Family_Particles: 0
    },
    {
      Family_Zone_Delete: 0
    },
    {
      Family_Particles_Flow: 0
    },
    {
      SinMovers: 0
    },
    {
      Family_Particle_Sprites: 0
    },
    {
      Family_Splash_Stoppers: 0
    },
    {
      WaterFam: 0
    },
    {
      Family_Statics: 0
    },
    {
      Theme_Changers: 0
    },
    {
      ActiveTiled: 0
    },
    {
      TiledDeath: 0
    },
    {
      ActiveSprite: 0
    },
    {
      ActiveSaw: 0
    },
    {
      DoorsFam: 0
    },
    {
      BridgeFam: 0
    },
    {
      SecurityFam: 0
    },
    {
      UIFam: 0
    },
    {
      Anchor: 0
    },
    {
      TouchFam: 0
    },
    {
      LightFam: 0
    },
    {
      UIButtonFam: 0
    },
    {
      SocialMediaFam: 0
    },
    {
      ResponsiveObjects: 0
    },
    {
      EOLogos: 0
    },
    {
      PrimaryAngle: 0
    },
    {
      Player_Start_X: 0
    },
    {
      Player_Start_Y: 0
    },
    {
      RespawnCPGlobal: 0
    },
    {
      Current_Checkpoint: 0
    },
    {
      playerGravityNormal: 0
    },
    {
      playerFallSpeedNormal: 0
    },
    {
      playerDecelerationGround: 0
    },
    {
      playerMaxSpeedGround: 0
    },
    {
      playerDecelerationAir: 0
    },
    {
      playerMaxSpeedAir: 0
    },
    {
      TouchXBaseline: 0
    },
    {
      TouchXMovement: 0
    },
    {
      Wall_Fall_Slow: 0
    },
    {
      Wall_Fall_Boost_X: 0
    },
    {
      WallJumpBuffer: 0
    },
    {
      PlayerY: 0
    },
    {
      coveyorSpeedHorizontal: 0
    },
    {
      conveyorSpeedVertical: 0
    },
    {
      NormalJumpBuffer: 0
    },
    {
      TouchXBase: 0
    },
    {
      TouchDirection: 0
    },
    {
      jumpSustainPower: 0
    },
    {
      jumpSustainTime: 0
    },
    {
      Jump_Strength: 0
    },
    {
      Wall_Jump_Boost_Y: 0
    },
    {
      Wall_Jump_Boost_X: 0
    },
    {
      flappyJumpPower: 0
    },
    {
      flappySustainPower: 0
    },
    {
      flappySustainTime: 0
    },
    {
      textime: 0
    },
    {
      SawRotationNormal: 0
    },
    {
      SawRotationReverse: 0
    },
    {
      Last_Layout: 0
    },
    {
      ResetSets: 0
    },
    {
      Saved: 0
    },
    {
      RevengeTime: 0
    },
    {
      RescueTime: 0
    },
    {
      FinishedState: 0
    },
    {
      GameJumps: 0
    },
    {
      GameDeaths: 0
    },
    {
      GameTime: 0
    },
    {
      BestRevenge: 0
    },
    {
      TotalJumps: 0
    },
    {
      TotalDeaths: 0
    },
    {
      TotalTime: 0
    },
    {
      GameMode: 0
    },
    {
      GameState: 0
    },
    {
      UIType: 0
    },
    {
      UIMenuIndex: 0
    },
    {
      UIStartY: 0
    },
    {
      UISelection: 0
    },
    {
      LanguageIndex: 0
    },
    {
      ScaleOutPC: 0
    },
    {
      ScaleOutMobileL: 0
    },
    {
      ScaleOutMobileP: 0
    },
    {
      ScaleInPC: 0
    },
    {
      ScaleInMobileL: 0
    },
    {
      ScaleInMobileP: 0
    },
    {
      VolumeSFX: 0
    },
    {
      VolumeMusic: 0
    },
    {
      Towerfall: 0
    },
    {
      CherriesCollected: 0
    },
    {
      LoadState: 0
    },
    {
      UION: 0
    },
    {
      UIOpacity: 0
    },
    {
      UnlimitedLives: 0
    },
    {
      GameLives: 0
    },
    {
      domain: 0
    },
    {
      CameraZoomMobileP: 0
    },
    {
      CameraZoomMobileL: 0
    },
    {
      CameraZoomNormal: 0
    },
    {
      BarWidth: 0
    },
    {
      LevelsUp: 0
    },
    {
      LevelsDown: 0
    },
    {
      LevelTransferCheck: 0
    }
  ]
}
{
  const e = self.C3

  function b(a, c) {
    return 'string' === typeof a || 'string' === typeof c ? ('number' === typeof a ? (Math.round(1e10 * a) / 1e10).toString() : a) + ('number' === typeof c ? (Math.round(1e10 * c) / 1e10).toString() : c) : a && c ? 1 : 0
  }
  self.C3_ExpressionFuncs = [
    () => 'Character Initialization',
    () => 8,
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject()
    },
    () => 'UI',
    () => 32,
    () => 16,
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject() - 32
    },
    a => {
      const c = a._GetNode(0).GetVar()
      return () => c.GetValue()
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject(0)
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject(0) - 32
    },
    () => 'Character is In Play',
    () => 4,
    () => 'InPlay',
    () => 'Self Destruct',
    () => 0,
    () => 'Player',
    () => 'SelfDestruct',
    () => 'Death',
    () => 1,
    () => 'Normal State',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar()
      return () => c() - d.GetValue()
    },
    () => 0.1,
    () => 'Jumptimer',
    () => 'MovingLeft',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpBehavior() - d.GetValue()
    },
    () => 'WallJumpRight',
    () => -2,
    () => 'WallCling',
    () => 6,
    () => 9,
    () => 0.2,
    () => 15,
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpBehavior() + d.GetValue()
    },
    () => 'WallJumpLeft',
    () => 2,
    () => 'Paused State',
    () => 'Box State',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject(1)
    },
    () => 'Conveyor Moveable',
    () => 'lightride',
    () => -100,
    () => 0.5,
    () => 'Horizontal',
    a => {
      const c = a._GetNode(0).GetVar()
      return () => -c.GetValue()
    },
    () => -150,
    () => 'Vertical',
    () => 'Swimming State',
    () => 150,
    () => 70,
    () => -75,
    () => 75,
    () => 100,
    () => 'Death State',
    () => 10,
    () => '',
    () => 0.25,
    () => 0.05,
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => e.lerp(c(), 1, 1)
    },
    () => 'Respawn',
    () => 'GameOverFade',
    () => 'FadeLayer',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('GameOverFade')
    },
    () => 'Respawn State',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpInstVar()
    },
    () => 'flappyActive',
    a => {
      const c = a._GetNode(0).GetVar()
      return () => 'Checkpoint: ' + c.GetValue()
    },
    () => 'CheckpointBleep',
    () => 'flappyRespawn',
    () => 'PlayerRespawnPosition',
    () => 'Respawning...',
    () => 3,
    () => 'Respawned',
    () => -285,
    () => 'Gameover State',
    () => 'GameOver',
    () => 'Level Change State',
    () => 'LevelChange',
    () => 'Movement Controls',
    a => {
      const c = a._GetNode(0)
      return () => b('jump', c.ExpInstVar())
    },
    () => 'Flappy Jump',
    () => 'Normal Jump',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('Jumptimer')
    },
    () => 0.09,
    () => 'Move_Left',
    () => -60,
    () => 'MoveLeft',
    () => 'Default',
    () => 'Move_Right',
    () => 60,
    () => 'MoveRight',
    () => 'Jump Functions (Normal)',
    () => 'Sustain',
    () => 'JumpOn',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod()
      return () => c.ExpBehavior() - 60 * d.GetValue() * f()
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1),
        f = a._GetNode(2).GetBoundMethod()
      return () => c.ExpObject() + 60 * (d.ExpBehavior('Sustain') + 0.2) * f()
    },
    () => 'WallJump',
    () => 7,
    () => 'Wall Jump Left',
    () => 'Wall Jump Right',
    () => 'Recover Jump',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior()
    },
    () => 'RotateValue',
    () => -180,
    () => 'RotateRight',
    () => 180,
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('RotateValue')
    },
    () => 'BoxJump',
    () => -475,
    () => 'Extend',
    () => 0.7,
    () => 'Swimming',
    () => -90,
    () => 'Swim Jump',
    () => 'WaterTopJump',
    () => 'Landing',
    () => 5,
    () => 'HeightReset',
    () => 'Jump Functions (Flappy)',
    () => 'flappySustain',
    a => {
      const c = a._GetNode(0).GetVar()
      return () => c.GetValue() + 10
    },
    a => {
      const c = a._GetNode(0)
      return () => b('Flappy Jump ', c.ExpInstVar())
    },
    () => 'Animation 1',
    a => {
      const c = a._GetNode(0).GetVar()
      return () => 1.5 * -c.GetValue()
    },
    a => {
      const c = a._GetNode(0)
      return () => b('Flappy Wings ', c.ExpInstVar())
    },
    () => 0.10000000000000009,
    () => 360,
    () => 48,
    () => 'Scanlines',
    () => 'GlowHorizontal',
    () => 'GlowVertical',
    () => 'Confusion',
    () => 'SecurityHum',
    () => 'Sleep',
    () => 'Chasing',
    () => 1.5,
    () => 2.5,
    () => 'dooropen',
    () => 'Spark',
    () => 'Active',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar()
      return () => c(d.GetValue(), f.GetValue())
    },
    () => 'Inactive',
    () => 'Player Particles',
    () => 'Water Particles',
    () => 270,
    () => 'Interact',
    () => 'Environment',
    () => 'Death Effects',
    a => {
      const c = a._GetNode(0).GetVar()
      return () => c.GetValue() - 5
    },
    () => 0.4,
    () => 'Particle Physics',
    () => 'Particles Red',
    () => 0.3,
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c(30, 330)
    },
    () => 'Particles Death',
    () => 'DeadLights',
    () => 2e3,
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c(300, 400)
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c(0, 360)
    },
    () => 'Switch and Door Triggers',
    () => 'SwitchSpawn',
    () => 'Normal Switch',
    () => -1,
    () => 'Top',
    () => 'Bottom',
    () => 'Door',
    () => 'On',
    () => 'StartFall',
    () => 9720,
    () => 'StartRotate',
    () => -10,
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1)
      return () => c.ExpObject() + d.ExpObject() / 2
    },
    () => 'Bridge',
    () => 'BridgeOpen',
    () => 'BridgeWithdraw',
    () => 'bridgewithdraw',
    () => 'Particles General',
    () => 'ZoneTransfer',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject(2)
    },
    a => {
      const c = a._GetNode(0)
      return () => b('TransferTween', c.ExpObject())
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1)
      return () => c.ExpObject() - d.ExpInstVar()
    },
    a => {
      const c = a._GetNode(0)
      return () => b('TransferDownTween', c.ExpObject())
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod()
      return () => c.ExpObject() + 300 * d()
    },
    () => 'Pipes',
    () => 'Red Pipes',
    () => 'Purple Pipe Volume',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod()
      return () => c.ExpBehavior() - 1500 * d()
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod()
      return () => c.ExpBehavior() + 1500 * d()
    },
    () => 200,
    () => 300,
    () => 36,
    () => 96,
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject() - 24
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject() + 24
    },
    () => 'Wings',
    () => 'flappyWingsTween',
    () => 'wingsdeathtween',
    () => 'NewWings',
    () => 'flappyWingsTweenOn',
    () => 'Clouds',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2).GetBoundMethod()
      return () => c(d() / 2 - 1e3, f() / 2 + 1e3)
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c('Cloud_1', 'Cloud_2', 'Cloud_3')
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c(-20, -30, -40, -50)
    },
    () => 'Paused',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(0) - d.ExpObject() / 2
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(0) + d.ExpObject() / 2
    },
    () => 'Clouds2',
    () => 'Big Square',
    () => 'GameTimer',
    () => 'Last_Layout',
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c()
    },
    () => 'Save System',
    () => 'Autosave',
    () => 'Language',
    () => 'GameLives',
    () => 'UnlimitedLives',
    () => 'Camera',
    () => 'Fullscreen',
    () => 'Music',
    () => 'SFX',
    () => 'Performance',
    () => 'respawnCP',
    () => 'Towerfall',
    () => 'GameTime',
    a => {
      const c = a._GetNode(0).GetVar(),
        d = a._GetNode(1).GetVar()
      return () => c.GetValue() + d.GetValue()
    },
    () => 'TotalDeaths',
    () => 'SquaresSpoken',
    () => 'Rescue',
    () => 'Revenge',
    () => 'BestRescue',
    () => 'BestRevenge',
    () => 'FlappySaveGame',
    () => 'Processing Sets...',
    () => 'All Sets Complete',
    () => 'Quit',
    () => 'Quiting',
    () => 'ResetGame From Options',
    () => 'Resetting',
    () => 'Restart Game End',
    () => 'Reset',
    () => 'Clear Data',
    () => 'SawDeaths',
    () => 'LaserDeaths',
    () => 'BotDeaths',
    () => 'PlatformDeaths',
    () => 'Loader Layout Complete',
    () => 'Sitelock Check',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar()
      return () => c(d.GetValue(), 1, '.')
    },
    () => 'construct',
    () => 'preview.construct.net',
    () => "greatmathgame",
    () => "https://www.greatmathgame.com/",
    () => "www.greatmathgame.com",
    () => "www.greatmathgame.com",
    () => "greatmathgame",
    () => "https://www.greatmathgame.com/",
    () => 'Load Saved Items3',
    () => 'AJAX Initial Request',
    () => 'IntroText',
    () => 'Load Requests',
    () => 'LoadingDictionary',
    () => 'SettingSaves',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('Language')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('GameLives')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('Music')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('SFX')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('respawnCP')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('GameTime')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('TotalDeaths')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('SquaresSpoken')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('Rescue')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('Revenge')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('BestRescue')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject('BestRevenge')
    },
    () => 'AJAX Requests',
    () => 'SmallDiagLoad',
    () => 'SmallSquareDown',
    () => 'BigSquareDiagRandom',
    () => 'BigSquareTowerTop',
    () => 'BigSquareTopFall',
    () => 'Diagend',
    () => 'OptionsLanguage',
    () => 'Splash Screen Layout Change',
    () => 'SplashFade',
    () => 'SplashFadeIn',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('SplashFadeIn')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('SplashFade')
    },
    () => 'Layout Start Events',
    () => 'EO Splash',
    () => 'EvilObjective',
    () => 'Splash Screen2',
    () => 'Splash',
    () => 'Menu',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(b(b(b(b(c.ExpObject(d.GetValue(), 0), '\n'), '\n'), f.ExpObject(g.GetValue(), 1)), '\n'), '\n'), h.ExpObject(k.GetValue(), 2)), '\n'), '\n'), m.ExpObject(r.GetValue(), 3))
    },
    () => 'Flappy Tower Layout',
    () => 'BigFLAPPYTower',
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c('FadeLayer')
    },
    () => 'Layout Initialize',
    () => 'BlurVertical',
    a => {
      const c = a._GetNode(0).GetBoundMethod()
      return () => c('Widescreenbars')
    },
    () => 'Start',
    () => 'Index Objects',
    () => 'Camera Starting Events',
    () => 'CameraZoomEndOut',
    () => 'CameraZoomEnd',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('CameraZoomEnd')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('CameraZoomEndOut')
    },
    () => 1376,
    () => 'Towerfall Initialization',
    () => 'Game Modes',
    () => 'Normal Mode',
    () => 'Normal',
    () => 'Game Is Paused',
    () => 'Ending',
    () => 'Scale Adjustment On Load',
    () => 'Main',
    () => 'UI Navigation',
    () => 'MenuChangeInProgress',
    () => -30,
    () => 30,
    () => 'Play Button',
    () => 'GameStart',
    () => 'StartOn',
    () => 'UIStartOn',
    a => {
      const c = a._GetNode(0)
      return () => 1.1 * c.ExpObject()
    },
    () => 'StartOff',
    () => 'Options Button',
    () => 'UIOptionsOn',
    () => 'Music Button',
    () => 'SFX Button',
    () => 'Language Button',
    () => 'LanguageSwitch',
    () => 'Quit Button',
    () => 'BSTextboxsize',
    () => 'Fall',
    () => 'Dropping',
    () => 'LevelTransition',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2)
      return () => c(4, d(2, f.ExpInstVar() / 2))
    },
    () => -200,
    () => 'CameraAdjustPositionX',
    () => 'CameraAdjustPositionY',
    () => 'MainLoop',
    () => 'ScaleDrop',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('CameraAdjustPositionX')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('CameraAdjustPositionY')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('ScaleDrop')
    },
    () => 'OptionsCam',
    () => 'Options',
    () => 960,
    () => 'Game Is In Play',
    () => 'Transition',
    () => 'menu',
    () => 'FadeIn',
    () => 'QuickFade',
    () => 160,
    () => 84,
    () => 'LogoUp',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2)
      return () => c(6, d(2, f.ExpInstVar() / 2))
    },
    () => 'TowerRise',
    () => 'Zone Activation',
    () => 'ZoneTransition',
    () => 'FinalZoneOut',
    () => 1.1,
    () => 'FinalZoneIn',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('FinalZoneOut')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('FinalZoneIn')
    },
    () => 0.6,
    () => 'LogoDown',
    () => 'BossTextReveal',
    () => 512,
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod()
      return () => c.ExpObject(d.GetValue(), f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    },
    () => 'Sound Controls',
    () => 'MusicOn',
    () => 'MusicOff',
    () => 'SFXOn',
    () => 'SFXOff',
    () => 'WidescreenTween',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject() + d.GetValue()
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject() - d.GetValue()
    },
    () => 'UI Adjustments',
    () => 'ResponsiveUI',
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(d.ExpInstVar_Family(), 'left')
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2)
      return () => c.ExpInstVar_Family() + d(f.ExpObject())
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(d.ExpInstVar_Family(), 'right')
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetBoundMethod(),
        f = a._GetNode(2),
        g = a._GetNode(3).GetBoundMethod()
      return () => c.ExpInstVar_Family() + (d(f.ExpObject()) - g())
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(d.ExpInstVar_Family(), 'up')
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1)
      return () => c(d.ExpInstVar_Family(), 'down')
    },
    () => 'Language Setup',
    () => 'english',
    () => 'English',
    () => 'spanish',
    () => 'latam',
    () => 'Spanish',
    () => 'japanese',
    () => 'Japanese',
    () => 'Dialogue Box',
    () => 'Checkpoint Save Actions',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1)
      return () => c.ExpObject(d.ExpInstVar())
    },
    () => 'Spoken',
    () => 'Animation 3',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1)
      return () => c.ExpObject(d.ExpInstVar(), 1)
    },
    () => 'Animation 2',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2)
      return () => c.ExpObject(d.GetValue(), f.ExpInstVar())
    },
    () => 'SmallText',
    () => 'Dictionary',
    () => 'TowerTop',
    a => {
      const c = a._GetNode(0).GetVar(),
        d = a._GetNode(1)
      return () => c.GetValue() + d.ExpBehavior('GameTimer')
    },
    () => 'PDeath',
    () => 1370,
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject(d.GetValue(), 0)
    },
    () => 12,
    () => 20,
    () => 'Bottom Switch',
    () => 'BottomSwitch',
    () => 'FinalCamScale',
    () => 'FinalCam',
    () => 1250,
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('FinalCamScale')
    },
    () => 'ArmsUp',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject(d.GetValue(), 10)
    },
    () => 'PreEnding',
    () => 'DashBridge',
    () => 'BSDrop',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject() + 200
    },
    () => 'Flying',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpObject() - 50
    },
    () => 'Pineapple',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(c.ExpObject(d.GetValue(), 0), f(Math.floor(g.GetValue() / 3600), 2)), ':'), h(Math.floor((k.GetValue() / 60) % 60), 2)), ':'), m(Math.floor(r.GetValue() % 60), 2))
    },
    () => 'BigSquare',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(c.ExpObject(d.GetValue(), 1), f(Math.floor(g.GetValue() / 3600), 2)), ':'), h(Math.floor((k.GetValue() / 60) % 60), 2)), ':'), m(Math.floor(r.GetValue() % 60), 2))
    },
    () => 'Deaths',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar()
      return () => b(c.ExpObject(d.GetValue(), 2), f.GetValue())
    },
    () => 'Thanks',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject(d.GetValue(), 3)
    },
    () => 90,
    () => 1006,
    () => 1901,
    () => 'Debug',
    () => 'Steam',
    () => 'GameOverFade2',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('GameOverFade2')
    },
    () => 'https://apps.apple.com/us/app/big-neon-tower-vs-tiny-square/id1561217173',
    () => 'NewWindow',
    () => 'https://store.steampowered.com/app/758010/Big_NEON_Tower_VS_Tiny_Square/',
    () => 'https://play.google.com/store/apps/details?id=com.eointeractive.bigneontower.android',
    () => 'https://evilobjective.itch.io/big-neon-tower-tiny-square',
    () => 'CreditsLanguage',
    () => 'SelfPingPong',
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject(d.GetValue(), 12)
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar()
      return () => c.ExpObject(d.GetValue(), 11)
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(b(b(b(b(c.ExpObject(d.GetValue(), 1), '[outline=#292929]'), '[color=#118ab2]'), f(Math.floor(g.GetValue() / 3600), 2)), ':'), h(Math.floor((k.GetValue() / 60) % 60), 2)), ':'), m(Math.floor(r.GetValue() % 60), 2)), '[/color]'), '[/outline]')
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(b(b(b(b(c.ExpObject(d.GetValue(), 2), '[outline=#292929]'), '[color=#118ab2]'), f(Math.floor(g.GetValue() / 3600), 2)), ':'), h(Math.floor((k.GetValue() / 60) % 60), 2)), ':'), m(Math.floor(r.GetValue() % 60), 2)), '[/color]'), '[/outline]')
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetVar()
      return () => b(b(b(c.ExpObject(d.GetValue(), 3), '[color=#ef2e4e]'), f.GetValue()), '[/color]')
    },
    a => {
      const c = a._GetNode(0).GetBoundMethod(),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar()
      return () => c(Math.floor(d.GetValue() / 3600), 2) + ':' + f(Math.floor((g.GetValue() / 60) % 60), 2) + ':' + h(Math.floor(k.GetValue() % 60), 2)
    },
    a => {
      const c = a._GetNode(0),
        d = a._GetNode(1).GetVar(),
        f = a._GetNode(2).GetBoundMethod(),
        g = a._GetNode(3).GetVar(),
        h = a._GetNode(4).GetBoundMethod(),
        k = a._GetNode(5).GetVar(),
        m = a._GetNode(6).GetBoundMethod(),
        r = a._GetNode(7).GetVar()
      return () => b(b(b(b(b(b(b(b(b(c.ExpObject(d.GetValue(), 10), '[outline=#292929]'), '[color=#118ab2]'), f(Math.floor(g.GetValue() / 3600), 2)), ':'), h(Math.floor((k.GetValue() / 60) % 60), 2)), ':'), m(Math.floor(r.GetValue() % 60), 2)), '[/color]'), '[/outline]')
    },
    () => 'FadeOut',
    () => 'http://evilobjective.com/bntpp-html5/',
    () => 'http://evilobjective.com/contact/',
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('FadeIn')
    },
    a => {
      const c = a._GetNode(0)
      return () => c.ExpBehavior('FadeOut')
    },
    () => 'Social Media2'
  ]
}
var module$str$c3runtime = {}
const scriptsInEvents$$module$str$scriptsInEvents = {
  async GlobalSettings_Event181_Act6(e, b) {
    parent.cmgGameEvent('start')
  },
  async Achievements_Event1_Act2(e, b) {
    parent.cmgGameEvent('start', e.globalVars.LevelTransferCheck)
  }
}
self.C3.ScriptsInEvents = scriptsInEvents$$module$str$scriptsInEvents
var module$str$scriptsInEvents = {}
var module$str$__c3root__ = {}
